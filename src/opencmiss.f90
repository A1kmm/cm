!> \file
!> $Id: opencmiss.f90 542 2009-06-03 17:16:22Z chrispbradley $
!> \author Chris Bradley
!> \brief The top level OpenCMISS module.
!>
!> \mainpage OpenCMISS Documentation
!>
!> An open source interactive computer program for Continuum Mechanics, Image analysis, Signal processing and System
!> Identification. Target usage: Bioengineering application of finite element analysis, boundary element and collocation
!> techniques.
!>
!> \section LICENSE
!>
!> Version: MPL 1.1/GPL 2.0/LGPL 2.1
!>
!> The contents of this file are subject to the Mozilla Public License
!> Version 1.1 (the "License"); you may not use this file except in
!> compliance with the License. You may obtain a copy of the License at
!> http://www.mozilla.org/MPL/
!>
!> Software distributed under the License is distributed on an "AS IS"
!> basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
!> License for the specific language governing rights and limitations
!> under the License.
!>
!> The Original Code is OpenCMISS
!>
!> The Initial Developer of the Original Code is University of Auckland,
!> Auckland, New Zealand and University of Oxford, Oxford, United
!> Kingdom. Portions created by the University of Auckland and University
!> of Oxford are Copyright (C) 2007 by the University of Auckland and
!> the University of Oxford. All Rights Reserved.
!>
!> Contributor(s):
!>
!> Alternatively, the contents of this file may be used under the terms of
!> either the GNU General Public License Version 2 or later (the "GPL"), or
!> the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
!> in which case the provisions of the GPL or the LGPL are applicable instead
!> of those above. If you wish to allow use of your version of this file only
!> under the terms of either the GPL or the LGPL, and not to allow others to
!> use your version of this file under the terms of the MPL, indicate your
!> decision by deleting the provisions above and replace them with the notice
!> and other provisions required by the GPL or the LGPL. If you do not delete
!> the provisions above, a recipient may use your version of this file under
!> the terms of any one of the MPL, the GPL or the LGPL.
!>
!>
!> The top level OpenCMISS module. This module is the buffer module between the OpenCMISS library and user code.
MODULE OPENCMISS

  USE ANALYTIC_ANALYSIS_ROUTINES
  USE BASE_ROUTINES
  USE BASIS_ROUTINES
  USE BOUNDARY_CONDITIONS_ROUTINES
  USE CMISS
  USE CMISS_CELLML
  USE COMP_ENVIRONMENT
  USE CONSTANTS
  USE CONTROL_LOOP_ROUTINES
  USE COORDINATE_ROUTINES
  USE EQUATIONS_ROUTINES
  USE EQUATIONS_SET_CONSTANTS
  USE EQUATIONS_SET_ROUTINES
  USE FIELD_ROUTINES
  USE FIELD_IO_ROUTINES
  USE GENERATED_MESH_ROUTINES
  USE HISTORY_ROUTINES
  USE INPUT_OUTPUT
  !USE ISO_C_BINDING
  USE ISO_VARYING_STRING
  USE KINDS
  USE MESH_ROUTINES
  USE NODE_ROUTINES
  USE PROBLEM_CONSTANTS
  USE PROBLEM_ROUTINES
  USE REGION_ROUTINES
  USE SOLVER_ROUTINES
  USE STRINGS
  USE TYPES
   
  IMPLICIT NONE

  PRIVATE
  
  !Module parameters
  
  !Module types

  !>Contains information about a basis function.
  TYPE CMISSBasisType
    PRIVATE
    TYPE(BASIS_TYPE), POINTER :: BASIS
  END TYPE CMISSBasisType

  !>Contains information on the boundary conditions for the equations set.
  TYPE CMISSBoundaryConditionsType
    PRIVATE
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
  END TYPE CMISSBoundaryConditionsType

  !>Contains information on a CellML environment.
  TYPE CMISSCellMLType
    PRIVATE
    TYPE(CELLML_TYPE), POINTER :: CELLML
  END TYPE CMISSCellMLType

  !>Contains information on a control loop.
  TYPE CMISSControlLoopType
    PRIVATE
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
  END TYPE CMISSControlLoopType

  !>Contains information on a coordinate system.
  TYPE CMISSCoordinateSystemType
    PRIVATE
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
  END TYPE CMISSCoordinateSystemType

  !>Contains information on the mesh decomposition.
  TYPE CMISSDecompositionType
    PRIVATE
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
  END TYPE CMISSDecompositionType
  
  !>Contains information about the equations in an equations set.
  TYPE CMISSEquationsType
    PRIVATE
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
  END TYPE CMISSEquationsType
  
  !>Contains information on an equations set defined on a region. 
  TYPE CMISSEquationsSetType
    PRIVATE
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
  END TYPE CMISSEquationsSetType

  !>Contains information for a field defined on a region.
  TYPE CMISSFieldType
    PRIVATE
    TYPE(FIELD_TYPE), POINTER :: FIELD
  END TYPE CMISSFieldType
  
  !>Contains information for a fields defined on a region.
  TYPE CMISSFieldsType
    PRIVATE
    TYPE(FIELDS_TYPE), POINTER :: FIELDS
  END TYPE CMISSFieldsType
  
  !>Contains information on a generated mesh.
  TYPE CMISSGeneratedMeshType
    PRIVATE
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
  END TYPE CMISSGeneratedMeshType
  
  !>Contains information about a history file for a control loop.
  TYPE CMISSHistoryType
    PRIVATE
    TYPE(HISTORY_TYPE), POINTER :: HISTORY
  END TYPE CMISSHistoryType
  
  !>Contains information on a mesh defined on a region.
  TYPE CMISSMeshType
    PRIVATE
    TYPE(MESH_TYPE), POINTER :: MESH
  END TYPE CMISSMeshType
  
  !>Contains information on a mesh elements defined in a mesh
  TYPE CMISSMeshElementsType
    PRIVATE
    TYPE(MESH_ELEMENTS_TYPE), POINTER :: MESH_ELEMENTS
  END TYPE CMISSMeshElementsType
  
  !>Contains information on the nodes defined on a region.
  TYPE CMISSNodesType
    PRIVATE
    TYPE(NODES_TYPE), POINTER :: NODES
  END TYPE CMISSNodesType
  
  !>Contains information for a problem.
  TYPE CMISSProblemType
    PRIVATE
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
  END TYPE CMISSProblemType

  !>Contains information for a particular quadrature scheme for a basis. 
  TYPE CMISSQuadratureType
    PRIVATE
    TYPE(QUADRATURE_TYPE), POINTER :: QUADRATURE
  END TYPE CMISSQuadratureType

 !>Contains information for a region.
  TYPE CMISSRegionType
    PRIVATE
    TYPE(REGION_TYPE), POINTER :: REGION
  END TYPE CMISSRegionType

  !>Contains information about a solver.
  TYPE CMISSSolverType
    PRIVATE
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
  END TYPE CMISSSolverType
  
  !>Contains information about the solver equations for a solver.
  TYPE CMISSSolverEquationsType
    PRIVATE
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
  END TYPE CMISSSolverEquationsType
  
  !Module variables

  TYPE(VARYING_STRING) :: ERROR

  !Interface CMISS_Finalise_
  !  MODULE PROCEDURE CMISSFinalise
  !END INTERFACE !CMISS_Finalise_

  INTERFACE CMISSInitialise
    MODULE PROCEDURE CMISSInitialiseNumber
    MODULE PROCEDURE CMISSInitialiseObj
  END INTERFACE !CMISSInitialise

  !PUBLIC CMISS_Finalise,CMISS_Initialise
  PUBLIC CMISSFinalise,CMISSInitialise

  PUBLIC CMISSBasisType,CMISSBasisTypeFinalise,CMISSBasisTypeInitialise

  PUBLIC CMISSBoundaryConditionsType,CMISSBoundaryConditionsTypeFinalise,CMISSBoundaryConditionsTypeInitialise

  PUBLIC CMISSCellMLType,CMISSCellMLTypeFinalise,CMISSCellMLTypeInitialise

  PUBLIC CMISSControlLoopType,CMISSControlLoopTypeFinalise,CMISSControlLoopTypeInitialise

  PUBLIC CMISSCoordinateSystemType,CMISSCoordinateSystemTypeFinalise,CMISSCoordinateSystemTypeInitialise

  PUBLIC CMISSDecompositionType,CMISSDecompositionTypeFinalise,CMISSDecompositionTypeInitialise

  PUBLIC CMISSEquationsType,CMISSEquationsTypeFinalise,CMISSEquationsTypeInitialise

  PUBLIC CMISSEquationsSetType,CMISSEquationsSetTypeFinalise,CMISSEquationsSetTypeInitialise

  PUBLIC CMISSFieldType,CMISSFieldTypeFinalise,CMISSFieldTypeInitialise

  PUBLIC CMISSFieldsType,CMISSFieldsTypeCreate,CMISSFieldsTypeFinalise,CMISSFieldsTypeInitialise

  PUBLIC CMISSGeneratedMeshType,CMISSGeneratedMeshTypeFinalise,CMISSGeneratedMeshTypeInitialise

  PUBLIC CMISSHistoryType,CMISSHistoryTypeFinalise,CMISSHistoryTypeInitialise

  PUBLIC CMISSMeshType,CMISSMeshTypeFinalise,CMISSMeshTypeInitialise

  PUBLIC CMISSMeshElementsType,CMISSMeshElementsTypeFinalise,CMISSMeshElementsTypeInitialise

  PUBLIC CMISSNodesType,CMISSNodesTypeFinalise,CMISSNodesTypeInitialise

  PUBLIC CMISSProblemType,CMISSProblemTypeFinalise,CMISSProblemTypeInitialise

  PUBLIC CMISSQuadratureType,CMISSQuadratureTypeFinalise,CMISSQuadratureTypeInitialise

  PUBLIC CMISSRegionType,CMISSRegionTypeFinalise,CMISSRegionTypeInitialise

  PUBLIC CMISSSolverType,CMISSSolverTypeFinalise,CMISSSolverTypeInitialise

  PUBLIC CMISSSolverEquationsType,CMISSSolverEquationsTypeFinalise,CMISSSolverEquationsTypeInitialise
  

!!==================================================================================================================================
!!
!! ANALYTIC_ANALYSIS_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Output the analytic error analysis for a field compared to the analytic values parameter set.
  INTERFACE CMISSAnalyticAnalysisOutput
    MODULE PROCEDURE CMISSAnalyticAnalysisOutputNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisOutputObj
  END INTERFACE !CMISSAnalyticAnalysisOutput

  !>Get the absolute error of the node.
  INTERFACE CMISSAnalyticAnalysisAbsoluteErrorGetNode
    MODULE PROCEDURE CMISSAnalyticAnalysisAbsoluteErrorGetNodeNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisAbsoluteErrorGetNodeObj
  END INTERFACE !CMISSAnalyticAnalysisAbsoluteErrorGetNode
  
  !>Get the percentage error of the node.
  INTERFACE CMISSAnalyticAnalysisPercentageErrorGetNode
    MODULE PROCEDURE CMISSAnalyticAnalysisPercentageErrorGetNodeNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisPercentageErrorGetNodeObj
  END INTERFACE !CMISSAnalyticAnalysisPercentageErrorGetNode

  !>Get the relative error of the node.
  INTERFACE CMISSAnalyticAnalysisRelativeErrorGetNode
    MODULE PROCEDURE CMISSAnalyticAnalysisRelativeErrorGetNodeNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisRelativeErrorGetNodeObj
  END INTERFACE !CMISSAnalyticAnalysisRelativeErrorGetNode

  !>Get the absolute error of the element.
  INTERFACE CMISSAnalyticAnalysisAbsoluteErrorGetElement
    MODULE PROCEDURE CMISSAnalyticAnalysisAbsoluteErrorGetElementNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisAbsoluteErrorGetElementObj
  END INTERFACE !CMISSAnalyticAnalysisAbsoluteErrorGetElement

  !>Get the percentage error of the element.
  INTERFACE CMISSAnalyticAnalysisPercentageErrorGetElement
    MODULE PROCEDURE CMISSAnalyticAnalysisPercentageErrorGetElementNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisPercentageErrorGetElementObj
  END INTERFACE !CMISSAnalyticAnalysisPercentageErrorGetElement

  !>Get the relative error of the element.
  INTERFACE CMISSAnalyticAnalysisRelativeErrorGetElement
    MODULE PROCEDURE CMISSAnalyticAnalysisRelativeErrorGetElementNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisRelativeErrorGetElementObj
  END INTERFACE !CMISSAnalyticAnalysisRelativeErrorGetElement

  !>Get the absolute error of the constant.
  INTERFACE CMISSAnalyticAnalysisAbsoluteErrorGetConstant
    MODULE PROCEDURE CMISSAnalyticAnalysisAbsoluteErrorGetConstantNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisAbsoluteErrorGetConstantObj
  END INTERFACE !CMISSAnalyticAnalysisAbsoluteErrorGetConstant

  !>Get the percentage error of the constant.
  INTERFACE CMISSAnalyticAnalysisPercentageErrorGetConstant
    MODULE PROCEDURE CMISSAnalyticAnalysisPercentageErrorGetConstantNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisPercentageErrorGetConstantObj
  END INTERFACE !CMISSAnalyticAnalysisPercentageErrorGetConstant

  !>Get the relative error of the constant.
  INTERFACE CMISSAnalyticAnalysisRelativeErrorGetConstant
    MODULE PROCEDURE CMISSAnalyticAnalysisRelativeErrorGetConstantNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisRelativeErrorGetConstantObj
  END INTERFACE !CMISSAnalyticAnalysisRelativeErrorGetConstant

  !>Get the rms error of nodes.
  INTERFACE CMISSAnalyticAnalysisRmsErrorGetNode
    MODULE PROCEDURE CMISSAnalyticAnalysisRmsErrorGetNodeNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisRmsErrorGetNodeObj
  END INTERFACE !CMISSAnalyticAnalysisRmsErrorGetNode

  !>Get the rms error of elements.
  INTERFACE CMISSAnalyticAnalysisRmsErrorGetElement
    MODULE PROCEDURE CMISSAnalyticAnalysisRmsErrorGetElementNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisRmsErrorGetElementObj
  END INTERFACE !CMISSAnalyticAnalysisRmsErrorGetElement

  !>Get integral of numerical values.
  INTERFACE CMISSAnalyticAnalysisIntegralNumericalValueGet
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralNumericalValueGetNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralNumericalValueGetObj
  END INTERFACE !CMISSAnalyticAnalysisIntegralNumericalValueGet

  !>Get integral of analytical values.
  INTERFACE CMISSAnalyticAnalysisIntegralAnalyticValueGet
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralAnalyticValueGetNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralAnalyticValueGetObj
  END INTERFACE !CMISSAnalyticAnalysisIntegralAnalyticValueGet

  !>Get integral of percentage errors.
  INTERFACE CMISSAnalyticAnalysisIntegralPercentageErrorGet
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralPercentageErrorGetNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralPercentageErrorGetObj
  END INTERFACE !CMISSAnalyticAnalysisIntegralPercentageErrorGet

  !>Get integral of absolute errors.
  INTERFACE CMISSAnalyticAnalysisIntegralAbsoluteErrorGet
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralAbsoluteErrorGetNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralAbsoluteErrorGetObj
  END INTERFACE !CMISSAnalyticAnalysisIntegralAbsoluteErrorGet

  !>Get integral of relative errors.
  INTERFACE CMISSAnalyticAnalysisIntegralRelativeErrorGet
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralRelativeErrorGetNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralRelativeErrorGetObj
  END INTERFACE !CMISSAnalyticAnalysisIntegralRelativeErrorGet

  !>Get integral of nid numerical errors.
  INTERFACE CMISSAnalyticAnalysisIntegralNidNumericalValueGet
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralNidNumericalValueGetNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralNidNumericalValueGetObj
  END INTERFACE !CMISSAnalyticAnalysisIntegralNidNumericalValueGet

  !>Get integral of nid errors.
  INTERFACE CMISSAnalyticAnalysisIntegralNidErrorGet
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralNidErrorGetNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralNidErrorGetObj
  END INTERFACE !CMISSAnalyticAnalysisIntegralNidErrorGet
  
  PUBLIC CMISSAnalyticAnalysisOutput

  PUBLIC CMISSAnalyticAnalysisAbsoluteErrorGetNode,CMISSAnalyticAnalysisPercentageErrorGetNode, &
    & CMISSAnalyticAnalysisRelativeErrorGetNode

  PUBLIC CMISSAnalyticAnalysisAbsoluteErrorGetElement,CMISSAnalyticAnalysisPercentageErrorGetElement, &
    & CMISSAnalyticAnalysisRelativeErrorGetElement

  PUBLIC CMISSAnalyticAnalysisAbsoluteErrorGetConstant,CMISSAnalyticAnalysisPercentageErrorGetConstant, &
    & CMISSAnalyticAnalysisRelativeErrorGetConstant

  PUBLIC CMISSAnalyticAnalysisRmsErrorGetNode,CMISSAnalyticAnalysisRmsErrorGetElement

  PUBLIC CMISSAnalyticAnalysisIntegralNumericalValueGet,CMISSAnalyticAnalysisIntegralAnalyticValueGet, &
    & CMISSAnalyticAnalysisIntegralPercentageErrorGet,CMISSAnalyticAnalysisIntegralAbsoluteErrorGet, &
    & CMISSAnalyticAnalysisIntegralRelativeErrorGet,CMISSAnalyticAnalysisIntegralNidNumericalValueGet, &
    & CMISSAnalyticAnalysisIntegralNidErrorGet
 
!!==================================================================================================================================
!!
!! BASE_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_DiagnosticAndTimingConstants OPENCMISS::DiagnosticAndTiming::Constants
  !> \brief Diagnostic and Timing constants.
  !>@{  
  !> \addtogroup OPENCMISS_DiagnosticTypes OPENCMISS::DiagnosticAndTiming::DiagnosticTypes
  !> \brief Diganostic constants.
  !> \see OPENCMISS::DiagnosticTypes,OPENCMISS
  !>@{  
  INTEGER(INTG), PARAMETER :: CMISSAllDiagType = ALL_DIAG_TYPE !<Type for setting diagnostic output in all routines \see OPENCMISS_DiagnosticTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSInDiagType = IN_DIAG_TYPE !<Type for setting diagnostic output in one routine \see OPENCMISS_DiagnosticTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFromDiagType = FROM_DIAG_TYPE !<Type for setting diagnostic output in one routine downwards \see OPENCMISS_DiagnosticTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_TimingTypes OPENCMISS::DiagnosticAndTiming::TimingTypes
  !> \brief Timing constants.
  !> \see OPENCMISS::TimingTypes,OPENCMISS
  !>@{  
  INTEGER(INTG), PARAMETER :: CMISSAllTimingType = ALL_TIMING_TYPE !<Type for setting timing output in all routines \see OPENCMISS_TimingTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSInTimingType = IN_TIMING_TYPE !<Type for setting timing output in one routine \see OPENCMISS_TimingTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFromTimingType = FROM_TIMING_TYPE !<Type for setting timing output from one routine downwards \see OPENCMISS_TimingTypes,OPENCMISS
  !>@}
  !>@}
 
  !Module types

  !Module variables

  !Interfaces

  PUBLIC CMISSAllDiagType,CMISSInDiagType,CMISSFromDiagType

  PUBLIC CMISSAllTimingType,CMISSInTimingType,CMISSFromTimingType

  PUBLIC CMISSDiagnosticsSetOff,CMISSDiagnosticsSetOn

  PUBLIC CMISSOutputSetOff,CMISSOutputSetOn

  PUBLIC CMISSTimingSetOff,CMISSTimingSetOn,CMISSTimingSummaryOutput

!!==================================================================================================================================
!!
!! BASIS_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_BasisConstants OPENCMISS::Basis::Constants
  !> \brief Basis function constants.
  !>@{  
  !> \addtogroup OPENCMISS_BasisTypes OPENCMISS::Basis::BasisTypes
  !> \brief Basis definition type parameters.
  !> \see OPENCMISS::BasisConstants,OPENCMISS
  !>@{ symbol 'nodenumber' at (1) has no IMPLICIT type.
  INTEGER(INTG), PARAMETER :: CMISSBasisLagrangeHermiteTPType = BASIS_LAGRANGE_HERMITE_TP_TYPE !<Lagrange-Hermite tensor product basis type \see OPENCMISS_BasisTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSBasisSimplexType = BASIS_SIMPLEX_TYPE !<Simplex basis type \see OPENCMISS_BasisTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSBasisSerendipityType = BASIS_SERENDIPITY_TYPE !<Serendipity basis type \see OPENCMISS_BasisTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSBasisAuxilliaryType = BASIS_AUXILLIARY_TYPE !<Auxillary basis type \see OPENCMISS_BasisTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSBasisBSplineTPType = BASIS_B_SPLINE_TP_TYPE !<B-spline basis type \see OPENCMISS_BasisTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSBasisFourierLagrangeHermiteTPType = BASIS_FOURIER_LAGRANGE_HERMITE_TP_TYPE !<Fourier-Lagrange tensor product basis type \see OPENCMISS_BasisTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSBasisExtendedLagrangeTPType = BASIS_EXTENDED_LAGRANGE_TP_TYPE !< Extendend Lagrange tensor product basis type \see OPENCMISS_BasisTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_BasisInterpolationSpecifications OPENCMISS::Basis::InterpolationSpecifications
  !> \brief Interpolation specification parameters
  !> \see OPENCMISS::BasisConstants,OPENCMISS
  !>@{ 
  INTEGER(INTG), PARAMETER :: CMISSBasisLinearLagrangeInterpolation = BASIS_LINEAR_LAGRANGE_INTERPOLATION !<Linear Lagrange interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSBasisQuadraticLagrangeInterpolation = BASIS_QUADRATIC_LAGRANGE_INTERPOLATION !<Quadratic Lagrange interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSBasisCubicLagrangeInterpolation = BASIS_CUBIC_LAGRANGE_INTERPOLATION !<Cubic Lagrange interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSBasisCubicHermiteInterpolation = BASIS_CUBIC_HERMITE_INTERPOLATION !<Cubic Hermite interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSBasisQuadratic1HermiteInterpolation = BASIS_QUADRATIC1_HERMITE_INTERPOLATION !<Quadratic Hermite (no derivative at xi=0) interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSBasisQuadratic2HermiteInterpolation = BASIS_QUADRATIC2_HERMITE_INTERPOLATION !<Quadratic Hermite (no derivative at xi=1) interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSBasisLinearSimplexInterpolation = BASIS_LINEAR_SIMPLEX_INTERPOLATION !<Linear Simplex interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSBasisQuadraticSimplexInterpolation = BASIS_QUADRATIC_SIMPLEX_INTERPOLATION !<Quadratic Simplex interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSBasisCubicSimplexInterpolation = BASIS_CUBIC_SIMPLEX_INTERPOLATION !<Cubic Simplex interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_BasisQuadratureSchemes OPENCMISS::Basis::QuadratureSchemes
  !> \brief Quadrature scheme parameters
  !> \see OPENCMISS::BasisConstants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSBasisDefaultQuadratureScheme = BASIS_DEFAULT_QUADRATURE_SCHEME !<Identifier for the default quadrature scheme \see OPENCMISS_BasisQuadratureSchemes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSBasisLowQuadratureScheme = BASIS_LOW_QUADRATURE_SCHEME !<Identifier for a low order quadrature scheme \see OPENCMISS_BasisQuadratureSchemes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSBasisMidQuadratureScheme = BASIS_MID_QUADRATURE_SCHEME !<Identifier for a mid order quadrature scheme \see OPENCMISS_BasisQuadratureSchemes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSBasisHighQuadratureScheme = BASIS_HIGH_QUADRATURE_SCHEME !<Identifier for a high order quadrature scheme \see OPENCMISS_BasisQuadratureSchemes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_BasisQuadratureTypes OPENCMISS::Basis::QuadratureTypes
  !> \brief Basis quadrature type parameters.
  !> \see OPENCMISS::BasisConstants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSBasisGaussLegendreQuadrature = BASIS_GAUSS_LEGENDRE_QUADRATURE !<Gauss-Legendre quadrature \see OPENCMISS_BasisQuadratureTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSBasisGaussLaguerreQuadrature = BASIS_GAUSS_LAGUERRE_QUADRATURE !<Gauss-Laguerre quadrature \see OPENCMISS_BasisQuadratureTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSBasisGaussHermiteQuadrature = BASIS_GUASS_HERMITE_QUADRATURE !<Gauss-Hermite quadrature \see OPENCMISS_BasisQuadratureTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSBasisAdaptiveGaussLegendreQuadrature = BASIS_ADAPTIVE_GAUSS_LEGENDRE_QUADRATURE !<Adaptive Gauss-Legendre quadrature \see OPENCMISS_BasisQuadratureTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSBasisGaussSimplexQuadrature = BASIS_GAUSS_SIMPLEX_QUADRATURE !<Gauss-Legendre for Simplex elements quadrature \see OPENCMISS_BasisQuadratureTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_BasisXiCollapse OPENCMISS::Basis::XiCollapse
  !> \brief Basis Xi collapse parameters.
  !> \see OPENCMISS::Basis,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSBasisXiCollapsed = BASIS_XI_COLLAPSED !<The Xi direction is collapsed \see OPENCMISS_BasisXiCollapse,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSBasisCollapsedAtXi0 = BASIS_COLLAPSED_AT_XI0 !<The Xi direction at the xi=0 end of this Xi direction is collapsed \see OPENCMISS_BasisXiCollapse,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSBasisCollapsedAtXi1 = BASIS_COLLAPSED_AT_XI1 !<The Xi direction at the xi=1 end of this Xi direction is collapsed \see OPENCMISS_BasisXiCollapse,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSBasisNotCollapsed = BASIS_NOT_COLLAPSED !<The Xi direction is not collapsed \see OPENCMISS_XiCollapse,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Returns the collapsed Xi flags for a basis.
  INTERFACE CMISSBasisCollapsedXiGet
    MODULE PROCEDURE CMISSBasisCollapsedXiGetNumber
    MODULE PROCEDURE CMISSBasisCollapsedXiGetObj
  END INTERFACE !CMISSBasisCollapsedXiGet
  
  !>Sets/changes the collapsed Xi flags for a basis.
  INTERFACE CMISSBasisCollapsedXiSet
    MODULE PROCEDURE CMISSBasisCollapsedXiSetNumber
    MODULE PROCEDURE CMISSBasisCollapsedXiSetObj
  END INTERFACE !CMISSBasisCollapsedXiSet
  
  !>Finishes the creation of a new basis. \see OPENCMISS::CMISSBasisCreateStart
  INTERFACE CMISSBasisCreateFinish
    MODULE PROCEDURE CMISSBasisCreateFinishNumber
    MODULE PROCEDURE CMISSBasisCreateFinishObj
  END INTERFACE !CMISSBasisCreateFinish
  
  !>Starts the creation of a new basis. \see OPENCMISS::CMISSBasisCreateFinish
  INTERFACE CMISSBasisCreateStart
    MODULE PROCEDURE CMISSBasisCreateStartNumber
    MODULE PROCEDURE CMISSBasisCreateStartObj
  END INTERFACE !CMISSBasisCreateStart
  
  !>Destroys a basis.
  INTERFACE CMISSBasisDestroy
    MODULE PROCEDURE CMISSBasisDestroyNumber
    MODULE PROCEDURE CMISSBasisDestroyObj
  END INTERFACE !CMISSBasisDestroy

  !>Get the interpolation type in each Xi directions for a basis.
  INTERFACE CMISSBasisInterpolationXiGet
    MODULE PROCEDURE CMISSBasisInterpolationXiGetNumber
    MODULE PROCEDURE CMISSBasisInterpolationXiGetObj
  END INTERFACE !CMISSBasisInterpolationXiGet
  
  !>Sets/changes the interpolation type in each Xi directions for a basis.
  INTERFACE CMISSBasisInterpolationXiSet
    MODULE PROCEDURE CMISSBasisInterpolationXiSetNumber
    MODULE PROCEDURE CMISSBasisInterpolationXiSetObj
  END INTERFACE !CMISSBasisInterpolationXiSet
  
  !>Returns the number of local nodes in a basis.
  INTERFACE CMISSBasisNumberOfLocalNodesGet
    MODULE PROCEDURE CMISSBasisNumberOfLocalNodesGetNumber
    MODULE PROCEDURE CMISSBasisNumberOfLocalNodesGetObj
  END INTERFACE !CMISSBasisNumberOfLocalNodesGet
  
  !>Returns the number of Xi directions in a basis.
  INTERFACE CMISSBasisNumberOfXiGet
    MODULE PROCEDURE CMISSBasisNumberOfXiGetNumber
    MODULE PROCEDURE CMISSBasisNumberOfXiGetObj
  END INTERFACE !CMISSBasisNumberOfXiGet
  
  !>Sets/changes the number of Xi directions in a basis.
  INTERFACE CMISSBasisNumberOfXiSet
    MODULE PROCEDURE CMISSBasisNumberOfXiSetNumber
    MODULE PROCEDURE CMISSBasisNumberOfXiSetObj
  END INTERFACE !CMISSBasisNumberOfXiSet
  
  !>Returns the number of Gauss points in each Xi direction on a basis quadrature.
  INTERFACE CMISSBasisQuadratureNumberOfGaussXiGet
    MODULE PROCEDURE CMISSBasisQuadratureNumberOfGaussXiGetNumber
    MODULE PROCEDURE CMISSBasisQuadratureNumberOfGaussXiGetObj
  END INTERFACE !CMISSBasisQuadratureNumberOfGaussXiGet
  
  !>Sets/changes the number of Gauss points in each Xi direction on a basis quadrature.
  INTERFACE CMISSBasisQuadratureNumberOfGaussXiSet
    MODULE PROCEDURE CMISSBasisQuadratureNumberOfGaussXiSetNumber
    MODULE PROCEDURE CMISSBasisQuadratureNumberOfGaussXiSetObj
  END INTERFACE !CMISSBasisQuadratureNumberOfGaussXiSet
  
  !>Returns the order of quadrature for a basis quadrature.
  INTERFACE CMISSBasisQuadratureOrderGet
    MODULE PROCEDURE CMISSBasisQuadratureOrderGetNumber
    MODULE PROCEDURE CMISSBasisQuadratureOrderGetObj
  END INTERFACE !CMISSBasisQuadratureOrderGet
  
  !>Sets/changes the order of quadrature for a basis quadrature.
  INTERFACE CMISSBasisQuadratureOrderSet
    MODULE PROCEDURE CMISSBasisQuadratureOrderSetNumber
    MODULE PROCEDURE CMISSBasisQuadratureOrderSetObj
  END INTERFACE !CMISSBasisQuadratureOrderSet
  
  !>Returns the quadrature type for a basis quadrature.
  INTERFACE CMISSBasisQuadratureTypeGet
    MODULE PROCEDURE CMISSBasisQuadratureTypeGetNumber
    MODULE PROCEDURE CMISSBasisQuadratureTypeGetObj
  END INTERFACE !CMISSBasisQuadratureTypeGet
  
  !>Sets/changes the quadrature type for a basis quadrature.
  INTERFACE CMISSBasisQuadratureTypeSet
    MODULE PROCEDURE CMISSBasisQuadratureTypeSetNumber
    MODULE PROCEDURE CMISSBasisQuadratureTypeSetObj
  END INTERFACE !CMISSBasisQuadratureTypeSet
  
  !>Returns the type of a basis.
  INTERFACE CMISSBasisTypeGet
    MODULE PROCEDURE CMISSBasisTypeGetNumber
    MODULE PROCEDURE CMISSBasisTypeGetObj
  END INTERFACE !CMISSBasisTypeGet
  
  !>Sets/changes the type of a basis.
  INTERFACE CMISSBasisTypeSet
    MODULE PROCEDURE CMISSBasisTypeSetNumber
    MODULE PROCEDURE CMISSBasisTypeSetObj
  END INTERFACE !CMISSBasisTypeSet
  
  PUBLIC CMISSBasisLagrangeHermiteTPType,CMISSBasisSimplexType,CMISSBasisSerendipityType,CMISSBasisAuxilliaryType, &
    & CMISSBasisBSplineTPType,CMISSBasisFourierLagrangeHermiteTPType,CMISSBasisExtendedLagrangeTPType

  PUBLIC CMISSBasisLinearLagrangeInterpolation,CMISSBasisQuadraticLagrangeInterpolation,CMISSBasisCubicLagrangeInterpolation, &
    & CMISSBasisCubicHermiteInterpolation,CMISSBasisQuadratic1HermiteInterpolation,CMISSBasisQuadratic2HermiteInterpolation, &
    & CMISSBasisLinearSimplexInterpolation,CMISSBasisQuadraticSimplexInterpolation,CMISSBasisCubicSimplexInterpolation

  PUBLIC CMISSBasisDefaultQuadratureScheme,CMISSBasisLowQuadratureScheme,CMISSBasisMidQuadratureScheme, &
    & CMISSBasisHighQuadratureScheme

  PUBLIC CMISSBasisGaussLegendreQuadrature,CMISSBasisGaussLaguerreQuadrature,CMISSBasisGaussHermiteQuadrature, &
    & CMISSBasisAdaptiveGaussLegendreQuadrature,CMISSBasisGaussSimplexQuadrature

  PUBLIC CMISSBasisXiCollapsed,CMISSBasisCollapsedAtXi0,CMISSBasisCollapsedAtXi1,CMISSBasisNotCollapsed

  PUBLIC CMISSBasisCollapsedXiGet,CMISSBasisCollapsedXiSet
  
  PUBLIC CMISSBasisCreateFinish,CMISSBasisCreateStart,CMISSBasisDestroy

  PUBLIC CMISSBasisInterpolationXiGet,CMISSBasisInterpolationXiSet

  PUBLIC CMISSBasisNumberOfLocalNodesGet

  PUBLIC CMISSBasisNumberOfXiGet,CMISSBasisNumberOfXiSet

  PUBLIC CMISSBasisQuadratureNumberOfGaussXiGet,CMISSBasisQuadratureNumberOfGaussXiSet

  PUBLIC CMISSBasisQuadratureOrderGet,CMISSBasisQuadratureOrderSet

  PUBLIC CMISSBasisQuadratureTypeGet,CMISSBasisQuadratureTypeSet
 
  PUBLIC CMISSBasisTypeGet,CMISSBasisTypeSet
 
!!==================================================================================================================================
!!
!! BOUNDARY_CONDITIONS_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters


  !> \addtogroup OPENCMISS_BoundaryConditionsConstants OPENCMISS::BoundaryConditions::Constants
  !> \brief Boundary conditions constants.
  !>@{  
  !> \addtogroup OPENCMISS_BoundaryConditionsTypes OPENCMISS::BoundaryConditions::Types
  !> \brief Boundary conditions type parameters.
  !> \see OPENCMISS::BoundaryConditions,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSBoundaryConditionNotFixed = BOUNDARY_CONDITION_NOT_FIXED !<The dof is not fixed. \see OPENCMISS_BoundaryConditionsTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSBoundaryConditionFixed = BOUNDARY_CONDITION_FIXED !<The dof is fixed as a boundary condition. \see OPENCMISS_BoundaryConditionsTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSBoundaryConditionMixed = BOUNDARY_CONDITION_MIXED !<The dof is set as a mixed boundary condition. \see OPENCMISS_BoundaryConditionsTypes,OPENCMISS

  !Temporary boundary flags (to be removed when general boundary object becomes available!)
  INTEGER(INTG), PARAMETER :: CMISSBoundaryConditionFixedWall = BOUNDARY_CONDITION_FIXED_WALL
  INTEGER(INTG), PARAMETER :: CMISSBoundaryConditionInletWall = BOUNDARY_CONDITION_FIXED_INLET
  INTEGER(INTG), PARAMETER :: CMISSBoundaryConditionOutletWall = BOUNDARY_CONDITION_FIXED_OUTLET
  INTEGER(INTG), PARAMETER :: CMISSBoundaryConditionMovedWall = BOUNDARY_CONDITION_MOVED_WALL
  INTEGER(INTG), PARAMETER :: CMISSBoundaryConditionFreeWall = BOUNDARY_CONDITION_FREE_WALL

  !>@}
  !>@}
  
  !Module types

  !Module variables

  !Interfaces

  !>Destroys boundary conditions.
  INTERFACE CMISSBoundaryConditionsDestroy
    MODULE PROCEDURE CMISSBoundaryConditionsDestroyNumber
    MODULE PROCEDURE CMISSBoundaryConditionsDestroyObj
  END INTERFACE !CMISSBoundaryConditionsDestroy

  !>Adds to the value of the specified constant and sets this as a boundary condition on the specified constant.
  INTERFACE CMISSBoundaryConditionsAddConstant
    MODULE PROCEDURE CMISSBoundaryConditionsAddConstantNumber
    MODULE PROCEDURE CMISSBoundaryConditionsAddConstantObj
  END INTERFACE !CMISSBoundaryConditionsAddConstant

  !>Sets the value of the specified constant as a boundary condition on the specified constant.
  INTERFACE CMISSBoundaryConditionsSetConstant
    MODULE PROCEDURE CMISSBoundaryConditionsSetConstantNumber
    MODULE PROCEDURE CMISSBoundaryConditionsSetConstantObj
  END INTERFACE !CMISSBoundaryConditionsSetConstant

  !>Adds to the value of the element constant and sets this as a boundary condition on the specified element.
  INTERFACE CMISSBoundaryConditionsAddElement
    MODULE PROCEDURE CMISSBoundaryConditionsAddElementNumber
    MODULE PROCEDURE CMISSBoundaryConditionsAddElementObj
  END INTERFACE !CMISSBoundaryConditionsAddElement

  !>Sets the value of the specified element as a boundary condition on the specified element.
  INTERFACE CMISSBoundaryConditionsSetElement
    MODULE PROCEDURE CMISSBoundaryConditionsSetElementNumber
    MODULE PROCEDURE CMISSBoundaryConditionsSetElementObj
  END INTERFACE !CMISSBoundaryConditionsSetElement

  !>Adds to the value of the node constant and sets this as a boundary condition on the specified node.
  INTERFACE CMISSBoundaryConditionsAddNode
    MODULE PROCEDURE CMISSBoundaryConditionsAddNodeNumber
    MODULE PROCEDURE CMISSBoundaryConditionsAddNodeObj
  END INTERFACE !CMISSBoundaryConditionsAddNode

  !>Sets the value of the specified node as a boundary condition on the specified node.
  INTERFACE CMISSBoundaryConditionsSetNode
    MODULE PROCEDURE CMISSBoundaryConditionsSetNodeNumber
    MODULE PROCEDURE CMISSBoundaryConditionsSetNodeObj
  END INTERFACE !CMISSBoundaryConditionsSetNode

  !>Gets the boundary conditions for an equations set.
  INTERFACE CMISSEquationsSetBoundaryConditionsGet
    MODULE PROCEDURE CMISSEquationsSetBoundaryConditionsGetNumber
    MODULE PROCEDURE CMISSEquationsSetBoundaryConditionsGetObj
  END INTERFACE !CMISSEquationsSetBoundaryConditionsGet

  PUBLIC CMISSBoundaryConditionNotFixed,CMISSBoundaryConditionFixed,CMISSBoundaryConditionMixed
  !Temporary boundary flags (to be removed when general boundary object becomes available!)
  PUBLIC CMISSBoundaryConditionFixedWall,CMISSBoundaryConditionInletWall,CMISSBoundaryConditionMovedWall, &
    & CMISSBoundaryConditionFreeWall,CMISSBoundaryConditionOutletWall

  PUBLIC CMISSBoundaryConditionsDestroy

  PUBLIC CMISSBoundaryConditionsAddConstant,CMISSBoundaryConditionsSetConstant

  PUBLIC CMISSBoundaryConditionsAddElement,CMISSBoundaryConditionsSetElement

  PUBLIC CMISSBoundaryConditionsAddNode,CMISSBoundaryConditionsSetNode

  PUBLIC CMISSEquationsSetBoundaryConditionsGet

!!==================================================================================================================================
!!
!! CMISS_CELLML
!!
!!==================================================================================================================================
  
  !Module parameters

  !> \addtogroup OPENCMISS_CellMLConstants OPENCMISS::CellML::Constants
  !> \brief CellML constants.
  !>@{  
  !> \addtogroup OPENCMISS_CellMLFieldTypes OPENCMISS::CellML::FieldTypes
  !> \brief CellML field type parameters.
  !> \see OPENCMISS::CellML,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSCellMLModelsFieldType = CELLML_MODELS_FIELD_TYPE !<CellML models field type \see OPENCMISS_CellMLFieldTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSCellMLStateFieldType = CELLML_STATE_FIELD_TYPE !<CellML state field type \see OPENCMISS_CellMLFieldTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSCellMLIntermediateFieldType = CELLML_INTERMEDIATE_FIELD_TYPE !<CellML intermediate field type \see OPENCMISS_CellMLFieldTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSCellMLParametersFieldType = CELLML_PARAMETERS_FIELD_TYPE !<CellML parameters field type \see OPENCMISS_CellMLFieldTypes,OPENCMISS
  !>@}
  !>@}
  
  !Module types
  
  !Module variables
  
  !Interfaces
    
  !>Finishes the creation of a CellML environment. \see OPENCMISS::CMISSCellMLCreateStart
  INTERFACE CMISSCellMLCreateFinish
    MODULE PROCEDURE CMISSCellMLCreateFinishNumber
    MODULE PROCEDURE CMISSCellMLCreateFinishObj
  END INTERFACE !CMISSCellMLCreateFinish

  !>Starts the creation of a CellML environment. \see OPENCMISS::CMISSCellMLCreateFinish
  INTERFACE CMISSCellMLCreateStart
    MODULE PROCEDURE CMISSCellMLCreateStartNumber
    MODULE PROCEDURE CMISSCellMLCreateStartObj
  END INTERFACE !CMISSCellMLCreateStart

  !>Destroys a CellML environment.
  INTERFACE CMISSCellMLDestroy
    MODULE PROCEDURE CMISSCellMLDestroyNumber
    MODULE PROCEDURE CMISSCellMLDestroyObj
  END INTERFACE !CMISSCellMLDestroy

  !>Finishes the creation of CellML models. \see OPENCMISS::CMISSCellMLModelsCreateStart
  INTERFACE CMISSCellMLModelsCreateFinish
    MODULE PROCEDURE CMISSCellMLModelsCreateFinishNumber
    MODULE PROCEDURE CMISSCellMLModelsCreateFinishObj
  END INTERFACE !CMISSCellMLModelsCreateFinish

  !>Starts the creation of CellML models. \see OPENCMISS::CMISSCellMLModelsCreateFinish
  INTERFACE CMISSCellMLModelsCreateStart
    MODULE PROCEDURE CMISSCellMLModelsCreateStartNumber
    MODULE PROCEDURE CMISSCellMLModelsCreateStartObj
  END INTERFACE !CMISSCellMLModelsCreateStart

  !>Imports the specified CellML model into a CellML models environment. 
  INTERFACE CMISSCellMLModelImport
    MODULE PROCEDURE CMISSCellMLModelImportNumberC
    MODULE PROCEDURE CMISSCellMLModelImportObjC
    MODULE PROCEDURE CMISSCellMLModelImportNumberVS
    MODULE PROCEDURE CMISSCellMLModelImportObjVS
  END INTERFACE !CMISSCellMLModelImport

  !>Finishes the creation of CellML models field. \see OPENCMISS::CMISSCellMLModelsFieldCreateStart
  INTERFACE CMISSCellMLModelsFieldCreateFinish
    MODULE PROCEDURE CMISSCellMLModelsFieldCreateFinishNumber
    MODULE PROCEDURE CMISSCellMLModelsFieldCreateFinishObj
  END INTERFACE !CMISSCellMLModelsFieldCreateFinish

  !>Starts the creation of CellML models field. \see OPENCMISS::CMISSCellMLModelsFieldCreateFinish
  INTERFACE CMISSCellMLModelsFieldCreateStart
    MODULE PROCEDURE CMISSCellMLModelsFieldCreateStartNumber
    MODULE PROCEDURE CMISSCellMLModelsFieldCreateStartObj
  END INTERFACE !CMISSCellMLModelsFieldCreateStart

  !>Returns the CellML models field for a CellML environment. 
  INTERFACE CMISSCellMLModelsFieldGet
    MODULE PROCEDURE CMISSCellMLModelsFieldGetNumber
    MODULE PROCEDURE CMISSCellMLModelsFieldGetObj
  END INTERFACE !CMISSCellMLModelsFieldGet
  
  !>Finishes the creation of CellML state field. \see OPENCMISS::CMISSCellMLStateFieldCreateStart
  INTERFACE CMISSCellMLStateFieldCreateFinish
    MODULE PROCEDURE CMISSCellMLStateFieldCreateFinishNumber
    MODULE PROCEDURE CMISSCellMLStateFieldCreateFinishObj
  END INTERFACE !CMISSCellMLStateFieldCreateFinish

  !>Starts the creation of CellML state field. \see OPENCMISS::CMISSCellMLStateFieldCreateFinish
  INTERFACE CMISSCellMLStateFieldCreateStart
    MODULE PROCEDURE CMISSCellMLStateFieldCreateStartNumber
    MODULE PROCEDURE CMISSCellMLStateFieldCreateStartObj
  END INTERFACE !CMISSCellMLStateFieldCreateStart

  !>Returns the CellML state field for a CellML environment. 
  INTERFACE CMISSCellMLStateFieldGet
    MODULE PROCEDURE CMISSCellMLStateFieldGetNumber
    MODULE PROCEDURE CMISSCellMLStateFieldGetObj
  END INTERFACE !CMISSCellMLStateFieldGet

  !>Returns the component for a given CellML field that corresponds to the speicifed CellML URI. 
  INTERFACE CMISSCellMLFieldComponentGet
    MODULE PROCEDURE CMISSCellMLFieldComponentGetNumberC
    MODULE PROCEDURE CMISSCellMLFieldComponentGetObjC
    MODULE PROCEDURE CMISSCellMLFieldComponentGetNumberVS
    MODULE PROCEDURE CMISSCellMLFieldComponentGetObjVS
  END INTERFACE !CMISSCellMLFieldComponentGet

  !>Adds a specific variable to the CellML environments intermediate field.
  INTERFACE CMISSCellMLIntermediateFieldAdd
    MODULE PROCEDURE CMISSCellMLIntermediateFieldAddNumberC
    MODULE PROCEDURE CMISSCellMLIntermediateFieldAddObjC
    MODULE PROCEDURE CMISSCellMLIntermediateFieldAddNumberVS
    MODULE PROCEDURE CMISSCellMLIntermediateFieldAddObjVS
  END INTERFACE !CMISSCellMLIntermediateFieldAdd
  
  !>Finishes the creation of CellML intermediate field. \see OPENCMISS::CMISSCellMLIntermediateFieldCreateStart
  INTERFACE CMISSCellMLIntermediateFieldCreateFinish
    MODULE PROCEDURE CMISSCellMLIntermediateFieldCreateFinishNumber
    MODULE PROCEDURE CMISSCellMLIntermediateFieldCreateFinishObj
  END INTERFACE !CMISSCellMLIntermediateFieldCreateFinish

  !>Starts the creation of CellML intermediate field. \see OPENCMISS::CMISSCellMLIntermediateFieldCreateFinish
  INTERFACE CMISSCellMLIntermediateFieldCreateStart
    MODULE PROCEDURE CMISSCellMLIntermediateFieldCreateStartNumber
    MODULE PROCEDURE CMISSCellMLIntermediateFieldCreateStartObj
  END INTERFACE !CMISSCellMLIntermediateFieldCreateStart

  !>Returns the CellML intermediate field for a CellML environment. 
  INTERFACE CMISSCellMLIntermediateFieldGet
    MODULE PROCEDURE CMISSCellMLIntermediateFieldGetNumber
    MODULE PROCEDURE CMISSCellMLIntermediateFieldGetObj
  END INTERFACE !CMISSCellMLIntermediateFieldGet

  !>Adds a specific variable to the CellML environments parameters.
  INTERFACE CMISSCellMLParameterAdd
    MODULE PROCEDURE CMISSCellMLParameterAddNumberC
    MODULE PROCEDURE CMISSCellMLParameterAddObjC
    MODULE PROCEDURE CMISSCellMLParameterAddNumberVS
    MODULE PROCEDURE CMISSCellMLParameterAddObjVS
  END INTERFACE !CMISSCellMLParameterAdd
  
  !>Finishes the creation of CellML parameters. \see OPENCMISS::CMISSCellMLParametersCreateStart
  INTERFACE CMISSCellMLParametersCreateFinish
    MODULE PROCEDURE CMISSCellMLParametersCreateFinishNumber
    MODULE PROCEDURE CMISSCellMLParametersCreateFinishObj
  END INTERFACE !CMISSCellMLParametersCreateFinish

  !>Starts the creation of CellML parameters. \see OPENCMISS::CMISSCellMLParametersCreateFinish
  INTERFACE CMISSCellMLParametersCreateStart
    MODULE PROCEDURE CMISSCellMLParametersCreateStartNumber
    MODULE PROCEDURE CMISSCellMLParametersCreateStartObj
  END INTERFACE !CMISSCellMLParametersCreateStart

  !>Finishes the creation of CellML parameters field. \see OPENCMISS::CMISSCellMLParametersFieldCreateStart
  INTERFACE CMISSCellMLParametersFieldCreateFinish
    MODULE PROCEDURE CMISSCellMLParametersFieldCreateFinishNumber
    MODULE PROCEDURE CMISSCellMLParametersFieldCreateFinishObj
  END INTERFACE !CMISSCellMLParametersFieldCreateFinish

  !>Starts the creation of CellML parameters field. \see OPENCMISS::CMISSCellMLParametersFieldCreateFinish
  INTERFACE CMISSCellMLParametersFieldCreateStart
    MODULE PROCEDURE CMISSCellMLParametersFieldCreateStartNumber
    MODULE PROCEDURE CMISSCellMLParametersFieldCreateStartObj
  END INTERFACE !CMISSCellMLParametersFieldCreateStart

  !>Returns the CellML parameters field for a CellML environment. 
  INTERFACE CMISSCellMLParametersFieldGet
    MODULE PROCEDURE CMISSCellMLParametersFieldGetNumber
    MODULE PROCEDURE CMISSCellMLParametersFieldGetObj
  END INTERFACE !CMISSCellMLParametersFieldGet

  !>Validate and instantiate the specified CellML environment. 
  INTERFACE CMISSCellMLGenerate
    MODULE PROCEDURE CMISSCellMLGenerateNumber
    MODULE PROCEDURE CMISSCellMLGenerateObj
  END INTERFACE !CMISSCellMLGenerate

  PUBLIC CMISSCellMLModelsFieldType,CMISSCellMLStateFieldType,CMISSCellMLIntermediateFieldType,CMISSCellMLParametersFieldType
  
  PUBLIC CMISSCellMLCreateFinish,CMISSCellMLCreateStart

  PUBLIC CMISSCellMLDestroy

  PUBLIC CMISSCellMLModelsCreateFinish,CMISSCellMLModelsCreateStart,CMISSCellMLModelImport

  PUBLIC CMISSCellMLModelsFieldCreateFinish,CMISSCellMLModelsFieldCreateStart,CMISSCellMLModelsFieldGet

  PUBLIC CMISSCellMLStateFieldCreateFinish,CMISSCellMLStateFieldCreateStart,CMISSCellMLStateFieldGet

  PUBLIC CMISSCellMLFieldComponentGet

  PUBLIC CMISSCellMLIntermediateFieldAdd,CMISSCellMLIntermediateFieldCreateFinish,CMISSCellMLIntermediateFieldCreateStart, &
    & CMISSCellMLIntermediateFieldGet

  PUBLIC CMISSCellMLParameterAdd,CMISSCellMLParametersCreateFinish,CMISSCellMLParametersCreateStart

  PUBLIC CMISSCellMLParametersFieldCreateFinish,CMISSCellMLParametersFieldCreateStart,CMISSCellMLParametersFieldGet

  PUBLIC CMISSCellMLGenerate

!!==================================================================================================================================
!!
!! COMP_ENVIRONMENT
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  PUBLIC CMISSComputationalNodeNumberGet
  
  PUBLIC CMISSComputationalNumberOfNodesGet

!!==================================================================================================================================
!!
!! CONSTANTS
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_Constants OPENCMISS::Constants
  !> \brief Control loops constants.
  !>@{  
  !> \addtogroup OPENCMISS_GlobalDerivativeConstants OPENCMISS::Constants::GlobalDerivativeConstants
  !> \brief Global derivative constant identifiers
  !> \see OPENCMISS_CONSTANTS,OPENCMISS
  !>@{ 
  INTEGER(INTG), PARAMETER :: CMISSNoGlobalDerivative = NO_GLOBAL_DERIV !<No global derivative i.e., u \see OPENCMISS_GlobalDerivativeConstants,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSGlobalDerivativeS1 = GLOBAL_DERIV_S1 !<First global derivative in the s1 direction i.e., du/ds1 \see OPENCMISS_GlobalDerivativeConstants,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSGlobalDerivativeS2 = GLOBAL_DERIV_S2 !<First global derivative in the s2 direction i.e., du/ds2 \see OPENCMISS_GlobalDerivativeConstants,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSGlobalDerivativeS1S2 = GLOBAL_DERIV_S1_S2 !<Global Cross derivative in the s1 and s2 direction i.e., d^2u/ds1ds2 \see OPENCMISS_GlobalDerivativeConstants,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSGlobalDerivativeS3 = GLOBAL_DERIV_S3 !<First global derivative in the s3 direction i.e., du/ds3 \see OPENCMISS_GlobalDerivativeConstants,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSGlobalDerivativeS1S3 = GLOBAL_DERIV_S1_S3 !<Global Cross derivative in the s1 and s3 direction i.e., d^2u/ds1ds3 \see OPENCMISS_GlobalDerivativeConstants,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSGlobalDerivativeS2S3 = GLOBAL_DERIV_S2_S3 !<Global Cross derivative in the s2 and s3 direction i.e., d^2u/ds2ds3 \see OPENCMISS_GlobalDerivativeConstants,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSGlobalDerivativeS1S2S3 = GLOBAL_DERIV_S1_S2_S3 !<Cross derivative in the s1, s2 and s3 direction i.e., d^3u/ds1ds2ds3 \see OPENCMISS_GlobalDerivativeConstants,OPENCMISS
  !>@}
  !>@}
  
  !Module types

  !Module variables

  !Interfaces

  PUBLIC CMISSNoGlobalDerivative,CMISSGlobalDerivativeS1,CMISSGlobalDerivativeS2,CMISSGlobalDerivativeS1S2, &
    & CMISSGlobalDerivativeS3,CMISSGlobalDerivativeS1S3,CMISSGlobalDerivativeS2S3,CMISSGlobalDerivativeS1S2S3

!!==================================================================================================================================
!!
!! CONTROL_LOOP_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_ControlLoopConstants OPENCMISS::ControlLoop::Constants
  !> \brief Control loops constants.
  !>@{  
  !> \addtogroup OPENCMISS_ControlLoopIdentifiers OPENCMISS::ControlLoop::Identifiers
  !> \brief The control loop identification parameters.
  !> \see OPENCMISS::ControlLoop,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSControlLoopNode = CONTROL_LOOP_NODE !<The identifier for a each "leaf" node in a control loop. \see OPENCMISS_ControlLoopIdentifiers,OPENCMISS
  !>@}
  !>@}
  
  !Module types

  !Module variables

  !Interfaces

  !>Returns the current time parameters for a time control loop.
  INTERFACE CMISSControlLoopCurrentTimesGet
    MODULE PROCEDURE CMISSControlLoopCurrentTimesGetNumber0
    MODULE PROCEDURE CMISSControlLoopCurrentTimesGetNumber1
    MODULE PROCEDURE CMISSControlLoopCurrentTimesGetObj
  END INTERFACE !CMISSControlLoopCurrentTimesGet

  !>Destroy a control loop.
  INTERFACE CMISSControlLoopDestroy
    MODULE PROCEDURE CMISSControlLoopDestroyNumber0
    MODULE PROCEDURE CMISSControlLoopDestroyNumber1
    MODULE PROCEDURE CMISSControlLoopDestroyObj
  END INTERFACE !CMISSControlLoopDestroy

  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root.
  INTERFACE CMISSControlLoopGet
    MODULE PROCEDURE CMISSControlLoopGetNumber00
    MODULE PROCEDURE CMISSControlLoopGetNumber10
    MODULE PROCEDURE CMISSControlLoopGetNumber01
    MODULE PROCEDURE CMISSControlLoopGetNumber11
    MODULE PROCEDURE CMISSControlLoopGetObj0
    MODULE PROCEDURE CMISSControlLoopGetObj1
  END INTERFACE !CMISSControlLoopGet

  !>Sets/changes the iteration parameters for a fixed control loop. \todo need a get metod
  INTERFACE CMISSControlLoopIterationsSet
    MODULE PROCEDURE CMISSControlLoopIterationsSetNumber0
    MODULE PROCEDURE CMISSControlLoopIterationsSetNumber1
    MODULE PROCEDURE CMISSControlLoopIterationsSetObj
  END INTERFACE !CMISSControlLoopIterationsSet

  !>Sets/changes the maximum iterations for a while control loop. \todo need a get method
  INTERFACE CMISSControlLoopMaximumIterationsSet
    MODULE PROCEDURE CMISSControlLoopMaximumIterationsSetNumber0
    MODULE PROCEDURE CMISSControlLoopMaximumIterationsSetNumber1
    MODULE PROCEDURE CMISSControlLoopMaximumIterationsSetObj
  END INTERFACE !CMISSControlLoopMaximumIterationsSet

  !>Returns the number of sub loops for a control loop.
  INTERFACE CMISSControlLoopNumberOfSubLoopsGet
    MODULE PROCEDURE CMISSControlLoopNumberOfSubLoopsGetNumber0
    MODULE PROCEDURE CMISSControlLoopNumberOfSubLoopsGetNumber1
    MODULE PROCEDURE CMISSControlLoopNumberOfSubLoopsGetObj
  END INTERFACE !CMISSControlLoopNumberOfSubLoopsGet

  !>Sets/changes the number of sub loops for a control loop. \todo is this really a public method???
  INTERFACE CMISSControlLoopNumberOfSubLoopsSet
    MODULE PROCEDURE CMISSControlLoopNumberOfSubLoopsSetNumber0
    MODULE PROCEDURE CMISSControlLoopNumberOfSubLoopsSetNumber1
    MODULE PROCEDURE CMISSControlLoopNumberOfSubLoopsSetObj
  END INTERFACE !CMISSControlLoopNumberOfSubLoopsGet

  !>Sets/changes the output parameters for a time control loop.
  INTERFACE CMISSControlLoopTimeOutputSet
    MODULE PROCEDURE CMISSControlLoopTimeOutputSetNumber0
    MODULE PROCEDURE CMISSControlLoopTimeOutputSetNumber1
    MODULE PROCEDURE CMISSControlLoopTimeOutputSetObj
  END INTERFACE !CMISSControlLoopTimeOutputSet

  !>Sets/changes the input parameters for a time control loop.
  INTERFACE CMISSControlLoopTimeInputSet
    MODULE PROCEDURE CMISSControlLoopTimeInputSetNumber0
    MODULE PROCEDURE CMISSControlLoopTimeInputSetNumber1
    MODULE PROCEDURE CMISSControlLoopTimeInputSetObj
  END INTERFACE !CMISSControlLoopTimeInputSet

  !>Returns the time parameters for a time control loop.
  INTERFACE CMISSControlLoopTimesGet
    MODULE PROCEDURE CMISSControlLoopTimesGetNumber0
    MODULE PROCEDURE CMISSControlLoopTimesGetNumber1
    MODULE PROCEDURE CMISSControlLoopTimesGetObj
  END INTERFACE !CMISSControlLoopTimesGet

  !>Sets/Changes the time parameters for a time control loop.
  INTERFACE CMISSControlLoopTimesSet
    MODULE PROCEDURE CMISSControlLoopTimesSetNumber0
    MODULE PROCEDURE CMISSControlLoopTimesSetNumber1
    MODULE PROCEDURE CMISSControlLoopTimesSetObj
  END INTERFACE !CMISSControlLoopTimesSet

  !>Sets/Changes the loop type for a control loop. \todo Is this really a public       method? \todo need a get method
  INTERFACE CMISSControlLoopTypeSet
    MODULE PROCEDURE CMISSControlLoopTypeSetNumber0
    MODULE PROCEDURE CMISSControlLoopTypeSetNumber1
    MODULE PROCEDURE CMISSControlLoopTypeSetObj
  END INTERFACE !CMISSControlLoopTypeSet

  PUBLIC CMISSControlLoopNode
  
  PUBLIC CMISSControlLoopCurrentTimesGet
   
  PUBLIC CMISSControlLoopDestroy

  PUBLIC CMISSControlLoopGet

  PUBLIC CMISSControlLoopIterationsSet

  PUBLIC CMISSControlLoopMaximumIterationsSet

  PUBLIC CMISSControlLoopNumberOfSubLoopsGet,CMISSControlLoopNumberOfSubLoopsSet

  PUBLIC CMISSControlLoopTimeOutputSet,CMISSControlLoopTimeInputSet
  
  PUBLIC CMISSControlLoopTimesGet,CMISSControlLoopTimesSet

  PUBLIC CMISSControlLoopTypeSet
 

!!==================================================================================================================================
!!
!! COORDINATE_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_CoordinateConstants OPENCMISS::Coordinate::Constants
  !> \brief Coordinate constants.
  !>@{  
  !> \addtogroup OPENCMISS_CoordinateSystemTypes OPENCMISS::Coordinate::SystemTypes
  !> \brief Coordinate system type parameters.
  !> \see OPENCMISS::Coordinate,OPENCMISS
  !>@{ 
  INTEGER(INTG), PARAMETER :: CMISSCoordinateRectangularCartesianType = COORDINATE_RECTANGULAR_CARTESIAN_TYPE !<Rectangular Cartesian coordinate system type \see OPENCMISS_CoordinateSystemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSCoordinateCylindricalPolarType = COORDINATE_CYLINDRICAL_POLAR_TYPE !<Cylindrical polar coordinate system type \see OPENCMISS_CoordinateSystemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSCoordinateSphericalPolarType = COORDINATE_SPHERICAL_POLAR_TYPE !<Spherical polar coordinate system type \see OPENCMISS_CoordinateSystemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSCoordinateProlateSpheroidalType = COORDINATE_PROLATE_SPHEROIDAL_TYPE !<Prolate spheroidal coordinate system type \see OPENCMISS_CoordinateSystemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSCoordinateOblateSpheroidalType = COORDINATE_OBLATE_SPHEROIDAL_TYPE !<Oblate spheroidal coordinate system type \see OPENCMISS_CoordinateSystemTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_CoordinateRadialInterpolations OPENCMISS::Coordinate::RadialInterpolations
  !> \brief The type of radial interpolation for polar coordinate systems
  !> \see OPENCMISS::Coordinate,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSCoordinateNoRadialInterpolationType = COORDINATE_NO_RADIAL_INTERPOLATION_TYPE !<No radial interpolation \see OPENCMISS_CoordinateRadialInterpolations,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSCoordinateRadialInterpolationType = COORDINATE_RADIAL_INTERPOLATION_TYPE !<r radial interpolation \see OPENCMISS_CoordinateRadialInterpolations,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSCoordinateRadialSquaredInterpolationType = COORDINATE_RADIAL_SQUARED_INTERPOLATION_TYPE !<r^2 radial interpolation \see OPENCMISS_CoordinateRadialInterpolations,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSCoordinateRadialCubedInterpolationType = COORDINATE_RADIAL_CUBED_INTERPOLATION_TYPE !<r^3 radial interpolation \see OPENCMISS_CoordinateRadialInterpolations,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Finishes the creation of a coordinate system. \see OPENCMISS::CMISSCoordinateSystemCreateStart
  INTERFACE CMISSCoordinateSystemCreateFinish
    MODULE PROCEDURE CMISSCoordinateSystemCreateFinishNumber
    MODULE PROCEDURE CMISSCoordinateSystemCreateFinishObj
  END INTERFACE !CMISSCoordinateSystemCreateFinish

  !>Starts the creation of a coordinate system. \see OPENCMISS::CMISSCoordinateSystemCreateFinish
  INTERFACE CMISSCoordinateSystemCreateStart
    MODULE PROCEDURE CMISSCoordinateSystemCreateStartNumber
    MODULE PROCEDURE CMISSCoordinateSystemCreateStartObj
  END INTERFACE !CMISSCoordinateSystemCreateStart

  !>Destorys a coordinate system.
  INTERFACE CMISSCoordinateSystemDestroy
    MODULE PROCEDURE CMISSCoordinateSystemDestroyNumber
    MODULE PROCEDURE CMISSCoordinateSystemDestroyObj
  END INTERFACE !CMISSCoordinateSystemDestroy

  !>Returns the coordinate system dimension. \todo user number method \todo fix pointers
  INTERFACE CMISSCoordinateSystemDimensionGet
    MODULE PROCEDURE CMISSCoordinateSystemDimensionGetNumber
    MODULE PROCEDURE CMISSCoordinateSystemDimensionGetObj
  END INTERFACE !CMISSCoordinateSystemDimensionGet

  !>Sets/changes the coordinate system dimension. \todo fix pointers
  INTERFACE CMISSCoordinateSystemDimensionSet
    MODULE PROCEDURE CMISSCoordinateSystemDimensionSetNumber
    MODULE PROCEDURE CMISSCoordinateSystemDimensionSetObj
  END INTERFACE !CMISSCoordinateSystemDimensionSet

  !>Returns the coordinate system focus. \todo user number method \todo fix pointers
  INTERFACE CMISSCoordinateSystemFocusGet
    MODULE PROCEDURE CMISSCoordinateSystemFocusGetNumber
    MODULE PROCEDURE CMISSCoordinateSystemFocusGetObj
  END INTERFACE !CMISSCoordinateSystemFocusGet
    
  !>Sets/changes the coordinate system focus. \todo user number method \todo fix pointers
  INTERFACE CMISSCoordinateSystemFocusSet
    MODULE PROCEDURE CMISSCoordinateSystemFocusSetNumber
    MODULE PROCEDURE CMISSCoordinateSystemFocusSetObj
  END INTERFACE !CMISSCoordinateSystemFocusSet

  !>Returns the coordinate system radial interpolation type. \todo user number method \todo fix pointers
  INTERFACE CMISSCoordinateSystemRadialInterpolationGet
    MODULE PROCEDURE CMISSCoordinateSystemRadialInterpolationGetNumber
    MODULE PROCEDURE CMISSCoordinateSystemRadialInterpolationGetObj
  END INTERFACE !CMISSCoordinateSystemRadialInterpolationGet
    
  !>Sets/changes the coordinate system radial interpolation type. \todo user number method \todo fix pointers
  INTERFACE CMISSCoordinateSystemRadialInterpolationSet
    MODULE PROCEDURE CMISSCoordinateSystemRadialInterpolationSetNumber
    MODULE PROCEDURE CMISSCoordinateSystemRadialInterpolationSetObj
  END INTERFACE !CMISSCoordinateSystemRadialInterpolationSet
    
  !>Returns the coordinate system type. \todo user number method \todo fix pointers
  INTERFACE CMISSCoordinateSystemTypeGet
    MODULE PROCEDURE CMISSCoordinateSystemTypeGetNumber
    MODULE PROCEDURE CMISSCoordinateSystemTypeGetObj
  END INTERFACE !CMISSCoordinateSystemTypeGet
    
  !>Sets/changes the coordinate system type. \todo user number method \todo fix pointers
  INTERFACE CMISSCoordinateSystemTypeSet
    MODULE PROCEDURE CMISSCoordinateSystemTypeSetNumber
    MODULE PROCEDURE CMISSCoordinateSystemTypeSetObj
  END INTERFACE !CMISSCoordinateSystemTypeSet

  !>Returns the coordinate system orign. 
  INTERFACE CMISSCoordinateSystemOriginGet
    MODULE PROCEDURE CMISSCoordinateSystemOriginGetNumber
    MODULE PROCEDURE CMISSCoordinateSystemOriginGetObj
  END INTERFACE !CMISSCoordinateSystemOriginGet

  !>Sets/changes the coordinate system orign. 
  INTERFACE CMISSCoordinateSystemOriginSet
    MODULE PROCEDURE CMISSCoordinateSystemOriginSetNumber
    MODULE PROCEDURE CMISSCoordinateSystemOriginSetObj
  END INTERFACE !CMISSCoordinateSystemOriginSet

  !>Returns the coordinate system orientation. 
  INTERFACE CMISSCoordinateSystemOrientationGet
    MODULE PROCEDURE CMISSCoordinateSystemOrientationGetNumber
    MODULE PROCEDURE CMISSCoordinateSystemOrientationGetObj
  END INTERFACE !CMISSCoordinateSystemOrientationGet

  !>Sets/changes the coordinate system orientation. 
  INTERFACE CMISSCoordinateSystemOrientationSet
    MODULE PROCEDURE CMISSCoordinateSystemOrientationSetNumber
    MODULE PROCEDURE CMISSCoordinateSystemOrientationSetObj
  END INTERFACE !CMISSCoordinateSystemOrientationSet

  PUBLIC CMISSCoordinateRectangularCartesianType,CMISSCoordinateCylindricalPolarType,CMISSCoordinateSphericalPolarType, &
    & CMISSCoordinateProlateSpheroidalType,CMISSCoordinateOblateSpheroidalType

  PUBLIC CMISSCoordinateNoRadialInterpolationType,CMISSCoordinateRadialInterpolationType, &
    & CMISSCoordinateRadialSquaredInterpolationType,CMISSCoordinateRadialCubedInterpolationType

  PUBLIC CMISSCoordinateSystemCreateFinish,CMISSCoordinateSystemCreateStart

  PUBLIC CMISSCoordinateSystemDestroy
  
  PUBLIC CMISSCoordinateSystemDimensionGet,CMISSCoordinateSystemDimensionSet

  PUBLIC CMISSCoordinateSystemFocusGet,CMISSCoordinateSystemFocusSet

  PUBLIC CMISSCoordinateSystemRadialInterpolationGet,CMISSCoordinateSystemRadialInterpolationSet

  PUBLIC CMISSCoordinateSystemTypeGet,CMISSCoordinateSystemTypeSet

  PUBLIC CMISSCoordinateSystemOriginGet,CMISSCoordinateSystemOriginSet

  PUBLIC CMISSCoordinateSystemOrientationGet,CMISSCoordinateSystemOrientationSet
  
!!==================================================================================================================================
!!
!! EQUATIONS_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters
  
  !> \addtogroup OPENCMISS_EquationsConstants OPENCMISS::Equations::Constants
  !> \brief Equations  constants.
  !>@{
  !> \addtogroup OPENCMISS_EquationsOutputTypes OPENCMISS::Equations::OutputTypes
  !> \brief Equations output types
  !> \see OPENCMISS::Equations,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSEquationsNoOutput = EQUATIONS_NO_OUTPUT!<No output from the equations \see OPENCMISS_EquationsOutputTypes,OPENCMISS   
  INTEGER(INTG), PARAMETER :: CMISSEquationsTimingOutput = EQUATIONS_TIMING_OUTPUT !<Timing information output. \see OPENCMISS_EquationsOutputTypes,OPENCMISS   
  INTEGER(INTG), PARAMETER :: CMISSEquationsMatrixOutput = EQUATIONS_MATRIX_OUTPUT !<All below and equation matrices output. \see OPENCMISS_EquationsOutputTypes,OPENCMISS   
  INTEGER(INTG), PARAMETER :: CMISSEquationsElementMatrixOutput = EQUATIONS_ELEMENT_MATRIX_OUTPUT !<All below and element matrices output. \see OPENCMISS_EquationsOutputTypes,OPENCMISS   
  !>@}
  !> \addtogroup OPENCMISS_EquationsSparsityTypes OPENCMISS::Equations::SparsityTypes
  !> \brief Equations sparsity types
  !> \see OPENCMISS::Equations,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSEquationsSparseMatrices = EQUATIONS_SPARSE_MATRICES !<Use sparse matrices for the equations. \see OPENCMISS_EquationsSparsityTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsFullMatrices = EQUATIONS_FULL_MATRICES !<Use fully populated matrices for the equations. \see OPENCMISS_EquationsSparsityTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_EquationsLumpingTypes OPENCMISS::Equations::LumpingTypes
  !> \brief Equations lumping types
  !> \see OPENCMISS::Equations,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSEquationsUnlumpedMatrices = EQUATIONS_UNLUMPED_MATRICES !<The equations matrices are not lumped. \see OPENCMISS_EquationsLumpingTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsLumpedMatrices = EQUATIONS_LUMPED_MATRICES !<The equations matrices are "mass" lumped. \see OPENCMISS_EquationsLumpingTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_EquationsLinearityTypes OPENCMISS::Equations::LinearityTypes
  !> \brief The equations linearity types
  !> \see OPENCMISS::Equations,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSEquationsLinear = EQUATIONS_LINEAR !<The equations are linear. \see OPENCMISS_EquationsLinearityTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsNonlinear = EQUATIONS_NONLINEAR !<The equations are non-linear. \see \see OPENCMISS_EquationsLinearityTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsNonlinearBCs = EQUATIONS_NONLINEAR_BCS !<The equations have non-linear boundary conditions. \see \see OPENCMISS_EquationsLinearityTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_EquationsTimeDepedenceTypes OPENCMISS::Equations::TimeDepedenceTypes
  !> \brief The equations time dependence types
  !> \see OPENCMISS::Equations,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSEquationsStatic = EQUATIONS_STATIC !<The equations are static and have no time dependence. \see OPENCMISS_EquationsTimeDepedenceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsQuasistatic = EQUATIONS_QUASISTATIC !<The equations are quasi-static. \see OPENCMISS_EquationsTimeDepedenceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsFirstOrderDynamic = EQUATIONS_FIRST_ORDER_DYNAMIC !<The equations are first order dynamic. \see OPENCMISS_EquationsTimeDepedenceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSecondOrderDynamic = EQUATIONS_SECOND_ORDER_DYNAMIC !<The equations are a second order dynamic. \see OPENCMISS_EquationsTimeDepedenceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsTimeStepping = EQUATIONS_TIME_STEPPING !<The equations are for time stepping. \see OPENCMISS_EquationsTimeDepedenceTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Destroys equations for an equations set.
  INTERFACE CMISSEquationsDestroy
    MODULE PROCEDURE CMISSEquationsDestroyNumber
    MODULE PROCEDURE CMISSEquationsDestroyObj
  END INTERFACE !CMISSEquationsDestroy

  !>Gets the linearity type for equations.
  INTERFACE CMISSEquationsLinearityTypeGet
    MODULE PROCEDURE CMISSEquationsLinearityTypeGetNumber
    MODULE PROCEDURE CMISSEquationsLinearityTypeGetObj
  END INTERFACE !CMISSEquationsLinearityTypeGet

  !>Gets the lumping type for equations.
  INTERFACE CMISSEquationsLumpingTypeGet
    MODULE PROCEDURE CMISSEquationsLumpingTypeGetNumber
    MODULE PROCEDURE CMISSEquationsLumpingTypeGetObj
  END INTERFACE !CMISSEquationsLumpingTypeGet

  !>Sets/changes the lumping type for equations.
  INTERFACE CMISSEquationsLumpingTypeSet
    MODULE PROCEDURE CMISSEquationsLumpingTypeSetNumber
    MODULE PROCEDURE CMISSEquationsLumpingTypeSetObj
  END INTERFACE !CMISSEquationsLumpingTypeSet

  !>Gets the output type for equations.
  INTERFACE CMISSEquationsOutputTypeGet
    MODULE PROCEDURE CMISSEquationsOutputTypeGetNumber
    MODULE PROCEDURE CMISSEquationsOutputTypeGetObj
  END INTERFACE !CMISSEquationsOutputTypeGet

  !>Sets/changes the output type for equations.
  INTERFACE CMISSEquationsOutputTypeSet
    MODULE PROCEDURE CMISSEquationsOutputTypeSetNumber
    MODULE PROCEDURE CMISSEquationsOutputTypeSetObj
  END INTERFACE !CMISSEquationsOutputTypeSet

 !>Gets the sparsity type for equations.
  INTERFACE CMISSEquationsSparsityTypeGet
    MODULE PROCEDURE CMISSEquationsSparsityTypeGetNumber
    MODULE PROCEDURE CMISSEquationsSparsityTypeGetObj
  END INTERFACE !CMISSEquationsSparsityTypeGet

  !>Sets/changes the sparsity type for equations.
  INTERFACE CMISSEquationsSparsityTypeSet
    MODULE PROCEDURE CMISSEquationsSparsityTypeSetNumber
    MODULE PROCEDURE CMISSEquationsSparsityTypeSetObj
  END INTERFACE !CMISSEquationsSparsityTypeSet

  !>Gets the time dependence type for equations.
  INTERFACE CMISSEquationsTimeDependenceTypeGet
    MODULE PROCEDURE CMISSEquationsTimeDependenceTypeGetNumber
    MODULE PROCEDURE CMISSEquationsTimeDependenceTypeGetObj
  END INTERFACE !CMISSEquationsTimeDependenceTypeGet

 PUBLIC CMISSEquationsNoOutput,CMISSEquationsTimingOutput,CMISSEquationsMatrixOutput,CMISSEquationsElementMatrixOutput

  PUBLIC CMISSEquationsSparseMatrices,CMISSEquationsFullMatrices

  PUBLIC CMISSEquationsUnlumpedMatrices,CMISSEquationsLumpedMatrices

  PUBLIC CMISSEquationsLinear,CMISSEquationsNonlinear,CMISSEquationsNonlinearBCs

  PUBLIC CMISSEquationsStatic,CMISSEquationsQuasistatic,CMISSEquationsFirstOrderDynamic,CMISSEquationsSecondOrderDynamic, &
    & CMISSEquationsTimeStepping

  PUBLIC CMISSEquationsDestroy

  PUBLIC CMISSEquationsLinearityTypeGet

  PUBLIC CMISSEquationsLumpingTypeGet,CMISSEquationsLumpingTypeSet

  PUBLIC CMISSEquationsOutputTypeGet,CMISSEquationsOutputTypeSet

  PUBLIC CMISSEquationsSparsityTypeGet,CMISSEquationsSparsityTypeSet

  PUBLIC CMISSEquationsTimeDependenceTypeGet

!!==================================================================================================================================
!!
!! EQUATIONS_SET_CONSTANTS
!!
!!==================================================================================================================================

  !Module parameters
  
  !> \addtogroup OPENCMISS_EquationsSetConstants OPENCMISS::EquationsSet::Constants
  !> \brief Equations set constants.
  !>@{
  !> \addtogroup OPENCMISS_EquationsSetClasses OPENCMISS::EquationsSet::Classes
  !> \brief Equations set classes.
  !> \see OPENCMISS::EquationsSet,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetNoClass = EQUATIONS_SET_NO_CLASS !<No equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS   
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetElasticityClass = EQUATIONS_SET_ELASTICITY_CLASS !<Elasticity equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS   
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetFluidMechanicsClass = EQUATIONS_SET_FLUID_MECHANICS_CLASS !<Fluid Mechanics equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS   
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetElectroMechanicsClass = EQUATIONS_SET_ELECTROMAGNETICS_CLASS !<Electromagnetics equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS   
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetClassicalFieldClass = EQUATIONS_SET_CLASSICAL_FIELD_CLASS !<Classical Field equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS   
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetBioelectricsClass = EQUATIONS_SET_BIOELECTRICS_CLASS !<Bioelectrics equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS     
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetModalClass = EQUATIONS_SET_MODAL_CLASS !<Modal equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS     
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetFittingClass = EQUATIONS_SET_FITTING_CLASS !<Fitting equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS     
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetOptimisationClass = EQUATIONS_SET_OPTIMISATION_CLASS !<Optimisation equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS     
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetMultiPhysicsClass = EQUATIONS_SET_MULTI_PHYSICS_CLASS !<Multi Physics equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS   
  !>@}
  !> \addtogroup OPENCMISS_EquationsSetTypes OPENCMISS::EquationsSet::Types
  !> \brief Equations set Types.
  !> \see OPENCMISS::EquationsSet,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetNoType = EQUATIONS_SET_NO_TYPE !<No equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetLinearElasticityType = EQUATIONS_SET_LINEAR_ELASTICITY_TYPE !<Linear elasticity equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetFiniteElasticityType = EQUATIONS_SET_FINITE_ELASTICITY_TYPE !<Finite elasticity equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetStokesEquationType = EQUATIONS_SET_STOKES_EQUATION_TYPE !<Stokes equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetNavierStokesEquationType = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TYPE !<Navier-Stokes equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetDarcyEquationType = EQUATIONS_SET_DARCY_EQUATION_TYPE !<Darcy equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetElectrostaticType = EQUATIONS_SET_ELECTROSTATIC_TYPE !<Electrostatic equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetMagnetoStaticType = EQUATIONS_SET_MAGNETOSTATIC_TYPE !<Magnetostatic equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetMaxwellsEquationType = EQUATIONS_SET_MAXWELLS_EQUATIONS_TYPE !<Maxwells equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetLaplaceEquationType = EQUATIONS_SET_LAPLACE_EQUATION_TYPE !<Laplace equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetPoissonEquationType = EQUATIONS_SET_POISSON_EQUATION_TYPE !<Poisson equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetHelmholtzEquationType = EQUATIONS_SET_HELMHOLTZ_EQUATION_TYPE !<Helmholtz equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetWaveEquationType = EQUATIONS_SET_WAVE_EQUATION_TYPE !<Wave equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetDiffusionEquationType = EQUATIONS_SET_DIFFUSION_EQUATION_TYPE !<Diffusion equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetAdvectionDiffusionEquationType = EQUATIONS_SET_ADVECTION_DIFFUSION_EQUATION_TYPE !<Advection-Diffusion equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetReactionDiffusionEquationType = EQUATIONS_SET_REACTION_DIFFUSION_EQUATION_TYPE !<Reaction-Diffusion equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetBiharmonicEquationType = EQUATIONS_SET_BIHARMONIC_EQUATION_TYPE !<Biharmonic equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetMonodomainEquationType = EQUATIONS_SET_MONODOMAIN_EQUATION_TYPE !<Monodomain equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetBidomainEquationType = EQUATIONS_SET_BIDOMAIN_EQUATION_TYPE !<Bidomain equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetLinearElasticModalType = EQUATIONS_SET_LINEAR_ELASTIC_MODAL_TYPE !<Linear elasticity modal equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetGalerkinProjectionEquationType = EQUATIONS_SET_GALERKIN_PROJECTION_EQUATION_TYPE !<Galerkin projection equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetFiniteElasticityDarcyType = EQUATIONS_SET_FINITE_ELASTICITY_DARCY_TYPE !<Finite Elasticity Darcy equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetFiniteElasticityStokesType = EQUATIONS_SET_FINITE_ELASTICITY_STOKES_TYPE !<Finite Elasticity Stokes equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetFiniteElasticityNavierStokesType = &
    & EQUATIONS_SET_FINITE_ELASTICITY_NAVIER_STOKES_TYPE !<Finite Elasticity Navier Stokes equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetDiffusionDiffusionType = EQUATIONS_SET_DIFFUSION_DIFFUSION_TYPE !<Diffusion Diffusion equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetDiffusionAdvectionDiffusionType = EQUATIONS_SET_DIFFUSION_ADVECTION_DIFFUSION_TYPE !<Diffusion Advection Diffusion equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_EquationsSetSubtypes OPENCMISS::EquationsSet::Subtypes
  !> \brief Equations set subtypes.
  !> \see OPENCMISS::EquationsSet,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetNoSubtype = EQUATIONS_SET_NO_SUBTYPE !<No equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetThreeDimensionalSubtype = EQUATIONS_SET_THREE_DIMENSIONAL_SUBTYPE !<Three dimensional linear elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetPlaneStressSubtype = EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRESS_SUBTYPE !<Plane stress linear elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetPlaneStrainSubtype = EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRAIN_SUBTYPE !<Plane strain linear elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetOneDimensionalSubtype = EQUATIONS_SET_ONE_DIMENSIONAL_SUBTYPE !<One dimensional linear elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetPlateSubtype = EQUATIONS_SET_PLATE_SUBTYPE !<Plate linear elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetShellSubtype = EQUATIONS_SET_SHELL_SUBTYPE !<Shell linear elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetMooneyRivlinSubtype = EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE !< Mooney-Rivlin constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetIsotropicExponentialSubtype = EQUATIONS_SET_ISOTROPIC_EXPONENTIAL_SUBTYPE !< Isotropic exponential constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetTransverseIsotropicExponentialSubtype = &
    & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_EXPONENTIAL_SUBTYPE !< Transverse isotropic exponential constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetOrthotropicMaterialCostaSubtype = &
    & EQUATIONS_SET_ORTHOTROPIC_MATERIAL_COSTA_SUBTYPE !< Orthotropic Costa constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetStaticStokesSubtype = EQUATIONS_SET_STATIC_STOKES_SUBTYPE !<Static Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetLaplaceStokesSubtype = EQUATIONS_SET_LAPLACE_STOKES_SUBTYPE !<Laplace type Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetTransientStokesSubtype = EQUATIONS_SET_TRANSIENT_STOKES_SUBTYPE !<Transient Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetALEStokesSubtype = EQUATIONS_SET_ALE_STOKES_SUBTYPE !<ALE Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetPGMStokesSubtype = EQUATIONS_SET_PGM_STOKES_SUBTYPE !<PGM Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetOptimisedStokesSubtype = EQUATIONS_SET_OPTIMISED_STOKES_SUBTYPE !<Optimised Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetStaticNavierStokesSubtype = EQUATIONS_SET_STATIC_NAVIER_STOKES_SUBTYPE !<Static Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetLaplaceNavierStokesSubtype = EQUATIONS_SET_LAPLACE_NAVIER_STOKES_SUBTYPE !<Laplace type Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetTransientNavierStokesSubtype = EQUATIONS_SET_TRANSIENT_NAVIER_STOKES_SUBTYPE !<Transient Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetALENavierStokesSubtype = EQUATIONS_SET_ALE_NAVIER_STOKES_SUBTYPE !<ALE Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetPGMNavierStokesSubtype = EQUATIONS_SET_PGM_NAVIER_STOKES_SUBTYPE !<PGM Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetOptimisedNavierStokesSubtype = EQUATIONS_SET_OPTIMISED_NAVIER_STOKES_SUBTYPE !<Optimised Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetStandardDarcySubtype = EQUATIONS_SET_STANDARD_DARCY_SUBTYPE !<Standard Darcy equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetQuasistaticDarcySubtype = EQUATIONS_SET_QUASISTATIC_DARCY_SUBTYPE !<Quasistatic Darcy equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetALEDarcySubtype = EQUATIONS_SET_ALE_DARCY_SUBTYPE !<ALE Darcy equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetTransientDarcySubtype = EQUATIONS_SET_TRANSIENT_DARCY_SUBTYPE !<Transient Darcy equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetStandardLaplaceSubtype = EQUATIONS_SET_STANDARD_LAPLACE_SUBTYPE !<Standard Laplace equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetGeneralisedLaplaceSubtype = EQUATIONS_SET_GENERALISED_LAPLACE_SUBTYPE !<Generalised Laplace equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetMovingMeshLaplaceSubtype = EQUATIONS_SET_MOVING_MESH_LAPLACE_SUBTYPE !<Moving mesh Laplace equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetStokesPoissonSubtype = EQUATIONS_SET_STOKES_POISSON_SUBTYPE !<Vector source Poisson equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetNavierStokesPoissonSubtype = EQUATIONS_SET_NAVIER_STOKES_POISSON_SUBTYPE !<Vector source Poisson equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetConstantSourcePoissonSubtype = EQUATIONS_SET_CONSTANT_SOURCE_POISSON_SUBTYPE !<Constant source Poisson equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetLinearSourcePoissonSubtype = EQUATIONS_SET_LINEAR_SOURCE_POISSON_SUBTYPE !<Linear source Poisson equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetQuadraticSourcePoissonSubtype = EQUATIONS_SET_QUADRATIC_SOURCE_POISSON_SUBTYPE !<Quadratic source Poisson equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetExponentialSourcePoissonSubtype = EQUATIONS_SET_EXPONENTIAL_SOURCE_POISSON_SUBTYPE !<Exponential source Poisson equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetNoSourceHelmholtzSubtype = EQUATIONS_SET_NO_SOURCE_HELMHOLTZ_SUBTYPE !<No source Helmholtz equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetNoSourceDiffusionSubtype = EQUATIONS_SET_NO_SOURCE_DIFFUSION_SUBTYPE !<No source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetConstantSourceDiffusionSubtype = EQUATIONS_SET_CONSTANT_SOURCE_DIFFUSION_SUBTYPE !<Constant source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetLinearSourceDiffusionSubtype = EQUATIONS_SET_LINEAR_SOURCE_DIFFUSION_SUBTYPE !<Linear source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetQuadraticSourceDiffusionSubtype = EQUATIONS_SET_QUADRATIC_SOURCE_DIFFUSION_SUBTYPE !<Quadratic source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetExponentialSourceDiffusionSubtype = &
    & EQUATIONS_SET_EXPONENTIAL_SOURCE_DIFFUSION_SUBTYPE !<Exponential source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetNoSourceAdvectionDiffusionSubtype = & 
    & EQUATIONS_SET_NO_SOURCE_ADVECTION_DIFFUSION_SUBTYPE !<No source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetConstantSourceAdvectionDiffusionSubtype = &
    & EQUATIONS_SET_CONSTANT_SOURCE_ADVECTION_DIFFUSION_SUBTYPE !<Constant source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetLinearSourceAdvectionDiffusionSubtype = &
    & EQUATIONS_SET_LINEAR_SOURCE_ADVECTION_DIFFUSION_SUBTYPE !<Linear source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetQuadraticSourceAdvectionDiffusionSubtype = &
    & EQUATIONS_SET_QUADRATIC_SOURCE_ADVECTION_DIFFUSION_SUBTYPE !<Quadratic source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetExponentialSourceAdvectionDiffusionSubtype = &
    & EQUATIONS_SET_EXPONENTIAL_SOURCE_ADVECTION_DIFFUSION_SUBTYPE !<Exponential source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS

INTEGER(INTG), PARAMETER :: CMISSEquationsSetNoSourceStaticAdvecDiffSubtype = & 
    & EQUATIONS_SET_NO_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE !<No source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetConstantSourceStaticAdvecDiffSubtype = &
    & EQUATIONS_SET_CONSTANT_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE !<Constant source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetLinearSourceStaticAdvecDiffSubtype = &
    & EQUATIONS_SET_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE !<Linear source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetFirstBidomainSubtype = EQUATIONS_SET_FIRST_BIDOMAIN_SUBTYPE !<First bidomain equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetSecondBidomainSubtype = EQUATIONS_SET_SECOND_BIDOMAIN_SUBTYPE !<Second bidomain equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetStandardGalerkinProjectionSubtype = &
    & EQUATIONS_SET_STANDARD_GALERKIN_PROJECTION_SUBTYPE !<Standard Galerkin Projection equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetGeneralisedGalerkinProjectionSubtype = &
    & EQUATIONS_SET_GENERALISED_GALERKIN_PROJECTION_SUBTYPE !<Generalised Galerkin Projection equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetMatPropertiesGalerkinProjectionSubtype = &
    & EQUATIONS_SET_MAT_PROPERTIES_GALERKIN_PROJECTION_SUBTYPE !<Material Properties Galerkin Projection equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISSEquationsSetStandardElasticityDarcySubtype = EQUATIONS_SET_STANDARD_ELASTICITY_DARCY_SUBTYPE !<Standard Elasticity Darcy equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetCoupledSourceDiffusionDiffusionSubtype = &
    & EQUATIONS_SET_COUPLED_SOURCE_DIFFUSION_DIFFUSION_SUBTYPE !<Coupled source diffusion-diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetCoupledSourceDiffusionAdvecDiffusionSubtype = &
    & EQUATIONS_SET_COUPLED_SOURCE_DIFFUSION_ADVEC_DIFFUSION_SUBTYPE !<Coupled source diffusion & advection-diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS

  !>@}
  !> \addtogroup OPENCMISS_EquationsSetSolutionMethods OPENCMISS::EquationsSet::SolutionMethods
  !> \brief The solution method parameters
  !> \see OPENCMISS::EquationsSet,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetFEMSolutionMethod = EQUATIONS_SET_FEM_SOLUTION_METHOD !<Finite Element Method solution method. \see OPENCMISS_EquationsSetSolutionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetBEMSolutionMethod = EQUATIONS_SET_BEM_SOLUTION_METHOD !<Boundary Element Method solution method. \see OPENCMISS_EquationsSetSolutionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetFDSolutionMethod = EQUATIONS_SET_FD_SOLUTION_METHOD !<Finite Difference solution method. \see OPENCMISS_EquationsSetSolutionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetFVSolutionMethod = EQUATIONS_SET_FV_SOLUTION_METHOD !<Finite Volume solution method. \see OPENCMISS_EquationsSetSolutionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetGFEMSolutionMethod = EQUATIONS_SET_GFEM_SOLUTION_METHOD !<Grid-based Finite Element Method solution method. \see OPENCMISS_EquationsSetSolutionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetGFDSolutionMethod = EQUATIONS_SET_GFD_SOLUTION_METHOD !<Grid-based Finite Difference solution method. \see OPENCMISS_EquationsSetSolutionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetGFVSolutionMethod = EQUATIONS_SET_GFV_SOLUTION_METHOD !<Grid-based Finite Volume solution method. \see OPENCMISS_EquationsSetSolutionMethods,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_EquationsSetAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes
  !> \brief The analytic function types.
  !> \see OPENCMISS::EquationsSet,OPENCMISS
  !>@{
  !> \addtogroup OPENCMISS_EquationsSetLaplaceAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::Laplace
  !> \brief The analytic function types for a Laplace equation
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{  
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetLaplaceEquationTwoDim1 = EQUATIONS_SET_LAPLACE_EQUATION_TWO_DIM_1 !<u=x**2+2*x*y-y**2 \see OPENCMISS_EquationsSetLaplaceAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetLaplaceEquationTwoDim2 = EQUATIONS_SET_LAPLACE_EQUATION_TWO_DIM_2 !<u=cos(x)cosh(y) \see OPENCMISS_EquationsSetLaplaceAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetLaplaceEquationThreeDim1 = EQUATIONS_SET_LAPLACE_EQUATION_THREE_DIM_1 !<u=x**2-2*y**2+z**2 \see OPENCMISS_EquationsSetLaplaceAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetLaplaceEquationThreeDim2 = EQUATIONS_SET_LAPLACE_EQUATION_THREE_DIM_2 !<u=cos(x)*cosh(y)*z \see OPENCMISS_EquationsSetLaplaceAnalyticFunctionTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_PoissonAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::Poisson
  !> \brief The analytic function types for a Poisson equation.
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{  
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetPoissonTwoDim1 = EQUATIONS_SET_POISSON_EQUATION_TWO_DIM_1 !<u=ln(4/(x+y+1^2)) \see OPENCMISS_EquationsSetPoissonAnalyticFunctionTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_DiffusionAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::Diffusion
  !> \brief The analytic function types for a diffusion equation.
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{  
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetDiffusionTwoDim1 = EQUATIONS_SET_DIFFUSION_EQUATION_TWO_DIM_1 !<u=exp(-kt)*sin(sqrt(k)*(x*cos(phi)+y*sin(phi))) \see OPENCMISS_EquationsSetDiffusionAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetLinearSourceDiffusionThreeDim1 = &
    & EQUATIONS_SET_LINEAR_SOURCE_DIFFUSION_EQUATION_THREE_DIM_1 
  !>@}
  !> \addtogroup OPENCMISS_AdvectionDiffusionAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::AdvectionDiffusion
  !> \brief The analytic function types for an advection-diffusion equation.
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{  
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetAdvectionDiffusionTwoDim1 = EQUATIONS_SET_ADVECTION_DIFFUSION_EQUATION_TWO_DIM_1 !<u=exp(-kt)*sin(sqrt(k)*(x*cos(phi)+y*sin(phi))) \see OPENCMISS_EquationsSetDiffusionAnalyticFunctionTypes,OPENCMISS
  !> \addtogroup OPENCMISS_StokesAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::Stokes
  !> \brief The analytic function types for a Stokes equation.
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{  
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetStokesTwoDim1 = EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetStokesTwoDim2 = EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetStokesTwoDim3 = EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_3 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetStokesThreeDim1 = EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetStokesThreeDim2 = EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetStokesThreeDim3 = EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_3 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_NavierStokesAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::NavierStokes
  !> \brief The analytic function types for a Navier-Stokes equation.
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{  
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetNavierStokesTwoDim1 = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetNavierStokesTwoDim2 = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetNavierStokesTwoDim3 = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_3 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetNavierStokesThreeDim1 = EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetNavierStokesThreeDim2 = EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetNavierStokesThreeDim3 = EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_3 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_DarcyAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::Darcy
  !> \brief The analytic function types for a Darcy equation.
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{  
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetDarcyTwoDim1 = EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetDarcyAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetDarcyTwoDim2 = EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetDarcyAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetDarcyTwoDim3 = EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_3 !<u=tbd \see OPENCMISS_EquationsSetDarcyAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetDarcyThreeDim1 = EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetDarcyAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetDarcyThreeDim2 = EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetDarcyAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetDarcyThreeDim3 = EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_3 !<u=tbd \see OPENCMISS_EquationsSetDarcyAnalyticFunctionTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::LinearElasticity
  !> \brief The analytic function types for a LinearElasticity equation
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{  
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetLinearElasticityEquationOneDim1 = &
    & EQUATIONS_SET_LINEAR_ELASTICITY_EQUATION_ONE_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetLinearElasticityEquationTwoDim1 = & 
    & EQUATIONS_SET_LINEAR_ELASTICITY_EQUATION_TWO_DIM_PLANE_STRESS_1 !<u=tbd \see OPENCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSEquationsSetLinearElasticityEquationThreeDim1 = & 
    & EQUATIONS_SET_LINEAR_ELASTICITY_EQUATION_THREE_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OPENCMISS
  !>@}
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  PUBLIC CMISSEquationsSetNoClass,CMISSEquationsSetElasticityClass,CMISSEquationsSetFluidMechanicsClass, &
    & CMISSEquationsSetElectroMechanicsClass,CMISSEquationsSetClassicalFieldClass,CMISSEquationsSetBioelectricsClass, &
    & CMISSEquationsSetModalClass,CMISSEquationsSetFittingClass,CMISSEquationsSetOptimisationClass, &
    & CMISSEquationsSetMultiPhysicsClass

  PUBLIC CMISSEquationsSetNoType,CMISSEquationsSetLinearElasticityType,CMISSEquationsSetFiniteElasticityType, &
    & CMISSEquationsSetStokesEquationType,CMISSEquationsSetNavierStokesEquationType,CMISSEquationsSetDarcyEquationType, &
    & CMISSEquationsSetElectrostaticType,CMISSEquationsSetMagnetoStaticType,CMISSEquationsSetMaxwellsEquationType, &
    & CMISSEquationsSetLaplaceEquationType,CMISSEquationsSetPoissonEquationType,CMISSEquationsSetHelmholtzEquationType, &
    & CMISSEquationsSetWaveEquationType,CMISSEquationsSetDiffusionEquationType,CMISSEquationsSetAdvectionDiffusionEquationType, &
    & CMISSEquationsSetReactionDiffusionEquationType,CMISSEquationsSetBiharmonicEquationType, &
    & CMISSEquationsSetMonodomainEquationType,CMISSEquationsSetBidomainEquationType,CMISSEquationsSetLinearElasticModalType, &
    & CMISSEquationsSetGalerkinProjectionEquationType

  PUBLIC CMISSEquationsSetFiniteElasticityDarcyType, &
    & CMISSEquationsSetFiniteElasticityStokesType, CMISSEquationsSetFiniteElasticityNavierStokesType, &
    & CMISSEquationsSetDiffusionDiffusionType, CMISSEquationsSetDiffusionAdvectionDiffusionType

  PUBLIC CMISSEquationsSetNoSubtype,CMISSEquationsSetThreeDimensionalSubtype,CMISSEquationsSetPlaneStressSubtype, &
    & CMISSEquationsSetPlaneStrainSubtype,CMISSEquationsSetOneDimensionalSubtype,CMISSEquationsSetPlateSubtype, &
    & CMISSEquationsSetShellSubtype, &
    & CMISSEquationsSetMooneyRivlinSubtype,CMISSEquationsSetIsotropicExponentialSubtype, &
    & CMISSEquationsSetTransverseIsotropicExponentialSubtype, &
    & CMISSEquationsSetStaticStokesSubtype, CMISSEquationsSetLaplaceStokesSubtype, &
    & CMISSEquationsSetTransientStokesSubtype,CMISSEquationsSetALEStokesSubtype,CMISSEquationsSetALENavierStokesSubtype, &
    & CMISSEquationsSetOptimisedStokesSubtype,CMISSEquationsSetStaticNavierStokesSubtype, &
    & CMISSEquationsSetLaplaceNavierStokesSubtype,CMISSEquationsSetTransientNavierStokesSubtype,&
    & CMISSEquationsSetOptimisedNavierStokesSubtype,CMISSEquationsSetStandardDarcySubtype, &
    & CMISSEquationsSetQuasistaticDarcySubtype,CMISSEquationsSetALEDarcySubtype,CMISSEquationsSetTransientDarcySubtype, &
    & CMISSEquationsSetStandardLaplaceSubtype,CMISSEquationsSetMovingMeshLaplaceSubtype, &
    & CMISSEquationsSetGeneralisedLaplaceSubtype,CMISSEquationsSetConstantSourcePoissonSubtype, &
    & CMISSEquationsSetStokesPoissonSubtype, CMISSEquationsSetNavierStokesPoissonSubtype, &
    & CMISSEquationsSetLinearSourcePoissonSubtype,CMISSEquationsSetQuadraticSourcePoissonSubtype, &
    & CMISSEquationsSetExponentialSourcePoissonSubtype,CMISSEquationsSetNoSourceHelmholtzSubtype, &
    & CMISSEquationsSetNoSourceDiffusionSubtype,CMISSEquationsSetConstantSourceDiffusionSubtype, &
    & CMISSEquationsSetLinearSourceDiffusionSubtype,CMISSEquationsSetQuadraticSourceDiffusionSubtype, &
    & CMISSEquationsSetExponentialSourceDiffusionSubtype,CMISSEquationsSetNoSourceAdvectionDiffusionSubtype, &
    & CMISSEquationsSetConstantSourceAdvectionDiffusionSubtype,CMISSEquationsSetLinearSourceAdvectionDiffusionSubtype, &
    & CMISSEquationsSetQuadraticSourceAdvectionDiffusionSubtype,CMISSEquationsSetExponentialSourceAdvectionDiffusionSubtype, &
    & CMISSEquationsSetNoSourceStaticAdvecDiffSubtype, CMISSEquationsSetConstantSourceStaticAdvecDiffSubtype, &
    & CMISSEquationsSetLinearSourceStaticAdvecDiffSubtype, CMISSEquationsSetPGMStokesSubtype, &
    & CMISSEquationsSetFirstBidomainSubtype,CMISSEquationsSetSecondBidomainSubtype, &
    & CMISSEquationsSetStandardGalerkinProjectionSubtype,CMISSEquationsSetGeneralisedGalerkinProjectionSubtype, &
    & CMISSEquationsSetMatPropertiesGalerkinProjectionSubtype,CMISSEquationsSetPGMNavierStokesSubtype, &
    & CMISSEquationsSetCoupledSourceDiffusionDiffusionSubtype, CMISSEquationsSetCoupledSourceDiffusionAdvecDiffusionSubtype

  PUBLIC CMISSEquationsSetFEMSolutionMethod,CMISSEquationsSetBEMSolutionMethod,CMISSEquationsSetFDSolutionMethod, &
    & CMISSEquationsSetFVSolutionMethod,CMISSEquationsSetGFEMSolutionMethod,CMISSEquationsSetGFDSolutionMethod, &
    & CMISSEquationsSetGFVSolutionMethod

  PUBLIC CMISSEquationsSetLaplaceEquationTwoDim1,CMISSEquationsSetLaplaceEquationTwoDim2, &
    & CMISSEquationsSetLaplaceEquationThreeDim1,CMISSEquationsSetLaplaceEquationThreeDim2

  PUBLIC CMISSEquationsSetLinearElasticityEquationOneDim1,CMISSEquationsSetLinearElasticityEquationTwoDim1, &
    & CMISSEquationsSetLinearElasticityEquationThreeDim1

  PUBLIC CMISSEquationsSetDiffusionTwoDim1,CMISSEquationsSetLinearSourceDiffusionThreeDim1

  PUBLIC CMISSEquationsSetAdvectionDiffusionTwoDim1

  PUBLIC CMISSEquationsSetPoissonTwoDim1

  PUBLIC CMISSEquationsSetStokesTwoDim1,CMISSEquationsSetStokesTwoDim2,CMISSEquationsSetStokesTwoDim3
  PUBLIC CMISSEquationsSetStokesThreeDim1,CMISSEquationsSetStokesThreeDim2,CMISSEquationsSetStokesThreeDim3

  PUBLIC CMISSEquationsSetNavierStokesTwoDim1,CMISSEquationsSetNavierStokesTwoDim2,CMISSEquationsSetNavierStokesTwoDim3
  PUBLIC CMISSEquationsSetNavierStokesThreeDim1,CMISSEquationsSetNavierStokesThreeDim2,CMISSEquationsSetNavierStokesThreeDim3
  
  PUBLIC CMISSEquationsSetDarcyTwoDim1,CMISSEquationsSetDarcyTwoDim2,CMISSEquationsSetDarcyTwoDim3
  PUBLIC CMISSEquationsSetDarcyThreeDim1,CMISSEquationsSetDarcyThreeDim2,CMISSEquationsSetDarcyThreeDim3

!!==================================================================================================================================
!!
!! EQUATIONS_SET_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters
  
  !Module types

  !Module variables

  !Interfaces

  !>Finish the creation of a analytic solution for an equations set. \see OPENCMISS::CMISSEquationsSetAnalyticCreateStart
  INTERFACE CMISSEquationsSetAnalyticCreateFinish
    MODULE PROCEDURE CMISSEquationsSetAnalyticCreateFinishNumber
    MODULE PROCEDURE CMISSEquationsSetAnalyticCreateFinishObj
  END INTERFACE !CMISSEquationsSetAnalyticCreateFinish
  
  !>Start the creation of a analytic solution for an equations set. \see OPENCMISS::CMISSEquationsSetAnalyticCreateFinish
  INTERFACE CMISSEquationsSetAnalyticCreateStart
    MODULE PROCEDURE CMISSEquationsSetAnalyticCreateStartNumber
    MODULE PROCEDURE CMISSEquationsSetAnalyticCreateStartObj
  END INTERFACE !CMISSEquationsSetAnalyticCreateStart
  
  !>Destroy the analytic solution for an equations set.
  INTERFACE CMISSEquationsSetAnalyticDestroy
    MODULE PROCEDURE CMISSEquationsSetAnalyticDestroyNumber
    MODULE PROCEDURE CMISSEquationsSetAnalyticDestroyObj
  END INTERFACE !CMISSEquationsSetAnalyticDestroy
  
  !>Set boundary conditions for an equation set according to the analytic equations.
  INTERFACE CMISSEquationsSetBoundaryConditionsAnalytic
    MODULE PROCEDURE CMISSEquationsSetBoundaryConditionsAnalyticNumber
    MODULE PROCEDURE CMISSEquationsSetBoundaryConditionsAnalyticObj
  END INTERFACE !CMISSEquationsSetBoundaryConditionsAnalytic
  
  !>Finish the creation of boundary conditions for an equation set. \see OPENCMISS::CMISSEquationsSetBoundaryConditionsCreateStart
  INTERFACE CMISSEquationsSetBoundaryConditionsCreateFinish
    MODULE PROCEDURE CMISSEquationsSetBoundaryConditionsCreateFinishNumber
    MODULE PROCEDURE CMISSEquationsSetBoundaryConditionsCreateFinishObj
  END INTERFACE !CMISSEquationsSetBoundaryConditionsCreateFinish
  
  !>Start the creation of boundary conditions for an equation set. \see OPENCMISS::CMISSEquationsSetBoundaryConditionsCreateFinish
  INTERFACE CMISSEquationsSetBoundaryConditionsCreateStart
    MODULE PROCEDURE CMISSEquationsSetBoundaryConditionsCreateStartNumber
    MODULE PROCEDURE CMISSEquationsSetBoundaryConditionsCreateStartObj
  END INTERFACE !CMISSEquationsSetBoundaryConditionsCreateStart
  
  !>Destroy the boundary conditions for an equations set.
  INTERFACE CMISSEquationsSetBoundaryConditionsDestroy
    MODULE PROCEDURE CMISSEquationsSetBoundaryConditionsDestroyNumber
    MODULE PROCEDURE CMISSEquationsSetBoundaryConditionsDestroyObj
  END INTERFACE !CMISSEquationsSetBoundaryConditionsDestroy
  
  !>Finish the creation of an equations set. \see OPENCMISS::CMISSEquationsSetCreateStart
  INTERFACE CMISSEquationsSetCreateFinish
    MODULE PROCEDURE CMISSEquationsSetCreateFinishNumber
    MODULE PROCEDURE CMISSEquationsSetCreateFinishObj
  END INTERFACE !CMISSEquationsSetCreateFinish
  
  !>Start the creation of an equations set on a region. \see OPENCMISS::CMISSEquationsSetCreateFinish
  INTERFACE CMISSEquationsSetCreateStart
    MODULE PROCEDURE CMISSEquationsSetCreateStartNumber
    MODULE PROCEDURE CMISSEquationsSetCreateStartObj
  END INTERFACE !CMISSEquationsSetCreateStart
  
  !>Destroy an equations set. 
  INTERFACE CMISSEquationsSetDestroy
    MODULE PROCEDURE CMISSEquationsSetDestroyNumber
    MODULE PROCEDURE CMISSEquationsSetDestroyObj
  END INTERFACE !CMISSEquationsSetDestroy
  
  !>Finish the creation of dependent variables for an equations set. \see OPENCMISS::CMISSEquationsSetDependentCreateStart
  INTERFACE CMISSEquationsSetDependentCreateFinish
    MODULE PROCEDURE CMISSEquationsSetDependentCreateFinishNumber
    MODULE PROCEDURE CMISSEquationsSetDependentCreateFinishObj
  END INTERFACE !CMISSEquationsSetDependentCreateFinish
  
  !>Start the creation of dependent variables for an equations set. \see OPENCMISS::CMISSEquationsSetDependentCreateFinish
  INTERFACE CMISSEquationsSetDependentCreateStart
    MODULE PROCEDURE CMISSEquationsSetDependentCreateStartNumber
    MODULE PROCEDURE CMISSEquationsSetDependentCreateStartObj
  END INTERFACE !CMISSEquationsSetDependentCreateStart
  
  !>Destroy the dependent variables for an equations set.
  INTERFACE CMISSEquationsSetDependentDestroy
    MODULE PROCEDURE CMISSEquationsSetDependentDestroyNumber
    MODULE PROCEDURE CMISSEquationsSetDependentDestroyObj
  END INTERFACE !CMISSEquationsSetDependentDestroy
  
  !>Finish the creation of equations for an equations set. \see OPENCMISS::CMISSEquationsSetEquationsCreateStart
  INTERFACE CMISSEquationsSetEquationsCreateFinish
    MODULE PROCEDURE CMISSEquationsSetEquationsCreateFinishNumber
    MODULE PROCEDURE CMISSEquationsSetEquationsCreateFinishObj
  END INTERFACE !CMISSEquationsSetEquationsCreateFinish
  
  !>Start the creation of equations for an equations set. \see OPENCMISS::CMISSEquationsSetEquationsCreateFinish
  INTERFACE CMISSEquationsSetEquationsCreateStart
    MODULE PROCEDURE CMISSEquationsSetEquationsCreateStartNumber
    MODULE PROCEDURE CMISSEquationsSetEquationsCreateStartObj
  END INTERFACE !CMISSEquationsSetEquationsCreateStart
  
  !>Destroy the equations for an equations set.
  INTERFACE CMISSEquationsSetEquationsDestroy
    MODULE PROCEDURE CMISSEquationsSetEquationsDestroyNumber
    MODULE PROCEDURE CMISSEquationsSetEquationsDestroyObj
  END INTERFACE !CMISSEquationsSetEquationsDestroy
  
  !>Finish the creation of independent fields for an equations set. \see OPENCMISS::CMISSEquationsSetIndependentCreateStart
  INTERFACE CMISSEquationsSetIndependentCreateFinish
    MODULE PROCEDURE CMISSEquationsSetIndependentCreateFinishNumber
    MODULE PROCEDURE CMISSEquationsSetIndependentCreateFinishObj
  END INTERFACE !CMISSEquationsSetIndependentCreateFinish
  
  !>Start the creation of independent fields for an equations set. \see OPENCMISS::CMISSEquationsSetMaterialsCreateFinish
  INTERFACE CMISSEquationsSetIndependentCreateStart
    MODULE PROCEDURE CMISSEquationsSetIndependentCreateStartNumber
    MODULE PROCEDURE CMISSEquationsSetIndependentCreateStartObj
  END INTERFACE !CMISSEquationsSetIndependentCreateStart
  
  !>Destroy the independent fields for an equations set.
  INTERFACE CMISSEquationsSetIndependentDestroy
    MODULE PROCEDURE CMISSEquationsSetIndependentDestroyNumber
    MODULE PROCEDURE CMISSEquationsSetIndependentDestroyObj
  END INTERFACE !CMISSEquationsSetIndependentDestroy
  
  !>Finish the creation of materials for an equations set. \see OPENCMISS::CMISSEquationsSetMaterialsCreateStart
  INTERFACE CMISSEquationsSetMaterialsCreateFinish
    MODULE PROCEDURE CMISSEquationsSetMaterialsCreateFinishNumber
    MODULE PROCEDURE CMISSEquationsSetMaterialsCreateFinishObj
  END INTERFACE !CMISSEquationsSetMaterialsCreateFinish
  
  !>Start the creation of materials for an equations set. \see OPENCMISS::CMISSEquationsSetMaterialsCreateFinish
  INTERFACE CMISSEquationsSetMaterialsCreateStart
    MODULE PROCEDURE CMISSEquationsSetMaterialsCreateStartNumber
    MODULE PROCEDURE CMISSEquationsSetMaterialsCreateStartObj
  END INTERFACE !CMISSEquationsSetMaterialsCreateStart
  
  !>Destroy the materials for an equations set.
  INTERFACE CMISSEquationsSetMaterialsDestroy
    MODULE PROCEDURE CMISSEquationsSetMaterialsDestroyNumber
    MODULE PROCEDURE CMISSEquationsSetMaterialsDestroyObj
  END INTERFACE !CMISSEquationsSetMaterialsDestroy
  
  !>Returns the solution method for an equations set.
  INTERFACE CMISSEquationsSetSolutionMethodGet
    MODULE PROCEDURE CMISSEquationsSetSolutionMethodGetNumber
    MODULE PROCEDURE CMISSEquationsSetSolutionMethodGetObj
  END INTERFACE !CMISSEquationsSetSolutionMethodGet

  !>Sets/changes the solution method for an equations set.
  INTERFACE CMISSEquationsSetSolutionMethodSet
    MODULE PROCEDURE CMISSEquationsSetSolutionMethodSetNumber
    MODULE PROCEDURE CMISSEquationsSetSolutionMethodSetObj
  END INTERFACE !CMISSEquationsSetSolutionMethodSet
  
  !>Finish the creation of a source for an equations set. \see OPENCMISS::CMISSEquationsSetSourceCreateStart
  INTERFACE CMISSEquationsSetSourceCreateFinish
    MODULE PROCEDURE CMISSEquationsSetSourceCreateFinishNumber
    MODULE PROCEDURE CMISSEquationsSetSourceCreateFinishObj
  END INTERFACE !CMISSEquationsSetSourceCreateFinish
  
  !>Start the creation of a source for an equations set. \see OPENCMISS::CMISSEquationsSetSourceCreateFinish
  INTERFACE CMISSEquationsSetSourceCreateStart
    MODULE PROCEDURE CMISSEquationsSetSourceCreateStartNumber
    MODULE PROCEDURE CMISSEquationsSetSourceCreateStartObj
  END INTERFACE !CMISSEquationsSetSourceCreateStart
  
  !>Destroy the source for an equations set.
  INTERFACE CMISSEquationsSetSourceDestroy
    MODULE PROCEDURE CMISSEquationsSetSourceDestroyNumber
    MODULE PROCEDURE CMISSEquationsSetSourceDestroyObj
  END INTERFACE !CMISSEquationsSetSourceDestroy
  
  !>Returns the equations set specification i.e., equations set class, type and subtype for an equations set.
  INTERFACE CMISSEquationsSetSpecificationGet
    MODULE PROCEDURE CMISSEquationsSetSpecificationGetNumber
    MODULE PROCEDURE CMISSEquationsSetSpecificationGetObj
  END INTERFACE !CMISSEquationsSetSpecificationGet
  
   !>Sets/changes the equations set specification i.e., equations set class, type and subtype for an equations set.
  INTERFACE CMISSEquationsSetSpecificationSet
    MODULE PROCEDURE CMISSEquationsSetSpecificationSetNumber
    MODULE PROCEDURE CMISSEquationsSetSpecificationSetObj
  END INTERFACE !CMISSEquationsSetSpecificationSet
  
  PUBLIC CMISSEquationsSetAnalyticCreateFinish,CMISSEquationsSetAnalyticCreateStart
  
  PUBLIC CMISSEquationsSetAnalyticDestroy
  
  PUBLIC CMISSEquationsSetBoundaryConditionsAnalytic
  
  PUBLIC CMISSEquationsSetBoundaryConditionsCreateFinish,CMISSEquationsSetBoundaryConditionsCreateStart
  
  PUBLIC CMISSEquationsSetBoundaryConditionsDestroy
  
  PUBLIC CMISSEquationsSetCreateFinish,CMISSEquationsSetCreateStart
  
  PUBLIC CMISSEquationsSetDestroy
  
  PUBLIC CMISSEquationsSetDependentCreateFinish,CMISSEquationsSetDependentCreateStart
  
  PUBLIC CMISSEquationsSetDependentDestroy
  
  PUBLIC CMISSEquationsSetEquationsCreateFinish,CMISSEquationsSetEquationsCreateStart
  
  PUBLIC CMISSEquationsSetEquationsDestroy
  
  PUBLIC CMISSEquationsSetIndependentCreateFinish,CMISSEquationsSetIndependentCreateStart
  
  PUBLIC CMISSEquationsSetIndependentDestroy
  
  PUBLIC CMISSEquationsSetMaterialsCreateFinish,CMISSEquationsSetMaterialsCreateStart
  
  PUBLIC CMISSEquationsSetMaterialsDestroy

  PUBLIC CMISSEquationsSetSolutionMethodGet,CMISSEquationsSetSolutionMethodSet
  
  PUBLIC CMISSEquationsSetSourceCreateFinish,CMISSEquationsSetSourceCreateStart
  
  PUBLIC CMISSEquationsSetSourceDestroy

  PUBLIC CMISSEquationsSetSpecificationGet,CMISSEquationsSetSpecificationSet
  
  
!!==================================================================================================================================
!!
!! FIELD_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_FieldConstants OPENCMISS::Field::Constants
  !> \brief Field constants.
  !>@{  
  !> \addtogroup OPENCMISS_FieldDependentTypes OPENCMISS::Field::DependentTypes
  !> \brief Depedent field parameter types.
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSFieldIndependentType = FIELD_INDEPENDENT_TYPE !<Independent field type \see OPENCMISS_FieldDependentTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFieldDependentType = FIELD_DEPENDENT_TYPE !<Dependent field type \see OPENCMISS_FieldDependentTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_FieldDimensionTypes OPENCMISS::Field::DimensionTypes
  !> \brief Field dimension parameter types.
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSFieldScalarDimensionType = FIELD_SCALAR_DIMENSION_TYPE !<Scalar field \see OPENCMISS_FieldDimensionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFieldVectorDimensionType = FIELD_VECTOR_DIMENSION_TYPE !<Vector field \see OPENCMISS_FieldDimensionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFieldTensorDimensionType = FIELD_TENSOR_DIMENSION_TYPE !<Tensor field \see OPENCMISS_FieldDimensionTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_FieldTypes OPENCMISS::Field::Types
  !> \brief Field type parameters.
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSFieldGeometricType = FIELD_GEOMETRIC_TYPE !<Geometric field \see OPENCMISS_FieldTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFieldFibreType = FIELD_FIBRE_TYPE !<Fibre field \see OPENCMISS_FieldTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFieldGeneralType = FIELD_GENERAL_TYPE !<General field \see OPENCMISS_FieldTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFieldMaterialType = FIELD_MATERIAL_TYPE !<Material field \see OPENCMISS_FieldTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_FieldInterpolationTypes OPENCMISS::Field::InterpolationTypes
  !> \brief Field interpolation parameters.
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSFieldConstantInterpolation = FIELD_CONSTANT_INTERPOLATION !<Constant interpolation. One parameter for the field \see OPENCMISS_FieldInterpolationTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFieldElementBasedInterpolation = FIELD_ELEMENT_BASED_INTERPOLATION !<Element based interpolation. Parameters are different in each element \see OPENCMISS_FieldInterpolationTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFieldNodeBasedInterpolation = FIELD_NODE_BASED_INTERPOLATION !<Node based interpolation. Parameters are nodal based and a basis function is used \see OPENCMISS_FieldInterpolationTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFieldGridPointBasedInterpolation = FIELD_GRID_POINT_BASED_INTERPOLATION !<Grid point based interpolation. Parameters are different at each grid point \see OPENCMISS_FieldInterpolationTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFieldGaussPointBasedInterpolation = FIELD_GAUSS_POINT_BASED_INTERPOLATION !<Gauss point based interpolation. Parameters are different at each Gauss point \see OPENCMISS_FieldInterpolationTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_FieldVariableTypes OPENCMISS::Field::VariableTypes
  !> \brief Field variable type parameters.
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSFieldUVariableType = FIELD_U_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFieldDelUDelNVariableType = FIELD_DELUDELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFieldDelUDelTVariableType = FIELD_DELUDELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFieldDel2UDelT2VariableType = FIELD_DEL2UDELT2_VARIABLE_TYPE !<Second type derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFieldVVariableType = FIELD_V_VARIABLE_TYPE !<Second standard variable type i.e., v \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFieldDelVDelNVariableType = FIELD_DELVDELN_VARIABLE_TYPE !<Second normal variable type i.e., dv/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_FieldDataTypes OPENCMISS::Field::DataTypes
  !> \brief Field data types
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSFieldIntgType = FIELD_INTG_TYPE !<Integer field data type \see OPENCMISS_FieldDataTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFieldSPType = FIELD_SP_TYPE !<Single precision real field data type \see OPENCMISS_FieldDataTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFieldDPType = FIELD_DP_TYPE !<Double precision real field data type \see OPENCMISS_FieldDataTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFieldLType = FIELD_L_TYPE !<Logical field data type \see OPENCMISS_FieldDataTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_FieldDOFOrderTypes OPENCMISS::Field::DOFOrderTypes
  !> \brief Field DOF order types
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSFieldSeparatedComponentDOFOrder = FIELD_SEPARATED_COMPONENT_DOF_ORDER !<Field variable component dofs are not contiguous \see OPENCMISS_FieldDOFOrderTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFieldContiguousComponentDOFOrder = FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER !<Field variable component dofs are contiguous \see OPENCMISS_FieldDOFOrderTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_FieldParameterSetTypes OPENCMISS::Field::ParameterSetTypes
  !> \brief Field parameter set type parameters
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSFieldValuesSetType = FIELD_VALUES_SET_TYPE !<The parameter set corresponding to the field values (at time T+DT for dynamic problems) \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSInitialValuesSetType = FIELD_INITIAL_VALUES_SET_TYPE !<The parameter set corresponding to the field initial values \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFieldIncrementalValuesSetType = FIELD_INCREMENTAL_VALUES_SET_TYPE !<The parameter set corresponding to the field incremental values \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFieldAnalyticValuesSetType = FIELD_ANALYTIC_VALUES_SET_TYPE !<The parameter set corresponding to the analytic field values \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSPreviousValuesSetType = FIELD_PREVIOUS_VALUES_SET_TYPE !<The parameter set corresponding to the previous field values (at time T) \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSMeanPredictedDisplacementSetType = FIELD_MEAN_PREDICTED_DISPLACEMENT_SET_TYPE !<The parameter set corresponding to the mean predicited avalues (at time T+DT) \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFieldVelocityValuesSetType = FIELD_VELOCITY_VALUES_SET_TYPE !<The parameter set corresponding to the velocity values (at time T+DT) \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFieldInitialVelocitySetType = FIELD_INITIAL_VELOCITY_SET_TYPE !<The parameter set corresponding to the initial velocity values for dynamic problems. This is also the previous velocity values \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFieldPreviousVelocitySetType = FIELD_PREVIOUS_VELOCITY_SET_TYPE !<The parameter set corresponding to the previous velocity values (at time T). This is also the initial velocity values for dynamic problems. \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFieldMeanPredictedVelocitySetType = FIELD_MEAN_PREDICTED_VELOCITY_SET_TYPE !<The parameter set corresponding to the mean predicited velocity values (at time T+DT) \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFieldAccelerationValuesSetType = FIELD_ACCELERATION_VALUES_SET_TYPE !<The parameter set corresponding to the acceleration values (at time T+DT) \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSInitialAccelerationSetType = FIELD_INITIAL_ACCELERATION_SET_TYPE !<The parameter set corresponding to the initial acceleration values for dynamic problems. This is also the previous accelearation values \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFieldPreviousAccelerationSetType = FIELD_PREVIOUS_ACCELERATION_SET_TYPE !<The parameter set corresponding to the previous acceleration values (at time T).This is also the initial acceleration values for dynamic problems. \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSMeanPredictedAccelerationSetType = FIELD_MEAN_PREDICTED_ACCELERATION_SET_TYPE !<The parameter set corresponding to the mean predicited acceleration values (at time T+DT) \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_FieldScalingTypes OPENCMISS::Field::ScalingTypes
  !> \brief Field scaling type parameters
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSFieldNoScaling = FIELD_NO_SCALING !<The field is not scaled \see OPENCMISS_FieldScalingTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFieldUnitScaling = FIELD_UNIT_SCALING !<The field has unit scaling \see OPENCMISS_FieldScalingTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFieldArcLengthScaling = FIELD_ARC_LENGTH_SCALING !<The field has arc length scaling \see OPENCMISS_FieldScalingTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFieldArithmeticMeanScaling = FIELD_ARITHMETIC_MEAN_SCALING !<The field has arithmetic mean of the arc length scaling \see OPENCMISS_FieldScalingTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSFieldHarmonicMeanScaling = FIELD_HARMONIC_MEAN_SCALING !<The field has geometric mean of the arc length scaling \see OPENCMISS_FieldScalingTypes,OPENCMISS
  !>@}
  !>@}
  
  !Module types

  !Module variables

  !Interfaces

  !>Returns the interpolation type for a field variable component.
  INTERFACE CMISSFieldComponentInterpolationGet
    MODULE PROCEDURE CMISSFieldComponentInterpolationGetNumber
    MODULE PROCEDURE CMISSFieldComponentInterpolationGetObj
  END INTERFACE !CMISSFieldComponentInterpolationGet

  !>Sets/changes the interpolation type for a field variable component.
  INTERFACE CMISSFieldComponentInterpolationSet
    MODULE PROCEDURE CMISSFieldComponentInterpolationSetNumber
    MODULE PROCEDURE CMISSFieldComponentInterpolationSetObj
  END INTERFACE !CMISSFieldComponentInterpolationSet

  !>Returns the label for a field variable component.
  INTERFACE CMISSFieldComponentLabelGet
    MODULE PROCEDURE CMISSFieldComponentLabelGetCNumber
    MODULE PROCEDURE CMISSFieldComponentLabelGetCObj
    MODULE PROCEDURE CMISSFieldComponentLabelGetVSNumber
    MODULE PROCEDURE CMISSFieldComponentLabelGetVSObj
  END INTERFACE !CMISSFieldComponentLabelGet
  
  !>Sets/changes the label for a field variable component.
  INTERFACE CMISSFieldComponentLabelSet
    MODULE PROCEDURE CMISSFieldComponentLabelSetCNumber
    MODULE PROCEDURE CMISSFieldComponentLabelSetCObj
    MODULE PROCEDURE CMISSFieldComponentLabelSetVSNumber
    MODULE PROCEDURE CMISSFieldComponentLabelSetVSObj
  END INTERFACE !CMISSFieldComponentLabelSet

  !>Returns the mesh component number for a field variable component.
  INTERFACE CMISSFieldComponentMeshComponentGet
    MODULE PROCEDURE CMISSFieldComponentMeshComponentGetNumber
    MODULE PROCEDURE CMISSFieldComponentMeshComponentGetObj
  END INTERFACE !CMISSFieldComponentMeshComponentGet

  !>Sets/changes the mesh component number for a field variable component.
  INTERFACE CMISSFieldComponentMeshComponentSet
    MODULE PROCEDURE CMISSFieldComponentMeshComponentSetNumber
    MODULE PROCEDURE CMISSFieldComponentMeshComponentSetObj
  END INTERFACE !CMISSFieldComponentMeshComponentSet  

  !>Initialises the values of a parameter set of a field variable component to a constant value.
  INTERFACE CMISSFieldComponentValuesInitialise
    MODULE PROCEDURE CMISSFieldComponentValuesInitialiseIntgNumber
    MODULE PROCEDURE CMISSFieldComponentValuesInitialiseIntgObj
    MODULE PROCEDURE CMISSFieldComponentValuesInitialiseSPNumber
    MODULE PROCEDURE CMISSFieldComponentValuesInitialiseSPObj
    MODULE PROCEDURE CMISSFieldComponentValuesInitialiseDPNumber
    MODULE PROCEDURE CMISSFieldComponentValuesInitialiseDPObj
    MODULE PROCEDURE CMISSFieldComponentValuesInitialiseLNumber
    MODULE PROCEDURE CMISSFieldComponentValuesInitialiseLObj
  END INTERFACE !CMISSFieldComponentValuesInitialise

  !>Returns the data type for a field variable.
  INTERFACE CMISSFieldDataTypeGet
    MODULE PROCEDURE CMISSFieldDataTypeGetNumber
    MODULE PROCEDURE CMISSFieldDataTypeGetObj
  END INTERFACE !CMISSFieldDataTypeGet

  !>Sets/changes the data type for a field variable.
  INTERFACE CMISSFieldDataTypeSet
    MODULE PROCEDURE CMISSFieldDataTypeSetNumber
    MODULE PROCEDURE CMISSFieldDataTypeSetObj
  END INTERFACE !CMISSFieldDataTypeSet

  !>Returns the DOF order type for a field variable.
  INTERFACE CMISSFieldDOFOrderTypeGet
    MODULE PROCEDURE CMISSFieldDOFOrderTypeGetNumber
    MODULE PROCEDURE CMISSFieldDOFOrderTypeGetObj
  END INTERFACE !CMISSFieldDOFOrderTypeGet

  !>Sets/changes the DOF order type for a field variable. Note: for contiguous coponent DOF ordering all the components of the field variable must have the same interpolation type.
  INTERFACE CMISSFieldDOFOrderTypeSet
    MODULE PROCEDURE CMISSFieldDOFOrderTypeSetNumber
    MODULE PROCEDURE CMISSFieldDOFOrderTypeSetObj
  END INTERFACE !CMISSFieldDOFOrderTypeSet

  !>Finishes the creation of a field. \see OPENCMISS::CMISSFieldCreateStart
  INTERFACE CMISSFieldCreateFinish 
    MODULE PROCEDURE CMISSFieldCreateFinishNumber
    MODULE PROCEDURE CMISSFieldCreateFinishObj
  END INTERFACE !CMISSFieldCreateFinish

  !>Starts the creation of a field. \see OPENCMISS::CMISSFieldCreateFinish
  INTERFACE CMISSFieldCreateStart
    MODULE PROCEDURE CMISSFieldCreateStartNumber
    MODULE PROCEDURE CMISSFieldCreateStartObj
  END INTERFACE !CMISSFieldCreateStart

  !>Returns the dependent type for a field.
  INTERFACE CMISSFieldDependentTypeGet
    MODULE PROCEDURE CMISSFieldDependentTypeGetNumber
    MODULE PROCEDURE CMISSFieldDependentTypeGetObj
  END INTERFACE !CMISSFieldDependentTypeGet

  !>Sets/changes the dependent type for a field.
  INTERFACE CMISSFieldDependentTypeSet
    MODULE PROCEDURE CMISSFieldDependentTypeSetNumber
    MODULE PROCEDURE CMISSFieldDependentTypeSetObj
  END INTERFACE !CMISSFieldDependentTypeSet

  !>Destroys a field.
  INTERFACE CMISSFieldDestroy
    MODULE PROCEDURE CMISSFieldDestroyNumber
    MODULE PROCEDURE CMISSFieldDestroyObj
  END INTERFACE !CMISSFieldDestroy

  !>Returns the field dimension for a field variable.
  INTERFACE CMISSFieldDimensionGet
    MODULE PROCEDURE CMISSFieldDimensionGetNumber
    MODULE PROCEDURE CMISSFieldDimensionGetObj
  END INTERFACE !CMISSFieldDimensionGet

  !>Sets/changes the field dimension for a field variable.
  INTERFACE CMISSFieldDimensionSet
    MODULE PROCEDURE CMISSFieldDimensionSetNumber
    MODULE PROCEDURE CMISSFieldDimensionSetObj
  END INTERFACE !CMISSFieldDimensionSet

  !>Returns the geometric field for a field.
  INTERFACE CMISSFieldGeometricFieldGet
    MODULE PROCEDURE CMISSFieldGeometricFieldGetNumber
    MODULE PROCEDURE CMISSFieldGeometricFieldGetObj
  END INTERFACE !CMISSFieldGeometricFieldGet

  !>Sets/changes the geometric field for a field. 
  INTERFACE CMISSFieldGeometricFieldSet
    MODULE PROCEDURE CMISSFieldGeometricFieldSetNumber
    MODULE PROCEDURE CMISSFieldGeometricFieldSetObj
  END INTERFACE !CMISSFieldGeometricFieldSet

 !>Returns the label for a field.
  INTERFACE CMISSFieldLabelGet
    MODULE PROCEDURE CMISSFieldLabelGetCNumber
    MODULE PROCEDURE CMISSFieldLabelGetCObj
    MODULE PROCEDURE CMISSFieldLabelGetVSNumber
    MODULE PROCEDURE CMISSFieldLabelGetVSObj
  END INTERFACE !CMISSFieldLabelGet
  
  !>Sets/changes the label for a field.
  INTERFACE CMISSFieldLabelSet
    MODULE PROCEDURE CMISSFieldLabelSetCNumber
    MODULE PROCEDURE CMISSFieldLabelSetCObj
    MODULE PROCEDURE CMISSFieldLabelSetVSNumber
    MODULE PROCEDURE CMISSFieldLabelSetVSObj
  END INTERFACE !CMISSFieldLabelSet

  !>Returns the mesh decomposition for a field. 
  INTERFACE CMISSFieldMeshDecompositionGet
    MODULE PROCEDURE CMISSFieldMeshDecompositionGetNumber
    MODULE PROCEDURE CMISSFieldMeshDecompositionGetObj
  END INTERFACE !CMISSFieldMeshDecompositionGet

  !>Sets/changes the mesh decomposition for a field. \todo remove when fields take decomposition argument on creation???
  INTERFACE CMISSFieldMeshDecompositionSet
    MODULE PROCEDURE CMISSFieldMeshDecompositionSetNumber
    MODULE PROCEDURE CMISSFieldMeshDecompositionSetObj
  END INTERFACE !CMISSFieldMeshDecompositionSet

  !>Returns the number of field components for a field variable.
  INTERFACE CMISSFieldNumberOfComponentsGet 
    MODULE PROCEDURE CMISSFieldNumberOfComponentsGetNumber
    MODULE PROCEDURE CMISSFieldNumberOfComponentsGetObj
  END INTERFACE !CMISSFieldNumberOfComponentsGet

  !>Sets/changes the number of field components for a field variable.
  INTERFACE CMISSFieldNumberOfComponentsSet 
    MODULE PROCEDURE CMISSFieldNumberOfComponentsSetNumber
    MODULE PROCEDURE CMISSFieldNumberOfComponentsSetObj
  END INTERFACE !CMISSFieldNumberOfComponentsSet

  !>Returns the number of field variables for a field.
  INTERFACE CMISSFieldNumberOfVariablesGet 
    MODULE PROCEDURE CMISSFieldNumberOfVariablesGetNumber
    MODULE PROCEDURE CMISSFieldNumberOfVariablesGetObj
  END INTERFACE !CMISSFieldNumberOfVariablesGet

  !>Sets/changes the number of field variables for a field.
  INTERFACE CMISSFieldNumberOfVariablesSet 
    MODULE PROCEDURE CMISSFieldNumberOfVariablesSetNumber
    MODULE PROCEDURE CMISSFieldNumberOfVariablesSetObj
  END INTERFACE !CMISSFieldNumberOfVariablesSet

  !>Adds the given value to the given parameter set for the constant of the field variable component.
  INTERFACE CMISSFieldParameterSetAddConstant
    MODULE PROCEDURE CMISSFieldParameterSetAddConstantIntgNumber
    MODULE PROCEDURE CMISSFieldParameterSetAddConstantIntgObj
    MODULE PROCEDURE CMISSFieldParameterSetAddConstantSPNumber
    MODULE PROCEDURE CMISSFieldParameterSetAddConstantSPObj
    MODULE PROCEDURE CMISSFieldParameterSetAddConstantDPNumber
    MODULE PROCEDURE CMISSFieldParameterSetAddConstantDPObj
    MODULE PROCEDURE CMISSFieldParameterSetAddConstantLNumber
    MODULE PROCEDURE CMISSFieldParameterSetAddConstantLObj
  END INTERFACE !CMISSFieldParameterSetAddConstant

  !>Adds the given value to the given parameter set for a particular user element of the field variable component.
  INTERFACE CMISSFieldParameterSetAddElement
    MODULE PROCEDURE CMISSFieldParameterSetAddElementIntgNumber
    MODULE PROCEDURE CMISSFieldParameterSetAddElementIntgObj
    MODULE PROCEDURE CMISSFieldParameterSetAddElementSPNumber
    MODULE PROCEDURE CMISSFieldParameterSetAddElementSPObj
    MODULE PROCEDURE CMISSFieldParameterSetAddElementDPNumber
    MODULE PROCEDURE CMISSFieldParameterSetAddElementDPObj
    MODULE PROCEDURE CMISSFieldParameterSetAddElementLNumber
    MODULE PROCEDURE CMISSFieldParameterSetAddElementLObj
  END INTERFACE !CMISSFieldParameterSetAddElement

  !>Adds the given value to the given parameter set for a particular user node of the field variable component.
  INTERFACE CMISSFieldParameterSetAddNode
    MODULE PROCEDURE CMISSFieldParameterSetAddNodeIntgNumber
    MODULE PROCEDURE CMISSFieldParameterSetAddNodeIntgObj
    MODULE PROCEDURE CMISSFieldParameterSetAddNodeSPNumber
    MODULE PROCEDURE CMISSFieldParameterSetAddNodeSPObj
    MODULE PROCEDURE CMISSFieldParameterSetAddNodeDPNumber
    MODULE PROCEDURE CMISSFieldParameterSetAddNodeDPObj
    MODULE PROCEDURE CMISSFieldParameterSetAddNodeLNumber
    MODULE PROCEDURE CMISSFieldParameterSetAddNodeLObj
  END INTERFACE !CMISSFieldParameterSetAddNode

  !>Creates a new parameter set of type set type for a field variable.
  INTERFACE CMISSFieldParameterSetCreate
    MODULE PROCEDURE CMISSFieldParameterSetCreateNumber
    MODULE PROCEDURE CMISSFieldParameterSetCreateObj
  END INTERFACE !CMISSFieldParameterSetCreate
  
  !>Destroy a parameter set of type set type for a field variable.
  INTERFACE CMISSFieldParameterSetDestroy
    MODULE PROCEDURE CMISSFieldParameterSetDestroyNumber
    MODULE PROCEDURE CMISSFieldParameterSetDestroyObj
  END INTERFACE !CMISSFieldParameterSetCreate
  
  !>Returns a pointer to the specified field parameter set local data array. The pointer must be restored with a call to OPENCMISS::CMISSFieldParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  INTERFACE CMISSFieldParameterSetDataGet
    MODULE PROCEDURE CMISSFieldParameterSetDataGetIntgNumber
    MODULE PROCEDURE CMISSFieldParameterSetDataGetIntgObj
    MODULE PROCEDURE CMISSFieldParameterSetDataGetSPNumber
    MODULE PROCEDURE CMISSFieldParameterSetDataGetSPObj
    MODULE PROCEDURE CMISSFieldParameterSetDataGetDPNumber
    MODULE PROCEDURE CMISSFieldParameterSetDataGetDPObj
    MODULE PROCEDURE CMISSFieldParameterSetDataGetLNumber
    MODULE PROCEDURE CMISSFieldParameterSetDataGetLObj
  END INTERFACE !CMISSFieldParameterSetDataGet
  
  !>Restores the specified field variable parameter set local array that was obtained with an OPENCMISS::CMISSFieldParameterSetDataGet call.
  INTERFACE CMISSFieldParameterSetDataRestore
    MODULE PROCEDURE CMISSFieldParameterSetDataRestoreIntgNumber
    MODULE PROCEDURE CMISSFieldParameterSetDataRestoreIntgObj
    MODULE PROCEDURE CMISSFieldParameterSetDataRestoreSPNumber
    MODULE PROCEDURE CMISSFieldParameterSetDataRestoreSPObj
    MODULE PROCEDURE CMISSFieldParameterSetDataRestoreDPNumber
    MODULE PROCEDURE CMISSFieldParameterSetDataRestoreDPObj
    MODULE PROCEDURE CMISSFieldParameterSetDataRestoreLNumber
    MODULE PROCEDURE CMISSFieldParameterSetDataRestoreLObj
  END INTERFACE !CMISSFieldParameterSetDataRestore
  
  !>Returns from the given parameter set a value for the specified constant of a field variable component.
  INTERFACE CMISSFieldParameterSetGetConstant
    MODULE PROCEDURE CMISSFieldParameterSetGetConstantIntgNumber
    MODULE PROCEDURE CMISSFieldParameterSetGetConstantIntgObj
    MODULE PROCEDURE CMISSFieldParameterSetGetConstantSPNumber
    MODULE PROCEDURE CMISSFieldParameterSetGetConstantSPObj
    MODULE PROCEDURE CMISSFieldParameterSetGetConstantDPNumber
    MODULE PROCEDURE CMISSFieldParameterSetGetConstantDPObj
    MODULE PROCEDURE CMISSFieldParameterSetGetConstantLNumber
    MODULE PROCEDURE CMISSFieldParameterSetGetConstantLObj
  END INTERFACE !CMISSFieldParameterSetGetConstant

  !>Returns from the given parameter set a value for the specified element of a field variable component.
  INTERFACE CMISSFieldParameterSetGetElement
    MODULE PROCEDURE CMISSFieldParameterSetGetElementIntgNumber
    MODULE PROCEDURE CMISSFieldParameterSetGetElementIntgObj
    MODULE PROCEDURE CMISSFieldParameterSetGetElementSPNumber
    MODULE PROCEDURE CMISSFieldParameterSetGetElementSPObj
    MODULE PROCEDURE CMISSFieldParameterSetGetElementDPNumber
    MODULE PROCEDURE CMISSFieldParameterSetGetElementDPObj
    MODULE PROCEDURE CMISSFieldParameterSetGetElementLNumber
    MODULE PROCEDURE CMISSFieldParameterSetGetElementLObj
  END INTERFACE !CMISSFieldParameterSetGetElement

  !>Returns from the given parameter set a value for the specified node and derivative of a field variable component.
  INTERFACE CMISSFieldParameterSetGetNode
    MODULE PROCEDURE CMISSFieldParameterSetGetNodeIntgNumber
    MODULE PROCEDURE CMISSFieldParameterSetGetNodeIntgObj
    MODULE PROCEDURE CMISSFieldParameterSetGetNodeSPNumber
    MODULE PROCEDURE CMISSFieldParameterSetGetNodeSPObj
    MODULE PROCEDURE CMISSFieldParameterSetGetNodeDPNumber
    MODULE PROCEDURE CMISSFieldParameterSetGetNodeDPObj
    MODULE PROCEDURE CMISSFieldParameterSetGetNodeLNumber
    MODULE PROCEDURE CMISSFieldParameterSetGetNodeLObj
  END INTERFACE !CMISSFieldParameterSetGetNode

  !>Updates the given parameter set with the given value for the constant of a field variable component.
  INTERFACE CMISSFieldParameterSetUpdateConstant
    MODULE PROCEDURE CMISSFieldParameterSetUpdateConstantIntgNumber
    MODULE PROCEDURE CMISSFieldParameterSetUpdateConstantIntgObj
    MODULE PROCEDURE CMISSFieldParameterSetUpdateConstantSPNumber
    MODULE PROCEDURE CMISSFieldParameterSetUpdateConstantSPObj
    MODULE PROCEDURE CMISSFieldParameterSetUpdateConstantDPNumber
    MODULE PROCEDURE CMISSFieldParameterSetUpdateConstantDPObj
    MODULE PROCEDURE CMISSFieldParameterSetUpdateConstantLNumber
    MODULE PROCEDURE CMISSFieldParameterSetUpdateConstantLObj
  END INTERFACE !CMISSFieldParameterSetUpdateConstant

  !>Updates the given parameter set with the given value for a particular user element of a field variable component.
  INTERFACE CMISSFieldParameterSetUpdateElement
    MODULE PROCEDURE CMISSFieldParameterSetUpdateElementIntgNumber
    MODULE PROCEDURE CMISSFieldParameterSetUpdateElementIntgObj
    MODULE PROCEDURE CMISSFieldParameterSetUpdateElementSPNumber
    MODULE PROCEDURE CMISSFieldParameterSetUpdateElementSPObj
    MODULE PROCEDURE CMISSFieldParameterSetUpdateElementDPNumber
    MODULE PROCEDURE CMISSFieldParameterSetUpdateElementDPObj
    MODULE PROCEDURE CMISSFieldParameterSetUpdateElementLNumber
    MODULE PROCEDURE CMISSFieldParameterSetUpdateElementLObj
  END INTERFACE !CMISSFieldParameterSetUpdateElement

  !>Finishes the parameter set update for a field variable. \see OPENCMISS::CMISSFieldParameterSetUpdateStart
  INTERFACE CMISSFieldParameterSetUpdateFinish
    MODULE PROCEDURE CMISSFieldParameterSetUpdateFinishNumber
    MODULE PROCEDURE CMISSFieldParameterSetUpdateFinishObj
  END INTERFACE !CMISSFieldParameterSetUpdateFinish

  !>Updates the given parameter set with the given value for a particular user node of a field variable component.
  INTERFACE CMISSFieldParameterSetUpdateNode
    MODULE PROCEDURE CMISSFieldParameterSetUpdateNodeIntgNumber
    MODULE PROCEDURE CMISSFieldParameterSetUpdateNodeIntgObj
    MODULE PROCEDURE CMISSFieldParameterSetUpdateNodeSPNumber
    MODULE PROCEDURE CMISSFieldParameterSetUpdateNodeSPObj
    MODULE PROCEDURE CMISSFieldParameterSetUpdateNodeDPNumber
    MODULE PROCEDURE CMISSFieldParameterSetUpdateNodeDPObj
    MODULE PROCEDURE CMISSFieldParameterSetUpdateNodeLNumber
    MODULE PROCEDURE CMISSFieldParameterSetUpdateNodeLObj
  END INTERFACE !CMISSFieldParameterSetUpdateNode

  !>Starts the parameter set update for a field variable. \see OPENCMISS::CMISSFieldParameterSetUpdateFinish
  INTERFACE CMISSFieldParameterSetUpdateStart
    MODULE PROCEDURE CMISSFieldParameterSetUpdateStartNumber
    MODULE PROCEDURE CMISSFieldParameterSetUpdateStartObj
  END INTERFACE !CMISSFieldParameterSetUpdateStart

  !>Copy the parameters from the parameter set of a component of a field variable to the paramters of a parameter set of
  !>a component of another field variable.
  INTERFACE CMISSFieldParametersToFieldParametersComponentCopy
    MODULE PROCEDURE CMISSFieldParametersToFieldParametersComponentCopyNumber
    MODULE PROCEDURE CMISSFieldParametersToFieldParametersComponentCopyObj
  END INTERFACE !CMISSFieldParametersToFieldParametersComponentCopy

  !>Returns the scaling type for a field.  
  INTERFACE CMISSFieldScalingTypeGet
    MODULE PROCEDURE CMISSFieldScalingTypeGetNumber
    MODULE PROCEDURE CMISSFieldScalingTypeGetObj
  END INTERFACE !CMISSFieldScalingTypeGet
    
  !>Sets/changes the scaling type for a field.  
  INTERFACE CMISSFieldScalingTypeSet
    MODULE PROCEDURE CMISSFieldScalingTypeSetNumber
    MODULE PROCEDURE CMISSFieldScalingTypeSetObj
  END INTERFACE !CMISSFieldScalingTypeSet
    
  !>Returns the type for a field. 
  INTERFACE CMISSFieldTypeGet
    MODULE PROCEDURE CMISSFieldTypeGetNumber
    MODULE PROCEDURE CMISSFieldTypeGetObj
  END INTERFACE !CMISSFieldTypeGet
    
  !>Sets/changes the type for a field. 
  INTERFACE CMISSFieldTypeSet
    MODULE PROCEDURE CMISSFieldTypeSetNumber
    MODULE PROCEDURE CMISSFieldTypeSetObj
  END INTERFACE !CMISSFieldTypeSet
    
  !>Returns the label for a field variable. 
  INTERFACE CMISSFieldVariableLabelGet
    MODULE PROCEDURE CMISSFieldVariableLabelGetCNumber
    MODULE PROCEDURE CMISSFieldVariableLabelGetCObj
    MODULE PROCEDURE CMISSFieldVariableLabelGetVSNumber
    MODULE PROCEDURE CMISSFieldVariableLabelGetVSObj
  END INTERFACE !CMISSFieldVariableLabelGet
    
  !>Sets/changes the label for a field variable. 
  INTERFACE CMISSFieldVariableLabelSet
    MODULE PROCEDURE CMISSFieldVariableLabelSetCNumber
    MODULE PROCEDURE CMISSFieldVariableLabelSetCObj
    MODULE PROCEDURE CMISSFieldVariableLabelSetVSNumber
    MODULE PROCEDURE CMISSFieldVariableLabelSetVSObj
  END INTERFACE !CMISSFieldVariableLabelSet
    
  !>Returns the field variable types for a field. 
  INTERFACE CMISSFieldVariableTypesGet
    MODULE PROCEDURE CMISSFieldVariableTypesGetNumber
    MODULE PROCEDURE CMISSFieldVariableTypesGetObj
  END INTERFACE !CMISSFieldVariableTypesGet
    
  !>Sets/changes the field variable types for a field. 
  INTERFACE CMISSFieldVariableTypesSet
    MODULE PROCEDURE CMISSFieldVariableTypesSetNumber
    MODULE PROCEDURE CMISSFieldVariableTypesSetObj
  END INTERFACE !CMISSFieldVariableTypesSet

  
  PUBLIC CMISSFieldDependentType,CMISSFieldIndependentType

  PUBLIC CMISSFieldScalarDimensionType,CMISSFieldVectorDimensionType,CMISSFieldTensorDimensionType

  PUBLIC CMISSFieldGeometricType,CMISSFieldFibreType,CMISSFieldGeneralType,CMISSFieldMaterialType

  PUBLIC CMISSFieldConstantInterpolation,CMISSFieldElementBasedInterpolation,CMISSFieldNodeBasedInterpolation, &
    & CMISSFieldGridPointBasedInterpolation,CMISSFieldGaussPointBasedInterpolation

  PUBLIC CMISSFieldUVariableType,CMISSFieldDelUDelNVariableType,CMISSFieldDelUDelTVariableType,CMISSFieldDel2UDelT2VariableType, &
    & CMISSFieldVVariableType,CMISSFieldDelVDelNVariableType

  PUBLIC CMISSFieldIntgType,CMISSFieldSPType,CMISSFieldDPType,CMISSFieldLType

  PUBLIC CMISSFieldSeparatedComponentDOFOrder,CMISSFieldContiguousComponentDOFOrder

  PUBLIC CMISSFieldValuesSetType,CMISSInitialValuesSetType,CMISSFieldIncrementalValuesSetType,CMISSFieldAnalyticValuesSetType, &
    & CMISSPreviousValuesSetType,CMISSMeanPredictedDisplacementSetType,CMISSFieldVelocityValuesSetType, &
    & CMISSFieldInitialVelocitySetType,CMISSFieldPreviousVelocitySetType,CMISSFieldMeanPredictedVelocitySetType, &
    & CMISSFieldAccelerationValuesSetType,CMISSInitialAccelerationSetType,CMISSFieldPreviousAccelerationSetType, &
    & CMISSMeanPredictedAccelerationSetType

  PUBLIC CMISSFieldNoScaling,CMISSFieldUnitScaling,CMISSFieldArcLengthScaling,CMISSFieldArithmeticMeanScaling, &
    & CMISSFieldHarmonicMeanScaling

  PUBLIC CMISSFieldComponentInterpolationGet,CMISSFieldComponentInterpolationSet

  PUBLIC CMISSFieldComponentLabelGet,CMISSFieldComponentLabelSet

  PUBLIC CMISSFieldComponentMeshComponentGet,CMISSFieldComponentMeshComponentSet

  PUBLIC CMISSFieldComponentValuesInitialise

  PUBLIC CMISSFieldDataTypeGet,CMISSFieldDataTypeSet

  PUBLIC CMISSFieldDOFOrderTypeGet,CMISSFieldDOFOrderTypeSet

  PUBLIC CMISSFieldCreateFinish,CMISSFieldCreateStart

  PUBLIC CMISSFieldDependentTypeGet,CMISSFieldDependentTypeSet

  PUBLIC CMISSFieldDestroy

  PUBLIC CMISSFieldDimensionGet,CMISSFieldDimensionSet

  PUBLIC CMISSFieldGeometricFieldGet,CMISSFieldGeometricFieldSet

  PUBLIC CMISSFieldLabelGet,CMISSFieldLabelSet

  PUBLIC CMISSFieldMeshDecompositionGet,CMISSFieldMeshDecompositionSet

  PUBLIC CMISSFieldNumberOfComponentsGet,CMISSFieldNumberOfComponentsSet

  PUBLIC CMISSFieldNumberOfVariablesGet,CMISSFieldNumberOfVariablesSet

  PUBLIC CMISSFieldParameterSetAddConstant,CMISSFieldParameterSetAddElement,CMISSFieldParameterSetAddNode

  PUBLIC CMISSFieldParameterSetCreate

  PUBLIC CMISSFieldParameterSetDestroy

  PUBLIC CMISSFieldParameterSetDataGet,CMISSFieldParameterSetDataRestore

  PUBLIC CMISSFieldParameterSetGetConstant,CMISSFieldParameterSetGetElement,CMISSFieldParameterSetGetNode

  PUBLIC CMISSFieldParameterSetUpdateConstant,CMISSFieldParameterSetUpdateElement,CMISSFieldParameterSetUpdateNode

  PUBLIC CMISSFieldParameterSetUpdateFinish,CMISSFieldParameterSetUpdateStart

  PUBLIC CMISSFieldParametersToFieldParametersComponentCopy

  PUBLIC CMISSFieldScalingTypeGet,CMISSFieldScalingTypeSet

  PUBLIC CMISSFieldTypeGet,CMISSFieldTypeSet

  PUBLIC CMISSFieldVariableLabelGet,CMISSFieldVariableLabelSet

  PUBLIC CMISSFieldVariableTypesGet,CMISSFieldVariableTypesSet
 
!!==================================================================================================================================
!!
!! FIELD_IO_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  INTERFACE CMISSFieldIOElementsExport
    MODULE PROCEDURE CMISSFieldIOElementsExportCCObj
    MODULE PROCEDURE CMISSFieldIOElementsExportVSCObj
    MODULE PROCEDURE CMISSFieldIOElementsExportCVSObj
    MODULE PROCEDURE CMISSFieldIOElementsExportVSVSObj
  END INTERFACE !CMISSFieldIOElementsExport

  INTERFACE CMISSFieldIONodesExport
    MODULE PROCEDURE CMISSFieldIONodesExportCCObj
    MODULE PROCEDURE CMISSFieldIONodesExportVSCObj
    MODULE PROCEDURE CMISSFieldIONodesExportCVSObj
    MODULE PROCEDURE CMISSFieldIONodesExportVSVSObj
  END INTERFACE !CMISSFieldIONodesExport

  PUBLIC CMISSFieldIOElementsExport,CMISSFieldIONodesExport
  
!!==================================================================================================================================
!!
!! GENERATED_MESH_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_GeneratedMeshConstants OPENCMISS::GeneratedMesh::Constants
  !> \brief Generated mesh constants.
  !>@{
  !> \addtogroup OPENCMISS_GeneratedMeshTypes OPENCMISS::GeneratedMesh::Types 
  !> \brief Generated mesh types.
  !> \see OPENCMISS::GeneratedMesh,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSGeneratedMeshRegularMeshType = GENERATED_MESH_REGULAR_MESH_TYPE !<A regular generated mesh. \see OPENCMISS_GeneratedMeshTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSGeneratedMeshPolarMeshType = GENERATED_MESH_POLAR_MESH_TYPE !<A polar generated mesh. \see OPENCMISS_GeneratedMeshTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSGeneratedMeshFractalTreeMeshType = GENERATED_MESH_FRACTAL_TREE_MESH_TYPE !<A fractal tree generated mesh. \see OPENCMISS_GeneratedMeshTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Returns the basis for a generated mesh.
  INTERFACE CMISSGeneratedMeshBasisGet
    MODULE PROCEDURE CMISSGeneratedMeshBasisGetNumber
    MODULE PROCEDURE CMISSGeneratedMeshBasisGetObj
  END INTERFACE !CMISSGeneratedMeshBasisGet

  !>Sets/changes the basis for a generated mesh.
  INTERFACE CMISSGeneratedMeshBasisSet
    MODULE PROCEDURE CMISSGeneratedMeshBasisSetNumber
    MODULE PROCEDURE CMISSGeneratedMeshBasisSetObj
  END INTERFACE !CMISSGeneratedMeshBasisSet

  !>Finishes the creation of a generated mesh. \see OPENCMISS::CMISSGeneratedMeshCreateStart
  INTERFACE CMISSGeneratedMeshCreateFinish
    MODULE PROCEDURE CMISSGeneratedMeshCreateFinishNumber
    MODULE PROCEDURE CMISSGeneratedMeshCreateFinishObj
  END INTERFACE !CMISSGeneratedMeshCreateFinish

  !>Starts the creation of a generated mesh. \see OPENCMISS::CMISSGeneratedMeshCreateFinish
  INTERFACE CMISSGeneratedMeshCreateStart
    MODULE PROCEDURE CMISSGeneratedMeshCreateStartNumber
    MODULE PROCEDURE CMISSGeneratedMeshCreateStartObj
  END INTERFACE !CMISSGeneratedMeshCreateStart

  !>Destroys a generated mesh.
  INTERFACE CMISSGeneratedMeshDestroy
    MODULE PROCEDURE CMISSGeneratedMeshDestroyNumber
    MODULE PROCEDURE CMISSGeneratedMeshDestroyObj
  END INTERFACE !CMISSGeneratedMeshDestroy

  !>Returns the extent of a generated mesh.
  INTERFACE CMISSGeneratedMeshExtentGet
    MODULE PROCEDURE CMISSGeneratedMeshExtentGetNumber
    MODULE PROCEDURE CMISSGeneratedMeshExtentGetObj
  END INTERFACE !CMISSGeneratedMeshExtentGet

  !>Sets/changes the extent of a generated mesh.
  INTERFACE CMISSGeneratedMeshExtentSet
    MODULE PROCEDURE CMISSGeneratedMeshExtentSetNumber
    MODULE PROCEDURE CMISSGeneratedMeshExtentSetObj
  END INTERFACE !CMISSGeneratedMeshExtentSet

  !>Returns the number of elements in a generated mesh.
  INTERFACE CMISSGeneratedMeshNumberOfElementsGet
    MODULE PROCEDURE CMISSGeneratedMeshNumberOfElementsGetNumber
    MODULE PROCEDURE CMISSGeneratedMeshNumberOfElementsGetObj
  END INTERFACE !CMISSGeneratedMeshNumberOfElementsGet

  !>Sets/changes the number of elements in a generated mesh.
  INTERFACE CMISSGeneratedMeshNumberOfElementsSet
    MODULE PROCEDURE CMISSGeneratedMeshNumberOfElementsSetNumber
    MODULE PROCEDURE CMISSGeneratedMeshNumberOfElementsSetObj
  END INTERFACE !CMISSGeneratedMeshNumberOfElementsSet

  !>Returns the origin of a generated mesh.
  INTERFACE CMISSGeneratedMeshOriginGet
    MODULE PROCEDURE CMISSGeneratedMeshOriginGetNumber
    MODULE PROCEDURE CMISSGeneratedMeshOriginGetObj
  END INTERFACE !CMISSGeneratedMeshOriginGet

  !>Sets/changes the origin of a generated mesh.
  INTERFACE CMISSGeneratedMeshOriginSet
    MODULE PROCEDURE CMISSGeneratedMeshOriginSetNumber
    MODULE PROCEDURE CMISSGeneratedMeshOriginSetObj
  END INTERFACE !CMISSGeneratedMeshOriginSet

  !>Returns the type of a generated mesh.
  INTERFACE CMISSGeneratedMeshTypeGet
    MODULE PROCEDURE CMISSGeneratedMeshTypeGetNumber
    MODULE PROCEDURE CMISSGeneratedMeshTypeGetObj
  END INTERFACE !CMISSGeneratedMeshTypeGet

  !>Sets/changes the type of a generated mesh.
  INTERFACE CMISSGeneratedMeshTypeSet
    MODULE PROCEDURE CMISSGeneratedMeshTypeSetNumber
    MODULE PROCEDURE CMISSGeneratedMeshTypeSetObj
  END INTERFACE !CMISSGeneratedMeshTypeSet

  !>Calculates and sets the geometric field parameters for a generated mesh
  INTERFACE CMISSGeneratedMeshGeometricParametersCalculate
    MODULE PROCEDURE CMISSGeneratedMeshGeometricParametersCalculateNumber
    MODULE PROCEDURE CMISSGeneratedMeshGeometricParametersCalculateObj
  END INTERFACE !CMISSGeneratedMeshGeometricParametersCalculate

  PUBLIC CMISSGeneratedMeshRegularMeshType,CMISSGeneratedMeshPolarMeshType,CMISSGeneratedMeshFractalTreeMeshType

  PUBLIC CMISSGeneratedMeshBasisGet,CMISSGeneratedMeshBasisSet

  PUBLIC CMISSGeneratedMeshCreateFinish,CMISSGeneratedMeshCreateStart

  PUBLIC CMISSGeneratedMeshDestroy

  PUBLIC CMISSGeneratedMeshExtentGet,CMISSGeneratedMeshExtentSet

  PUBLIC CMISSGeneratedMeshNumberOfElementsGet,CMISSGeneratedMeshNumberOfElementsSet

  PUBLIC CMISSGeneratedMeshOriginGet,CMISSGeneratedMeshOriginSet

  PUBLIC CMISSGeneratedMeshTypeGet,CMISSGeneratedMeshTypeSet

  PUBLIC CMISSGeneratedMeshGeometricParametersCalculate
  
  
!!==================================================================================================================================
!!
!! KINDS
!!
!!==================================================================================================================================

  !Module parameters
 
  !> \addtogroup OPENCMISS_KindConstants OPENCMISS::Kinds::Constants
  !> \brief Kind constants.
  !>@{  
  !> \addtogroup OPENCMISS_IntegerKinds OPENCMISS::Kinds::Integers
  !> \brief Kind parameters for integer data types.
  !> \see OPENCMISS::Kinds,OPENCMISS
  !>@{
  INTEGER, PARAMETER :: CMISSIntg = INTG !<Standard integer kind. \see OPENCMISS_IntegerKinds,OPENCMISS
  INTEGER, PARAMETER :: CMISSSIntg = SINTG !<Short integer kind. \see OPENCMISS_IntegerKinds,OPENCMISS
  INTEGER, PARAMETER :: CMISSLIntg = LINTG !<Long integer kind. \see OPENCMISS_IntegerKinds,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_RealKinds OPENCMISS::Kinds::Reals
  !> \brief Kind parameters for real data types.
  !> \see OPENCMISS::Kinds,OPENCMISS
  !>@{
  INTEGER, PARAMETER :: CMISSSP = SP !<Single precision real kind. \see OPENCMISS_RealKinds,OPENCMISS
  INTEGER, PARAMETER :: CMISSDP = DP !<Double precision real kind. \see OPENCMISS_RealKinds,OPENCMISS
  INTEGER, PARAMETER :: CMISSQP = QP !<Quadruple precision real kind. \see OPENCMISS_RealKinds,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_ComplexKinds OPENCMISS::Kinds::Complex
  !> \brief Kind parameters for complex data types
  !> \see OPENCMISS::Kinds,OPENCMISS
  !>@{
  INTEGER, PARAMETER :: CMISSSPC = SPC !<Single precision complex kind. \see OPENCMISS_ComplexKinds,OPENCMISS
  INTEGER, PARAMETER :: CMISSDPC = DPC !<Double precision complex kind. \see OPENCMISS_ComplexKinds,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  PUBLIC CMISSIntg,CMISSSIntg,CMISSLIntg

  PUBLIC CMISSSP,CMISSDP,CMISSQP

  PUBLIC CMISSSPC,CMISSDPC
  
!!==================================================================================================================================
!!
!! MESH_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_MeshConstants OPENCMISS::Mesh::Constants
  !> \brief Mesh constants.
  !>@{  
  !> \addtogroup OPENCMISS_DecompositionTypes OPENCMISS::Mesh::DecompositionTypes
  !> \brief The Decomposition types parameters
  !> \see OPENCMISS::Mesh,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSDecompositionAllType = DECOMPOSITION_ALL_TYPE !<The decomposition contains all elements. \see OPENCMISS_DecompositionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSDecompositionCalculatedType = DECOMPOSITION_CALCULATED_TYPE !<The element decomposition is calculated by graph partitioning. \see OPENCMISS_DecompositionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSDecompositionUserDefinedType = DECOMPOSITION_USER_DEFINED_TYPE !<The user will set the element decomposition. \see OPENCMISS_DecompositionTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Finishes the creation of a domain decomposition. \see OPENCMISS::CMISSDecompositionCreateStart
  INTERFACE CMISSDecompositionCreateFinish
    MODULE PROCEDURE CMISSDecompositionCreateFinishNumber
    MODULE PROCEDURE CMISSDecompositionCreateFinishObj
  END INTERFACE !CMISSDecompositionCreateFinish

  !>Start the creation of a domain decomposition for a given mesh. \see OPENCMISS::CMISSDecompositionCreateFinish 
  INTERFACE CMISSDecompositionCreateStart
    MODULE PROCEDURE CMISSDecompositionCreateStartNumber
    MODULE PROCEDURE CMISSDecompositionCreateStartObj
  END INTERFACE !CMISSDecompositionCreateFinish

  !>Destroys a domain decomposition.
  INTERFACE CMISSDecompositionDestroy
    MODULE PROCEDURE CMISSDecompositionDestroyNumber
    MODULE PROCEDURE CMISSDecompositionDestroyObj
  END INTERFACE !CMISSDecompositionDestroy

  !>Calculates the element domains for the decomposition of a mesh.
  INTERFACE CMISSDecompositionElementDomainCalculate
    MODULE PROCEDURE CMISSDecompositionElementDomainCalculateNumber
    MODULE PROCEDURE CMISSDecompositionElementDomainCalculateObj
  END INTERFACE !CMISSDecompositionElementDomainCalculate

  !>Returns the domain for a given element in a decomposition of a mesh.
  INTERFACE CMISSDecompositionElementDomainGet
    MODULE PROCEDURE CMISSDecompositionElementDomainGetNumber
    MODULE PROCEDURE CMISSDecompositionElementDomainGetObj
  END INTERFACE !CMISSDecompositionElementDomainGet

  !>Sets/changes the domain for a given element in a decomposition of a mesh.
  INTERFACE CMISSDecompositionElementDomainSet
    MODULE PROCEDURE CMISSDecompositionElementDomainSetNumber
    MODULE PROCEDURE CMISSDecompositionElementDomainSetObj
  END INTERFACE !CMISSDecompositionElementDomainSet

  !>Returns the mesh component number used for the decomposition of a mesh.
  INTERFACE CMISSDecompositionMeshComponentGet
    MODULE PROCEDURE CMISSDecompositionMeshComponentGetNumber
    MODULE PROCEDURE CMISSDecompositionMeshComponentGetObj
  END INTERFACE !CMISSDecompositionMeshComponentGet

  !>Sets/changes the mesh component number used for the decomposition of a mesh.
  INTERFACE CMISSDecompositionMeshComponentSet
    MODULE PROCEDURE CMISSDecompositionMeshComponentSetNumber
    MODULE PROCEDURE CMISSDecompositionMeshComponentSetObj
  END INTERFACE !CMISSDecompositionMeshComponentSet

  !>Returns the number of domains used for the decomposition of a mesh.
  INTERFACE CMISSDecompositionNumberOfDomainsGet
    MODULE PROCEDURE CMISSDecompositionNumberOfDomainsGetNumber
    MODULE PROCEDURE CMISSDecompositionNumberOfDomainsGetObj
  END INTERFACE !CMISSDecompositionNumberOfDomainsGet

  !>Sets/changes the number of domains used for the decomposition of a mesh.
  INTERFACE CMISSDecompositionNumberOfDomainsSet
    MODULE PROCEDURE CMISSDecompositionNumberOfDomainsSetNumber
    MODULE PROCEDURE CMISSDecompositionNumberOfDomainsSetObj
  END INTERFACE !CMISSDecompositionNumberOfDomainsSet

  !>Returns the type of decomposition.
  INTERFACE CMISSDecompositionTypeGet
    MODULE PROCEDURE CMISSDecompositionTypeGetNumber
    MODULE PROCEDURE CMISSDecompositionTypeGetObj
  END INTERFACE !CMISSDecompositionTypeGet

  !>Sets/changes the type of decomposition.
  INTERFACE CMISSDecompositionTypeSet
    MODULE PROCEDURE CMISSDecompositionTypeSetNumber
    MODULE PROCEDURE CMISSDecompositionTypeSetObj
  END INTERFACE !CMISSDecompositionTypeSet

  !>Finishes the creation of a mesh. \see OPENCMISS::CMISSMeshCreateStart
  INTERFACE CMISSMeshCreateFinish
    MODULE PROCEDURE CMISSMeshCreateFinishNumber
    MODULE PROCEDURE CMISSMeshCreateFinishObj
  END INTERFACE !CMISSMeshCreateFinish

  !>Starts the creation of a mesh. \see OPENCMISS::CMISSMeshCreateFinish
  INTERFACE CMISSMeshCreateStart
    MODULE PROCEDURE CMISSMeshCreateStartNumber
    MODULE PROCEDURE CMISSMeshCreateStartObj
  END INTERFACE !CMISSMeshCreateStart

  !>Destroys a mesh. 
  INTERFACE CMISSMeshDestroy
    MODULE PROCEDURE CMISSMeshDestroyNumber
    MODULE PROCEDURE CMISSMeshDestroyObj
  END INTERFACE !CMISSMeshDestroy

  !>Returns the number of mesh components in a mesh. 
  INTERFACE CMISSMeshNumberOfComponentsGet
    MODULE PROCEDURE CMISSMeshNumberOfComponentsGetNumber
    MODULE PROCEDURE CMISSMeshNumberOfComponentsGetObj
  END INTERFACE !CMISSMeshNumberOfComponentsGet

  !>Sets/changes the number of mesh components in a mesh. 
  INTERFACE CMISSMeshNumberOfComponentsSet
    MODULE PROCEDURE CMISSMeshNumberOfComponentsSetNumber
    MODULE PROCEDURE CMISSMeshNumberOfComponentsSetObj
  END INTERFACE !CMISSMeshNumberOfComponentsSet

  !>Returns the number of elements in a mesh. 
  INTERFACE CMISSMeshNumberOfElementsGet
    MODULE PROCEDURE CMISSMeshNumberOfElementsGetNumber
    MODULE PROCEDURE CMISSMeshNumberOfElementsGetObj
  END INTERFACE !CMISSMeshNumberOfElementsGet

  !>Sets/changes the number of elements in a mesh. 
  INTERFACE CMISSMeshNumberOfElementsSet
    MODULE PROCEDURE CMISSMeshNumberOfElementsSetNumber
    MODULE PROCEDURE CMISSMeshNumberOfElementsSetObj
  END INTERFACE !CMISSMeshNumberOfElementsSet

  !>Returns the basis for an element in a mesh. 
  INTERFACE CMISSMeshElementsBasisGet
    MODULE PROCEDURE CMISSMeshElementsBasisGetNumber
    MODULE PROCEDURE CMISSMeshElementsBasisGetObj
  END INTERFACE !CMISSMeshElementsBasisGet

  !>Sets/changes the basis for an element in a mesh. 
  INTERFACE CMISSMeshElementsBasisSet
    MODULE PROCEDURE CMISSMeshElementsBasisSetNumber
    MODULE PROCEDURE CMISSMeshElementsBasisSetObj
  END INTERFACE !CMISSMeshElementsBasisSet

  !>Finishes the creation of a mesh elements for a mesh component. \see OPENCMISS::CMISSMeshElementsCreateStart
  INTERFACE CMISSMeshElementsCreateFinish
    MODULE PROCEDURE CMISSMeshElementsCreateFinishNumber
    MODULE PROCEDURE CMISSMeshElementsCreateFinishObj
  END INTERFACE !CMISSMeshElementsCreateFinish

  !>Starts the creation of a mesh elements for a mesh component. \see OPENCMISS::CMISSMeshElementsCreateFinish
  INTERFACE CMISSMeshElementsCreateStart
    MODULE PROCEDURE CMISSMeshElementsCreateStartNumber
    MODULE PROCEDURE CMISSMeshElementsCreateStartObj
  END INTERFACE !CMISSMeshElementsCreateStart

  !>Returns the element nodes for an element in a mesh. 
  INTERFACE CMISSMeshElementsNodesGet
    MODULE PROCEDURE CMISSMeshElementsNodesGetNumber
    MODULE PROCEDURE CMISSMeshElementsNodesGetObj
  END INTERFACE !CMISSMeshElementsNodesGet

  !>Sets/changes the element nodes for an element in a mesh. 
  INTERFACE CMISSMeshElementsNodesSet
    MODULE PROCEDURE CMISSMeshElementsNodesSetNumber
    MODULE PROCEDURE CMISSMeshElementsNodesSetObj
  END INTERFACE !CMISSMeshElementsNodesSet

  !>Returns the element user number for an element in a mesh. 
  INTERFACE CMISSMeshElementsUserNumberGet
    MODULE PROCEDURE CMISSMeshElementsUserNumberGetNumber
    MODULE PROCEDURE CMISSMeshElementsUserNumberGetObj
  END INTERFACE !CMISSMeshElementsUserNumberGet

  !>Sets/changes the element user number for an element in a mesh. 
  INTERFACE CMISSMeshElementsUserNumberSet
    MODULE PROCEDURE CMISSMeshElementsUserNumberSetNumber
    MODULE PROCEDURE CMISSMeshElementsUserNumberSetObj
  END INTERFACE !CMISSMeshElementsUserNumberSet

    !>Returns the domain for a given element in a decomposition of a mesh.
  INTERFACE CMISSDecompositionNodeDomainGet
    MODULE PROCEDURE CMISSDecompositionNodeDomainGetNumber
    MODULE PROCEDURE CMISSDecompositionNodeDomainGetObj
  END INTERFACE !CMISSDecompositionElementDomainGet

  PUBLIC CMISSDecompositionAllType,CMISSDecompositionCalculatedType,CMISSDecompositionUserDefinedType

  PUBLIC CMISSDecompositionCreateFinish,CMISSDecompositionCreateStart

  PUBLIC CMISSDecompositionDestroy

  PUBLIC CMISSDecompositionElementDomainCalculate

  PUBLIC CMISSDecompositionElementDomainGet,CMISSDecompositionElementDomainSet

  PUBLIC CMISSDecompositionMeshComponentGet,CMISSDecompositionMeshComponentSet

  PUBLIC CMISSDecompositionNumberOfDomainsGet,CMISSDecompositionNumberOfDomainsSet

  PUBLIC CMISSDecompositionTypeGet,CMISSDecompositionTypeSet

  PUBLIC CMISSMeshCreateFinish,CMISSMeshCreateStart

  PUBLIC CMISSMeshDestroy

  PUBLIC CMISSMeshNumberOfComponentsGet,CMISSMeshNumberOfComponentsSet

  PUBLIC CMISSMeshNumberOfElementsGet,CMISSMeshNumberOfElementsSet

  PUBLIC CMISSMeshElementsBasisGet,CMISSMeshElementsBasisSet

  PUBLIC CMISSMeshElementsCreateFinish,CMISSMeshElementsCreateStart

  PUBLIC CMISSMeshElementsNodesGet,CMISSMeshElementsNodesSet

  PUBLIC CMISSMeshElementsUserNumberGet,CMISSMeshElementsUserNumberSet
  
  PUBLIC CMISSDecompositionNodeDomainGet

!!==================================================================================================================================
!!
!! NODE_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Finishes the process of creating nodes in a region. \see OPENCMISS::CMISSNodesCreateStart
  INTERFACE CMISSNodesCreateFinish
    MODULE PROCEDURE CMISSNodesCreateFinishNumber
    MODULE PROCEDURE CMISSNodesCreateFinishObj
  END INTERFACE !CMISSNodesCreateFinish

  !>Starts the process of creating nodes in a region. \see OPENCMISS::CMISSNodesCreateFinish
  INTERFACE CMISSNodesCreateStart
    MODULE PROCEDURE CMISSNodesCreateStartNumber
    MODULE PROCEDURE CMISSNodesCreateStartObj
  END INTERFACE !CMISSNodesCreateStart
    
  !>Destroys nodes.
  INTERFACE CMISSNodesDestroy
    MODULE PROCEDURE CMISSNodesDestroyNumber
    MODULE PROCEDURE CMISSNodesDestroyObj
  END INTERFACE !CMISSNodesDestroy
   
  !>Returns the label for a node identified by a given global number. \todo should this be a user number?
  INTERFACE CMISSNodesLabelGet
    MODULE PROCEDURE CMISSNodesLabelGetCNumber
    MODULE PROCEDURE CMISSNodesLabelGetCObj
    MODULE PROCEDURE CMISSNodesLabelGetVSNumber
    MODULE PROCEDURE CMISSNodesLabelGetVSObj
  END INTERFACE !CMISSNodesLabelGet

  !>Sets/changes the label for a node identified by a given global number. \todo should this be a user number?
  INTERFACE CMISSNodesLabelSet
    MODULE PROCEDURE CMISSNodesLabelSetCNumber
    MODULE PROCEDURE CMISSNodesLabelSetCObj
    MODULE PROCEDURE CMISSNodesLabelSetVSNumber
    MODULE PROCEDURE CMISSNodesLabelSetVSObj
  END INTERFACE !CMISSNodesLabelSet
     
  !>Returns the user number for a node identified by a given global number. 
  INTERFACE CMISSNodesUserNumberGet
    MODULE PROCEDURE CMISSNodesUserNumberGetNumber
    MODULE PROCEDURE CMISSNodesUserNumberGetObj
  END INTERFACE !CMISSNodesUserNumberGet

  !>Sets/changes the user number for a node identified by a given global number. 
  INTERFACE CMISSNodesUserNumberSet
    MODULE PROCEDURE CMISSNodesUserNumberSetNumber
    MODULE PROCEDURE CMISSNodesUserNumberSetObj
  END INTERFACE !CMISSNodesUserNumberSet

  PUBLIC CMISSNodesCreateFinish,CMISSNodesCreateStart

  PUBLIC CMISSNodesDestroy

  PUBLIC CMISSNodesLabelGet,CMISSNodesLabelSet

  PUBLIC CMISSNodesUserNumberGet,CMISSNodesUserNumberSet
 
!!==================================================================================================================================
!!
!! PROBLEM_CONSTANTS_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters
 
  !> \addtogroup OPENCMISS_ProblemConstants OPENCMISS::Problem::Constants
  !> \brief Problem constants.
  !>@{  
  !> \addtogroup OPENCMISS_ProblemClasses OPENCMISS::Problem::Classes
  !> \brief Problem classes.
  !> \see OPENCMISS::Problem,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSProblemNoClass = PROBLEM_NO_CLASS !<No problem class \see OPENCMISS_ProblemClasses,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemElasticityClass = PROBLEM_ELASTICITY_CLASS !<Elasticity problem class \see OPENCMISS_ProblemClasses,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemFluidMechanicsClass = PROBLEM_FLUID_MECHANICS_CLASS !<Fluid mechanics problem class \see OPENCMISS_ProblemClasses,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemElectromagneticsClass = PROBLEM_ELECTROMAGNETICS_CLASS !<Electromagnetics problem class \see OPENCMISS_ProblemClasses,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemClassicalFieldClass = PROBLEM_CLASSICAL_FIELD_CLASS !<Classical field problem class \see OPENCMISS_ProblemClasses,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemBioelectricsClass = PROBLEM_BIOELECTRICS_CLASS !<Bioelectrics problem class \see OPENCMISS_ProblemClasses,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemModalClass = PROBLEM_MODAL_CLASS !<Modal problem class \see OPENCMISS_ProblemClasses,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemFittingClass = PROBLEM_FITTING_CLASS !<Fitting problem class \see OPENCMISS_ProblemClasses,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemOptimisationClass = PROBLEM_OPTIMISATION_CLASS !<Optimisation problem class \see OPENCMISS_ProblemClasses,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemMultiPhysicsClass = PROBLEM_MULTI_PHYSICS_CLASS !<Multi physics problem class \see OPENCMISS_ProblemClasses,OPENCMISS 
  !>@}
  !> \addtogroup OPENCMISS_ProblemTypes OPENCMISS::Problem::Types
  !> \brief Problem Types.
  !> \see OPENCMISS::Problem,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSProblemNoType = PROBLEM_NO_TYPE !<No problem type \see OPENCMISS_ProblemTypes,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemLinearElasticityType = PROBLEM_LINEAR_ELASTICITY_TYPE !<Linear elasticity problem type \see OPENCMISS_ProblemTypes,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemFiniteElasticityType = PROBLEM_FINITE_ELASTICITY_TYPE !<Finite elasticity problem type \see OPENCMISS_ProblemTypes,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemStokesEquationType = PROBLEM_STOKES_EQUATION_TYPE !<Stokes equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemNavierStokesEquationType = PROBLEM_NAVIER_STOKES_EQUATION_TYPE !<Navier-Stokes problem type \see OPENCMISS_ProblemTypes,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemDarcyEquationType = PROBLEM_DARCY_EQUATION_TYPE !<Darcy equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemElectrostaticType = PROBLEM_ELECTROSTATIC_TYPE !<Electrostatic problem type \see OPENCMISS_ProblemTypes,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemMagnetostaticType = PROBLEM_MAGNETOSTATIC_TYPE !<Magnetostatic problem type \see OPENCMISS_ProblemTypes,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemMaxwellsEquationsType = PROBLEM_MAXWELLS_EQUATIONS_TYPE !<Maxwell's equations problem type \see OPENCMISS_ProblemTypes,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemLaplaceEquationType = PROBLEM_LAPLACE_EQUATION_TYPE !<Laplace problem type \see OPENCMISS_ProblemTypes,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemPoissonEquationType = PROBLEM_POISSON_EQUATION_TYPE !<Poisson problem type \see OPENCMISS_ProblemTypes,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemHelmholtzEquationType = PROBLEM_HELMHOLTZ_EQUATION_TYPE !<Helmholtz problem type \see OPENCMISS_ProblemTypes,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemWaveEquationType = PROBLEM_WAVE_EQUATION_TYPE !<Wave equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemDiffusionEquationType = PROBLEM_DIFFUSION_EQUATION_TYPE !<Diffusion equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemAdvectionDiffusionEquationType = PROBLEM_ADVECTION_DIFFUSION_EQUATION_TYPE !<Advection-Diffusion equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemReactionDiffusionEquationType = PROBLEM_REACTION_DIFFUSION_EQUATION_TYPE !<Reaction-Diffusion equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemBiharmonicEquationType = PROBLEM_BIHARMONIC_EQUATION_TYPE !<Bi-harmonic equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemMonodomainEquationType = PROBLEM_MONODOMAIN_EQUATION_TYPE !<Monodomain equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemBidomainEquationType = PROBLEM_BIDOMAIN_EQUATION_TYPE !<Bidomain equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemLinearElasticModalType = PROBLEM_LINEAR_ELASTIC_MODAL_TYPE !<Linear elastic modal problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemGalerkinProjectionType = PROBLEM_GALERKIN_PROJECTION_TYPE !<Galerkin projection problem type \see OPENCMISS_ProblemTypes,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemFiniteElasticityDarcyType = PROBLEM_FINITE_ELASTICITY_DARCY_TYPE !<Finite Elasticity Darcy problem type \see OPENCMISS_ProblemTypes,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemFiniteElasticityStokesType = PROBLEM_FINITE_ELASTICITY_STOKES_TYPE !<Finite Elasticity Stokes problem type \see OPENCMISS_ProblemTypes,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemFiniteElasticityNavierStokesType = PROBLEM_FINITE_ELASTICITY_NAVIER_STOKES_TYPE !<Finite Elasticity NavierStokes problem type \see OPENCMISS_ProblemTypes,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemDiffusionDiffusionType = PROBLEM_DIFFUSION_DIFFUSION_TYPE !<Diffusion Diffusion problem type \see OPENCMISS_ProblemTypes,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISSProblemDiffusionAdvectionDiffusionType = PROBLEM_DIFFUSION_ADVECTION_DIFFUSION_TYPE !<Diffusion Advection Diffusion problem type \see OPENCMISS_ProblemTypes,OPENCMISS 
  !>@}
  !> \addtogroup OPENCMISS_ProblemSubTypes OPENCMISS::Problem::Subtypes
  !> \brief Problem Subtypes.
  !> \see OPENCMISS::Problem,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSProblemNoSubtype = PROBLEM_NO_SUBTYPE !<No problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemStaticStokesSubtype = PROBLEM_STATIC_STOKES_SUBTYPE !<Static Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemLaplaceStokesSubtype = PROBLEM_LAPLACE_STOKES_SUBTYPE !<Laplace type Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemTransientStokesSubtype = PROBLEM_TRANSIENT_STOKES_SUBTYPE !<Transient Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemALEStokesSubtype = PROBLEM_ALE_STOKES_SUBTYPE !<ALE Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemPGMStokesSubtype = PROBLEM_PGM_STOKES_SUBTYPE !<PGM Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemOptimisedStokesSubtype = PROBLEM_OPTIMISED_STOKES_SUBTYPE !<Optimised Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemStaticNavierStokesSubtype = PROBLEM_STATIC_NAVIER_STOKES_SUBTYPE !<Static Navier-Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemLaplaceNavierStokesSubtype = PROBLEM_LAPLACE_NAVIER_STOKES_SUBTYPE !<Laplace type Navier-Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemTransientNavierStokesSubtype = PROBLEM_TRANSIENT_NAVIER_STOKES_SUBTYPE !<Transient Navier-Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemALENavierStokesSubtype = PROBLEM_ALE_NAVIER_STOKES_SUBTYPE !<ALE Navier-Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemPGMNavierStokesSubtype = PROBLEM_PGM_NAVIER_STOKES_SUBTYPE !<PGM Navier-Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemOptimisedNavierStokesSubtype = PROBLEM_OPTIMISED_NAVIER_STOKES_SUBTYPE !<Optimised Navier-Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemStandardDarcySubtype = PROBLEM_STANDARD_DARCY_SUBTYPE !<Standard Darcy problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemQuasistaticDarcySubtype = PROBLEM_QUASISTATIC_DARCY_SUBTYPE !<Quasistatic Darcy problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemALEDarcySubtype = PROBLEM_ALE_DARCY_SUBTYPE !<ALE Darcy problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemTransientDarcySubtype = PROBLEM_TRANSIENT_DARCY_SUBTYPE !<Transient Darcy problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemStandardLaplaceSubtype = PROBLEM_STANDARD_LAPLACE_SUBTYPE !<Standard Laplace problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemGeneralisedLaplaceSubtype = PROBLEM_GENERALISED_LAPLACE_SUBTYPE !<Generalised Laplace problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemLinearSourcePoissonSubtype = PROBLEM_LINEAR_SOURCE_POISSON_SUBTYPE !<Linear source Poisson problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemStokesPoissonSubtype = PROBLEM_STOKES_POISSON_SUBTYPE !<Vector source Poisson problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemNavierStokesPoissonSubtype = PROBLEM_NAVIER_STOKES_POISSON_SUBTYPE !<Vector source Poisson problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemNonlinearSourcePoissonSubtype = PROBLEM_NONLINEAR_SOURCE_POISSON_SUBTYPE !<Nonlinear source Poisson problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemNoSourceHelmholtzSubtype = PROBLEM_NO_SOURCE_HELMHOLTZ_SUBTYPE !<No source Helmholtz problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemNoSourceDiffusionSubtype = PROBLEM_NO_SOURCE_DIFFUSION_SUBTYPE !<No source Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemLinearSourceDiffusionSubtype = PROBLEM_LINEAR_SOURCE_DIFFUSION_SUBTYPE !<Linear source Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemNonlinearSourceDiffusionSubtype = PROBLEM_NONLINEAR_SOURCE_DIFFUSION_SUBTYPE !<Nonlinear source Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemNoSourceAdvectionDiffusionSubtype = PROBLEM_NO_SOURCE_ADVECTION_DIFFUSION_SUBTYPE !<No source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemLinearSourceAdvectionDiffusionSubtype = & 
    & PROBLEM_LINEAR_SOURCE_ADVECTION_DIFFUSION_SUBTYPE !<Linear source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemNonlinearSourceAdvectionDiffusionSubtype = &
    & PROBLEM_NONLINEAR_SOURCE_ADVECTION_DIFFUSION_SUBTYPE !<Nonlinear source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISSProblemNoSourceStaticAdvecDiffSubtype = PROBLEM_NO_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE !<No source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemLinearSourceStaticAdvecDiffSubtype = & 
    & PROBLEM_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE !<Linear source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemNonlinearSourceStaticAdvecDiffSubtype = &
    & PROBLEM_NONLINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE !<Nonlinear source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISSProblemStandardGalerkinProjectionSubtype = &
    & PROBLEM_STANDARD_GALERKIN_PROJECTION_SUBTYPE !<Standard Galerkin projection problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemGeneralisedGalerkinProjectionSubtype = &
    & PROBLEM_GENERALISED_GALERKIN_PROJECTION_SUBTYPE !<Generalised Galerkin projection problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemMatPropertiesGalerkinProjectionSubtype = &
    & PROBLEM_MAT_PROPERTIES_GALERKIN_PROJECTION_SUBTYPE !<Material Properties Galerkin projection problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISSProblemStandardElasticityDarcySubtype = PROBLEM_STANDARD_ELASTICITY_DARCY_SUBTYPE !<Standard Elasticity Darcy problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemCoupledSourceDiffusionDiffusionSubtype = & 
    & PROBLEM_COUPLED_SOURCE_DIFFUSION_DIFFUSION_SUBTYPE !<Coupled source diffusion-diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemCoupledSourceDiffusionAdvecDiffusionSubtype = & 
    & PROBLEM_COUPLED_SOURCE_DIFFUSION_ADVEC_DIFFUSION_SUBTYPE !<Coupled source diffusion & advection-diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS

  !>@}
  !> \addtogroup OPENCMISS_ProblemControlLoopTypes OPENCMISS::Problem::ControlLoopTypes
  !> \brief Problem control loop type parameters
  !> \see OPENCMISS::Problem,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSProblemControlSimpleType = PROBLEM_CONTROL_SIMPLE_TYPE !<Simple, one iteration control loop. \see OPENCMISS_ProblemControlLoopTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemControlFixedLoopType = PROBLEM_CONTROL_FIXED_LOOP_TYPE !<Fixed iteration control loop. \see OPENCMISS_ProblemControlLoopTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemControlTimeLoopType = PROBLEM_CONTROL_TIME_LOOP_TYPE !<Time control loop. \see OPENCMISS_ProblemControlLoopTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSProblemControlWhileLoopType = PROBLEM_CONTROL_WHILE_LOOP_TYPE !<While control loop. \see OPENCMISS_ProblemControlLoopTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  PUBLIC CMISSProblemNoClass,CMISSProblemElasticityClass,CMISSProblemFluidMechanicsClass,CMISSProblemElectromagneticsClass, &
    & CMISSProblemClassicalFieldClass,CMISSProblemBioelectricsClass,CMISSProblemModalClass,CMISSProblemFittingClass, &
    & CMISSProblemOptimisationClass,CMISSProblemMultiPhysicsClass

  PUBLIC CMISSProblemNoType

  PUBLIC CMISSProblemLinearElasticityType,CMISSProblemFiniteElasticityType

  PUBLIC CMISSProblemStokesEquationType,CMISSProblemNavierStokesEquationType,CMISSProblemDarcyEquationType

  PUBLIC CMISSProblemElectrostaticType,CMISSProblemMagnetostaticType,CMISSProblemMaxwellsEquationsType

  PUBLIC CMISSProblemLaplaceEquationType,CMISSProblemPoissonEquationType,CMISSProblemHelmholtzEquationType, &
    & CMISSProblemWaveEquationType,CMISSProblemDiffusionEquationType,CMISSProblemAdvectionDiffusionEquationType, &
    & CMISSProblemReactionDiffusionEquationType,CMISSProblemBiharmonicEquationType

  PUBLIC CMISSProblemMonodomainEquationType,CMISSProblemBidomainEquationType

  PUBLIC CMISSProblemLinearElasticModalType

  PUBLIC CMISSProblemGalerkinProjectionType

  PUBLIC CMISSProblemFiniteElasticityDarcyType, &
    & CMISSProblemFiniteElasticityStokesType, CMISSProblemFiniteElasticityNavierStokesType, &
    & CMISSProblemDiffusionDiffusionType, CMISSProblemDiffusionAdvectionDiffusionType 

  PUBLIC CMISSProblemNoSubtype

  PUBLIC CMISSProblemStaticStokesSubtype,CMISSProblemLaplaceStokesSubtype,CMISSProblemTransientStokesSubtype, &
    & CMISSProblemOptimisedStokesSubtype,CMISSProblemALEStokesSubtype,CMISSProblemPGMStokesSubtype

  PUBLIC CMISSProblemStaticNavierStokesSubtype,CMISSProblemLaplaceNavierStokesSubtype,CMISSProblemTransientNavierStokesSubtype, &
    & CMISSProblemOptimisedNavierStokesSubtype,CMISSProblemALENavierStokesSubtype,CMISSProblemPGMNavierStokesSubtype

  PUBLIC CMISSProblemStandardDarcySubtype,CMISSProblemQuasistaticDarcySubtype,CMISSProblemALEDarcySubtype, &
    & CMISSProblemTransientDarcySubtype

  PUBLIC CMISSProblemStandardLaplaceSubtype,CMISSProblemGeneralisedLaplaceSubtype

  PUBLIC CMISSProblemLinearSourcePoissonSubtype,CMISSProblemNonlinearSourcePoissonSubtype,CMISSProblemStokesPoissonSubtype, &
    & CMISSProblemNavierStokesPoissonSubtype

  PUBLIC CMISSProblemNoSourceHelmholtzSubtype

  PUBLIC CMISSProblemNoSourceDiffusionSubtype,CMISSProblemLinearSourceDiffusionSubtype,CMISSProblemNonlinearSourceDiffusionSubtype

  PUBLIC CMISSProblemNoSourceAdvectionDiffusionSubtype,CMISSProblemLinearSourceAdvectionDiffusionSubtype, &
    & CMISSProblemNonlinearSourceAdvectionDiffusionSubtype

  PUBLIC CMISSProblemNoSourceStaticAdvecDiffSubtype,CMISSProblemLinearSourceStaticAdvecDiffSubtype, &
    & CMISSProblemNonlinearSourceStaticAdvecDiffSubtype

  PUBLIC CMISSProblemStandardGalerkinProjectionSubtype,CMISSProblemGeneralisedGalerkinProjectionSubtype, &
    & CMISSProblemMatPropertiesGalerkinProjectionSubtype

  PUBLIC CMISSProblemControlSimpleType,CMISSProblemControlFixedLoopType,CMISSProblemControlTimeLoopType, &
    & CMISSProblemControlWhileLoopType

  PUBLIC CMISSProblemStandardElasticityDarcySubtype, CMISSProblemCoupledSourceDiffusionDiffusionSubtype, &
   & CMISSProblemCoupledSourceDiffusionAdvecDiffusionSubtype

!!==================================================================================================================================
!!
!! PROBLEM_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Finishes the process of creating a problem. \see OPENCMISS::CMISSProblemCreateStart
  INTERFACE CMISSProblemCreateFinish
    MODULE PROCEDURE CMISSProblemCreateFinishNumber
    MODULE PROCEDURE CMISSProblemCreateFinishObj
  END INTERFACE !CMISSProblemCreateFinish

  !>Start the process of creating a problem. \see OPENCMISS::CMISSProblemCreateFinish
  INTERFACE CMISSProblemCreateStart
    MODULE PROCEDURE CMISSProblemCreateStartNumber
    MODULE PROCEDURE CMISSProblemCreateStartObj
  END INTERFACE !CMISSProblemCreateStart
 
  !>Destroys a problem. 
  INTERFACE CMISSProblemDestroy
    MODULE PROCEDURE CMISSProblemDestroyNumber
    MODULE PROCEDURE CMISSProblemDestroyObj
  END INTERFACE !CMISSProblemDestroy
  
  !>Finishes the process of creating a control loop on a problem. \see OPENCMISS::CMISSProblemControlLoopCreateStart
  INTERFACE CMISSProblemControlLoopCreateFinish
    MODULE PROCEDURE CMISSProblemControlLoopCreateFinishNumber
    MODULE PROCEDURE CMISSProblemControlLoopCreateFinishObj
  END INTERFACE !CMISSProblemControlLoopCreateFinish

  !>Starts the process of creating a control loop on a problem. \see OPENCMISS::CMISSProblemControlLoopCreateFinish
  INTERFACE CMISSProblemControlLoopCreateStart
    MODULE PROCEDURE CMISSProblemControlLoopCreateStartNumber
    MODULE PROCEDURE CMISSProblemControlLoopCreateStartObj
  END INTERFACE !CMISSProblemControlLoopCreateStart

  !>Destroys the control loop for a problem. 
  INTERFACE CMISSProblemControlLoopDestroy
    MODULE PROCEDURE CMISSProblemControlLoopDestroyNumber
    MODULE PROCEDURE CMISSProblemControlLoopDestroyObj
  END INTERFACE !CMISSProblemControlLoopDestroy
  
  !>Returns a control loop for a problem. 
  INTERFACE CMISSProblemControlLoopGet
    MODULE PROCEDURE CMISSProblemControlLoopGetNumber0
    MODULE PROCEDURE CMISSProblemControlLoopGetNumber1
    MODULE PROCEDURE CMISSProblemControlLoopGetObj0
    MODULE PROCEDURE CMISSProblemControlLoopGetObj1
  END INTERFACE !CMISSProblemControlLoopGet

  !>Solve a problem. 
  INTERFACE CMISSProblemSolve
    MODULE PROCEDURE CMISSProblemSolveNumber
    MODULE PROCEDURE CMISSProblemSolveObj
  END INTERFACE !CMISSProblemSolve

  !>Returns the solver for a problem control loop. 
  INTERFACE CMISSProblemSolverGet
    MODULE PROCEDURE CMISSProblemSolverGetNumber0
    MODULE PROCEDURE CMISSProblemSolverGetNumber1
    MODULE PROCEDURE CMISSProblemSolverGetObj0
    MODULE PROCEDURE CMISSProblemSolverGetObj1
  END INTERFACE !CMISSProblemSolverGet

  !>Finish the creation of solver equations for a problem. \see OPENCMISS::CMISSProblemSolverEquationsCreateStart
  INTERFACE CMISSProblemSolverEquationsCreateFinish
    MODULE PROCEDURE CMISSProblemSolverEquationsCreateFinishNumber
    MODULE PROCEDURE CMISSProblemSolverEquationsCreateFinishObj
  END INTERFACE !CMISSProblemSolverEquationsCreateFinish
  
  !>Start the creation of solver equations for a problem. \see OPENCMISS::CMISSProblemSolverEquationsCreateFinish
  INTERFACE CMISSProblemSolverEquationsCreateStart
    MODULE PROCEDURE CMISSProblemSolverEquationsCreateStartNumber
    MODULE PROCEDURE CMISSProblemSolverEquationsCreateStartObj
  END INTERFACE !CMISSProblemSolverEquationsCreateStart
  
  !>Destroys the solver equations for a problem. 
  INTERFACE CMISSProblemSolverEquationsDestroy
    MODULE PROCEDURE CMISSProblemSolverEquationsDestroyNumber
    MODULE PROCEDURE CMISSProblemSolverEquationsDestroyObj
  END INTERFACE !CMISSProblemSolverEquationsDestroy

  !>Returns the solver equations for a problem. 
  INTERFACE CMISSProblemSolverEquationsGet
    MODULE PROCEDURE CMISSProblemSolverEquationsGetNumber0
    MODULE PROCEDURE CMISSProblemSolverEquationsGetNumber1
    MODULE PROCEDURE CMISSProblemSolverEquationsGetObj0
    MODULE PROCEDURE CMISSProblemSolverEquationsGetObj1
  END INTERFACE !CMISSProblemSolverEquationsGet

  !>Finish the creation of solvers for a problem. \see OPENCMISS::CMISSProblemSolversCreateStart
  INTERFACE CMISSProblemSolversCreateFinish
    MODULE PROCEDURE CMISSProblemSolversCreateFinishNumber
    MODULE PROCEDURE CMISSProblemSolversCreateFinishObj
  END INTERFACE !CMISSProblemSolversCreateFinish
  
  !>Start the creation of solvers for a problem. \see OPENCMISS::CMISSProblemSolversCreateFinish
  INTERFACE CMISSProblemSolversCreateStart
    MODULE PROCEDURE CMISSProblemSolversCreateStartNumber
    MODULE PROCEDURE CMISSProblemSolversCreateStartObj
  END INTERFACE !CMISSProblemSolversCreateStart

  !>Destroy the solvers for a problem.
  INTERFACE CMISSProblemSolversDestroy
    MODULE PROCEDURE CMISSProblemSolversDestroyNumber
    MODULE PROCEDURE CMISSProblemSolversDestroyObj
  END INTERFACE !CMISSProblemSolversDestroy

  !>Returns the problem specification i.e., problem class, type and subtype for a problem. 
  INTERFACE CMISSProblemSpecificationGet
    MODULE PROCEDURE CMISSProblemSpecificationGetNumber
    MODULE PROCEDURE CMISSProblemSpecificationGetObj
  END INTERFACE !CMISSProblemSpecificationGet

  !>Sets/changes the problem specification i.e., problem class, type and subtype for a problem. 
  INTERFACE CMISSProblemSpecificationSet
    MODULE PROCEDURE CMISSProblemSpecificationSetNumber
    MODULE PROCEDURE CMISSProblemSpecificationSetObj
  END INTERFACE !CMISSProblemSpecificationSet

  PUBLIC CMISSProblemCreateFinish,CMISSProblemCreateStart

  PUBLIC CMISSProblemDestroy

  PUBLIC CMISSProblemControlLoopCreateFinish,CMISSProblemControlLoopCreateStart

  PUBLIC CMISSProblemControlLoopDestroy

  PUBLIC CMISSProblemControlLoopGet

  PUBLIC CMISSProblemSolve

  PUBLIC CMISSProblemSolverGet

  PUBLIC CMISSProblemSolverEquationsCreateFinish,CMISSProblemSolverEquationsCreateStart

  PUBLIC CMISSProblemSolverEquationsDestroy
  
  PUBLIC CMISSProblemSolverEquationsGet

  PUBLIC CMISSProblemSolversCreateFinish,CMISSProblemSolversCreateStart

  PUBLIC CMISSProblemSolversDestroy

  PUBLIC CMISSProblemSpecificationGet,CMISSProblemSpecificationSet
  
!!==================================================================================================================================
!!
!! REGION_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Returns the coordinate system of region.
  INTERFACE CMISSRegionCoordinateSystemGet
    MODULE PROCEDURE CMISSRegionCoordinateSystemGetNumber
    MODULE PROCEDURE CMISSRegionCoordinateSystemGetObj
  END INTERFACE !CMISSRegionCoordinateSystemGet

  !>Sets/changes the coordinate system of region.
  INTERFACE CMISSRegionCoordinateSystemSet
    MODULE PROCEDURE CMISSRegionCoordinateSystemSetNumber
    MODULE PROCEDURE CMISSRegionCoordinateSystemSetObj
  END INTERFACE !CMISSRegionCoordinateSystemSet

  !>Finishes the creation of a region. \see OPENCMISS::CMISSRegionCreateStart
  INTERFACE CMISSRegionCreateFinish
    MODULE PROCEDURE CMISSRegionCreateFinishNumber
    MODULE PROCEDURE CMISSRegionCreateFinishObj
  END INTERFACE !CMISSRegionCreateFinish

  !>Starts the creation of a region. \see OPENCMISS::CMISSRegionCreateFinish
  INTERFACE CMISSRegionCreateStart
    MODULE PROCEDURE CMISSRegionCreateStartNumber
    MODULE PROCEDURE CMISSRegionCreateStartObj
  END INTERFACE !CMISSRegionCreateStart
    
  !>Destroys a region. 
  INTERFACE CMISSRegionDestroy
    MODULE PROCEDURE CMISSRegionDestroyNumber
    MODULE PROCEDURE CMISSRegionDestroyObj
  END INTERFACE !CMISSRegionDestroy
    
  !>Returns the label of a region. 
  INTERFACE CMISSRegionLabelGet
    MODULE PROCEDURE CMISSRegionLabelGetCNumber
    MODULE PROCEDURE CMISSRegionLabelGetCObj
    MODULE PROCEDURE CMISSRegionLabelGetVSNumber
    MODULE PROCEDURE CMISSRegionLabelGetVSObj
  END INTERFACE !CMISSRegionLabelGet
    
  !>Sets/changes the label of a region. 
  INTERFACE CMISSRegionLabelSet
    MODULE PROCEDURE CMISSRegionLabelSetCNumber
    MODULE PROCEDURE CMISSRegionLabelSetCObj
    MODULE PROCEDURE CMISSRegionLabelSetVSNumber
    MODULE PROCEDURE CMISSRegionLabelSetVSObj
  END INTERFACE !CMISSRegionLabelSet

  PUBLIC CMISSRegionCoordinateSystemGet,CMISSRegionCoordinateSystemSet

  PUBLIC CMISSRegionCreateFinish,CMISSRegionCreateStart

  PUBLIC CMISSRegionDestroy

  PUBLIC CMISSRegionLabelGet,CMISSRegionLabelSet
  
!!==================================================================================================================================
!!
!! SOLVER_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_SolverConstants OPENCMISS::Solver::Constants
  !> \brief Solver constants.
  !>@{
  !> \addtogroup OPENCMISS_SolverTypes OPENCMISS::Solver::SolverTypes
  !> \brief The types of solver
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSSolverLinearType = SOLVER_LINEAR_TYPE !<A linear solver. \see OPENCMISS_SolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverNonlinearType = SOLVER_NONLINEAR_TYPE !<A nonlinear solver. \see OPENCMISS_SolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDynamicType = SOLVER_DYNAMIC_TYPE !<A dynamic solver. \see  OPENCMISS_SolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDAEType = SOLVER_DAE_TYPE !<A differential-algebraic equation solver. \see OPENCMISS_SolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverEigenproblemType = SOLVER_EIGENPROBLEM_TYPE !<A eigenproblem solver. \see OPENCMISS_SolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverOptimiserType = SOLVER_OPTIMISER_TYPE !<An optimiser solver. \see OPENCMISS_SolverTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_SolverLibraries OPENCMISS::Solver::SolverLibraries
  !> \brief The types of solver libraries.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSSolverCMISSLibrary = SOLVER_CMISS_LIBRARY !<CMISS (internal) solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverPETScLibrary = SOLVER_PETSC_LIBRARY !<PETSc solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverMUMPSLibrary = SOLVER_MUMPS_LIBRARY !<MUMPS solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverSuperLULibrary = SOLVER_SUPERLU_LIBRARY !<SuperLU solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverSpoolesLULibrary = SOLVER_SPOOLES_LIBRARY !<SPOOLES solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverUMFPACKLibrary = SOLVER_UMFPACK_LIBRARY !<UMFPACK solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverLUSOLLibrary = SOLVER_LUSOL_LIBRARY !<LUSOL solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverESSLLibrary = SOLVER_ESSL_LIBRARY !<ESSL solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverLAPACKLibrary = SOLVER_LAPACK_LIBRARY !<LAPACK solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverTAOLibrary = SOLVER_TAO_LIBRARY !<TAO solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverHypreLibrary = SOLVER_HYPRE_LIBRARY !<Hypre solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_LinearSolverTypes OPENCMISS::Solver::LinearSolverTypes
  !> \brief The types of linear solvers.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSSolverLinearDirectSolveType = SOLVER_LINEAR_DIRECT_SOLVE_TYPE !<Direct linear solver type. \see OPENCMISS_LinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverLinearIterativeSolveType = SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE !<Iterative linear solver type. \see OPENCMISS_LinearSolverTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_DirectLinearSolverTypes OPENCMISS::Solver::DirectLinearSolverTypes
  !> \brief The types of direct linear solvers. \todo Move libraries to a more appropriate place.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSSolverDirectLU = SOLVER_DIRECT_LU !<LU direct linear solver. \see OPENCMISS_DirectLinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDirectCholesky = SOLVER_DIRECT_CHOLESKY !<Cholesky direct linear solver. \see OPENCMISS_DirectLinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDirectSVD = SOLVER_DIRECT_SVD !<SVD direct linear solver. \see OPENCMISS_DirectLinearSolverTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_IterativeLinearSolverTypes OPENCMISS::Solver::IterativeLinearSolverTypes
  !> \brief The types of iterative linear solvers.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSSolverIterativeRichardson = SOLVER_ITERATIVE_RICHARDSON !<Richardson iterative solver type. \see  OPENCMISS_IterativeLinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverIterativeChebychev = SOLVER_ITERATIVE_CHEBYCHEV !<Chebychev iterative solver type. \see OPENCMISS_IterativeLinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverIterativeConjugateGradient = SOLVER_ITERATIVE_CONJUGATE_GRADIENT !<Conjugate gradient iterative solver type. \see OPENCMISS_IterativeLinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverIterativeBiconjugateGradient = SOLVER_ITERATIVE_BICONJUGATE_GRADIENT !<Bi-conjugate gradient iterative solver type. \see OPENCMISS_IterativeLinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverIterativeGMRES = SOLVER_ITERATIVE_GMRES !<Generalised minimum residual iterative solver type. \see OPENCMISS_IterativeLinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverIterativeBiCGSTAB = SOLVER_ITERATIVE_BiCGSTAB !<Stabalised bi-conjugate gradient iterative solver type. \see OPENCMISS_IterativeLinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverConjgradSquared = SOLVER_ITERATIVE_CONJGRAD_SQUARED !<Conjugate gradient squared iterative solver type. \see OPENCMISS_IterativeLinearSolverTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_IterativePreconditionerTypes OPENCMISS::Solver::IterativePreconditionerTypes
  !> \brief The types of iterative preconditioners.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSSolverIterativeNoPreconditioner = SOLVER_ITERATIVE_NO_PRECONDITIONER !<No preconditioner type. \see OPENCMISS_IterativePreconditionerTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverIterativeJacobiPreconditioner = SOLVER_ITERATIVE_JACOBI_PRECONDITIONER !<Jacobi preconditioner type. \see OPENCMISS_IterativePreconditionerTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverIterativeBlockJacobiPreconditioner = SOLVER_ITERATIVE_BLOCK_JACOBI_PRECONDITIONER !<Iterative block Jacobi preconditioner type. \see OPENCMISS_IterativePreconditionerTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverIterativeSORPreconditioner = SOLVER_ITERATIVE_SOR_PRECONDITIONER !<Successive over relaxation preconditioner type. \see OPENCMISS_IterativePreconditionerTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverIterativeIncompleteCholeskyPreconditioner = &
    & SOLVER_ITERATIVE_INCOMPLETE_CHOLESKY_PRECONDITIONER !<Incomplete Cholesky preconditioner type. \see OPENCMISS_IterativePreconditionerTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverIterativeIncompleteLUPreconditioner = SOLVER_ITERATIVE_INCOMPLETE_LU_PRECONDITIONER !<Incomplete LU preconditioner type. \see OPENCMISS_IterativePreconditionerTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverIterativeAdditiveSchwarzPreconditioner = SOLVER_ITERATIVE_ADDITIVE_SCHWARZ_PRECONDITIONER !<Additive Schwrz preconditioner type. \see OPENCMISS_IterativePreconditionerTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_NonlinearSolverTypes OPENCMISS::Solver::NonlinearSolverTypes
  !> \brief The types of nonlinear solvers.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSSolverNonlinearNewton = SOLVER_NONLINEAR_NEWTON !<Newton nonlinear solver type. \see OPENCMISS_NonlinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverNonlinearBFGSInverse = SOLVER_NONLINEAR_BFGS_INVERSE !<BFGS inverse nonlinear solver type. \see OPENCMISS_NonlinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverNonlinearSQP = SOLVER_NONLINEAR_SQP !<Sequential Quadratic Program nonlinear solver type. \see OPENCMISS_NonlinearSolverTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_NewtonSolverTypes OPENCMISS::Solver::NewtonSolverTypes
  !> \brief The types of nonlinear Newton solvers.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSSolverNewtonLinesearch = SOLVER_NEWTON_LINESEARCH !<Newton line search nonlinear solver type. \see OPENCMISS_NewtonSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverNewtonTrustregion = SOLVER_NEWTON_TRUSTREGION !<Newton trust region nonlinear solver type. \see OPENCMISS_NewtonSolverTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_NewtonLineSearchTypes OPENCMISS::Solver::NewtonLineSearchTypes
  !> \brief The types line search techniques for Newton line search nonlinear solvers.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSSolverNewtonLinesearchNoNorms = SOLVER_NEWTON_LINESEARCH_NONORMS !<No norms line search for Newton line search nonlinear solves \see OPENCMISS_NewtonLineSearchTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverNewtonLinesearchNone = SOLVER_NEWTON_LINESEARCH_NONE !<No line search for Newton line search nonlinear solves \see OPENCMISS_NewtonLineSearchTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverNewtonLinesearchQuadratic = SOLVER_NEWTON_LINESEARCH_QUADRATIC !<Quadratic search for Newton line search nonlinear solves \see OPENCMISS_NewtonLineSearchTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverNewtonLinesearchCubic = SOLVER_NEWTON_LINESEARCH_CUBIC !<Cubic search for Newton line search nonlinear solves \see OPENCMISS_NewtonLineSearchTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_JacobianCalculationTypes OPENCMISS::Solver::JacobianCalculationTypes
  !> \brief The Jacobian calculation types for a nonlinear solver.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSSolverNewtonJacobianNotCaclulated = SOLVER_NEWTON_JACOBIAN_NOT_CALCULATED !<The Jacobian values will not be calculated for the nonlinear equations set. \see OPENCMISS_JacobianCalculationTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverNewtonJacobianAnalyticCalculated = SOLVER_NEWTON_JACOBIAN_ANALTYIC_CALCULATED !<The Jacobian values will be calculated analytically for the nonlinear equations set. \see OPENCMISS_JacobianCalculationTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverNewtonJacobianFDCalculated = SOLVER_NEWTON_JACOBIAN_FD_CALCULATED !<The Jacobian values will be calcualted using finite differences for the nonlinear equations set. \see OPENCMISS_JacobianCalculationTypes,OPENCMISS
  !>@}  
  !> \addtogroup OPENCMISS_DynamicOrderTypes OPENCMISS::Solver::DynamicOrderTypes
  !> \brief The order types for a dynamic solver.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSSolverDynamicFirstOrder = SOLVER_DYNAMIC_FIRST_ORDER !<Dynamic solver has first order terms. \see OPENCMISS_DynamicOrderTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDynamicSecondOrder = SOLVER_DYNAMIC_SECOND_ORDER !<Dynamic solver has second order terms. \see OPENCMISS_DynamicOrderTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_DynamicLinearityTypes OPENCMISS::Solver::DynamicLinearityTypes
  !> \brief The time linearity types for a dynamic solver.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSSolverDynamicLinear = SOLVER_DYNAMIC_LINEAR !<Dynamic solver has linear terms. \see OPENCMISS_DynamicLinearityTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDynamicNonlinear = SOLVER_DYNAMIC_NONLINEAR !<Dynamic solver has nonlinear terms. \see OPENCMISS_DynamicLinearityTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_DynamicDegreeTypes OPENCMISS::Solver::DynamicDegreeTypes
  !> \brief The time interpolation polynomial degree types for a dynamic solver.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSSolverDynamicFirstDegree = SOLVER_DYNAMIC_FIRST_DEGREE !<Dynamic solver uses a first degree polynomial for time interpolation. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDynamicSecondDegree = SOLVER_DYNAMIC_SECOND_DEGREE !<Dynamic solver uses a second degree polynomial for time interpolation. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDynamicThirdDegree = SOLVER_DYNAMIC_THIRD_DEGREE !<Dynamic solver uses a third degree polynomial for time interpolation. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
  !>@}    
  !> \addtogroup OPENCMISS_DynamicSchemeTypes OPENCMISS::Solver::DynamicSchemeTypes
  !> \brief The types of dynamic solver scheme.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSSolverDynamicEulerScheme = SOLVER_DYNAMIC_EULER_SCHEME !<Euler (explicit) dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDynamicBackwardEulerScheme = SOLVER_DYNAMIC_BACKWARD_EULER_SCHEME !<Backward Euler (implicit) dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDynamicCrankNicholsonScheme = SOLVER_DYNAMIC_CRANK_NICHOLSON_SCHEME !<Crank-Nicholson dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDynamicGalerkinScheme = SOLVER_DYNAMIC_GALERKIN_SCHEME !<Galerkin dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDynamicZlamalScheme = SOLVER_DYNAMIC_ZLAMAL_SCHEME !<Zlamal dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDynamicSecondDegreeGearScheme = SOLVER_DYNAMIC_SECOND_DEGREE_GEAR_SCHEME !<2nd degree Gear dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDynamicSecondDegreeLiniger1Scheme = SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER1_SCHEME !<1st 2nd degree Liniger dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDynamicSecondDegreeLiniger2Scheme = SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER2_SCHEME !<2nd 2nd degree Liniger dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDynamicNewmark1Scheme = SOLVER_DYNAMIC_NEWMARK1_SCHEME !<1st Newmark dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDynamicNewmark2Scheme = SOLVER_DYNAMIC_NEWMARK2_SCHEME !<2nd Newmark dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDynamicNewmark3Scheme = SOLVER_DYNAMIC_NEWMARK3_SCHEME !<3rd Newmark dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDynamicThirdDegreeGearScheme = SOLVER_DYNAMIC_THIRD_DEGREE_GEAR_SCHEME !<3rd degree Gear dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDynamicThirdDegreeLiniger1Scheme = SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER1_SCHEME !<1st 3rd degree Liniger dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDynamicThirdDegreeLiniger2Scheme = SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER2_SCHEME !<2nd 3rd degree Liniger dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDynamicHouboltScheme = SOLVER_DYNAMIC_HOUBOLT_SCHEME !<Houbolt dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDynamicWilsonScheme = SOLVER_DYNAMIC_WILSON_SCHEME !<Wilson dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDynamicBossakNewmark1Scheme = SOLVER_DYNAMIC_BOSSAK_NEWMARK1_SCHEME !<1st Bossak-Newmark dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDynamicBossakNewmark2Scheme = SOLVER_DYNAMIC_BOSSAK_NEWMARK2_SCHEME !<2nd Bossak-Newmark dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDynamicHilbertHughesTaylor1Scheme = SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR1_SCHEME !<1st Hilbert-Hughes-Taylor dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDynamicHilbertHughesTaylor2Scheme = SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR2_SCHEME !<1st Hilbert-Hughes-Taylor dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDynamicUserDefinedScheme = SOLVER_DYNAMIC_USER_DEFINED_SCHEME !<User specified degree and theta dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_DAETypes OPENCMISS::Solver::DAETypes
  !> \brief The type of differential-algebraic equation.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSSolverDAEDifferentialOnly = SOLVER_DAE_DIFFERENTIAL_ONLY !<Differential equations only. \see OPENCMISS_DAETypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDAEIndex1 = SOLVER_DAE_INDEX_1 !<Index 1 differential-algebraic equation. \see OPENCMISS_DAETypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDAEIndex2 = SOLVER_DAE_INDEX_2 !<Index 2 differential-algebraic equation. \see OPENCMISS_DAETypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDAEIndex3 = SOLVER_DAE_INDEX_3 !<Index 3 differential-algebraic equation. \see OPENCMISS_DAETypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_DAESolverTypes OPENCMISS::Solver::DAESolverTypes
  !> \brief The differential-algebraic equation solver types for a differential-algebraic equation solver.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSSolverDAEEuler = SOLVER_DAE_EULER !<Euler differential-algebraic equation solver. \see 
  INTEGER(INTG), PARAMETER :: CMISSSolverDAECrankNicholson = SOLVER_DAE_CRANK_NICHOLSON !<Crank-Nicholson differential-algebraic equation solver. \see 
  INTEGER(INTG), PARAMETER :: CMISSSolverDAERungeKutta = SOLVER_DAE_RUNGE_KUTTA !<Runge-Kutta differential-algebraic equation solver. \see 
  INTEGER(INTG), PARAMETER :: CMISSSolverDAEAdamsMoulton = SOLVER_DAE_ADAMS_MOULTON !<Adams-Moulton differential-algebraic equation solver. \see 
  INTEGER(INTG), PARAMETER :: CMISSSolverDAEBDF = SOLVER_DAE_BDF !<General BDF differential-algebraic equation solver. \see 
  INTEGER(INTG), PARAMETER :: CMISSSolverRushLarson = SOLVER_DAE_RUSH_LARSON !<Rush-Larson differential-algebraic equation solver. \see 
  !>@}
  !> \addtogroup OPENCMISS_EulerDAESolverTypes OPENCMISS::Solver::EulerDAESolverTypes
  !> \brief The Euler solver types for a differential-algebriac equation solver.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSSolverDAEEulerForward = SOLVER_DAE_EULER_FORWARD !<Forward Euler differential equation solver. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDAEEulerBackward = SOLVER_DAE_EULER_BACKWARD !<Backward Euler differential equation solver. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverDAEEulerImproved = SOLVER_DAE_EULER_IMPROVED !<Improved Euler differential equation solver. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_SolutionInitialiseTypes OPENCMISS::Solver::SolutionInitialiseTypes
  !> \brief The types of solution initialisation.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSSolverSolutionInitialiseZero = SOLVER_SOLUTION_INITIALISE_ZERO !<Initialise the solution by zeroing it before a solve. \see OPENCMISS_SolutionInitialiseTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverSolutionInitialiseCurrentField = SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD !<Initialise the solution by copying in the current dependent field values. \see OPENCMISS_SolutionInitialiseTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverSolutionInitialiseNoChange = SOLVER_SOLUTION_INITIALISE_NO_CHANGE !<Do not change the solution before a solve. \see OPENCMISS_SolutionInitialiseTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_SolverOutputTypes OPENCMISS::Solver::OutputTypes
  !> \brief The types of output.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSSolverNoOutput = SOLVER_NO_OUTPUT !<No output from the solver routines. \see OPENCMISS_SolverOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverProgressOutput = SOLVER_PROGRESS_OUTPUT !<Progress output from solver routines. \see OPENCMISS_SolverOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverTimingOutput = SOLVER_TIMING_OUTPUT !<Timing output from the solver routines plus below. \see OPENCMISS_SolverOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverSolverOutput = SOLVER_SOLVER_OUTPUT !<Solver specific output from the solver routines plus below. \see OPENCMISS_SolverOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverSolverMatrixOutput = SOLVER_MATRIX_OUTPUT !<Solver matrices output from the solver routines plus below. \see OPENCMISS_SolverOutputTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_SolverEquationsSparsityTypes OPENCMISS::SolverEquations::SparsityTypes
  !> \brief The types of sparse solver equations matrices.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISSSolverEquationsSparseMatrices = SOLVER_SPARSE_MATRICES !<Use sparse solver matrices. \see OPENCMISS_SolverEquationsSparsityTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverEquationsFullMatrices = SOLVER_FULL_MATRICES !<Use fully populated solver matrices. \see OPENCMISS_SolverEquationsSparsityTypes,OPENCMISS
  !>@}
  !>@}
  
  !Module types

  !Module variables

  !Interfaces

  !>Returns the solver type for an Euler differential-algebraic equation solver. \todo should this be CMISSSolverDAEEulerSolverTypeGet???
  INTERFACE CMISSSolverDAEEulerSolverTypeGet
    MODULE PROCEDURE CMISSSolverDAEEulerSolverTypeGetNumber0
    MODULE PROCEDURE CMISSSolverDAEEulerSolverTypeGetNumber1
    MODULE PROCEDURE CMISSSolverDAEEulerSolverTypeGetObj
  END INTERFACE !CMISSSolverDAEEulerSolverTypeGet
  
  !>Sets/changes the solver type for an Euler differential-algebraic equation solver. \todo should this be CMISSSolverDAEEulerSolverTypeSet???
  INTERFACE CMISSSolverDAEEulerSolverTypeSet
    MODULE PROCEDURE CMISSSolverDAEEulerSolverTypeSetNumber0
    MODULE PROCEDURE CMISSSolverDAEEulerSolverTypeSetNumber1
    MODULE PROCEDURE CMISSSolverDAEEulerSolverTypeSetObj
  END INTERFACE !CMISSSolverDAEEulerSolverTypeSet

  !>Returns the solver type for an differential-algebraic equation solver.
  INTERFACE CMISSSolverDAESolverTypeGet
    MODULE PROCEDURE CMISSSolverDAESolverTypeGetNumber0
    MODULE PROCEDURE CMISSSolverDAESolverTypeGetNumber1
    MODULE PROCEDURE CMISSSolverDAESolverTypeGetObj
  END INTERFACE !CMISSSolverDAESolverTypeGet
  
  !>Sets/changes the solver type for an differential-algebraic equation solver.
  INTERFACE CMISSSolverDAESolverTypeSet
    MODULE PROCEDURE CMISSSolverDAESolverTypeSetNumber0
    MODULE PROCEDURE CMISSSolverDAESolverTypeSetNumber1
    MODULE PROCEDURE CMISSSolverDAESolverTypeSetObj
  END INTERFACE !CMISSSolverDAESolverTypeSet
  
  !>Sets/changes the times for a differential-algebraic equation solver.
  INTERFACE CMISSSolverDAETimesSet
    MODULE PROCEDURE CMISSSolverDAETimesSetNumber0
    MODULE PROCEDURE CMISSSolverDAETimesSetNumber1
    MODULE PROCEDURE CMISSSolverDAETimesSetObj
  END INTERFACE !CMISSSolverDAETimesSet
  
  !>Returns the degree of the polynomial used to interpolate time for a dynamic solver.
  INTERFACE CMISSSolverDynamicDegreeGet
    MODULE PROCEDURE CMISSSolverDynamicDegreeGetNumber0
    MODULE PROCEDURE CMISSSolverDynamicDegreeGetNumber1
    MODULE PROCEDURE CMISSSolverDynamicDegreeGetObj
  END INTERFACE !CMISSSolverDynamicDegreeGet
  
  !>Sets/changes the degree of the polynomial used to interpolate time for a dynamic solver.
  INTERFACE CMISSSolverDynamicDegreeSet
    MODULE PROCEDURE CMISSSolverDynamicDegreeSetNumber0
    MODULE PROCEDURE CMISSSolverDynamicDegreeSetNumber1
    MODULE PROCEDURE CMISSSolverDynamicDegreeSetObj
  END INTERFACE !CMISSSolverDynamicDegreeSet
  
  !>Returns the linearity type for the dynamic solver.
  INTERFACE CMISSSolverDynamicLinearityTypeGet
    MODULE PROCEDURE CMISSSolverDynamicLinearityTypeGetNumber0
    MODULE PROCEDURE CMISSSolverDynamicLinearityTypeGetNumber1
    MODULE PROCEDURE CMISSSolverDynamicLinearityTypeGetObj
  END INTERFACE !CMISSSolverDynamicLinearityTypeGet
  
  !>Returns the linear solver associated with a linear dynamic solver.
  INTERFACE CMISSSolverDynamicLinearSolverGet
    MODULE PROCEDURE CMISSSolverDynamicLinearSolverGetNumber0
    MODULE PROCEDURE CMISSSolverDynamicLinearSolverGetNumber1
    MODULE PROCEDURE CMISSSolverDynamicLinearSolverGetObj
  END INTERFACE !CMISSSolverDynamicNonlinearSolverGet
  
  !>Returns the nonlinear solver associated with a nonlinear dynamic solver.
  INTERFACE CMISSSolverDynamicNonlinearSolverGet
    MODULE PROCEDURE CMISSSolverDynamicNonlinearSolverGetNumber0
    MODULE PROCEDURE CMISSSolverDynamicNonlinearSolverGetNumber1
    MODULE PROCEDURE CMISSSolverDynamicNonlinearSolverGetObj
  END INTERFACE !CMISSSolverDynamicNonlinearSolverGet
  
  !>Sets/changes the scheme for a dynamic solver.
  INTERFACE CMISSSolverDynamicSchemeSet
    MODULE PROCEDURE CMISSSolverDynamicSchemeSetNumber0
    MODULE PROCEDURE CMISSSolverDynamicSchemeSetNumber1
    MODULE PROCEDURE CMISSSolverDynamicSchemeSetObj
  END INTERFACE !CMISSSolverDynamicSchemeSet
  
  !>Sets/changes the theta scheme values for a dynamic solver.
  INTERFACE CMISSSolverDynamicThetaSet
    MODULE PROCEDURE CMISSSolverDynamicThetaSetNumber00
    MODULE PROCEDURE CMISSSolverDynamicThetaSetNumber01
    MODULE PROCEDURE CMISSSolverDynamicThetaSetNumber10
    MODULE PROCEDURE CMISSSolverDynamicThetaSetNumber11
    MODULE PROCEDURE CMISSSolverDynamicThetaSetObj0
    MODULE PROCEDURE CMISSSolverDynamicThetaSetObj1
  END INTERFACE !CMISSSolverDynamicThetaSet
  
  !>Sets/changes the dynamic times for a dynamic solver.
  INTERFACE CMISSSolverDynamicTimesSet
    MODULE PROCEDURE CMISSSolverDynamicTimesSetNumber0
    MODULE PROCEDURE CMISSSolverDynamicTimesSetNumber1
    MODULE PROCEDURE CMISSSolverDynamicTimesSetObj
  END INTERFACE !CMISSSolverDynamicTimesSet
  
  !>Returns the type of library to use for the solver.
  INTERFACE CMISSSolverLibraryTypeGet
    MODULE PROCEDURE CMISSSolverLibraryTypeGetNumber0
    MODULE PROCEDURE CMISSSolverLibraryTypeGetNumber1
    MODULE PROCEDURE CMISSSolverLibraryTypeGetObj
  END INTERFACE !CMISSSolverLibraryTypeGet
  
  !>Sets/changes the type of library to use for the solver.
  INTERFACE CMISSSolverLibraryTypeSet
    MODULE PROCEDURE CMISSSolverLibraryTypeSetNumber0
    MODULE PROCEDURE CMISSSolverLibraryTypeSetNumber1
    MODULE PROCEDURE CMISSSolverLibraryTypeSetObj
  END INTERFACE !CMISSSolverLibraryTypeSet
  
  !>Sets/changes the type of direct linear solver.
  INTERFACE CMISSSolverLinearDirectTypeSet
    MODULE PROCEDURE CMISSSolverLinearDirectTypeSetNumber0
    MODULE PROCEDURE CMISSSolverLinearDirectTypeSetNumber1
    MODULE PROCEDURE CMISSSolverLinearDirectTypeSetObj
  END INTERFACE !CMISSSolverLinearDirectTypeSet
  
  !>Sets/changes the absolute tolerance for an iterative linear solver.
  INTERFACE CMISSSolverLinearIterativeAbsoluteToleranceSet
    MODULE PROCEDURE CMISSSolverLinearIterativeAbsoluteToleranceSetNumber0
    MODULE PROCEDURE CMISSSolverLinearIterativeAbsoluteToleranceSetNumber1
    MODULE PROCEDURE CMISSSolverLinearIterativeAbsoluteToleranceSetObj
  END INTERFACE !CMISSSolverLinearIterativeAbsoluteToleranceSet
  
  !>Sets/changes the divergence tolerance for an iterative linear solver.
  INTERFACE CMISSSolverLinearIterativeDivergenceToleranceSet
    MODULE PROCEDURE CMISSSolverLinearIterativeDivergenceToleranceSetNumber0
    MODULE PROCEDURE CMISSSolverLinearIterativeDivergenceToleranceSetNumber1
    MODULE PROCEDURE CMISSSolverLinearIterativeDivergenceToleranceSetObj
  END INTERFACE !CMISSSolverLinearIterativeDivergenceToleranceSet
  
  !>Sets/changes the GMRES restart value for a GMRES iterative linear solver.
  INTERFACE CMISSSolverLinearIterativeGMRESRestartSet
    MODULE PROCEDURE CMISSSolverLinearIterativeGMRESRestartSetNumber0
    MODULE PROCEDURE CMISSSolverLinearIterativeGMRESRestartSetNumber1
    MODULE PROCEDURE CMISSSolverLinearIterativeGMRESRestartSetObj
  END INTERFACE !CMISSSolverLinearIterativeGMRESRestartSet
  
  !>Sets/changes the maximum number of iterations for an iterative linear solver.
  INTERFACE CMISSSolverLinearIterativeMaximumIterationsSet
    MODULE PROCEDURE CMISSSolverLinearIterativeMaximumIterationsSetNumber0
    MODULE PROCEDURE CMISSSolverLinearIterativeMaximumIterationsSetNumber1
    MODULE PROCEDURE CMISSSolverLinearIterativeMaximumIterationsSetObj
  END INTERFACE !CMISSSolverLinearIterativeMaximumIterationsSet
  
  !>Sets/changes the type of preconditioner for an iterative linear solver.
  INTERFACE CMISSSolverLinearIterativePreconditionerTypeSet
    MODULE PROCEDURE CMISSSolverLinearIterativePreconditionerTypeSetNumber0
    MODULE PROCEDURE CMISSSolverLinearIterativePreconditionerTypeSetNumber1
    MODULE PROCEDURE CMISSSolverLinearIterativePreconditionerTypeSetObj
  END INTERFACE !CMISSSolverLinearIterativePreconditionerTypeSet
  
  !>Sets/changes the relative tolerance for an iterative linear solver.
  INTERFACE CMISSSolverLinearIterativeRelativeToleranceSet
    MODULE PROCEDURE CMISSSolverLinearIterativeRelativeToleranceSetNumber0
    MODULE PROCEDURE CMISSSolverLinearIterativeRelativeToleranceSetNumber1
    MODULE PROCEDURE CMISSSolverLinearIterativeRelativeToleranceSetObj
  END INTERFACE !CMISSSolverLinearIterativeRelativeToleranceSet
  
  !>Sets/changes the type of iterative linear solver.
  INTERFACE CMISSSolverLinearIterativeTypeSet
    MODULE PROCEDURE CMISSSolverLinearIterativeTypeSetNumber0
    MODULE PROCEDURE CMISSSolverLinearIterativeTypeSetNumber1
    MODULE PROCEDURE CMISSSolverLinearIterativeTypeSetObj
  END INTERFACE !CMISSSolverLinearIterativeTypeSet
  
  !>Sets/changes the type of linear solver.
  INTERFACE CMISSSolverLinearTypeSet
    MODULE PROCEDURE CMISSSolverLinearTypeSetNumber0
    MODULE PROCEDURE CMISSSolverLinearTypeSetNumber1
    MODULE PROCEDURE CMISSSolverLinearTypeSetObj
  END INTERFACE !CMISSSolverLinearTypeSet
  
  !>Sets/changes the absolute tolerance for a nonlinear Newton solver.
  INTERFACE CMISSSolverNewtonAbsoluteToleranceSet
    MODULE PROCEDURE CMISSSolverNewtonAbsoluteToleranceSetNumber0
    MODULE PROCEDURE CMISSSolverNewtonAbsoluteToleranceSetNumber1
    MODULE PROCEDURE CMISSSolverNewtonAbsoluteToleranceSetObj
  END INTERFACE !CMISSSolverNewtonAbsoluteToleranceSet
  
  !>Sets/changes the Jacobian calculation type for a nonlinear Newton solver.
  INTERFACE CMISSSolverNewtonJacobianCalculationTypeSet
    MODULE PROCEDURE CMISSSolverNewtonJacobianCalculationTypeSetNumber0
    MODULE PROCEDURE CMISSSolverNewtonJacobianCalculationTypeSetNumber1
    MODULE PROCEDURE CMISSSolverNewtonJacobianCalculationTypeSetObj
  END INTERFACE !CMISSSolverNewtonJacobianCalculationTypeSet
  
  !>Returns the linear solver associated with a nonlinear Newton solver.
  INTERFACE CMISSSolverNewtonLinearSolverGet
    MODULE PROCEDURE CMISSSolverNewtonLinearSolverGetNumber0
    MODULE PROCEDURE CMISSSolverNewtonLinearSolverGetNumber1
    MODULE PROCEDURE CMISSSolverNewtonLinearSolverGetObj
  END INTERFACE !CMISSSolverNewtonLinearSolverGet
  
  !>Sets/changes the line search alpha for a nonlinear Newton solver.
  INTERFACE CMISSSolverNewtonLineSearchAlphaSet
    MODULE PROCEDURE CMISSSolverNewtonLineSearchAlphaSetNumber0
    MODULE PROCEDURE CMISSSolverNewtonLineSearchAlphaSetNumber1
    MODULE PROCEDURE CMISSSolverNewtonLineSearchAlphaSetObj
  END INTERFACE !CMISSSolverNewtonLineSearchAlphaSet
  
  !>Sets/changes the line search maximum step for a nonlinear Newton solver.
  INTERFACE CMISSSolverNewtonLineSearchMaxStepSet
    MODULE PROCEDURE CMISSSolverNewtonLineSearchMaxStepSetNumber0
    MODULE PROCEDURE CMISSSolverNewtonLineSearchMaxStepSetNumber1
    MODULE PROCEDURE CMISSSolverNewtonLineSearchMaxStepSetObj
  END INTERFACE !CMISSSolverNewtonLineSearchMaxStepSet
  
  !>Sets/changes the line search step tolerance for a nonlinear Newton solver.
  INTERFACE CMISSSolverNewtonLineSearchStepTolSet
    MODULE PROCEDURE CMISSSolverNewtonLineSearchStepTolSetNumber0
    MODULE PROCEDURE CMISSSolverNewtonLineSearchStepTolSetNumber1
    MODULE PROCEDURE CMISSSolverNewtonLineSearchStepTolSetObj
  END INTERFACE !CMISSSolverNewtonLineSearchStepTolSet
  
  !>Sets/changes the type of line search for a nonlinear Newton solver.
  INTERFACE CMISSSolverNewtonLineSearchTypeSet
    MODULE PROCEDURE CMISSSolverNewtonLineSearchTypeSetNumber0
    MODULE PROCEDURE CMISSSolverNewtonLineSearchTypeSetNumber1
    MODULE PROCEDURE CMISSSolverNewtonLineSearchTypeSetObj
  END INTERFACE !CMISSSolverNewtonLineSearchTypeSet
  
  !>Sets/changes the maximum number of function evaluations for a nonlinear Newton solver.
  INTERFACE CMISSSolverNewtonMaximumFunctionEvaluationsSet
    MODULE PROCEDURE CMISSSolverNewtonMaximumFunctionEvaluationsSetNumber0
    MODULE PROCEDURE CMISSSolverNewtonMaximumFunctionEvaluationsSetNumber1
    MODULE PROCEDURE CMISSSolverNewtonMaximumFunctionEvaluationsSetObj
  END INTERFACE !CMISSSolverNewtonMaximumFunctionEvaluationsSet
  
  !>Sets/changes the maximum number of iterations for a nonlinear Newton solver.
  INTERFACE CMISSSolverNewtonMaximumIterationsSet
    MODULE PROCEDURE CMISSSolverNewtonMaximumIterationsSetNumber0
    MODULE PROCEDURE CMISSSolverNewtonMaximumIterationsSetNumber1
    MODULE PROCEDURE CMISSSolverNewtonMaximumIterationsSetObj
  END INTERFACE !CMISSSolverNewtonMaximumIterationsSet
  
  !>Sets/changes the relative tolerance for a nonlinear Newton solver.
  INTERFACE CMISSSolverNewtonRelativeToleranceSet
    MODULE PROCEDURE CMISSSolverNewtonRelativeToleranceSetNumber0
    MODULE PROCEDURE CMISSSolverNewtonRelativeToleranceSetNumber1
    MODULE PROCEDURE CMISSSolverNewtonRelativeToleranceSetObj
  END INTERFACE !CMISSSolverNewtonRelativeToleranceSet
  
  !>Sets/changes the solution tolerance for a nonlinear Newton solver.
  INTERFACE CMISSSolverNewtonSolutionToleranceSet
    MODULE PROCEDURE CMISSSolverNewtonSolutionToleranceSetNumber0
    MODULE PROCEDURE CMISSSolverNewtonSolutionToleranceSetNumber1
    MODULE PROCEDURE CMISSSolverNewtonSolutionToleranceSetObj
  END INTERFACE !CMISSSolverNewtonSolutionToleranceSet
  
  !>Sets/changes the trust region delta0 tolerance for a nonlinear Newton trust region solver.
  INTERFACE CMISSSolverNewtonTrustRegionDelta0Set
    MODULE PROCEDURE CMISSSolverNewtonTrustRegionDelta0SetNumber0
    MODULE PROCEDURE CMISSSolverNewtonTrustRegionDelta0SetNumber1
    MODULE PROCEDURE CMISSSolverNewtonTrustRegionDelta0SetObj
  END INTERFACE !CMISSSolverNewtonTrustRegionDelta0Set
  
  !>Sets/changes the trust region tolerance for a nonlinear Newton trust region solver.
  INTERFACE CMISSSolverNewtonTrustRegionToleranceSet
    MODULE PROCEDURE CMISSSolverNewtonTrustRegionToleranceSetNumber0
    MODULE PROCEDURE CMISSSolverNewtonTrustRegionToleranceSetNumber1
    MODULE PROCEDURE CMISSSolverNewtonTrustRegionToleranceSetObj
  END INTERFACE !CMISSSolverNewtonTrustRegionToleranceSet
  
  !>Sets/changes the type of nonlinear Newton trust region solver.
  INTERFACE CMISSSolverNewtonTypeSet
    MODULE PROCEDURE CMISSSolverNewtonTypeSetNumber0
    MODULE PROCEDURE CMISSSolverNewtonTypeSetNumber1
    MODULE PROCEDURE CMISSSolverNewtonTypeSetObj
  END INTERFACE !CMISSSolverNewtonTypeSet
  
  !>Sets/changes the type of nonlinear solver.
  INTERFACE CMISSSolverNonlinearTypeSet
    MODULE PROCEDURE CMISSSolverNonlinearTypeSetNumber0
    MODULE PROCEDURE CMISSSolverNonlinearTypeSetNumber1
    MODULE PROCEDURE CMISSSolverNonlinearTypeSetObj
  END INTERFACE !CMISSSolverNonlinearTypeSet
  
  !>Sets/changes the output type for a solver.
  INTERFACE CMISSSolverOutputTypeSet
    MODULE PROCEDURE CMISSSolverOutputTypeSetNumber0
    MODULE PROCEDURE CMISSSolverOutputTypeSetNumber1
    MODULE PROCEDURE CMISSSolverOutputTypeSetObj
  END INTERFACE !CMISSSolverOutputTypeSet
  
  !>Returns the solver equations for a solver.
  INTERFACE CMISSSolverSolverEquationsGet
    MODULE PROCEDURE CMISSSolverSolverEquationsGetNumber0
    MODULE PROCEDURE CMISSSolverSolverEquationsGetNumber1
    MODULE PROCEDURE CMISSSolverSolverEquationsGetObj
  END INTERFACE !CMISSSolverSolverEquationsGet
  
  !>Adds equations sets to solver equations.
  INTERFACE CMISSSolverEquationsEquationsSetAdd
    MODULE PROCEDURE CMISSSolverEquationsEquationsSetAddNumber0
    MODULE PROCEDURE CMISSSolverEquationsEquationsSetAddNumber1
    MODULE PROCEDURE CMISSSolverEquationsEquationsSetAddObj
  END INTERFACE !CMISSSolverEquationsEquationsSetAdd
  
  !>Sets/changes the sparsity type for solver equations.
  INTERFACE CMISSSolverEquationsSparsityTypeSet
    MODULE PROCEDURE CMISSSolverEquationsSparsityTypeSetNumber0
    MODULE PROCEDURE CMISSSolverEquationsSparsityTypeSetNumber1
    MODULE PROCEDURE CMISSSolverEquationsSparsityTypeSetObj
  END INTERFACE !CMISSSolverEquationsSparsityTypeSet

  
  PUBLIC CMISSSolverLinearType,CMISSSolverNonlinearType,CMISSSolverDynamicType,CMISSSolverDAEType,CMISSSolverEigenproblemType, &
    & CMISSSolverOptimiserType

  PUBLIC CMISSSolverCMISSLibrary,CMISSSolverPETScLibrary,CMISSSolverMUMPSLibrary

  PUBLIC CMISSSolverLinearDirectSolveType,CMISSSolverLinearIterativeSolveType

  PUBLIC CMISSSolverIterativeRichardson,CMISSSolverIterativeChebychev,CMISSSolverIterativeConjugateGradient, &
    & CMISSSolverIterativeBiconjugateGradient,CMISSSolverIterativeGMRES,CMISSSolverIterativeBiCGSTAB,CMISSSolverConjgradSquared

  PUBLIC CMISSSolverIterativeNoPreconditioner,CMISSSolverIterativeJacobiPreconditioner, &
    & CMISSSolverIterativeBlockJacobiPreconditioner,CMISSSolverIterativeSORPreconditioner, &
    & CMISSSolverIterativeIncompleteCholeskyPreconditioner,CMISSSolverIterativeIncompleteLUPreconditioner, &
    & CMISSSolverIterativeAdditiveSchwarzPreconditioner

  PUBLIC CMISSSolverNonlinearNewton,CMISSSolverNonlinearBFGSInverse,CMISSSolverNonlinearSQP

  PUBLIC CMISSSolverNewtonLinesearch,CMISSSolverNewtonTrustregion

  PUBLIC CMISSSolverNewtonLinesearchNoNorms,CMISSSolverNewtonLinesearchNone,CMISSSolverNewtonLinesearchQuadratic, &
    & CMISSSolverNewtonLinesearchCubic

  PUBLIC CMISSSolverNewtonJacobianNotCaclulated,CMISSSolverNewtonJacobianAnalyticCalculated, &
    & CMISSSolverNewtonJacobianFDCalculated

  PUBLIC CMISSSolverDynamicFirstOrder,CMISSSolverDynamicSecondOrder

  PUBLIC CMISSSolverDynamicLinear,CMISSSolverDynamicNonlinear

  PUBLIC CMISSSolverDynamicFirstDegree,CMISSSolverDynamicSecondDegree,CMISSSolverDynamicThirdDegree

  PUBLIC CMISSSolverDynamicEulerScheme,CMISSSolverDynamicBackwardEulerScheme,CMISSSolverDynamicCrankNicholsonScheme, &
    & CMISSSolverDynamicGalerkinScheme,CMISSSolverDynamicZlamalScheme,CMISSSolverDynamicSecondDegreeGearScheme, &
    & CMISSSolverDynamicSecondDegreeLiniger1Scheme,CMISSSolverDynamicSecondDegreeLiniger2Scheme, &
    & CMISSSolverDynamicNewmark1Scheme,CMISSSolverDynamicNewmark2Scheme,CMISSSolverDynamicNewmark3Scheme, &
    & CMISSSolverDynamicThirdDegreeGearScheme,CMISSSolverDynamicThirdDegreeLiniger1Scheme, &
    & CMISSSolverDynamicThirdDegreeLiniger2Scheme,CMISSSolverDynamicHouboltScheme,CMISSSolverDynamicWilsonScheme, &
    & CMISSSolverDynamicBossakNewmark1Scheme,CMISSSolverDynamicBossakNewmark2Scheme,CMISSSolverDynamicHilbertHughesTaylor1Scheme, &
    & CMISSSolverDynamicHilbertHughesTaylor2Scheme,CMISSSolverDynamicUserDefinedScheme

  PUBLIC CMISSSolverDAEDifferentialOnly,CMISSSolverDAEIndex1,CMISSSolverDAEIndex2,CMISSSolverDAEIndex3

  PUBLIC CMISSSolverDAEEuler,CMISSSolverDAECrankNicholson,CMISSSolverDAERungeKutta,CMISSSolverDAEAdamsMoulton,CMISSSolverDAEBDF, &
    & CMISSSolverRushLarson

  PUBLIC CMISSSolverDAEEulerForward,CMISSSolverDAEEulerBackward,CMISSSolverDAEEulerImproved

  PUBLIC CMISSSolverSolutionInitialiseZero,CMISSSolverSolutionInitialiseCurrentField,CMISSSolverSolutionInitialiseNoChange

  PUBLIC CMISSSolverNoOutput,CMISSSolverProgressOutput,CMISSSolverTimingOutput,CMISSSolverSolverOutput,CMISSSolverSolverMatrixOutput

  PUBLIC CMISSSolverEquationsSparseMatrices,CMISSSolverEquationsFullMatrices

  PUBLIC CMISSSolverDAEEulerSolverTypeGet, CMISSSolverDAEEulerSolverTypeSet

  PUBLIC CMISSSolverDAESolverTypeGet,CMISSSolverDAESolverTypeSet

  PUBLIC CMISSSolverDAETimesSet

  PUBLIC CMISSSolverDynamicDegreeGet,CMISSSolverDynamicDegreeSet

  PUBLIC CMISSSolverDynamicLinearityTypeGet

  PUBLIC CMISSSolverDynamicLinearSolverGet,CMISSSolverDynamicNonlinearSolverGet

  PUBLIC CMISSSolverDynamicSchemeSet

  PUBLIC CMISSSolverDynamicThetaSet

  PUBLIC CMISSSolverDynamicTimesSet

  PUBLIC CMISSSolverLibraryTypeGet,CMISSSolverLibraryTypeSet

  PUBLIC CMISSSolverLinearDirectTypeSet

  PUBLIC CMISSSolverLinearIterativeAbsoluteToleranceSet

  PUBLIC CMISSSolverLinearIterativeDivergenceToleranceSet

  PUBLIC CMISSSolverLinearIterativeGMRESRestartSet

  PUBLIC CMISSSolverLinearIterativeMaximumIterationsSet

  PUBLIC CMISSSolverLinearIterativePreconditionerTypeSet

  PUBLIC CMISSSolverLinearIterativeRelativeToleranceSet

  PUBLIC CMISSSolverLinearIterativeTypeSet

  PUBLIC CMISSSolverLinearTypeSet

  PUBLIC CMISSSolverNewtonAbsoluteToleranceSet

  PUBLIC CMISSSolverNewtonJacobianCalculationTypeSet

  PUBLIC CMISSSolverNewtonLinearSolverGet

  PUBLIC CMISSSolverNewtonLineSearchAlphaSet

  PUBLIC CMISSSolverNewtonLineSearchMaxStepSet

  PUBLIC CMISSSolverNewtonLineSearchStepTolSet

  PUBLIC CMISSSolverNewtonLineSearchTypeSet

  PUBLIC CMISSSolverNewtonMaximumFunctionEvaluationsSet

  PUBLIC CMISSSolverNewtonMaximumIterationsSet

  PUBLIC CMISSSolverNewtonRelativeToleranceSet

  PUBLIC CMISSSolverNewtonSolutionToleranceSet

  PUBLIC CMISSSolverNewtonTrustRegionDelta0Set

  PUBLIC CMISSSolverNewtonTrustRegionToleranceSet

  PUBLIC CMISSSolverNewtonTypeSet

  PUBLIC CMISSSolverNonlinearTypeSet

  PUBLIC CMISSSolverOutputTypeSet

  PUBLIC CMISSSolverSolverEquationsGet

  PUBLIC CMISSSolverEquationsEquationsSetAdd

  PUBLIC CMISSSolverEquationsSparsityTypeSet

  
  
!!
!!==================================================================================================================================
!!
  
CONTAINS

  !
  !================================================================================================================================
  !
  

  !>Finalises CMISS.
  SUBROUTINE CMISSFinalise(Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL CMISS_FINALISE(Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('OpenCMISS World Phase')
#endif

    RETURN
999 CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFinalise

  !
  !================================================================================================================================
  !

  !>Finalises CMISS for C.
  FUNCTION CMISSFinaliseC() BIND(C,NAME="CMISS_Finalise")
  
    !Argument variables
    !Function variable
    INTEGER(C_INT) :: CMISSFinaliseC
    !Local variables

    CALL CMISSFinalise(CMISSFinaliseC)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('OpenCMISS World Phase')
#endif

    RETURN
    
  END FUNCTION CMISSFinaliseC

  !
  !================================================================================================================================
  !
  
  !>Initialises CMISS returning a user number to the world coordinate system and region.
  SUBROUTINE CMISSInitialiseNumber(WorldCoordinateSystemUserNumber,WorldRegionUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: WorldCoordinateSystemUserNumber !<On return, the world coordinate system user number.
    INTEGER(INTG), INTENT(OUT) :: WorldRegionUserNumber !<On return, the world region user number.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: WORLD_COORDINATE_SYSTEM
    TYPE(REGION_TYPE), POINTER :: WORLD_REGION

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('OpenCMISS World Phase')
#endif

    NULLIFY(WORLD_COORDINATE_SYSTEM)
    NULLIFY(WORLD_REGION)
    CALL CMISS_Initialise(WORLD_REGION,Err,ERROR,*999)
    !CALL CMISS_Initialise(WORLD_COORDINATE_SYSTEM,WORLD_REGION,Err,ERROR,*999)
    WorldCoordinateSystemUserNumber=0
    !WorldCoordinateUserNumber=WORLD_COORDINATE_SYSTEM%USER_NUMBER
    WorldRegionUserNumber=WORLD_REGION%USER_NUMBER

    RETURN
999 CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSInitialiseNumber

  !
  !================================================================================================================================
  !
  
  !>Initialises CMISS returning a pointer to the world coordinate system and region.
  SUBROUTINE CMISSInitialiseObj(WorldCoordinateSystem,WorldRegion,Err)
  
    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT) :: WorldCoordinateSystem !<On return, the world coordinate system.
    TYPE(CMISSRegionType), INTENT(INOUT) :: WorldRegion !<On return, the world region.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('OpenCMISS World Phase')
#endif

    CALL CMISSCoordinateSystemTypeInitialise(WorldCoordinateSystem,Err)
    CALL CMISSRegionTypeInitialise(WorldRegion,Err)
    CALL CMISS_INITIALISE(WorldRegion%REGION,Err,ERROR,*999)
    !CALL CMISS_Initialise(WorldCoordinateSystem%COORDINATE_SYSTEM,WorldRegion%REGION,Err,ERROR,*999)

    RETURN
999 CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSInitialiseObj

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSBasisType object.
  SUBROUTINE CMISSBasisTypeFinalise(CMISSBasis,Err)
  
    !Argument variables
    TYPE(CMISSBasisType), INTENT(OUT) :: CMISSBasis !<The CMISSBasisType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisTypeFinalise",Err,ERROR,*999)
    
    IF(ASSOCIATED(CMISSBasis%BASIS)) CALL BASIS_DESTROY(CMISSBasis%BASIS,Err,ERROR,*999)

    CALL EXITS("CMISSBasisTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSBasisTypeFinalise",Err,ERROR)
    CALL EXITS("CMISSBasisTypeFinalise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisTypeFinalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSBasisType object.
  SUBROUTINE CMISSBasisTypeInitialise(CMISSBasis,Err)
  
    !Argument variables
    TYPE(CMISSBasisType), INTENT(OUT) :: CMISSBasis !<The CMISSBasisType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    
    CALL ENTERS("CMISSBasisTypeInitialise",Err,ERROR,*999)

    NULLIFY(CMISSBasis%BASIS)

    CALL EXITS("CMISSBasisTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSBasisTypeInitialise",Err,ERROR)
    CALL EXITS("CMISSBasisTypeInitialise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSBoundaryConditionsType object.
  SUBROUTINE CMISSBoundaryConditionsTypeFinalise(CMISSBoundaryConditions,Err)
  
    !Argument variables
    TYPE(CMISSBoundaryConditionsType), INTENT(OUT) :: CMISSBoundaryConditions !<The CMISSBoundaryConditionsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    
    CALL ENTERS("CMISSBoundaryConditionsTypeFinalise",Err,ERROR,*999)
    
    IF(ASSOCIATED(CMISSBoundaryConditions%BOUNDARY_CONDITIONS))  &
      & CALL BOUNDARY_CONDITIONS_DESTROY(CMISSBoundaryConditions%BOUNDARY_CONDITIONS,Err,ERROR,*999)

    CALL EXITS("CMISSBoundaryConditionsTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsTypeFinalise",Err,ERROR)
    CALL EXITS("CMISSBoundaryConditionsTypeFinalise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBoundaryConditionsTypeFinalise
  !
  !================================================================================================================================
  !

  !>Initialises a CMISSBoundaryConditionsType object.
  SUBROUTINE CMISSBoundaryConditionsTypeInitialise(CMISSBoundaryConditions,Err)
  
    !Argument variables
    TYPE(CMISSBoundaryConditionsType), INTENT(OUT) :: CMISSBoundaryConditions !<The CMISSBoundaryConditionsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBoundaryConditionsTypeInitialise",Err,ERROR,*999)
    
    NULLIFY(CMISSBoundaryConditions%BOUNDARY_CONDITIONS)

    CALL EXITS("CMISSBoundaryConditionsTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsTypeInitialise",Err,ERROR)
    CALL EXITS("CMISSBoundaryConditionsTypeInitialise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBoundaryConditionsTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSCellMLType object.
  SUBROUTINE CMISSCellMLTypeFinalise(CMISSCellML,Err)
  
    !Argument variables
    TYPE(CMISSCellMLType), INTENT(OUT) :: CMISSCellML !<The CMISSCellMLType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    
    CALL ENTERS("CMISSCellMLTypeFinalise",Err,ERROR,*999)
    
    IF(ASSOCIATED(CMISSCellML%CELLML))  &
      & CALL CELLML_DESTROY(CMISSCellML%CELLML,Err,ERROR,*999)

    CALL EXITS("CMISSCellMLTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSCellMLTypeFinalise",Err,ERROR)
    CALL EXITS("CMISSCellMLTypeFinalise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLTypeFinalise
  !
  !================================================================================================================================
  !

  !>Initialises a CMISSCellMLType object.
  SUBROUTINE CMISSCellMLTypeInitialise(CMISSCellML,Err)
  
    !Argument variables
    TYPE(CMISSCellMLType), INTENT(OUT) :: CMISSCellML !<The CMISSCellMLType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLTypeInitialise",Err,ERROR,*999)
    
    NULLIFY(CMISSCellML%CELLML)

    CALL EXITS("CMISSCellMLTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSCellMLTypeInitialise",Err,ERROR)
    CALL EXITS("CMISSCellMLTypeInitialise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSControlLoopType object.
  SUBROUTINE CMISSControlLoopTypeFinalise(CMISSControlLoop,Err)
  
    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(OUT) :: CMISSControlLoop !<The CMISSControlLoopType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    
    CALL ENTERS("CMISSControlLoopTypeFinalise",Err,ERROR,*999)
    
    IF(ASSOCIATED(CMISSControlLoop%CONTROL_LOOP))  &
      & CALL CONTROL_LOOP_DESTROY(CMISSControlLoop%CONTROL_LOOP,Err,ERROR,*999)

    CALL EXITS("CMISSControlLoopTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSControlLoopTypeFinalise",Err,ERROR)
    CALL EXITS("CMISSControlLoopTypeFinalise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopTypeFinalise
  !
  !================================================================================================================================
  !

  !>Initialises a CMISSControlLoopType object.
  SUBROUTINE CMISSControlLoopTypeInitialise(CMISSControlLoop,Err)
  
    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(OUT) :: CMISSControlLoop !<The CMISSControlLoopType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopTypeInitialise",Err,ERROR,*999)
    
    NULLIFY(CMISSControlLoop%CONTROL_LOOP)

    CALL EXITS("CMISSControlLoopTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSControlLoopTypeInitialise",Err,ERROR)
    CALL EXITS("CMISSControlLoopTypeInitialise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSCoordinateSystemType object.
  SUBROUTINE CMISSCoordinateSystemTypeFinalise(CMISSCoordinateSystem,Err)
  
    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(OUT) :: CMISSCoordinateSystem !<The CMISSCoordinateSystemType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    
    CALL ENTERS("CMISSCoordinateSystemTypeFinalise",Err,ERROR,*999)
    
    IF(ASSOCIATED(CMISSCoordinateSystem%COORDINATE_SYSTEM))  &
      & CALL COORDINATE_SYSTEM_DESTROY(CMISSCoordinateSystem%COORDINATE_SYSTEM,Err,ERROR,*999)

    CALL EXITS("CMISSCoordinateSystemTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemTypeFinalise",Err,ERROR)
    CALL EXITS("CMISSCoordinateSystemTypeFinalise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCoordinateSystemTypeFinalise
  !
  !================================================================================================================================
  !

  !>Initialises a CMISSCoordinateSystemType object.
  SUBROUTINE CMISSCoordinateSystemTypeInitialise(CMISSCoordinateSystem,Err)
  
    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(OUT) :: CMISSCoordinateSystem !<The CMISSCoordinateSystemType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables


    CALL ENTERS("CMISSCoordinateSystemTypeInitialise",Err,ERROR,*999)
    
    NULLIFY(CMISSCoordinateSystem%COORDINATE_SYSTEM)

    CALL EXITS("CMISSCoordinateSystemTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemTypeInitialise",Err,ERROR)
    CALL EXITS("CMISSCoordinateSystemTypeInitialise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCoordinateSystemTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSDecompositionType object.
  SUBROUTINE CMISSDecompositionTypeFinalise(CMISSDecomposition,Err)
  
    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(OUT) :: CMISSDecomposition !<The CMISSDecompositionType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    
    CALL ENTERS("CMISSDecompositionTypeFinalise",Err,ERROR,*999)
    
    IF(ASSOCIATED(CMISSDecomposition%DECOMPOSITION))  &
      & CALL DECOMPOSITION_DESTROY(CMISSDecomposition%DECOMPOSITION,Err,ERROR,*999)

    CALL EXITS("CMISSDecompositionTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSDecompositionTypeFinalise",Err,ERROR)
    CALL EXITS("CMISSDecompositionTypeFinalise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSDecompositionTypeFinalise
  
  !
  !================================================================================================================================
  !

  !>Initialises a CMISSDecompositionType object.
  SUBROUTINE CMISSDecompositionTypeInitialise(CMISSDecomposition,Err)
  
    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(OUT) :: CMISSDecomposition !<The CMISSDecompositionType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecompositionTypeInitialise",Err,ERROR,*999)
    
    NULLIFY(CMISSDecomposition%DECOMPOSITION)

    CALL EXITS("CMISSDecompositionTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSDecompositionTypeInitialise",Err,ERROR)
    CALL EXITS("CMISSDecompositionTypeInitialise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSDecompositionTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSEquationsType object.
  SUBROUTINE CMISSEquationsTypeFinalise(CMISSEquations,Err)
  
    !Argument variables
    TYPE(CMISSEquationsType), INTENT(OUT) :: CMISSEquations !<The CMISSEquationsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    
    CALL ENTERS("CMISSEquationsTypeFinalise",Err,ERROR,*999)
    
    IF(ASSOCIATED(CMISSEquations%EQUATIONS))  &
      & CALL EQUATIONS_DESTROY(CMISSEquations%EQUATIONS,Err,ERROR,*999)

    CALL EXITS("CMISSEquationsTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSEquationsTypeFinalise",Err,ERROR)
    CALL EXITS("CMISSEquationsTypeFinalise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsTypeFinalise
  
  !
  !================================================================================================================================
  !

  !>Initialises a CMISSEquationsType object.
  SUBROUTINE CMISSEquationsTypeInitialise(CMISSEquations,Err)
  
    !Argument variables
    TYPE(CMISSEquationsType), INTENT(OUT) :: CMISSEquations !<The CMISSEquationsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsTypeInitialise",Err,ERROR,*999)
    
    NULLIFY(CMISSEquations%EQUATIONS)

    CALL EXITS("CMISSEquationsTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSEquationsTypeInitialise",Err,ERROR)
    CALL EXITS("CMISSEquationsTypeInitialise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSEquationsSetType object.
  SUBROUTINE CMISSEquationsSetTypeFinalise(CMISSEquationsSet,Err)
  
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(OUT) :: CMISSEquationsSet !<The CMISSEquationsSetType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    
    CALL ENTERS("CMISSEquationsSetTypeFinalise",Err,ERROR,*999)
    
    IF(ASSOCIATED(CMISSEquationsSet%EQUATIONS_SET))  &
      & CALL EQUATIONS_SET_DESTROY(CMISSEquationsSet%EQUATIONS_SET,Err,ERROR,*999)

    CALL EXITS("CMISSEquationsSetTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSEquationsSetTypeFinalise",Err,ERROR)
    CALL EXITS("CMISSEquationsSetTypeFinalise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetTypeFinalise
  
  !
  !================================================================================================================================
  !

  !>Initialises a CMISSEquationsSetType object.
  SUBROUTINE CMISSEquationsSetTypeInitialise(CMISSEquationsSet,Err)
  
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(OUT) :: CMISSEquationsSet !<The CMISSEquationsSetType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetTypeInitialise",Err,ERROR,*999)
    
    NULLIFY(CMISSEquationsSet%EQUATIONS_SET)

    CALL EXITS("CMISSEquationsSetTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSEquationsSetTypeInitialise",Err,ERROR)
    CALL EXITS("CMISSEquationsSetTypeInitialise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSFieldType object.
  SUBROUTINE CMISSFieldTypeFinalise(CMISSField,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(OUT) :: CMISSField !<The CMISSFieldType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    
    CALL ENTERS("CMISSFieldTypeFinalise",Err,ERROR,*999)
    
    IF(ASSOCIATED(CMISSField%FIELD))  &
      & CALL FIELD_DESTROY(CMISSField%FIELD,Err,ERROR,*999)

    CALL EXITS("CMISSFieldTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSFieldTypeFinalise",Err,ERROR)
    CALL EXITS("CMISSFieldTypeFinalise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldTypeFinalise
  
  !
  !================================================================================================================================
  !

  !>Initialises a CMISSFieldType object.
  SUBROUTINE CMISSFieldTypeInitialise(CMISSField,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(OUT) :: CMISSField !<The CMISSFieldType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldTypeInitialise",Err,ERROR,*999)
    
    NULLIFY(CMISSField%FIELD)

    CALL EXITS("CMISSFieldTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSFieldTypeInitialise",Err,ERROR)
    CALL EXITS("CMISSFieldTypeInitialise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldTypeInitialise

  !
  !================================================================================================================================
  !

  !>Creates a CMISSFieldsType object for an object reference.
  SUBROUTINE CMISSFieldsTypeCreate(Region,Fields,Err)
  
    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: Region !<The region to get the fields from
    TYPE(CMISSFieldsType), INTENT(INOUT) :: Fields !<On return, the fields attached to the specified region. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldsTypeCreate",Err,ERROR,*999)

    IF(ASSOCIATED(Region%REGION)) THEN
      IF(ASSOCIATED(Fields%FIELDS)) THEN
        CALL FLAG_ERROR("Fields is already associated.",ERR,ERROR,*999)
      ELSE
        Fields%FIELDS=>Region%REGION%FIELDS
      ENDIF
    ELSE
      CALL FLAG_ERROR("The region is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldsTypeCreate")
    RETURN
999 CALL ERRORS("CMISSFieldsTypeCreate",Err,ERROR)
    CALL EXITS("CMISSFieldsTypeCreate")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldsTypeCreate

   !
  !================================================================================================================================
  !

  !>Finalises a CMISSFieldsType object.
  SUBROUTINE CMISSFieldsTypeFinalise(CMISSFields,Err)
  
    !Argument variables
    TYPE(CMISSFieldsType), INTENT(OUT) :: CMISSFields !<The CMISSFieldsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    
    CALL ENTERS("CMISSFieldsTypeFinalise",Err,ERROR,*999)
    
    NULLIFY(CMISSFields%FIELDS)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Fields Type')
#endif

    CALL EXITS("CMISSFieldsTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSFieldsTypeFinalise",Err,ERROR)
    CALL EXITS("CMISSFieldsTypeFinalise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldsTypeFinalise
  
  !
  !================================================================================================================================
  !

  !>Initialises a CMISSFieldsType object.
  SUBROUTINE CMISSFieldsTypeInitialise(CMISSFields,Err)
  
    !Argument variables
    TYPE(CMISSFieldsType), INTENT(OUT) :: CMISSFields !<The CMISSFieldsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldsTypeInitialise",Err,ERROR,*999)
    
#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Fields Type')
#endif

    NULLIFY(CMISSFields%FIELDS)

    CALL EXITS("CMISSFieldsTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSFieldsTypeInitialise",Err,ERROR)
    CALL EXITS("CMISSFieldsTypeInitialise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldsTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSGeneratedMeshType object.
  SUBROUTINE CMISSGeneratedMeshTypeFinalise(CMISSGeneratedMesh,Err)
  
    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(OUT) :: CMISSGeneratedMesh !<The CMISSGeneratedMeshType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    
    CALL ENTERS("CMISSGeneratedMeshTypeFinalise",Err,ERROR,*999)
    
    IF(ASSOCIATED(CMISSGeneratedMesh%GENERATED_MESH))  &
      & CALL GENERATED_MESH_DESTROY(CMISSGeneratedMesh%GENERATED_MESH,Err,ERROR,*999)

    CALL EXITS("CMISSGeneratedMeshTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshTypeFinalise",Err,ERROR)
    CALL EXITS("CMISSGeneratedMeshTypeFinalise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSGeneratedMeshTypeFinalise
  
  !
  !================================================================================================================================
  !

  !>Initialises a CMISSGeneratedMeshType object.
  SUBROUTINE CMISSGeneratedMeshTypeInitialise(CMISSGeneratedMesh,Err)
  
    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(OUT) :: CMISSGeneratedMesh !<The CMISSGeneratedMeshType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMeshTypeInitialise",Err,ERROR,*999)
    
    NULLIFY(CMISSGeneratedMesh%GENERATED_MESH)

    CALL EXITS("CMISSGeneratedMeshTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshTypeInitialise",Err,ERROR)
    CALL EXITS("CMISSGeneratedMeshTypeInitialise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSGeneratedMeshTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSHistoryType object.
  SUBROUTINE CMISSHistoryTypeFinalise(CMISSHistory,Err)
  
    !Argument variables
    TYPE(CMISSHistoryType), INTENT(OUT) :: CMISSHistory !<The CMISSHistoryType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    
    CALL ENTERS("CMISSHistoryTypeFinalise",Err,ERROR,*999)
    
    IF(ASSOCIATED(CMISSHistory%HISTORY))  &
      & CALL HISTORY_DESTROY(CMISSHistory%HISTORY,Err,ERROR,*999)

    CALL EXITS("CMISSHistoryTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSHistoryTypeFinalise",Err,ERROR)
    CALL EXITS("CMISSHistoryTypeFinalise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSHistoryTypeFinalise
  
  !
  !================================================================================================================================
  !

  !>Initialises a CMISSHistoryType object.
  SUBROUTINE CMISSHistoryTypeInitialise(CMISSHistory,Err)
  
    !Argument variables
    TYPE(CMISSHistoryType), INTENT(OUT) :: CMISSHistory !<The CMISSHistoryType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSHistoryTypeInitialise",Err,ERROR,*999)
    
    NULLIFY(CMISSHistory%HISTORY)

    CALL EXITS("CMISSHistoryTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSHistoryTypeInitialise",Err,ERROR)
    CALL EXITS("CMISSHistoryTypeInitialise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSHistoryTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSMeshType object.
  SUBROUTINE CMISSMeshTypeFinalise(CMISSMesh,Err)
  
    !Argument variables
    TYPE(CMISSMeshType), INTENT(OUT) :: CMISSMesh !<The CMISSMeshType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    
    CALL ENTERS("CMISSMeshTypeFinalise",Err,ERROR,*999)
    
    IF(ASSOCIATED(CMISSMesh%MESH))  &
      & CALL MESH_DESTROY(CMISSMesh%MESH,Err,ERROR,*999)

    CALL EXITS("CMISSMeshTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSMeshTypeFinalise",Err,ERROR)
    CALL EXITS("CMISSMeshTypeFinalise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshTypeFinalise
  
  !
  !================================================================================================================================
  !

  !>Initialises a CMISSMeshType object.
  SUBROUTINE CMISSMeshTypeInitialise(CMISSMesh,Err)
  
    !Argument variables
    TYPE(CMISSMeshType), INTENT(OUT) :: CMISSMesh !<The CMISSMeshType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshTypeInitialise",Err,ERROR,*999)
    
    NULLIFY(CMISSMesh%MESH)

    CALL EXITS("CMISSMeshTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSMeshTypeInitialise",Err,ERROR)
    CALL EXITS("CMISSMeshTypeInitialise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSMeshElementsType object.
  SUBROUTINE CMISSMeshElementsTypeFinalise(CMISSMeshElements,Err)
  
    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(OUT) :: CMISSMeshElements !<The CMISSMeshElementsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    
    CALL ENTERS("CMISSMeshElementsTypeFinalise",Err,ERROR,*999)
    
    IF(ASSOCIATED(CMISSMeshElements%MESH_ELEMENTS))  &
      & CALL MESH_TOPOLOGY_ELEMENTS_DESTROY(CMISSMeshElements%MESH_ELEMENTS,Err,ERROR,*999)

    CALL EXITS("CMISSMeshElementsTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSMeshElementsTypeFinalise",Err,ERROR)
    CALL EXITS("CMISSMeshElementsTypeFinalise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshElementsTypeFinalise
  
  !
  !================================================================================================================================
  !

  !>Initialises a CMISSMeshElementsType object.
  SUBROUTINE CMISSMeshElementsTypeInitialise(CMISSMeshElements,Err)
  
    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(OUT) :: CMISSMeshElements !<The CMISSMeshElementsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshElementsTypeInitialise",Err,ERROR,*999)
    
    NULLIFY(CMISSMeshElements%MESH_ELEMENTS)

    CALL EXITS("CMISSMeshElementsTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSMeshElementsTypeInitialise",Err,ERROR)
    CALL EXITS("CMISSMeshElementsTypeInitialise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshElementsTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSNodesType object.
  SUBROUTINE CMISSNodesTypeFinalise(CMISSNodes,Err)
  
    !Argument variables
    TYPE(CMISSNodesType), INTENT(OUT) :: CMISSNodes !<The CMISSNodesType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    
    CALL ENTERS("CMISSNodesTypeFinalise",Err,ERROR,*999)
    
    IF(ASSOCIATED(CMISSNodes%NODES))  &
      & CALL NODES_DESTROY(CMISSNodes%NODES,Err,ERROR,*999)

    CALL EXITS("CMISSNodesTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSNodesTypeFinalise",Err,ERROR)
    CALL EXITS("CMISSNodesTypeFinalise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSNodesTypeFinalise
  
  !
  !================================================================================================================================
  !

  !>Initialises a CMISSNodesType object.
  SUBROUTINE CMISSNodesTypeInitialise(CMISSNodes,Err)
  
    !Argument variables
    TYPE(CMISSNodesType), INTENT(OUT) :: CMISSNodes !<The CMISSNodesType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSNodesTypeInitialise",Err,ERROR,*999)
    
    NULLIFY(CMISSNodes%NODES)

    CALL EXITS("CMISSNodesTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSNodesTypeInitialise",Err,ERROR)
    CALL EXITS("CMISSNodesTypeInitialise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSNodesTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSProblemType object.
  SUBROUTINE CMISSProblemTypeFinalise(CMISSProblem,Err)
  
    !Argument variables
    TYPE(CMISSProblemType), INTENT(OUT) :: CMISSProblem !<The CMISSProblemType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    
    CALL ENTERS("CMISSProblemTypeFinalise",Err,ERROR,*999)
    
    IF(ASSOCIATED(CMISSProblem%PROBLEM))  &
      & CALL PROBLEM_DESTROY(CMISSProblem%PROBLEM,Err,ERROR,*999)

    CALL EXITS("CMISSProblemTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSProblemTypeFinalise",Err,ERROR)
    CALL EXITS("CMISSProblemTypeFinalise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemTypeFinalise
  
  !
  !================================================================================================================================
  !

  !>Initialises a CMISSProblemType object.
  SUBROUTINE CMISSProblemTypeInitialise(CMISSProblem,Err)
  
    !Argument variables
    TYPE(CMISSProblemType), INTENT(OUT) :: CMISSProblem !<The CMISSProblemType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemTypeInitialise",Err,ERROR,*999)
    
    NULLIFY(CMISSProblem%PROBLEM)

    CALL EXITS("CMISSProblemTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSProblemTypeInitialise",Err,ERROR)
    CALL EXITS("CMISSProblemTypeInitialise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSQuadratureType object.
  SUBROUTINE CMISSQuadratureTypeFinalise(CMISSQuadrature,Err)
  
    !Argument variables
    TYPE(CMISSQuadratureType), INTENT(OUT) :: CMISSQuadrature !<The CMISSQuadratureType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    
    CALL ENTERS("CMISSQuadratureTypeFinalise",Err,ERROR,*999)
    
    IF(ASSOCIATED(CMISSQuadrature%QUADRATURE))  &
      & CALL BASIS_QUADRATURE_DESTROY(CMISSQuadrature%QUADRATURE,Err,ERROR,*999)

    CALL EXITS("CMISSQuadratureTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSQuadratureTypeFinalise",Err,ERROR)
    CALL EXITS("CMISSQuadratureTypeFinalise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSQuadratureTypeFinalise
  
  !
  !================================================================================================================================
  !

  !>Initialises a CMISSQuadratureType object.
  SUBROUTINE CMISSQuadratureTypeInitialise(CMISSQuadrature,Err)
  
    !Argument variables
    TYPE(CMISSQuadratureType), INTENT(OUT) :: CMISSQuadrature !<The CMISSQuadratureType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSQuadratureTypeInitialise",Err,ERROR,*999)
    
    NULLIFY(CMISSQuadrature%QUADRATURE)

    CALL EXITS("CMISSQuadratureTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSQuadratureTypeInitialise",Err,ERROR)
    CALL EXITS("CMISSQuadratureTypeInitialise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSQuadratureTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSRegionType object.
  SUBROUTINE CMISSRegionTypeFinalise(CMISSRegion,Err)
  
    !Argument variables
    TYPE(CMISSRegionType), INTENT(OUT) :: CMISSRegion !<The CMISSRegionType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    
    CALL ENTERS("CMISSRegionTypeFinalise",Err,ERROR,*999)
    
    IF(ASSOCIATED(CMISSRegion%REGION))  &
      & CALL REGION_DESTROY(CMISSRegion%REGION,Err,ERROR,*999)

    CALL EXITS("CMISSRegionTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSRegionTypeFinalise",Err,ERROR)
    CALL EXITS("CMISSRegionTypeFinalise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSRegionTypeFinalise
  
  !
  !================================================================================================================================
  !

  !>Initialises a CMISSRegionType object.
  SUBROUTINE CMISSRegionTypeInitialise(CMISSRegion,Err)
  
    !Argument variables
    TYPE(CMISSRegionType), INTENT(OUT) :: CMISSRegion !<The CMISSRegionType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRegionTypeInitialise",Err,ERROR,*999)
    
    NULLIFY(CMISSRegion%REGION)

    CALL EXITS("CMISSRegionTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSRegionTypeInitialise",Err,ERROR)
    CALL EXITS("CMISSRegionTypeInitialise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSRegionTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSSolverType object.
  SUBROUTINE CMISSSolverTypeFinalise(CMISSSolver,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(OUT) :: CMISSSolver !<The CMISSSolverType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    
    CALL ENTERS("CMISSSolverTypeFinalise",Err,ERROR,*999)
    
    IF(ASSOCIATED(CMISSSolver%SOLVER))  &
      & CALL SOLVER_DESTROY(CMISSSolver%SOLVER,Err,ERROR,*999)

    CALL EXITS("CMISSSolverTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSSolverTypeFinalise",Err,ERROR)
    CALL EXITS("CMISSSolverTypeFinalise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverTypeFinalise
  
  !
  !================================================================================================================================
  !

  !>Initialises a CMISSSolverType object.
  SUBROUTINE CMISSSolverTypeInitialise(CMISSSolver,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(OUT) :: CMISSSolver !<The CMISSSolverType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverTypeInitialise",Err,ERROR,*999)
    
    NULLIFY(CMISSSolver%SOLVER)

    CALL EXITS("CMISSSolverTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSSolverTypeInitialise",Err,ERROR)
    CALL EXITS("CMISSSolverTypeInitialise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSSolverEquationsType object.
  SUBROUTINE CMISSSolverEquationsTypeFinalise(CMISSSolverEquations,Err)
  
    !Argument variables
    TYPE(CMISSSolverEquationsType), INTENT(OUT) :: CMISSSolverEquations !<The CMISSSolverEquationsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    
    CALL ENTERS("CMISSSolverEquationsTypeFinalise",Err,ERROR,*999)
    
    IF(ASSOCIATED(CMISSSolverEquations%SOLVER_EQUATIONS))  &
      & CALL SOLVER_EQUATIONS_DESTROY(CMISSSolverEquations%SOLVER_EQUATIONS,Err,ERROR,*999)

    CALL EXITS("CMISSSolverEquationsTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSSolverEquationsTypeFinalise",Err,ERROR)
    CALL EXITS("CMISSSolverEquationsTypeFinalise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverEquationsTypeFinalise
  
  !
  !================================================================================================================================
  !

  !>Initialises a CMISSSolverEquationsType object.
  SUBROUTINE CMISSSolverEquationsTypeInitialise(CMISSSolverEquations,Err)
  
    !Argument variables
    TYPE(CMISSSolverEquationsType), INTENT(OUT) :: CMISSSolverEquations !<The CMISSSolverEquationsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverEquationsTypeInitialise",Err,ERROR,*999)
    
    NULLIFY(CMISSSolverEquations%SOLVER_EQUATIONS)

    CALL EXITS("CMISSSolverEquationsTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSSolverEquationsTypeInitialise",Err,ERROR)
    CALL EXITS("CMISSSolverEquationsTypeInitialise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverEquationsTypeInitialise

!!==================================================================================================================================
!!
!! ANALYTIC_ANALYSIS_ROUTINES
!!
!!==================================================================================================================================

  !>Output the analytic error analysis for a field specified by a user number compared to the analytic values parameter set.
  SUBROUTINE CMISSAnalyticAnalysisOutputNumber(RegionUserNumber,FieldUserNumber,FileName,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    CHARACTER(LEN=*) :: FileName !<If not empty, the filename to output the analytic analysis to. If empty, the analysis will be output to the standard output.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisOutputNumber",Err,ERROR,*999)
    
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_OUTPUT(FIELD,FileName,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF
    
    CALL EXITS("CMISSAnalyticAnalysisOutputNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisOutputNumber",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisOutputNumber")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisOutputNumber

  !
  !================================================================================================================================
  !  

  !>Output the analytic error analysis for a field identified by an object compared to the analytic values parameter set.
  SUBROUTINE CMISSAnalyticAnalysisOutputObj(Field,FileName,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The dependent field to calculate the analytic error analysis for.
    CHARACTER(LEN=*) :: FileName !<If not empty, the filename to output the analytic analysis to. If empty, the analysis will be output to the standard output.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisOutputObj",Err,ERROR,*999)
    
    CALL ANALYTIC_ANALYSIS_OUTPUT(Field%FIELD,FileName,Err,ERROR,*999)

    CALL EXITS("CMISSAnalyticAnalysisOutputObj")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisOutputObj",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisOutputObj")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisOutputObj

  !
  !================================================================================================================================
  ! 

  !>Get absolute error value for the node in a field specified by a user number compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetNodeNumber(RegionUserNumber,FieldUserNumber,VariableType,DerivativeNumber, & 
    & NodeNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: NodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisAbsoluteErrorGetNodeNumber",Err,ERROR,*999)
    
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_ABSOLUTE_ERROR_GET_NODE(FIELD,VariableType,DerivativeNumber,NodeNumber,ComponentNumber,Value,ERR, &
          & ERROR,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF
    
    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetNodeNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisAbsoluteErrorGetNodeNumber",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetNodeNumber")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetNodeNumber

  !
  !================================================================================================================================
  !  

  !>Get absolute error value for the node in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetNodeObj(Field,VariableType,DerivativeNumber,NodeNumber,ComponentNumber,Value, &
    & Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: NodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisAbsoluteErrorGetNodeObj",Err,ERROR,*999)
    
    CALL ANALYTIC_ANALYSIS_ABSOLUTE_ERROR_GET_NODE(Field%FIELD,VariableType,DerivativeNumber,NodeNumber,ComponentNumber,Value, &
      & ERR,ERROR,*999)

    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetNodeObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisAbsoluteErrorGetNodeObj",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetNodeObj")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetNodeObj

  !
  !================================================================================================================================
  ! 

  !>Get percentage error value for the node in a field specified by a user number compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetNodeNumber(RegionUserNumber,FieldUserNumber,VariableType,DerivativeNumber, & 
    & NodeNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: NodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisPercentageErrorGetNodeNumber",Err,ERROR,*999)
    
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_PERCENTAGE_ERROR_GET_NODE(FIELD,VariableType,DerivativeNumber,NodeNumber,ComponentNumber,Value,ERR, &
          & ERROR,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF
    
    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetNodeNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisPercentageErrorGetNodeNumber",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetNodeNumber")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetNodeNumber

  !
  !================================================================================================================================
  !  

  !>Get percentage error value for the node in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetNodeObj(Field,VariableType,DerivativeNumber,NodeNumber,ComponentNumber,Value, &
    & Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: NodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisPercentageErrorGetNodeObj",Err,ERROR,*999)
    
    CALL ANALYTIC_ANALYSIS_PERCENTAGE_ERROR_GET_NODE(Field%FIELD,VariableType,DerivativeNumber,NodeNumber,ComponentNumber,Value, &
      & ERR,ERROR,*999)

    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetNodeObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisPercentageErrorGetNodeObj",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetNodeObj")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetNodeObj


  !
  !================================================================================================================================
  ! 

  !>Get relative error value for the node in a field specified by a user number compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetNodeNumber(RegionUserNumber,FieldUserNumber,VariableType,DerivativeNumber, & 
    & NodeNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: NodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisRelativeErrorGetNodeNumber",Err,ERROR,*999)
    
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_RELATIVE_ERROR_GET_NODE(FIELD,VariableType,DerivativeNumber,NodeNumber,ComponentNumber,Value,ERR, &
          & ERROR,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF
    
    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetNodeNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisRelativeErrorGetNodeNumber",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetNodeNumber")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetNodeNumber

  !
  !================================================================================================================================
  !  

  !>Get relative error value for the node in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetNodeObj(Field,VariableType,DerivativeNumber,NodeNumber,ComponentNumber,Value, &
    & Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: NodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisRelativeErrorGetNodeObj",Err,ERROR,*999)
    
    CALL ANALYTIC_ANALYSIS_RELATIVE_ERROR_GET_NODE(Field%FIELD,VariableType,DerivativeNumber,NodeNumber,ComponentNumber,Value, &
      & ERR,ERROR,*999)

    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetNodeObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisRelativeErrorGetNodeObj",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetNodeObj")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetNodeObj

  !
  !================================================================================================================================
  ! 

  !>Get absolute error value for the element in a field specified by a user number compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetElementNumber(RegionUserNumber,FieldUserNumber,VariableType,ElementNumber, &
    & ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: ElementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisAbsoluteErrorGetElementNumber",Err,ERROR,*999)
    
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_ABSOLUTE_ERROR_GET_ELEMENT(FIELD,VariableType,ElementNumber,ComponentNumber,Value,ERR,ERROR,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF
    
    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetElementNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisAbsoluteErrorGetElementNumber",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetElementNumber")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetElementNumber

  !
  !================================================================================================================================
  !  

  !>Get absolute error value for the element in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetElementObj(Field,VariableType,ElementNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: ElementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisAbsoluteErrorGetElementObj",Err,ERROR,*999)
    
    CALL ANALYTIC_ANALYSIS_ABSOLUTE_ERROR_GET_ELEMENT(Field%FIELD,VariableType,ElementNumber,ComponentNumber,Value,ERR,ERROR,*999)

    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetElementObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisAbsoluteErrorGetElementObj",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetElementObj")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetElementObj

  !
  !================================================================================================================================
  ! 

  !>Get percentage error value for the element in a field specified by a user number compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetElementNumber(RegionUserNumber,FieldUserNumber,VariableType,ElementNumber, &
    & ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: ElementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisPercentageErrorGetElementNumber",Err,ERROR,*999)
    
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_PERCENTAGE_ERROR_GET_ELEMENT(FIELD,VariableType,ElementNumber,ComponentNumber,Value,ERR,ERROR,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF
    
    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetElementNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisPercentageErrorGetElementNumber",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetElementNumber")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetElementNumber

  !
  !================================================================================================================================
  !  

  !>Get percentage error value for the element in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetElementObj(Field,VariableType,ElementNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: ElementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisPercentageErrorGetElementObj",Err,ERROR,*999)
    
    CALL ANALYTIC_ANALYSIS_PERCENTAGE_ERROR_GET_ELEMENT(Field%FIELD,VariableType,ElementNumber,ComponentNumber,Value,ERR,ERROR,*999)

    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetElementObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisPercentageErrorGetElementObj",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetElementObj")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetElementObj


  !
  !================================================================================================================================
  ! 

  !>Get relative error value for the element in a field specified by a user number compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetElementNumber(RegionUserNumber,FieldUserNumber,VariableType,ElementNumber, &
    & ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: ElementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisRelativeErrorGetElementNumber",Err,ERROR,*999)
    
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_RELATIVE_ERROR_GET_ELEMENT(FIELD,VariableType,ElementNumber,ComponentNumber,Value,ERR,ERROR,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF
    
    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetElementNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisRelativeErrorGetElementNumber",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetElementNumber")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetElementNumber

  !
  !================================================================================================================================
  !  

  !>Get relative error value for the element in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetElementObj(Field,VariableType,ElementNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: ElementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisRelativeErrorGetElementObj",Err,ERROR,*999)
    
    CALL ANALYTIC_ANALYSIS_RELATIVE_ERROR_GET_ELEMENT(Field%FIELD,VariableType,ElementNumber,ComponentNumber,Value,ERR,ERROR,*999)

    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetElementObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisRelativeErrorGetElementObj",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetElementObj")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetElementObj

  !
  !================================================================================================================================
  ! 

  !>Get absolute error value for the constant in a field specified by a user number compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetConstantNumber(RegionUserNumber,FieldUserNumber,VariableType,ComponentNumber, &
    & Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisAbsoluteErrorGetConstantNumber",Err,ERROR,*999)
    
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_ABSOLUTE_ERROR_GET_CONSTANT(FIELD,VariableType,ComponentNumber,Value,ERR,ERROR,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF
    
    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetConstantNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisAbsoluteErrorGetConstantNumber",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetElementNumber")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetConstantNumber

  !
  !================================================================================================================================
  !  

  !>Get absolute error value for the constant in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetConstantObj(Field,VariableType,ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisAbsoluteErrorGetConstantObj",Err,ERROR,*999)
    
    CALL ANALYTIC_ANALYSIS_ABSOLUTE_ERROR_GET_CONSTANT(Field%FIELD,VariableType,ComponentNumber,Value,ERR,ERROR,*999)

    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetConstantObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisAbsoluteErrorGetConstantObj",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetConstantObj")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetConstantObj

  !
  !================================================================================================================================
  ! 

  !>Get percentage error value for the constant in a field specified by a user number compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetConstantNumber(RegionUserNumber,FieldUserNumber,VariableType,ComponentNumber, &
    & Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisPercentageErrorGetConstantNumber",Err,ERROR,*999)
    
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_PERCENTAGE_ERROR_GET_CONSTANT(FIELD,VariableType,ComponentNumber,Value,ERR,ERROR,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF
    
    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetConstantNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisPercentageErrorGetConstantNumber",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetConstantNumber")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetConstantNumber

  !
  !================================================================================================================================
  !  

  !>Get percentage error value for the constant in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetConstantObj(Field,VariableType,ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisPercentageErrorGetConstantObj",Err,ERROR,*999)
    
    CALL ANALYTIC_ANALYSIS_PERCENTAGE_ERROR_GET_CONSTANT(Field%FIELD,VariableType,ComponentNumber,Value,ERR,ERROR,*999)

    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetConstantObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisPercentageErrorGetConstantObj",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetConstantObj")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetConstantObj


  !
  !================================================================================================================================
  ! 

  !>Get relative error value for the constant in a field specified by a user number compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetConstantNumber(RegionUserNumber,FieldUserNumber,VariableType,ComponentNumber, &
    & Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisRelativeErrorGetConstantNumber",Err,ERROR,*999)
    
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_RELATIVE_ERROR_GET_CONSTANT(FIELD,VariableType,ComponentNumber,Value,ERR,ERROR,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF
    
    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetConstantNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisRelativeErrorGetConstantNumber",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetConstantNumber")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetConstantNumber

  !
  !================================================================================================================================
  !  

  !>Get relative error value for the constant in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetConstantObj(Field,VariableType,ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisRelativeErrorGetConstantObj",Err,ERROR,*999)
    
    CALL ANALYTIC_ANALYSIS_RELATIVE_ERROR_GET_CONSTANT(Field%FIELD,VariableType,ComponentNumber,Value,ERR,ERROR,*999)

    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetConstantObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisRelativeErrorGetConstantObj",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetConstantObj")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetConstantObj

  !
  !================================================================================================================================
  ! 

  !>Get rms error value for nodes in a field compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisRmsErrorGetNodeNumber(RegionUserNumber,FieldUserNumber,VariableType,ComponentNumber, ErrorType, &
    & LocalValue,LocalGhostValue,GlobalValue,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    INTEGER(INTG), INTENT(IN) :: ErrorType !<error type
    REAL(DP), INTENT(OUT) :: LocalValue(8) !<On return, the local error
    REAL(DP), INTENT(OUT) :: LocalGhostValue(8) !<On return, the local ghost error
    REAL(DP), INTENT(OUT) :: GlobalValue(8) !<On return, the global error
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisRmsErrorGetNodeNumber",Err,ERROR,*999)
    
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_RMS_ERROR_GET_NODE(FIELD,VariableType,ComponentNumber,ErrorType,LocalValue,LocalGhostValue, &
          & GlobalValue,ERR,ERROR,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF
    
    CALL EXITS("CMISSAnalyticAnalysisRmsErrorGetNodeNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisRmsErrorGetNodeNumber",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisRmsErrorGetNodeNumber")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisRmsErrorGetNodeNumber

  !
  !================================================================================================================================
  !  

  !>Get rms error value for nodes in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisRmsErrorGetNodeObj(Field,VariableType,ComponentNumber,ErrorType,LocalValue,LocalGhostValue, &
    & GlobalValue,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    INTEGER(INTG), INTENT(IN) :: ErrorType !<error type
    REAL(DP), INTENT(OUT) :: LocalValue(8) !<On return, the local error
    REAL(DP), INTENT(OUT) :: LocalGhostValue(8) !<On return, the local ghost error
    REAL(DP), INTENT(OUT) :: GlobalValue(8) !<On return, the global error
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisRmsErrorGetNodeObj",Err,ERROR,*999)
    
    CALL ANALYTIC_ANALYSIS_RMS_ERROR_GET_NODE(Field%FIELD,VariableType,ComponentNumber,ErrorType,LocalValue,LocalGhostValue, &
      & GlobalValue,ERR,ERROR,*999)

    CALL EXITS("CMISSAnalyticAnalysisRmsErrorGetNodeObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisRmsErrorGetNodeObj",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisRmsErrorGetNodeObj")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisRmsErrorGetNodeObj

  !
  !================================================================================================================================
  ! 

  !>Get rms error value for elements in a field compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisRmsErrorGetElementNumber(RegionUserNumber,FieldUserNumber,VariableType,ComponentNumber, & 
    & ErrorType,LocalValue,LocalGhostValue,GlobalValue,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    INTEGER(INTG), INTENT(IN) :: ErrorType !<error type
    REAL(DP), INTENT(OUT) :: LocalValue !<On return, the local error
    REAL(DP), INTENT(OUT) :: LocalGhostValue !<On return, the local ghost error
    REAL(DP), INTENT(OUT) :: GlobalValue !<On return, the global error
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisRmsErrorGetElementNumber",Err,ERROR,*999)
    
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_RMS_ERROR_GET_ELEMENT(FIELD,VariableType,ComponentNumber,ErrorType,LocalValue,LocalGhostValue, &
          & GlobalValue,ERR,ERROR,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF
    
    CALL EXITS("CMISSAnalyticAnalysisRmsErrorGetElementNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisRmsErrorGetElementNumber",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisRmsErrorGetElementNumber")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisRmsErrorGetElementNumber

  !
  !================================================================================================================================
  !  

  !>Get relative error value for the constant in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisRmsErrorGetElementObj(Field,VariableType,ComponentNumber,ErrorType,LocalValue,LocalGhostValue, &
    & GlobalValue,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    INTEGER(INTG), INTENT(IN) :: ErrorType !<error type
    REAL(DP), INTENT(OUT) :: LocalValue !<On return, the local error
    REAL(DP), INTENT(OUT) :: LocalGhostValue !<On return, the local ghost error
    REAL(DP), INTENT(OUT) :: GlobalValue !<On return, the global error
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisRmsErrorGetNodeObj",Err,ERROR,*999)
    
    CALL ANALYTIC_ANALYSIS_RMS_ERROR_GET_ELEMENT(Field%FIELD,VariableType,ComponentNumber,ErrorType,LocalValue,LocalGhostValue, &
      & GlobalValue,ERR,ERROR,*999)

    CALL EXITS("CMISSAnalyticAnalysisRmsErrorGetElementObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisRmsErrorGetElementObj",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisRmsErrorGetElementObj")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisRmsErrorGetElementObj

  !
  !================================================================================================================================
  ! 

  !>Get integral value for the numerical values.
  SUBROUTINE CMISSAnalyticAnalysisIntegralNumericalValueGetNumber(RegionUserNumber,FieldUserNumber,VariableType,ComponentNumber, & 
    & IntegralValue,GhostIntegralValue,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    REAL(DP), INTENT(OUT) :: IntegralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: GhostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisIntegralNumericalValueGetNumber",Err,ERROR,*999)
    
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_INTEGRAL_NUMERICAL_VALUE_GET(FIELD,VariableType,ComponentNumber,IntegralValue,GhostIntegralValue, &
          & ERR,ERROR,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF
    
    CALL EXITS("CMISSAnalyticAnalysisIntegralNumericalValueGetNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralNumericalValueGetNumber",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisIntegralNumericalValueGetNumber")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisIntegralNumericalValueGetNumber

  !
  !================================================================================================================================
  !  

  !>Get integral value for the numerical values.
  SUBROUTINE CMISSAnalyticAnalysisIntegralNumericalValueGetObj(Field,VariableType,ComponentNumber,IntegralValue, &
    & GhostIntegralValue,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    REAL(DP), INTENT(OUT) :: IntegralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: GhostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisIntegralNumericalValueGetObj",Err,ERROR,*999)
    
    CALL ANALYTIC_ANALYSIS_INTEGRAL_NUMERICAL_VALUE_GET(Field%FIELD,VariableType,ComponentNumber,IntegralValue,GhostIntegralValue, &
          & ERR,ERROR,*999)

    CALL EXITS("CMISSAnalyticAnalysisIntegralNumericalValueGetObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralNumericalValueGetObj",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisIntegralNumericalValueGetObj")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisIntegralNumericalValueGetObj

  !
  !================================================================================================================================
  ! 

  !>Get integral value for the analytic values.
  SUBROUTINE CMISSAnalyticAnalysisIntegralAnalyticValueGetNumber(RegionUserNumber,FieldUserNumber,VariableType,ComponentNumber, & 
    & IntegralValue,GhostIntegralValue,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    REAL(DP), INTENT(OUT) :: IntegralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: GhostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisIntegralAnalyticValueGetNumber",Err,ERROR,*999)
    
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_INTEGRAL_ANALYTIC_VALUE_GET(FIELD,VariableType,ComponentNumber,IntegralValue,GhostIntegralValue, &
          & ERR,ERROR,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF
    
    CALL EXITS("CMISSAnalyticAnalysisIntegralAnalyticValueGetNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralAnalyticValueGetNumber",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisIntegralAnalyticValueGetNumber")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisIntegralAnalyticValueGetNumber

  !
  !================================================================================================================================
  !  

  !>Get integral value for the analytic values.
  SUBROUTINE CMISSAnalyticAnalysisIntegralAnalyticValueGetObj(Field,VariableType,ComponentNumber,IntegralValue, &
    & GhostIntegralValue,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    REAL(DP), INTENT(OUT) :: IntegralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: GhostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisIntegralAnalyticValueGetObj",Err,ERROR,*999)
    
    CALL ANALYTIC_ANALYSIS_INTEGRAL_ANALYTIC_VALUE_GET(Field%FIELD,VariableType,ComponentNumber,IntegralValue,GhostIntegralValue, &
          & ERR,ERROR,*999)

    CALL EXITS("CMISSAnalyticAnalysisIntegralAnalyticValueGetObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralAnalyticValueGetObj",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisIntegralAnalyticValueGetObj")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisIntegralAnalyticValueGetObj

  !
  !================================================================================================================================
  ! 

  !>Get integral value for the percentage errors.
  SUBROUTINE CMISSAnalyticAnalysisIntegralPercentageErrorGetNumber(RegionUserNumber,FieldUserNumber,VariableType,ComponentNumber, & 
    & IntegralValue,GhostIntegralValue,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    REAL(DP), INTENT(OUT) :: IntegralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: GhostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisIntegralPercentageErrorGetNumber",Err,ERROR,*999)
    
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_INTEGRAL_PERCENTAGE_ERROR_GET(FIELD,VariableType,ComponentNumber,IntegralValue,GhostIntegralValue, &
          & ERR,ERROR,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF
    
    CALL EXITS("CMISSAnalyticAnalysisIntegralPercentageErrorGetNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralPercentageErrorGetNumber",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisIntegralPercentageErrorGetNumber")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisIntegralPercentageErrorGetNumber

  !
  !================================================================================================================================
  !  

  !>Get integral value for the percentage errors.
  SUBROUTINE CMISSAnalyticAnalysisIntegralPercentageErrorGetObj(Field,VariableType,ComponentNumber,IntegralValue, &
    & GhostIntegralValue,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    REAL(DP), INTENT(OUT) :: IntegralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: GhostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisIntegralPercentageErrorGetObj",Err,ERROR,*999)
    
    CALL ANALYTIC_ANALYSIS_INTEGRAL_PERCENTAGE_ERROR_GET(Field%FIELD,VariableType,ComponentNumber,IntegralValue, & 
      & GhostIntegralValue,ERR,ERROR,*999)

    CALL EXITS("CMISSAnalyticAnalysisIntegralPercentageErrorGetObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralPercentageErrorGetObj",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisIntegralPercentageErrorGetObj")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisIntegralPercentageErrorGetObj

  !
  !================================================================================================================================
  ! 

  !>Get integral value for the absolute errors.
  SUBROUTINE CMISSAnalyticAnalysisIntegralAbsoluteErrorGetNumber(RegionUserNumber,FieldUserNumber,VariableType,ComponentNumber, & 
    & IntegralValue,GhostIntegralValue,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    REAL(DP), INTENT(OUT) :: IntegralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: GhostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisIntegralAbsoluteErrorGetNumber",Err,ERROR,*999)
    
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_INTEGRAL_ABSOLUTE_ERROR_GET(FIELD,VariableType,ComponentNumber,IntegralValue,GhostIntegralValue, &
          & ERR,ERROR,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF
    
    CALL EXITS("CMISSAnalyticAnalysisIntegralAbsoluteErrorGetNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralAbsoluteErrorGetNumber",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisIntegralAbsoluteErrorGetNumber")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisIntegralAbsoluteErrorGetNumber

  !
  !================================================================================================================================
  !  

  !>Get integral value for the absolute errors.
  SUBROUTINE CMISSAnalyticAnalysisIntegralAbsoluteErrorGetObj(Field,VariableType,ComponentNumber,IntegralValue, &
    & GhostIntegralValue,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    REAL(DP), INTENT(OUT) :: IntegralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: GhostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisIntegralAbsoluteErrorGetObj",Err,ERROR,*999)
    
    CALL ANALYTIC_ANALYSIS_INTEGRAL_ABSOLUTE_ERROR_GET(Field%FIELD,VariableType,ComponentNumber,IntegralValue,GhostIntegralValue, &
          & ERR,ERROR,*999)

    CALL EXITS("CMISSAnalyticAnalysisIntegralAbsoluteErrorGetObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralAbsoluteErrorGetObj",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisIntegralAbsoluteErrorGetObj")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisIntegralAbsoluteErrorGetObj

  !
  !================================================================================================================================
  ! 

  !>Get integral value for the relative error.
  SUBROUTINE CMISSAnalyticAnalysisIntegralRelativeErrorGetNumber(RegionUserNumber,FieldUserNumber,VariableType,ComponentNumber, & 
    & IntegralValue,GhostIntegralValue,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    REAL(DP), INTENT(OUT) :: IntegralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: GhostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisIntegralRelativeErrorGetNumber",Err,ERROR,*999)
    
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_INTEGRAL_RELATIVE_ERROR_GET(FIELD,VariableType,ComponentNumber,IntegralValue,GhostIntegralValue, &
          & ERR,ERROR,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF
    
    CALL EXITS("CMISSAnalyticAnalysisIntegralRelativeErrorGetNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralRelativeErrorGetNumber",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisIntegralRelativeErrorGetNumber")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisIntegralRelativeErrorGetNumber

  !
  !================================================================================================================================
  !  

  !>Get integral value for the relative error.
  SUBROUTINE CMISSAnalyticAnalysisIntegralRelativeErrorGetObj(Field,VariableType,ComponentNumber,IntegralValue, & 
    & GhostIntegralValue,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    REAL(DP), INTENT(OUT) :: IntegralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: GhostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisIntegralRelativeErrorGetObj",Err,ERROR,*999)
    
    CALL ANALYTIC_ANALYSIS_INTEGRAL_RELATIVE_ERROR_GET(Field%FIELD,VariableType,ComponentNumber,IntegralValue,GhostIntegralValue, &
      & ERR,ERROR,*999)

    CALL EXITS("CMISSAnalyticAnalysisIntegralRelativeErrorGetObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralRelativeErrorGetObj",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisIntegralRelativeErrorGetObj")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisIntegralRelativeErrorGetObj

  !
  !================================================================================================================================
  ! 

  !>Get integral value for the nid numerical.
  SUBROUTINE CMISSAnalyticAnalysisIntegralNidNumericalValueGetNumber(RegionUserNumber,FieldUserNumber,VariableType, &
    & ComponentNumber,IntegralValue,GhostIntegralValue,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    REAL(DP), INTENT(OUT) :: IntegralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: GhostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisIntegralNidNumericalValueGetNumber",Err,ERROR,*999)
    
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_INTEGRAL_NID_NUMERICAL_VALUE_GET(FIELD,VariableType,ComponentNumber,IntegralValue, &
          & GhostIntegralValue,ERR,ERROR,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF
    
    CALL EXITS("CMISSAnalyticAnalysisIntegralNidNumericalValueGetNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralNidNumericalValueGetNumber",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisIntegralNidNumericalValueGetNumber")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisIntegralNidNumericalValueGetNumber

  !
  !================================================================================================================================
  !  

  !>Get integral value for the nid numerical.
  SUBROUTINE CMISSAnalyticAnalysisIntegralNidNumericalValueGetObj(Field,VariableType,ComponentNumber,IntegralValue, & 
    & GhostIntegralValue,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    REAL(DP), INTENT(OUT) :: IntegralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: GhostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisIntegralNidNumericalValueGetObj",Err,ERROR,*999)
    
    CALL ANALYTIC_ANALYSIS_INTEGRAL_NID_NUMERICAL_VALUE_GET(Field%FIELD,VariableType,ComponentNumber,IntegralValue, &
      & GhostIntegralValue,ERR,ERROR,*999)

    CALL EXITS("CMISSAnalyticAnalysisIntegralNidNumericalValueGetObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralNidNumericalValueGetObj",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisIntegralNidNumericalValueGetObj")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisIntegralNidNumericalValueGetObj

  !
  !================================================================================================================================
  ! 

  !>Get integral value for the nid error.
  SUBROUTINE CMISSAnalyticAnalysisIntegralNidErrorGetNumber(RegionUserNumber,FieldUserNumber,VariableType,ComponentNumber, &
    & IntegralValue,GhostIntegralValue,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    REAL(DP), INTENT(OUT) :: IntegralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: GhostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisIntegralNidErrorGetNumber",Err,ERROR,*999)
    
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_INTEGRAL_NID_ERROR_GET(FIELD,VariableType,ComponentNumber,IntegralValue,GhostIntegralValue,ERR, &
          & ERROR,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF
    
    CALL EXITS("CMISSAnalyticAnalysisIntegralNidErrorGetNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralNidErrorGetNumber",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisIntegralNidErrorGetNumber")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisIntegralNidErrorGetNumber

  !
  !================================================================================================================================
  !  

  !>Get integral value for the nid error.
  SUBROUTINE CMISSAnalyticAnalysisIntegralNidErrorGetObj(Field,VariableType,ComponentNumber,IntegralValue,GhostIntegralValue,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: VariableType !<variable type
    REAL(DP), INTENT(OUT) :: IntegralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: GhostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisIntegralNidErrorGetObj",Err,ERROR,*999)
    
    CALL ANALYTIC_ANALYSIS_INTEGRAL_NID_ERROR_GET(Field%FIELD,VariableType,ComponentNumber,IntegralValue,GhostIntegralValue,ERR, &
      & ERROR,*999)

    CALL EXITS("CMISSAnalyticAnalysisIntegralNidErrorGetObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralNidErrorGetObj",Err,ERROR)
    CALL EXITS("CMISSAnalyticAnalysisIntegralNidErrorGetObj")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSAnalyticAnalysisIntegralNidErrorGetObj




!!==================================================================================================================================
!!
!! BASE_ROUTINES
!!
!!==================================================================================================================================

  !>Sets diagnostics off. \see OPENCMISS::CMISSDiagnosticsSetOn
  SUBROUTINE CMISSDiagnosticsSetOff(Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code     
    !Local variables

    CALL ENTERS("CMISSDiagnosticsSetOff",Err,ERROR,*999)

    CALL DIAGNOSTICS_SET_OFF(Err,ERROR,*999)

    CALL EXITS("CMISSDiagnosticsSetOff")
    RETURN
999 CALL ERRORS("CMISSDiagnosticsSetOff",Err,ERROR)
    CALL EXITS("CMISSDiagnosticsSetOff")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSDiagnosticsSetOff
  
  !
  !================================================================================================================================
  !
  
  !>Sets diagnostics on \see OPENCMISS::CMISSDiagnosticsSetOff
  SUBROUTINE CMISSDiagnosticsSetOn(DiagType,LevelList,DiagFilename,RoutineList,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: DiagType !<The type of diagnostics to set on \see OPENCMISS_DiagnosticTypes.
    INTEGER(INTG), INTENT(IN) :: LevelList(:) !<The list of diagnostic levels to set on.
    CHARACTER(LEN=*), INTENT(IN) :: DiagFilename !<If present the name of the file to output diagnostic information to. If omitted the diagnostic output is sent to the screen.
    CHARACTER(LEN=*), INTENT(IN) :: RoutineList(:) !<The list of routines to set diagnostics on in.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code     
    !Local variables
    
    CALL ENTERS("CMISSDiagnosticsSetOn",Err,ERROR,*999)

    CALL DIAGNOSTICS_SET_ON(DiagType,LevelList,DiagFilename,RoutineList,Err,ERROR,*999)

    CALL EXITS("CMISSDiagnosticsSetOn")
    RETURN
999 CALL ERRORS("CMISSDiagnosticsSetOn",Err,ERROR)
    CALL EXITS("CMISSDiagnosticsSetOn")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSDiagnosticsSetOn

  !
  !================================================================================================================================
  !
  
  !>Sets output off \see OPENCMISS::CMISSOutputSetOff
  SUBROUTINE CMISSOutputSetOff(Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code     
    !Local variables

    CALL ENTERS("CMISSOutputSetOff",Err,ERROR,*999)
    
    CALL OUTPUT_SET_OFF(Err,ERROR,*999)

    CALL EXITS("CMISSOutputSetOff")
    RETURN
999 CALL ERRORS("CMISSOutputSetOff",Err,ERROR)
    CALL EXITS("CMISSOutputSetOff")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSOutputSetOff
  
  !
  !================================================================================================================================
  !
  
  !>Sets output on \see OPENCMISS::CMISSOutputSetOff
  SUBROUTINE CMISSOutputSetOn(EchoFilename,Err)
  
    !Argument variables
    CHARACTER(LEN=*), INTENT(IN) :: EchoFilename !<The filename of the file to echo output to
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code     
    !Local variables

    CALL ENTERS("CMISSOutputSetOn",Err,ERROR,*999)
    
    CALL OUTPUT_SET_ON(EchoFilename,Err,ERROR,*999)

    CALL EXITS("CMISSOutputSetOn")
    RETURN
999 CALL ERRORS("CMISSOutputSetOn",Err,ERROR)
    CALL EXITS("CMISSOutputSetOn")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSOutputSetOn

  !
  !================================================================================================================================
  !
  
  !>Sets timing off \see OPENCMISS::CMISSTimingSetOn
  SUBROUTINE CMISSTimingSetOff(Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code     
    !Local variables

    CALL ENTERS("CMISSTimingSetOff",ERR,ERROR,*999)
    
    CALL TIMING_SET_OFF(Err,ERROR,*999)

    CALL EXITS("CMISSTimingSetOff")
    RETURN
999 CALL ERRORS("CMISSTimingSetOff",Err,ERROR)
    CALL EXITS("CMISSTimingSetOff")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSTimingSetOff
  
  !
  !================================================================================================================================
  !
  
  !>Sets timing on \see OPENCMISS::CMISSTimingSetOff
  SUBROUTINE CMISSTimingSetOn(TimingType,TimingSummaryFlag,TimingFilename,RoutineList,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: TimingType !<The type of timing to set on \see OPENCMISS_TimingTypes.
    LOGICAL, INTENT(IN) :: TimingSummaryFlag !<.TRUE. if the timing information will be output with subsequent OPENCMISS::CMISSTimingSummaryOutput calls, .FALSE. if the timing information will be output every time the routine exits.
    CHARACTER(LEN=*), INTENT(IN) :: TimingFilename !<If present the name of the file to output timing information to. If omitted the timing output is sent to the screen.
    CHARACTER(LEN=*), INTENT(IN) :: RoutineList(:) !<The list of routines to set timing on in.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code     
    !Local variables

    CALL ENTERS("CMISSTimingSetOn",Err,ERROR,*999)
    
    CALL TIMING_SET_ON(TimingType,TimingSummaryFlag,TimingFilename,RoutineList,Err,ERROR,*999)

    CALL EXITS("CMISSTimingSetOn")
    RETURN    
999 CALL ERRORS("CMISSTimingSetOn",Err,ERROR)
    CALL EXITS("CMISSTimingSetOn")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSTimingSetOn

  !
  !================================================================================================================================
  !
  
  !>Outputs the timing summary.
  SUBROUTINE CMISSTimingSummaryOutput(Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code     
    !Local variables

    CALL ENTERS("CMISSTimingSummaryOutput",Err,ERROR,*999)
    
    CALL TIMING_SUMMARY_OUTPUT(Err,ERROR,*999)

    CALL EXITS("CMISSTimingSummaryOutput")
    RETURN
999 CALL ERRORS("CMISSTimingSummaryOutput",Err,ERROR)
    CALL EXITS("CMISSTimingSummaryOutput")
    RETURN
    
  END SUBROUTINE CMISSTimingSummaryOutput

!!==================================================================================================================================
!!
!! BASIS_ROUTINES
!!
!!==================================================================================================================================

  !>Returns the collapsed Xi flags of a basis identified by a user number.
  SUBROUTINE CMISSBasisCollapsedXiGetNumber(UserNumber,CollapsedXi,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: UserNumber !<The user number of the basis to get the collapsed Xi flags for.
    INTEGER(INTG), INTENT(OUT) :: CollapsedXi(:) !<CollapsedXi(ni). On return, the collapsed Xi parameter for the ni'th Xi direction. \see OPENCMISS_XiCollapse
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSBasisCollapsedXiGetNumber",Err,ERROR,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(UserNumber,BASIS,ERR,ERROR,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_COLLAPSED_XI_GET(BASIS,CollapsedXi,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(UserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSBasisCollapsedXiGetNumber")
    RETURN
999 CALL ERRORS("CMISSBasisCollapsedXiGetNumber",Err,ERROR)
    CALL EXITS("CMISSBasisCollapsedXiGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisCollapsedXiGetNumber
  
  !
  !================================================================================================================================
  !
  
  !>Returns the collapsed Xi flags of a basis identified by an object.
  SUBROUTINE CMISSBasisCollapsedXiGetObj(Basis,CollapsedXi,Err)
  
    !Argument variables
    TYPE(CMISSBasisType), INTENT(IN) :: Basis !<The basis to get the collapsed Xi flags for.
    INTEGER(INTG), INTENT(OUT) :: CollapsedXi(:) !<CollapsedXi(ni). On return, the collapsed Xi parameter for the ni'th Xi direction. \see OPENCMISS_XiCollapse
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisCollapsedXiGetObj",Err,ERROR,*999)
    
    CALL BASIS_COLLAPSED_XI_GET(Basis%BASIS,CollapsedXi,Err,ERROR,*999)

    CALL EXITS("CMISSBasisCollapsedXiGetObj")
    RETURN
999 CALL ERRORS("CMISSBasisCollapsedXiGetObj",Err,ERROR)
    CALL EXITS("CMISSBasisCollapsedXiGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisCollapsedXiGetObj

  !
  !================================================================================================================================
  !
 
  !>Sets/changes the collapsed Xi flags of a basis identified by a user number.
  SUBROUTINE CMISSBasisCollapsedXiSetNumber(UserNumber,CollapsedXi,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: UserNumber !<The user number of the basis to set the collapsed Xi flags for.
    INTEGER(INTG), INTENT(IN) :: CollapsedXi(:) !<CollapsedXi(ni). The collapsed Xi parameter for the ni'th Xi direction to set. \see OPENCMISS_XiCollapse
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisCollapsedXiSetNumber",ERR,ERROR,*999)
    
    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(UserNumber,BASIS,ERR,ERROR,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_COLLAPSED_XI_SET(BASIS,CollapsedXi,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(UserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSBasisCollapsedXiSetNumber")
    RETURN
999 CALL ERRORS("CMISSBasisCollapsedXiSetNumber",Err,ERROR)
    CALL EXITS("CMISSBasisCollapsedXiSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisCollapsedXiSetNumber
  
  !
  !================================================================================================================================
  !
  
  !>Sets/changes the collapsed Xi flags of a basis identified by an object.
  SUBROUTINE CMISSBasisCollapsedXiSetObj(Basis,CollapsedXi,Err)
  
    !Argument variables
    TYPE(CMISSBasisType), INTENT(INOUT) :: Basis !<The basis to set the collapsed Xi flags for.
    INTEGER(INTG), INTENT(IN) :: CollapsedXi(:) !<CollapsedXi(ni). The collapsed Xi parameter for the ni'th Xi direction to set. \see OPENCMISS_XiCollapse
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisCollapsedXiSetObj",Err,ERROR,*999)

    CALL BASIS_COLLAPSED_XI_SET(Basis%BASIS,CollapsedXi,Err,ERROR,*999)

    CALL EXITS("CMISSBasisCollapsedXiSetObj")
    RETURN
999 CALL ERRORS("CMISSBasisCollapsedXiSetObj",Err,ERROR)
    CALL EXITS("CMISSBasisCollapsedXiSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisCollapsedXiSetObj

  !
  !================================================================================================================================
  !
  
   !>Finishes the creation of a new basis identified by a user number.
  SUBROUTINE CMISSBasisCreateFinishNumber(UserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: UserNumber !<The user number of the basis to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code     
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisCreateFinishNumber",ERR,ERROR,*999)
    
    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(UserNumber,BASIS,Err,ERROR,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_CREATE_FINISH(Basis,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(UserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF      

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Basis Create')
#endif

    CALL EXITS("CMISSBasisCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSBasisCreateFinishNumber",Err,ERROR)
    CALL EXITS("CMISSBasisCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisCreateFinishNumber

  !
  !================================================================================================================================
  !
  
  !>Finishes the creation of a new basis identified by an object.
  SUBROUTINE CMISSBasisCreateFinishObj(Basis,Err)
  
    !Argument variables
    TYPE(CMISSBasisType), INTENT(INOUT) :: Basis !<The basis to finish the creation of
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code     
    !Local variables

    CALL ENTERS("CMISSBasisCreateFinishObj",Err,ERROR,*999)

    CALL BASIS_CREATE_FINISH(Basis%BASIS,Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Basis Create')
#endif

    CALL EXITS("CMISSBasisCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSBasisCreateFinishObj",Err,ERROR)
    CALL EXITS("CMISSBasisCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisCreateFinishObj
  
  !
  !================================================================================================================================
  !
  
  !>Starts the creation of a new basis for a basis identified by a user number.
  SUBROUTINE CMISSBasisCreateStartNumber(UserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: UserNumber !<The user number of the basis to start the creation of.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS

    CALL ENTERS("CMISSBasisCreateStartNumber",Err,ERROR,*999)
    
#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Basis Create')
#endif

    NULLIFY(BASIS)
    CALL BASIS_CREATE_START(UserNumber,BASIS,Err,ERROR,*999)

    CALL EXITS("CMISSBasisCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSBasisCreateStartNumber",Err,ERROR)
    CALL EXITS("CMISSBasisCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisCreateStartNumber

  !
  !================================================================================================================================
  !  
 
  !>Starts the creation of a new basis for a basis identified by an object.
  SUBROUTINE CMISSBasisCreateStartObj(UserNumber,Basis,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: UserNumber !<The user number of the basis to start the creation of.
    TYPE(CMISSBasisType), INTENT(INOUT) :: Basis !<On exit, the newly created basis.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisCreateStartObj",Err,ERROR,*999)
    
#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Basis Create')
#endif

    CALL BASIS_CREATE_START(UserNumber,Basis%BASIS,Err,ERROR,*999)

    CALL EXITS("CMISSBasisCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSBasisCreateStartObj",Err,ERROR)
    CALL EXITS("CMISSBasisCreateStartObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisCreateStartObj
  
  !
  !================================================================================================================================
  !
  
  !>Destroys a basis identified by its basis user number.
  SUBROUTINE CMISSBasisDestroyNumber(UserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: UserNumber !<The user number of the basis to destroy.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisDestroyNumber",Err,ERROR,*999)
    
    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(UserNumber,BASIS,ERR,ERROR,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_DESTROY(BASIS,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(UserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF
      
    CALL EXITS("CMISSBasisDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSBasisDestroyNumber",Err,ERROR)
    CALL EXITS("CMISSBasisDestroyNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisDestroyNumber
  
  !
  !================================================================================================================================
  !
  
  !>Destroys a basis identified by an object.
  SUBROUTINE CMISSBasisDestroyObj(Basis,Err)
  
    !Argument variables
    TYPE(CMISSBasisType), INTENT(INOUT) :: Basis !<The basis to destroy.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisDestroyObj",Err,ERROR,*999)
    
    CALL BASIS_DESTROY(Basis%BASIS,Err,ERROR,*999)

    CALL EXITS("CMISSBasisDestroyObj")
    RETURN
999 CALL ERRORS("CMISSBasisDestroyObj",Err,ERROR)
    CALL EXITS("CMISSBasisDestroyObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisDestroyObj
  
  !
  !================================================================================================================================
  !
  
  !>Get the interpolation type in each xi directions for a basis identified by a user number.
  SUBROUTINE CMISSBasisInterpolationXiGetNumber(UserNumber,InterpolationXi,Err)
    
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: UserNumber !<The user number of the basis to get the interpolation xi for.
    INTEGER(INTG), INTENT(OUT) :: InterpolationXi(:) !<On return, the interpolation xi parameters for each Xi direction \see OPENCMISS_InterpolationSpecifications.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR
     
    CALL ENTERS("CMISSBasisInterpolationXiGetNumber",Err,ERROR,*999)
    
    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(UserNumber,BASIS,ERR,ERROR,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_INTERPOLATION_XI_GET(BASIS,InterpolationXi,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(UserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSBasisInterpolationXiGetNumber")
    RETURN
999 CALL ERRORS("CMISSBasisInterpolationXiGetNumber",Err,ERROR)
    CALL EXITS("CMISSBasisInterpolationXiGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisInterpolationXiGetNumber
  
  !
  !================================================================================================================================
  !
  
  !>Get the interpolation type in each xi directions for a basis indentified by an object. 
  SUBROUTINE CMISSBasisInterpolationXiGetObj(Basis,InterpolationXi,Err)
  
    !Argument variables
    TYPE(CMISSBasisType), INTENT(IN) :: Basis !<The basis to get the interpolation xi for.
    INTEGER(INTG), INTENT(OUT) :: InterpolationXi(:) !<On return, the interpolation xi parameters for each Xi direction \see OPENCMISS_InterpolationSpecifications.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisInterpolationXiGetObj",Err,ERROR,*999)
    
    CALL BASIS_INTERPOLATION_XI_GET(Basis%BASIS,InterpolationXi,Err,ERROR,*999)

    CALL EXITS("CMISSBasisInterpolationXiGetObj")
    RETURN
999 CALL ERRORS("CMISSBasisInterpolationXiGetObj",Err,ERROR)
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    CALL EXITS("CMISSBasisInterpolationXiGetObj")
    RETURN
    
  END SUBROUTINE CMISSBasisInterpolationXiGetObj
  
  !
  !================================================================================================================================
  !
  
  !>Sets/changes the interpolation type in each xi directions for a basis identified by a user number.
  SUBROUTINE CMISSBasisInterpolationXiSetNumber(UserNumber,InterpolationXi,Err)
  
    !Argument variables
     INTEGER(INTG), INTENT(IN) :: UserNumber !<The user number of the basis to get the interpolation xi for.
     INTEGER(INTG), INTENT(IN) :: InterpolationXi(:) !<The interpolation xi parameters for each Xi direction \see OPENCMISS_InterpolationSpecifications.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisInterpolationXiSetNumber",ERR,ERROR,*999)
    
    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(UserNumber,BASIS,ERR,ERROR,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_INTERPOLATION_XI_SET(BASIS,InterpolationXi,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(UserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF      

    CALL EXITS("CMISSBasisInterpolationXiSetNumber")
    RETURN
999 CALL ERRORS("CMISSBasisInterpolationXiSetNumber",Err,ERROR)
    CALL EXITS("CMISSBasisInterpolationXiSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisInterpolationXiSetNumber
  
  !
  !================================================================================================================================
  !
  
  !>Sets/changes the interpolation type in each xi directions for a basis indentified by an object.
  SUBROUTINE CMISSBasisInterpolationXiSetObj(Basis,InterpolationXi,Err)
  
    !Argument variables
    TYPE(CMISSBasisType), INTENT(IN) :: Basis !<The basis to get the interpolation xi for.
    INTEGER(INTG), INTENT(IN) :: InterpolationXi(:) !<The interpolation xi parameters for each Xi direction \see OPENCMISS_InterpolationSpecifications.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisInterpolationXiSetObj",Err,ERROR,*999)
    
    CALL BASIS_INTERPOLATION_XI_SET(Basis%BASIS,InterpolationXi,Err,ERROR,*999)

    CALL EXITS("CMISSBasisInterpolationXiSetObj")
    RETURN
999 CALL ERRORS("CMISSBasisInterpolationXiSetObj",Err,ERROR)
    CALL EXITS("CMISSBasisInterpolationXiSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisInterpolationXiSetObj
  
  !
  !================================================================================================================================
  !
  
  !>Returns the number of local nodes in a basis identified by a user number.
  SUBROUTINE CMISSBasisNumberOfLocalNodesGetNumber(UserNumber,NumberOfLocalNodes,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: UserNumber !<The user number of the basis to get the interpolation xi for.
    INTEGER(INTG), INTENT(OUT) :: NumberOfLocalNodes !<On return, the number of local nodes in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisNumberOfLocalNodesGetNumber",Err,ERROR,*999)
    
    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(UserNumber,BASIS,ERR,ERROR,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_NUMBER_OF_LOCAL_NODES_GET(BASIS,NumberOfLocalNodes,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(UserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSBasisNumberOfLocalNodesGetNumber")
    RETURN
999 CALL ERRORS("CMISSBasisNumberOfLocalNodesGetNumber",Err,ERROR)
    CALL EXITS("CMISSBasisNumberOfLocalNodesGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisNumberOfLocalNodesGetNumber
  
  !
  !================================================================================================================================
  !
  
  !>Returns the number of local nodes in a basis identified by an object.
  SUBROUTINE CMISSBasisNumberOfLocalNodesGetObj(Basis,NumberOfLocalNodes,Err)
  
    !Argument variables
    TYPE(CMISSBasisType), INTENT(IN) :: Basis !<The basis to get the number of local nodes for.
    INTEGER(INTG), INTENT(OUT) :: NumberOfLocalNodes !<On return, the number of local nodes in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisNumberOfLocalNodesGetObj",Err,ERROR,*999)

    CALL BASIS_NUMBER_OF_LOCAL_NODES_GET(Basis%BASIS,NumberOfLocalNodes,Err,ERROR,*999)

    CALL EXITS("CMISSBasisNumberOfLocalNodesGetObj")
    RETURN
999 CALL ERRORS("CMISSBasisNumberOfLocalNodesGetObj",Err,ERROR)
    CALL EXITS("CMISSBasisNumberOfLocalNodesGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisNumberOfLocalNodesGetObj
  
  !
  !================================================================================================================================
  !
  
  !>Returns the number of Xi directions in a basis identified by a user number.
  SUBROUTINE CMISSBasisNumberOfXiGetNumber(UserNumber,NumberOfXi,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: UserNumber !<The user number of the basis to get the number xi for.
    INTEGER(INTG), INTENT(OUT) :: NumberOfXi !<On return, the number of xi directions in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisNumberOfXiGetNumber",Err,ERROR,*999)
    
    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(UserNumber,BASIS,ERR,ERROR,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_NUMBER_OF_XI_GET(BASIS,NumberOfXi,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(UserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSBasisNumberOfXiGetNumber")
    RETURN
999 CALL ERRORS("CMISSBasisNumberOfXiGetNumber",Err,ERROR)
    CALL EXITS("CMISSBasisNumberOfXiGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisNumberOfXiGetNumber
  
  !
  !================================================================================================================================
  !
  
  !>Returns the number of Xi directions in a basis identified by an object.
  SUBROUTINE CMISSBasisNumberOfXiGetObj(Basis,NumberOfXi,Err)
  
    !Argument variables
    TYPE(CMISSBasisType), INTENT(IN) :: Basis !<The basis to get the number of xi directions for.
    INTEGER(INTG), INTENT(OUT) :: NumberOfXi !<On return, the number of xi directions in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisNumberOfXiGetObj",Err,ERROR,*999)
    
    CALL BASIS_NUMBER_OF_XI_GET(Basis%BASIS,NumberOfXi,Err,ERROR,*999)

    CALL EXITS("CMISSBasisNumberOfXiGetObj")
    RETURN
999 CALL ERRORS("CMISSBasisNumberOfXiGetObj",Err,ERROR)
    CALL EXITS("CMISSBasisNumberOfXiGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisNumberOfXiGetObj
  
  !
  !================================================================================================================================
  !
  
  !>Sets/changes the number of Xi directions in a basis identified by a user number.
  SUBROUTINE CMISSBasisNumberOfXiSetNumber(UserNumber,NumberOfXi,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: UserNumber !<The user number of the basis to set the number xi for.
    INTEGER(INTG), INTENT(IN) :: NumberOfXi !<The number of xi directions in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisNumberOfXiSetNumber",Err,ERROR,*999)
    
    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(UserNumber,BASIS,ERR,ERROR,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_NUMBER_OF_XI_SET(BASIS,NumberOfXi,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(UserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSBasisNumberOfXiSetNumber")
    RETURN
999 CALL ERRORS("CMISSBasisNumberOfXiSetNumber",Err,ERROR)
    CALL EXITS("CMISSBasisNumberOfXiSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisNumberOfXiSetNumber
  
  !
  !================================================================================================================================
  !
  
  !>Sets/changes the number of Xi directions in a basis identified by an object.
  SUBROUTINE CMISSBasisNumberOfXiSetObj(Basis,NumberOfXi,Err)
  
    !Argument variables
    TYPE(CMISSBasisType), INTENT(INOUT) :: Basis !<The basis to set the number of xi directions for.
    INTEGER(INTG), INTENT(IN) :: NumberOfXi !<The number of xi directions in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisNumberOfXiSetObj",Err,ERROR,*999)
    
    CALL BASIS_NUMBER_OF_XI_SET(Basis%BASIS,NumberOfXi,Err,ERROR,*999)

    CALL EXITS("CMISSBasisNumberOfXiSetObj")
    RETURN
999 CALL ERRORS("CMISSBasisNumberOfXiSetObj",Err,ERROR)
    CALL EXITS("CMISSBasisNumberOfXiSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisNumberOfXiSetObj
  
  !
  !================================================================================================================================
  !
  
  !>Returns the number of Gauss points in each Xi directions for a basis quadrature identified by a user number.
  SUBROUTINE CMISSBasisQuadratureNumberOfGaussXiGetNumber(UserNumber,NumberOfGaussXi,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: UserNumber !<The user number of the basis to get the number of Gauss Xi for.
    INTEGER(INTG), INTENT(OUT) :: NumberOfGaussXi(:) !<On return, the number of Gauss points in each Xi directions in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisQuadratureNumberOfGaussXiGetNumber",Err,ERROR,*999)
    
    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(UserNumber,BASIS,ERR,ERROR,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_QUADRATURE_NUMBER_OF_GAUSS_XI_GET(BASIS,NumberOfGaussXi,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(UserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSBasisQuadratureNumberOfGaussXiGetNumber")
    RETURN
999 CALL ERRORS("CMISSBasisQuadratureNumberOfGaussXiGetNumber",Err,ERROR)
    CALL EXITS("CMISSBasisQuadratureNumberOfGaussXiGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisQuadratureNumberOfGaussXiGetNumber
  
  !
  !================================================================================================================================
  !
  
  !>Returns the number Gauss points in each Xi directions for a basis quadrature identified by an object.
  SUBROUTINE CMISSBasisQuadratureNumberOfGaussXiGetObj(Basis,NumberOfGaussXi,Err)
  
    !Argument variables
    TYPE(CMISSBasisType), INTENT(IN) :: Basis !<The basis to get the number of Gauss Xi for.
    INTEGER(INTG), INTENT(OUT) :: NumberOfGaussXi(:) !<On return, the number of Gauss points in each Xi directions in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisQuadratureNumberOfGaussXiGetObj",Err,ERROR,*999)
    
    CALL BASIS_QUADRATURE_NUMBER_OF_GAUSS_XI_GET(Basis%BASIS,NumberOfGaussXi,Err,ERROR,*999)

    CALL EXITS("CMISSBasisQuadratureNumberOfGaussXiGetObj")
    RETURN
999 CALL ERRORS("CMISSBasisQuadratureNumberOfGaussXiGetObj",Err,ERROR)
    CALL EXITS("CMISSBasisQuadratureNumberOfGaussXiGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisQuadratureNumberOfGaussXiGetObj
  
  !
  !================================================================================================================================
  !
  
  !>Sets/changes the number of Gauss points in each Xi directions for a basis quadrature identified by a user number.
  SUBROUTINE CMISSBasisQuadratureNumberOfGaussXiSetNumber(UserNumber,NumberOfGaussXi,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: UserNumber !<The user number of the basis to set the number of Gauss Xi for.
    INTEGER(INTG), INTENT(IN) :: NumberOfGaussXi(:) !<The number of Gauss points in each Xi directions in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisQuadratureNumberOfGaussXiSetNumber",Err,ERROR,*999)
    
    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(UserNumber,BASIS,ERR,ERROR,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_QUADRATURE_NUMBER_OF_GAUSS_XI_SET(BASIS,NumberOfGaussXi,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(UserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF
    
    CALL EXITS("CMISSBasisQuadratureNumberOfGaussXiSetNumber")
    RETURN
999 CALL ERRORS("CMISSBasisQuadratureNumberOfGaussXiSetNumber",Err,ERROR)
    CALL EXITS("CMISSBasisQuadratureNumberOfGaussXiSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisQuadratureNumberOfGaussXiSetNumber
  
  !
  !================================================================================================================================
  !
  
  !>Sets the number Gauss points in each Xi directions for a basis quadrature identified by an object.
  SUBROUTINE CMISSBasisQuadratureNumberOfGaussXiSetObj(Basis,NumberOfGaussXi,Err)
  
    !Argument variables
    TYPE(CMISSBasisType), INTENT(INOUT) :: Basis !<The basis to get the number of Gauss Xi for.
    INTEGER(INTG), INTENT(IN) :: NumberOfGaussXi(:) !<The number of Gauss points in each Xi directions in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisQuadratureNumberOfGaussXiSetObj",Err,ERROR,*999)

    CALL BASIS_QUADRATURE_NUMBER_OF_GAUSS_XI_SET(Basis%BASIS,NumberOfGaussXi,Err,ERROR,*999)

    CALL EXITS("CMISSBasisQuadratureNumberOfGaussXiSetObj")
    RETURN
999 CALL ERRORS("CMISSBasisQuadratureNumberOfGaussXiSetObj",Err,ERROR)
    CALL EXITS("CMISSBasisQuadratureNumberOfGaussXiSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisQuadratureNumberOfGaussXiSetObj
  
  !
  !================================================================================================================================
  !
  
  !>Returns the order of quadrature a basis quadrature identified by a user number.
  SUBROUTINE CMISSBasisQuadratureOrderGetNumber(UserNumber,QuadratureOrder,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: UserNumber !<The user number of the basis to get the quadrature order for.
    INTEGER(INTG), INTENT(OUT) :: QuadratureOrder !<On return, the order of quadrature in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisQuadratureOrderGetNumber",Err,ERROR,*999)
    
    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(UserNumber,BASIS,ERR,ERROR,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_QUADRATURE_ORDER_GET(BASIS,QuadratureOrder,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(UserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSBasisQuadratureOrderGetNumber")
    RETURN
999 CALL ERRORS("CMISSBasisQuadratureOrderGetNumber",Err,ERROR)
    CALL EXITS("CMISSBasisQuadratureOrderGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisQuadratureOrderGetNumber
  
  !
  !================================================================================================================================
  !
  
  !>Returns the the order of quadrature for a basis quadrature identified by an object.
  SUBROUTINE CMISSBasisQuadratureOrderGetObj(Basis,QuadratureOrder,Err)
  
    !Argument variables
    TYPE(CMISSBasisType), INTENT(IN) :: Basis !<The basis to get the quadrature order for.
    INTEGER(INTG), INTENT(OUT) :: QuadratureOrder !<On return, the order of quadrature in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisQuadratureOrderGetObj",Err,ERROR,*999)
    
    CALL BASIS_QUADRATURE_ORDER_GET(Basis%BASIS,QuadratureOrder,Err,ERROR,*999)

    CALL EXITS("CMISSBasisQuadratureOrderGetObj")
    RETURN
999 CALL ERRORS("CMISSBasisQuadratureOrderGetObj",Err,ERROR)
    CALL EXITS("CMISSBasisQuadratureOrderGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisQuadratureOrderGetObj


  !
  !================================================================================================================================
  !
    
  !>Sets/changes the order of quadrature a basis quadrature identified by a user number.
  SUBROUTINE CMISSBasisQuadratureOrderSetNumber(UserNumber,QuadratureOrder,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: UserNumber !<The user number of the basis to set the quadrature order for.
    INTEGER(INTG), INTENT(IN) :: QuadratureOrder !<The order of quadrature in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisQuadratureOrderSetNumber",Err,ERROR,*999)
    
    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(UserNumber,BASIS,ERR,ERROR,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_QUADRATURE_ORDER_SET(BASIS,QuadratureOrder,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(UserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSBasisQuadratureOrderSetNumber")
    RETURN
999 CALL ERRORS("CMISSBasisQuadratureOrderSetNumber",Err,ERROR)
    CALL EXITS("CMISSBasisQuadratureOrderSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisQuadratureOrderSetNumber
  
  !
  !================================================================================================================================
  !
  
  !>Sets/changes the the order of quadrature for a basis quadrature identified by an object.
  SUBROUTINE CMISSBasisQuadratureOrderSetObj(Basis,QuadratureOrder,Err)
  
    !Argument variables
    TYPE(CMISSBasisType), INTENT(INOUT) :: Basis !<The basis to set the quadrature order for.
    INTEGER(INTG), INTENT(IN) :: QuadratureOrder !<The order of quadrature in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisQuadratureOrderSetObj",Err,ERROR,*999)
    
    CALL BASIS_QUADRATURE_ORDER_SET(Basis%BASIS,QuadratureOrder,Err,ERROR,*999)

    CALL EXITS("CMISSBasisQuadratureOrderSetObj")
    RETURN
999 CALL ERRORS("CMISSBasisQuadratureOrderSetObj",Err,ERROR)
    CALL EXITS("CMISSBasisQuadratureOrderSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisQuadratureOrderSetObj
  
  !
  !================================================================================================================================
  !
  
  !>Returns the type of quadrature a basis quadrature identified by a user number.
  SUBROUTINE CMISSBasisQuadratureTypeGetNumber(UserNumber,QuadratureType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: UserNumber !<The user number of the basis to get the quadrature type for.
    INTEGER(INTG), INTENT(OUT) :: QuadratureType !<On return, the type of quadrature in the specified basis. \see OPENCMISS_QuadratureTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisQuadratureTypeGetNumber",Err,ERROR,*999)
    
    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(UserNumber,BASIS,ERR,ERROR,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_QUADRATURE_TYPE_GET(BASIS,QuadratureType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(UserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSBasisQuadratureTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSBasisQuadratureTypeGetNumber",Err,ERROR)
    CALL EXITS("CMISSBasisQuadratureTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisQuadratureTypeGetNumber
  
  !
  !================================================================================================================================
  !
  
  !>Returns the the type of quadrature for a basis quadrature identified by an object.
  SUBROUTINE CMISSBasisQuadratureTypeGetObj(Basis,QuadratureType,Err)
  
    !Argument variables
    TYPE(CMISSBasisType), INTENT(IN) :: Basis !<The basis to get the quadrature order for.
    INTEGER(INTG), INTENT(OUT) :: QuadratureType !<On return, the type of quadrature in the specified basis. \see OPENCMISS_QuadratureTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisQuadratureTypeGetObj",Err,ERROR,*999)
    
    CALL BASIS_QUADRATURE_TYPE_GET(Basis%BASIS,QuadratureType,Err,ERROR,*999)

    CALL EXITS("CMISSBasisQuadratureTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSBasisQuadratureTypeGetObj",Err,ERROR)
    CALL EXITS("CMISSBasisQuadratureTypeGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisQuadratureTypeGetObj

  !
  !================================================================================================================================
  !
  
  !>Sets/changes the type of quadrature a basis quadrature identified by a user number.
  SUBROUTINE CMISSBasisQuadratureTypeSetNumber(UserNumber,QuadratureType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: UserNumber !<The user number of the basis to get the quadrature type for.
    INTEGER(INTG), INTENT(IN) :: QuadratureType !<The type of quadrature in the specified basis to set. \see OPENCMISS_QuadratureTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisQuadratureTypeSetNumber",Err,ERROR,*999)
    
    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(UserNumber,BASIS,ERR,ERROR,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_QUADRATURE_TYPE_SET(BASIS,QuadratureType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(UserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSBasisQuadratureTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSBasisQuadratureTypeSetNumber",Err,ERROR)
    CALL EXITS("CMISSBasisQuadratureTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisQuadratureTypeSetNumber
  
  !
  !================================================================================================================================
  !
  
  !>Sets/changes the the type of quadrature for a basis quadrature identified by an object.
  SUBROUTINE CMISSBasisQuadratureTypeSetObj(Basis,QuadratureType,Err)
  
    !Argument variables
    TYPE(CMISSBasisType), INTENT(INOUT) :: Basis !<The basis to get the quadrature type for.
    INTEGER(INTG), INTENT(OUT) :: QuadratureType !<The type of quadrature in the specified basis to set. \see OPENCMISS_QuadratureTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisQuadratureTypeSetObj",Err,ERROR,*999)
    
    CALL BASIS_QUADRATURE_TYPE_SET(Basis%BASIS,QuadratureType,Err,ERROR,*999)

    CALL EXITS("CMISSBasisQuadratureTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSBasisQuadratureTypeSetObj",Err,ERROR)
    CALL EXITS("CMISSBasisQuadratureTypeSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisQuadratureTypeSetObj

  !
  !================================================================================================================================
  !
  
  !>Returns the type of a basis identified by a user number.
  SUBROUTINE CMISSBasisTypeGetNumber(UserNumber,BasisType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: UserNumber !<The user number of the basis to get the type for.
    INTEGER(INTG), INTENT(OUT) :: BasisType !<On return, the type of the specified basis. \see OPENCMISS_BasisTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisTypeGetNumber",Err,ERROR,*999)
    
    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(UserNumber,BASIS,ERR,ERROR,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_TYPE_GET(BASIS,BasisType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(UserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSBasisTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSBasisTypeGetNumber",Err,ERROR)
    CALL EXITS("CMISSBasisTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisTypeGetNumber
  
  !
  !================================================================================================================================
  !
  
  !>Returns the type of a basis identified by an object.
  SUBROUTINE CMISSBasisTypeGetObj(Basis,BasisType,Err)
  
    !Argument variables
    TYPE(CMISSBasisType), INTENT(IN) :: Basis !<The basis to get the type for.
    INTEGER(INTG), INTENT(OUT) :: BasisType !<On return, the type of the specified basis. \see OPENCMISS_BasisTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisTypeGetObj",Err,ERROR,*999)
    
    CALL BASIS_TYPE_GET(Basis%BASIS,BasisType,Err,ERROR,*999)

    CALL EXITS("CMISSBasisTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSBasisTypeGetObj",Err,ERROR)
    CALL EXITS("CMISSBasisTypeGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisTypeGetObj

  !
  !================================================================================================================================
  !
  
  !>Sets/changes the type of a basis identified by a user number.
  SUBROUTINE CMISSBasisTypeSetNumber(UserNumber,BasisType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: UserNumber !<The user number of the basis to set the type for.
    INTEGER(INTG), INTENT(IN) :: BasisType !<The type of the specified basis to set. \see OPENCMISS_BasisTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisTypeSetNumber",ERR,ERROR,*999)
    
    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(UserNumber,BASIS,ERR,ERROR,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_TYPE_SET(BASIS,BasisType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(UserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSBasisTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSBasisTypeSetNumber",Err,ERROR)
    CALL EXITS("CMISSBasisTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisTypeSetNumber
  
  !
  !================================================================================================================================
  !
  
  !>Sets/changes the type of a basis identified by an object.
  SUBROUTINE CMISSBasisTypeSetObj(Basis,BasisType,Err)
  
    !Argument variables
    TYPE(CMISSBasisType), INTENT(INOUT) :: Basis !<The basis to set the type for.
    INTEGER(INTG), INTENT(IN) :: BasisType !<The type of the specified basis to set. \see OPENCMISS_BasisTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisTypeSetObj",Err,ERROR,*999)
    
    CALL BASIS_TYPE_SET(Basis%BASIS,BasisType,Err,ERROR,*999)

    CALL EXITS("CMISSBasisTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSBasisTypeSetObj",Err,ERROR)
    CALL EXITS("CMISSBasisTypeSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBasisTypeSetObj


!!==================================================================================================================================
!!
!! BOUNDARY_CONDITIONS_ROUTINES
!!
!!==================================================================================================================================
  
  !>Destroys the boundary conditions for an equations set identified by a user number.
  SUBROUTINE CMISSBoundaryConditionsDestroyNumber(RegionUserNumber,EquationsSetUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the equations set to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to destroy the boundary conditions for.
     INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBoundaryConditionsDestroyNumber",Err,ERROR,*999)
    
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(BOUNDARY_CONDITIONS)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_BOUNDARY_CONDITIONS_GET(EQUATIONS_SET,BOUNDARY_CONDITIONS,Err,ERROR,*999)
        CALL BOUNDARY_CONDITIONS_DESTROY(BOUNDARY_CONDITIONS,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSBoundaryConditionsDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsDestroyNumber",Err,ERROR)
    CALL EXITS("CMISSBoundaryConditionsDestroyNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBoundaryConditionsDestroyNumber

  !
  !================================================================================================================================
  !
    
  !>Destroys boundary conditions identified by an object.
  SUBROUTINE CMISSBoundaryConditionsDestroyObj(BoundaryConditions,Err)
  
    !Argument variables
    TYPE(CMISSBoundaryConditionsType), INTENT(INOUT) :: BoundaryConditions !<The boundary conditions to destroy.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBoundaryConditionsDestroyObj",Err,ERROR,*999)
    
    CALL BOUNDARY_CONDITIONS_DESTROY(BoundaryConditions%BOUNDARY_CONDITIONS,Err,ERROR,*999)

    CALL EXITS("CMISSBoundaryConditionsDestroyObj")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsDestroyObj",Err,ERROR)
    CALL EXITS("CMISSBoundaryConditionsDestroyObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBoundaryConditionsDestroyObj

  !
  !================================================================================================================================
  !
  
  !>Adds to the value of the specified constant and sets this as a boundary condition on the specified constant for boundary conditions identified by a user number.
  SUBROUTINE CMISSBoundaryConditionsAddConstantNumber(RegionUserNumber,EquationsSetUserNumber,VariableType,ComponentNumber, &
    &  Condition,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the equations set to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the dependent field to add the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the dependent field to add the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: Condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditions,OPENCMISS
    REAL(DP), INTENT(IN) :: Value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBoundaryConditionsAddConstantNumber",Err,ERROR,*999)
    
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(BOUNDARY_CONDITIONS)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
       IF(ASSOCIATED(EQUATIONS_SET)) THEN
         CALL EQUATIONS_SET_BOUNDARY_CONDITIONS_GET(EQUATIONS_SET,BOUNDARY_CONDITIONS,Err,ERROR,*999)
         CALL BOUNDARY_CONDITIONS_ADD_CONSTANT(BOUNDARY_CONDITIONS,VariableType,ComponentNumber,Condition,Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSBoundaryConditionsAddConstantNumber")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsAddConstantNumber",Err,ERROR)
    CALL EXITS("CMISSBoundaryConditionsAddConstantNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBoundaryConditionsAddConstantNumber
  
  !
  !================================================================================================================================
  !
  
  !>Adds to the value of the specified constant and sets this as a boundary condition on the specified constant for boundary conditions identified by an object.
  SUBROUTINE CMISSBoundaryConditionsAddConstantObj(BoundaryConditions,VariableType,ComponentNumber,Condition,Value,Err)
    
    !Argument variables
    TYPE(CMISSBoundaryConditionsType), INTENT(IN) :: BoundaryConditions !<The boundary conditions to add the constant to.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the dependent field to set the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: Condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditions,OPENCMISS
    REAL(DP), INTENT(IN) :: Value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    
    CALL ENTERS("CMISSBoundaryConditionsAddConstantObj",Err,ERROR,*999)
  
    CALL BOUNDARY_CONDITIONS_ADD_CONSTANT(BoundaryConditions%BOUNDARY_CONDITIONS,VariableType,ComponentNumber,Condition,Value, &
      & Err,ERROR,*999)

    CALL EXITS("CMISSBoundaryConditionsAddConstantObj")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsAddConstantObj",Err,ERROR)
    CALL EXITS("CMISSBoundaryConditionsAddConstantObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBoundaryConditionsAddConstantObj
 
  !
  !================================================================================================================================
  !
  

  !>Sets the value of the specified constant as a boundary condition on the specified constant for boundary conditions identified by a user number.
  SUBROUTINE CMISSBoundaryConditionsSetConstantNumber(RegionUserNumber,EquationsSetUserNumber,VariableType,ComponentNumber, &
    & Condition,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the equations set to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the dependent field to set the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: Condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditions,OPENCMISS
    REAL(DP), INTENT(IN) :: Value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBoundaryConditionsSetConstantNumber",Err,ERROR,*999)
    
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(BOUNDARY_CONDITIONS)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_BOUNDARY_CONDITIONS_GET(EQUATIONS_SET,BOUNDARY_CONDITIONS,Err,ERROR,*999)
        CALL BOUNDARY_CONDITIONS_SET_CONSTANT(BOUNDARY_CONDITIONS,VariableType,ComponentNumber,Condition,Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSBoundaryConditionsSetConstantNumber")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsSetConstantNumber",Err,ERROR)
    CALL EXITS("CMISSBoundaryConditionsSetConstantNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBoundaryConditionsSetConstantNumber
  
  !
  !================================================================================================================================
  !
  
  !>Sets the value of the specified constant and sets this as a boundary condition on the specified constant for boundary conditions identified by an object.
  SUBROUTINE CMISSBoundaryConditionsSetConstantObj(BoundaryConditions,VariableType,ComponentNumber,Condition,Value,Err)
  
    !Argument variables
    TYPE(CMISSBoundaryConditionsType), INTENT(IN) :: BoundaryConditions !<The boundary conditions to set the constant to.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the dependent field to set the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: Condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditions,OPENCMISS
    REAL(DP), INTENT(IN) :: Value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    
    CALL ENTERS("CMISSBoundaryConditionsSetConstantObj",ERR,ERROR,*999)
  
    CALL BOUNDARY_CONDITIONS_SET_CONSTANT(BoundaryConditions%BOUNDARY_CONDITIONS,VariableType,ComponentNumber,Condition,Value, &
      & Err,ERROR,*999)

    CALL EXITS("CMISSBoundaryConditionsSetConstantObj")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsSetConstantObj",Err,ERROR)
    CALL EXITS("CMISSBoundaryConditionsSetConstantObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBoundaryConditionsSetConstantObj

  !
  !================================================================================================================================
  !
  
  !>Adds the value to the specified element and sets this as a boundary condition on the specified element for boundary conditions identified by a user number.
  SUBROUTINE CMISSBoundaryConditionsAddElementNumber(RegionUserNumber,EquationsSetUserNumber,VariableType,ElementUserNumber, &
    & ComponentNumber,Condition,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the equations set to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the dependent field to add the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: ElementUserNumber !<The user number of the element to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the dependent field to add the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: Condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditions,OPENCMISS
    REAL(DP), INTENT(IN) :: Value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBoundaryConditionsAddElementNumber",Err,ERROR,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(BOUNDARY_CONDITIONS)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_BOUNDARY_CONDITIONS_GET(EQUATIONS_SET,BOUNDARY_CONDITIONS,Err,ERROR,*999)
        CALL BOUNDARY_CONDITIONS_ADD_ELEMENT(BOUNDARY_CONDITIONS,VariableType,ElementUserNumber,ComponentNumber,Condition,Value, &
          & Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSBoundaryConditionsAddElementNumber")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsAddElementNumber",Err,ERROR)
    CALL EXITS("CMISSBoundaryConditionsAddElementNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBoundaryConditionsAddElementNumber
  
  !
  !================================================================================================================================
  !
  
  !>Adds to the value of the specified element and sets this as a boundary condition on the specified element for boundary conditions identified by an object.
  SUBROUTINE CMISSBoundaryConditionsAddElementObj(BoundaryConditions,VariableType,ElementUserNumber,ComponentNumber, &
    & Condition,Value,Err)
  
    !Argument variables
    TYPE(CMISSBoundaryConditionsType), INTENT(IN) :: BoundaryConditions !<The boundary conditions to add the element to.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the dependent field to add the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: ElementUserNumber !<The user number of the element to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: Condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditions,OPENCMISS
    REAL(DP), INTENT(IN) :: Value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBoundaryConditionsAddElementObj",Err,ERROR,*999)

    CALL BOUNDARY_CONDITIONS_ADD_ELEMENT(BoundaryConditions%BOUNDARY_CONDITIONS,VariableType,ElementUserNumber,ComponentNumber, &
      & Condition,Value,Err,ERROR,*999)

    CALL EXITS("CMISSBoundaryConditionsAddElementObj")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsAddElementObj",Err,ERROR)
    CALL EXITS("CMISSBoundaryConditionsAddElementObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBoundaryConditionsAddElementObj
 
  !
  !================================================================================================================================
  !

  !>Sets the value of the specified element as a boundary condition on the specified element for boundary conditions identified by a user number.
  SUBROUTINE CMISSBoundaryConditionsSetElementNumber(RegionUserNumber,EquationsSetUserNumber,VariableType,ElementUserNumber, &
    & ComponentNumber,Condition,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the equations set to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the dependent field to set the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: ElementUserNumber !<The user number of the element to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: Condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditions,OPENCMISS
    REAL(DP), INTENT(IN) :: Value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBoundaryConditionsSetElementNumber",Err,ERROR,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(BOUNDARY_CONDITIONS)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_BOUNDARY_CONDITIONS_GET(EQUATIONS_SET,BOUNDARY_CONDITIONS,Err,ERROR,*999)
        CALL BOUNDARY_CONDITIONS_SET_ELEMENT(BOUNDARY_CONDITIONS,VariableType,ElementUserNumber,ComponentNumber,Condition,Value, &
          & Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSBoundaryConditionsSetElementNumber")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsSetElementNumber",Err,ERROR)
    CALL EXITS("CMISSBoundaryConditionsSetElementNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBoundaryConditionsSetElementNumber
  
  !
  !================================================================================================================================
  !
  
  !>Sets the value of the specified element and sets this as a boundary condition on the specified elements for boundary conditions identified by an object.
  SUBROUTINE CMISSBoundaryConditionsSetElementObj(BoundaryConditions,VariableType,ElementUserNumber,ComponentNumber, &
    & Condition,Value,Err)
  
    !Argument variables
    TYPE(CMISSBoundaryConditionsType), INTENT(IN) :: BoundaryConditions !<The boundary conditions to set the element to.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the dependent field to set the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: ElementUserNumber !<The user number of the element to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: Condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditions,OPENCMISS
    REAL(DP), INTENT(IN) :: Value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBoundaryConditionsSetElementObj",Err,ERROR,*999)
    
    CALL BOUNDARY_CONDITIONS_SET_ELEMENT(BoundaryConditions%BOUNDARY_CONDITIONS,VariableType,ElementUserNumber,ComponentNumber, &
      & Condition,Value,Err,ERROR,*999)

    CALL EXITS("CMISSBoundaryConditionsSetElementObj")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsSetElementObj",Err,ERROR)
    CALL EXITS("CMISSBoundaryConditionsSetElementObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBoundaryConditionsSetElementObj

  !
  !================================================================================================================================
  !
  
  !>Adds the value to the specified node and sets this as a boundary condition on the specified node for boundary conditions identified by a user number.
  SUBROUTINE CMISSBoundaryConditionsAddNodeNumber(RegionUserNumber,EquationsSetUserNumber,VariableType,DerivativeNumber, &
    & NodeUserNumber,ComponentNumber,Condition,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the equations set to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the dependent field to add the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<The user number of the node derivative to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: NodeUserNumber !<The user number of the node to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the dependent field to add the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: Condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditions,OPENCMISS
    REAL(DP), INTENT(IN) :: Value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBoundaryConditionsAddNodeNumber",Err,ERROR,*999)
    
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(BOUNDARY_CONDITIONS)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_BOUNDARY_CONDITIONS_GET(EQUATIONS_SET,BOUNDARY_CONDITIONS,Err,ERROR,*999)
        CALL BOUNDARY_CONDITIONS_ADD_NODE(BOUNDARY_CONDITIONS,VariableType,DerivativeNumber,NodeUserNumber,ComponentNumber, &
          & Condition,Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSBoundaryConditionsAddNodeNumber")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsAddNodeNumber",Err,ERROR)
    CALL EXITS("CMISSBoundaryConditionsAddNodeNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBoundaryConditionsAddNodeNumber
  
  !
  !================================================================================================================================
  !
  
  !>Adds to the value of the specified node and sets this as a boundary condition on the specified node for boundary conditions identified by an object.
  SUBROUTINE CMISSBoundaryConditionsAddNodeObj(BoundaryConditions,VariableType,DerivativeNumber,NodeUserNumber,ComponentNumber, &
    & Condition,Value,Err)
  
    !Argument variables
    TYPE(CMISSBoundaryConditionsType), INTENT(IN) :: BoundaryConditions !<The boundary conditions to add the node to.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the dependent field to add the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<The user number of the node derivative to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: NodeUserNumber !<The user number of the node to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: Condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditions,OPENCMISS
    REAL(DP), INTENT(IN) :: Value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBoundaryConditionsAddNodeObj",Err,ERROR,*999)
    
    CALL BOUNDARY_CONDITIONS_ADD_NODE(BoundaryConditions%BOUNDARY_CONDITIONS,VariableType,DerivativeNumber,NodeUserNumber, &
      & ComponentNumber,Condition,Value,Err,ERROR,*999)

    CALL EXITS("CMISSBoundaryConditionsAddNodeObj")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsAddNodeObj",Err,ERROR)
    CALL EXITS("CMISSBoundaryConditionsAddNodeObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBoundaryConditionsAddNodeObj
 
  !
  !================================================================================================================================
  !

  !>Sets the value of the specified node as a boundary condition on the specified node for boundary conditions identified by a user number.
  SUBROUTINE CMISSBoundaryConditionsSetNodeNumber(RegionUserNumber,EquationsSetUserNumber,VariableType,DerivativeNumber, &
    & NodeUserNumber,ComponentNumber,Condition,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the equations set to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the dependent field to set the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<The user number of the node derivative to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: NodeUserNumber !<The user number of the node to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: Condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditions,OPENCMISS
    REAL(DP), INTENT(IN) :: Value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBoundaryConditionsSetNodeNumber",Err,ERROR,*999)
    
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(BOUNDARY_CONDITIONS)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_BOUNDARY_CONDITIONS_GET(EQUATIONS_SET,BOUNDARY_CONDITIONS,Err,ERROR,*999)
        CALL BOUNDARY_CONDITIONS_SET_NODE(BOUNDARY_CONDITIONS,VariableType,DerivativeNumber,NodeUserNumber,ComponentNumber, &
          & Condition,Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSBoundaryConditionsSetNodeNumber")
    RETURN    
999 CALL ERRORS("CMISSBoundaryConditionsSetNodeNumber",Err,ERROR)
    CALL EXITS("CMISSBoundaryConditionsSetNodeNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBoundaryConditionsSetNodeNumber
  
  !
  !================================================================================================================================
  !
  
  !>Sets the value of the specified node and sets this as a boundary condition on the specified node for boundary conditions identified by an object.
  SUBROUTINE CMISSBoundaryConditionsSetNodeObj(BoundaryConditions,VariableType,DerivativeNumber,NodeUserNumber,ComponentNumber, &
    & Condition,Value,Err)
  
    !Argument variables
    TYPE(CMISSBoundaryConditionsType), INTENT(IN) :: BoundaryConditions !<The boundary conditions to set the node to.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the dependent field to set the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<The user number of the node derivative to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: NodeUserNumber !<The user number of the node to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: Condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditions,OPENCMISS
    REAL(DP), INTENT(IN) :: Value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSBoundaryConditionsSetNodeObj",Err,ERROR,*999)
    
    CALL BOUNDARY_CONDITIONS_SET_NODE(BoundaryConditions%BOUNDARY_CONDITIONS,VariableType,DerivativeNumber,NodeUserNumber, &
      & ComponentNumber,Condition,Value,Err,ERROR,*999)

    CALL EXITS("CMISSBoundaryConditionsSetNodeObj")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsSetNodeObj",Err,ERROR)
    CALL EXITS("CMISSBoundaryConditionsSetNodeObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSBoundaryConditionsSetNodeObj

  !
  !================================================================================================================================
  !

  !>Gets the boundary conditions for an equations set identified by a user number. 
  SUBROUTINE CMISSEquationsSetBoundaryConditionsGetNumber(RegionUserNumber,EquationsSetUserNumber,BoundaryConditions,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the equations set to get the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to get the boundary conditions for.
    TYPE(CMISSBoundaryConditionsType), INTENT(OUT) :: BoundaryConditions !<On return, The boundary conditions for the specified equations set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetBoundaryConditionsGetNumber",Err,ERROR,*999)
    
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
       IF(ASSOCIATED(EQUATIONS_SET)) THEN
         CALL EQUATIONS_SET_BOUNDARY_CONDITIONS_GET(EQUATIONS_SET,BoundaryConditions%BOUNDARY_CONDITIONS,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetBoundaryConditionsGetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetBoundaryConditionsGetNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsSetBoundaryConditionsGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetBoundaryConditionsGetNumber
  
  !
  !================================================================================================================================
  !
  
  !>Gets the boundary conditions for an equations set identified by a user number. 
  SUBROUTINE CMISSEquationsSetBoundaryConditionsGetObj(EquationsSet,BoundaryConditions,Err)
  
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(IN) :: EquationsSet !<The equations set to get the boundary conditions for.
    TYPE(CMISSBoundaryConditionsType), INTENT(OUT) :: BoundaryConditions !<On return, the boundary conditions for the specified equations set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    
    CALL ENTERS("CMISSEquationsSetBoundaryConditionsGetObj",ERR,ERROR,*999)

    CALL EQUATIONS_SET_BOUNDARY_CONDITIONS_GET(EquationsSet%EQUATIONS_SET,BoundaryConditions%BOUNDARY_CONDITIONS,Err,ERROR,*999)

    CALL EXITS("CMISSEquationsSetBoundaryConditionsGetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetBoundaryConditionsGetObj",Err,ERROR)
    CALL EXITS("CMISSEquationsSetBoundaryConditionsGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetBoundaryConditionsGetObj

!!==================================================================================================================================
!!
!! CMISS_CELLML
!!
!!==================================================================================================================================

  !>Finishes the creation of a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLCreateFinishNumber(CellMLUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to finish creating.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSCellMLCreateFinishNumber",Err,ERROR,*999)
 
    NULLIFY(CELLML)
    CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,CELLML,Err,ERROR,*999)
    IF(ASSOCIATED(CELLML)) THEN
      CALL CELLML_CREATE_FINISH(CELLML,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Create')
#endif

    CALL EXITS("CMISSCellMLCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLCreateFinishNumber",Err,ERROR)
    CALL EXITS("CMISSCellMLCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLCreateFinishNumber

  !  
  !================================================================================================================================
  !  
 
  !>Finish the creation of a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLCreateFinishObj(CellML,Err)
  
    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSCellMLCreateFinishObj",Err,ERROR,*999)
 
    CALL CELLML_CREATE_FINISH(CellML%CELLML,Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Create')
#endif

    CALL EXITS("CMISSCellMLCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSCellMLCreateFinishObj",Err,ERROR)
    CALL EXITS("CMISSCellMLCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLCreateFinishObj

  !  
  !================================================================================================================================
  !  

  !>Starts the creation of a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLCreateStartNumber(CellMLUserNumber,RegionUserNumber,FieldUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to start creating.
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the field to start the CellML enviroment creation on.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the Field to start the CellML enviroment creation on.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSCellMLCreateStartNumber",Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Create')
#endif
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL CELLML_CREATE_START(CellMLUserNumber,FIELD,CELLML,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCellMLCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLCreateStartNumber",Err,ERROR)
    CALL EXITS("CMISSCellMLCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLCreateStartNumber

  !  
  !================================================================================================================================
  !  
 
  !>Start the creation of a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLCreateStartObj(CellMLUserNumber,Field,CellML,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to start creating.
    TYPE(CMISSFieldType), INTENT(INOUT) :: Field !<The (source) field to set up the CellML environment for.
    TYPE(CMISSCellMLType), INTENT(OUT) :: CellML !<On return, the created CellML environment.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSCellMLCreateStartObj",Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Create')
#endif
 
    CALL CELLML_CREATE_START(CellMLUserNumber,Field%FIELD,CellML%CELLML,Err,ERROR,*999)

    CALL EXITS("CMISSCellMLCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSCellMLCreateStartObj",Err,ERROR)
    CALL EXITS("CMISSCellMLCreateStartObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLCreateStartObj

  !  
  !================================================================================================================================
  !
  
  !>Destroys a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLDestroyNumber(CellMLUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to destroy.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSCellMLDestroyNumber",Err,ERROR,*999)
 
    NULLIFY(CELLML)
    CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,CELLML,Err,ERROR,*999)
    IF(ASSOCIATED(CELLML)) THEN
      CALL CELLML_DESTROY(CELLML,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCellMLDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLDestroyNumber",Err,ERROR)
    CALL EXITS("CMISSCellMLDestroyNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLDestroyNumber

  !  
  !================================================================================================================================
  !  
 
  !>Destroy a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLDestroyObj(CellML,Err)
  
    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to destroy.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSCellMLDestroyObj",Err,ERROR,*999)
 
    CALL CELLML_DESTROY(CellML%CELLML,Err,ERROR,*999)

    CALL EXITS("CMISSCellMLDestroyObj")
    RETURN
999 CALL ERRORS("CMISSCellMLDestroyObj",Err,ERROR)
    CALL EXITS("CMISSCellMLDestroyObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLDestroyObj

  !  
  !================================================================================================================================
  !  
 
  !>Finishes the creation of CellML modesl for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLModelsCreateFinishNumber(CellMLUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to finish creating the models for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSCellMLModelsCreateFinishNumber",Err,ERROR,*999)
 
    NULLIFY(CELLML)
    CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,CELLML,Err,ERROR,*999)
    IF(ASSOCIATED(CELLML)) THEN
      CALL CELLML_MODELS_CREATE_FINISH(CELLML,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCellMLModelsCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLModelsCreateFinishNumber",Err,ERROR)
    CALL EXITS("CMISSCellMLModelsCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLModelsCreateFinishNumber

  !  
  !================================================================================================================================
  !  
 
  !>Finish the creation of CellML models for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLModelsCreateFinishObj(CellML,Err)
  
    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to finish the creation of the models for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSCellMLModelsCreateFinishObj",Err,ERROR,*999)
 
    CALL CELLML_MODELS_CREATE_FINISH(CellML%CELLML,Err,ERROR,*999)

    CALL EXITS("CMISSCellMLModelsCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSCellMLModelsCreateFinishObj",Err,ERROR)
    CALL EXITS("CMISSCellMLModelsCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLModelsCreateFinishObj

  !  
  !================================================================================================================================
  !  

  !>Starts the creation of CellML models for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLModelsCreateStartNumber(CellMLUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to start creating the models for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSCellMLModelsCreateStartNumber",Err,ERROR,*999)
 
    NULLIFY(CELLML)
    CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,CELLML,Err,ERROR,*999)
    IF(ASSOCIATED(CELLML)) THEN
      CALL CELLML_MODELS_CREATE_START(CELLML,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCellMLModelsCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLModelsCreateStartNumber",Err,ERROR)
    CALL EXITS("CMISSCellMLModelsCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLModelsCreateStartNumber

  !  
  !================================================================================================================================
  !  
 
  !>Start the creation of CellML models for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLModelsCreateStartObj(CellML,Err)
  
    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to start the creation of models for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSCellMLModelsCreateStartObj",Err,ERROR,*999)

 
    CALL CELLML_MODELS_CREATE_START(CellML%CELLML,Err,ERROR,*999)

    CALL EXITS("CMISSCellMLModelsCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSCellMLModelsCreateStartObj",Err,ERROR)
    CALL EXITS("CMISSCellMLModelsCreateStartObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLModelsCreateStartObj

  !  
  !================================================================================================================================
  !  

  !>Imports a specified CellML model as specified by a character URI into a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLModelImportNumberC(CellMLModelUserNumber,CellMLUserNumber,URI,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to import.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to import the model into.
    CHARACTER(LEN=*), INTENT(IN) :: URI !<The URI of the CellML model to import.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSCellMLModelImportNumberC",Err,ERROR,*999)
 
    NULLIFY(CELLML)
    CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,CELLML,Err,ERROR,*999)
    IF(ASSOCIATED(CELLML)) THEN
      CALL CELLML_MODEL_IMPORT(CellMLModelUserNumber,CELLML,URI,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCellMLModelImportNumberC")
    RETURN
999 CALL ERRORS("CMISSCellMLModelImportNumberC",Err,ERROR)
    CALL EXITS("CMISSCellMLModelImportNumberC")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLModelImportNumberC

  !  
  !================================================================================================================================
  !  
 
  !>Imports a specified CellML model as specified by a character URI into a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLModelImportObjC(CellMLModelUserNumber,CellML,URI,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to import.
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to import the model into.
    CHARACTER(LEN=*), INTENT(IN) :: URI !<The URI of the CellML model to import.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSCellMLModelImportObjC",Err,ERROR,*999)
 
    CALL CELLML_MODEL_IMPORT(CellMLModelUserNumber,CellML%CELLML,URI,Err,ERROR,*999)

    CALL EXITS("CMISSCellMLModelImportObjC")
    RETURN
999 CALL ERRORS("CMISSCellMLModelImportObjC",Err,ERROR)
    CALL EXITS("CMISSCellMLModelImportObjC")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLModelImportObjC

  !  
  !================================================================================================================================
  !  

  !>Imports a specified CellML model as specified by a varying string URI into a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLModelImportNumberVS(CellMLModelUserNumber,CellMLUserNumber,URI,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to import.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to import the model into.
    TYPE(VARYING_STRING), INTENT(IN) :: URI !<The URI of the CellML model to import.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSCellMLModelImportNumberVS",Err,ERROR,*999)
 
    NULLIFY(CELLML)
    CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,CELLML,Err,ERROR,*999)
    IF(ASSOCIATED(CELLML)) THEN
      CALL CELLML_MODEL_IMPORT(CellMLModelUserNumber,CELLML,CHAR(URI),Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCellMLModelImportNumberVS")
    RETURN
999 CALL ERRORS("CMISSCellMLModelImportNumberVS",Err,ERROR)
    CALL EXITS("CMISSCellMLModelImportNumberVS")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLModelImportNumberVS

  !  
  !================================================================================================================================
  !  
 
  !>Imports a specified CellML model as specified by a varying string URI into a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLModelImportObjVS(CellMLModelUserNumber,CellML,URI,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to import.
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to import the model into.
    TYPE(VARYING_STRING), INTENT(IN) :: URI !<The URI of the CellML model to import.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSCellMLModelImportObjVS",Err,ERROR,*999)
 
    CALL CELLML_MODEL_IMPORT(CellMLModelUserNumber,CellML%CELLML,CHAR(URI),Err,ERROR,*999)

    CALL EXITS("CMISSCellMLModelImportObjVS")
    RETURN
999 CALL ERRORS("CMISSCellMLModelImportObjVS",Err,ERROR)
    CALL EXITS("CMISSCellMLModelImportObjVS")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLModelImportObjVS

  !  
  !================================================================================================================================
  !  
 
  !>Finishes the creation of CellML models field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLModelsFieldCreateFinishNumber(CellMLUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to finish creating the models field for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSCellMLModelsFieldCreateFinishNumber",Err,ERROR,*999)
 
    NULLIFY(CELLML)
    CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,CELLML,Err,ERROR,*999)
    IF(ASSOCIATED(CELLML)) THEN
      CALL CELLML_MODELS_FIELD_CREATE_FINISH(CELLML,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCellMLModelsFieldCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLModelsFieldCreateFinishNumber",Err,ERROR)
    CALL EXITS("CMISSCellMLModelsFieldCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLModelsFieldCreateFinishNumber

  !  
  !================================================================================================================================
  !  
 
  !>Finish the creation of CellML models field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLModelsFieldCreateFinishObj(CellML,Err)
  
    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to finish the creation of the models field for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSCellMLModelsFieldCreateFinishObj",Err,ERROR,*999)
 
    CALL CELLML_MODELS_FIELD_CREATE_FINISH(CellML%CELLML,Err,ERROR,*999)

    CALL EXITS("CMISSCellMLModelsFieldCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSCellMLModelsFieldCreateFinishObj",Err,ERROR)
    CALL EXITS("CMISSCellMLModelsFieldCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLModelsFieldCreateFinishObj

  !  
  !================================================================================================================================
  !  

  !>Starts the creation of CellML models field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLModelsFieldCreateStartNumber(CellMLModelsFieldUserNumber,CellMLUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLModelsFieldUserNumber !<The user number of the CellML models field to start creating.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML environment to start creating the models field for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSCellMLModelsFieldCreateStartNumber",Err,ERROR,*999)
 
    NULLIFY(FIELD)
    NULLIFY(CELLML)
    CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,CELLML,Err,ERROR,*999)
    IF(ASSOCIATED(CELLML)) THEN
      CALL CELLML_MODELS_FIELD_CREATE_START(CellMLModelsFieldUserNumber,CELLML,FIELD,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCellMLModelsFieldCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLModelsFieldCreateStartNumber",Err,ERROR)
    CALL EXITS("CMISSCellMLModelsFieldCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLModelsFieldCreateStartNumber

  !  
  !================================================================================================================================
  !  
 
  !>Start the creation of CellML models field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLModelsFieldCreateStartObj(CellMLModelsFieldUserNumber,CellML,Field,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLModelsFieldUserNumber !<The user number of the CellML models field to start creating.
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to start the creation of models field for.
    TYPE(CMISSFieldType), INTENT(INOUT) :: Field !<On return, the created CellML models field.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSCellMLModelsFieldCreateStartObj",Err,ERROR,*999)
 
    CALL CELLML_MODELS_FIELD_CREATE_START(CellMLModelsFieldUserNumber,CellML%CELLML,Field%FIELD,Err,ERROR,*999)

    CALL EXITS("CMISSCellMLModelsFieldCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSCellMLModelsFieldCreateStartObj",Err,ERROR)
    CALL EXITS("CMISSCellMLModelsFieldCreateStartObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLModelsFieldCreateStartObj

  !  
  !================================================================================================================================
  !  
 
  !>Returns the CellML models field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLModelsFieldGetNumber(CellMLUserNumber,CellMLModelsFieldUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to get the CellML models field for.
    INTEGER(INTG), INTENT(OUT) :: CellMLModelsFieldUserNumber !<On return, the user number of the CellML models field.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSCellMLModelsFieldGetNumber",Err,ERROR,*999)
 
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,CELLML,Err,ERROR,*999)
    IF(ASSOCIATED(CELLML)) THEN
      CALL CELLML_MODELS_FIELD_GET(CELLML,FIELD,Err,ERROR,*999)
      CellMLModelsFieldUserNumber = FIELD%USER_NUMBER
    ELSE
      LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCellMLModelsFieldGetNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLModelsFieldGetNumber",Err,ERROR)
    CALL EXITS("CMISSCellMLModelsFieldGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLModelsFieldGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the CellML models field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLModelsFieldGetObj(CellML,Field,Err)
  
    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to get the models field for.
    TYPE(CMISSFieldType), INTENT(INOUT) :: Field !<On return, the CellML models field. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSCellMLModelsFieldGetObj",Err,ERROR,*999)
 
    CALL CELLML_MODELS_FIELD_GET(CellML%CELLML,Field%FIELD,Err,ERROR,*999)

    CALL EXITS("CMISSCellMLModelsFieldGetObj")
    RETURN
999 CALL ERRORS("CMISSCellMLModelsFieldGetObj",Err,ERROR)
    CALL EXITS("CMISSCellMLModelsFieldGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLModelsFieldGetObj
 
  !  
  !================================================================================================================================
  !  
 
  !>Finishes the creation of CellML state field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLStateFieldCreateFinishNumber(CellMLUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to finish creating the state field for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSCellMLStateFieldCreateFinishNumber",Err,ERROR,*999)
 
    NULLIFY(CELLML)
    CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,CELLML,Err,ERROR,*999)
    IF(ASSOCIATED(CELLML)) THEN
      CALL CELLML_STATE_FIELD_CREATE_FINISH(CELLML,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCellMLStateFieldCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLStateFieldCreateFinishNumber",Err,ERROR)
    CALL EXITS("CMISSCellMLStateFieldCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLStateFieldCreateFinishNumber

  !  
  !================================================================================================================================
  !  
 
  !>Finish the creation of CellML state field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLStateFieldCreateFinishObj(CellML,Err)
  
    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to finish the creation of the state field for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSCellMLStateFieldCreateFinishObj",Err,ERROR,*999)
 
    CALL CELLML_STATE_FIELD_CREATE_FINISH(CellML%CELLML,Err,ERROR,*999)

    CALL EXITS("CMISSCellMLStateFieldCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSCellMLStateFieldCreateFinishObj",Err,ERROR)
    CALL EXITS("CMISSCellMLStateFieldCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLStateFieldCreateFinishObj

  !  
  !================================================================================================================================
  !  

  !>Starts the creation of CellML state field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLStateFieldCreateStartNumber(CellMLStateFieldUserNumber,CellMLUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLStateFieldUserNumber !<The user number of the CellML state field to start creating.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML environment to start creating the state field for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSCellMLStateFieldCreateStartNumber",Err,ERROR,*999)
 
    NULLIFY(FIELD)
    NULLIFY(CELLML)
    CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,CELLML,Err,ERROR,*999)
    IF(ASSOCIATED(CELLML)) THEN
      CALL CELLML_STATE_FIELD_CREATE_START(CellMLStateFieldUserNumber,CELLML,FIELD,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCellMLStateFieldCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLStateFieldCreateStartNumber",Err,ERROR)
    CALL EXITS("CMISSCellMLStateFieldCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLStateFieldCreateStartNumber

  !  
  !================================================================================================================================
  !  
 
  !>Start the creation of CellML state field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLStateFieldCreateStartObj(CellMLStateFieldUserNumber,CellML,Field,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLStateFieldUserNumber !<The user number of the CellML state field to start creating.
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to start the creation of state field for.
    TYPE(CMISSFieldType), INTENT(INOUT) :: Field !<On return, the created CellML state field.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSCellMLStateFieldCreateStartObj",Err,ERROR,*999)
 
    CALL CELLML_STATE_FIELD_CREATE_START(CellMLStateFieldUserNumber,CellML%CELLML,Field%FIELD,Err,ERROR,*999)

    CALL EXITS("CMISSCellMLStateFieldCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSCellMLStateFieldCreateStartObj",Err,ERROR)
    CALL EXITS("CMISSCellMLStateFieldCreateStartObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLStateFieldCreateStartObj

  !  
  !================================================================================================================================
  !  
 
  !>Returns the CellML state field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLStateFieldGetNumber(CellMLUserNumber,CellMLStateFieldUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to get the CellML state field for.
    INTEGER(INTG), INTENT(OUT) :: CellMLStateFieldUserNumber !<On return, the user number of the CellML state field.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSCellMLStateFieldGetNumber",Err,ERROR,*999)
 
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,CELLML,Err,ERROR,*999)
    IF(ASSOCIATED(CELLML)) THEN
      CALL CELLML_STATE_FIELD_GET(CELLML,FIELD,Err,ERROR,*999)
      CellMLStateFieldUserNumber = FIELD%USER_NUMBER
    ELSE
      LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCellMLStateFieldGetNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLStateFieldGetNumber",Err,ERROR)
    CALL EXITS("CMISSCellMLStateFieldGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLStateFieldGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the CellML state field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLStateFieldGetObj(CellML,Field,Err)
  
    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to get the state field for.
    TYPE(CMISSFieldType), INTENT(INOUT) :: Field !<On return, the CellML state field.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSCellMLStateFieldGetObj",Err,ERROR,*999)
 
    CALL CELLML_STATE_FIELD_GET(CellML%CELLML,Field%FIELD,Err,ERROR,*999)

    CALL EXITS("CMISSCellMLStateFieldGetObj")
    RETURN
999 CALL ERRORS("CMISSCellMLStateFieldGetObj",Err,ERROR)
    CALL EXITS("CMISSCellMLStateFieldGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLStateFieldGetObj
 
  !  
  !================================================================================================================================
  !  
 
  !>Returns the field component number that corresponds to a character string URI for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLFieldComponentGetNumberC(CellMLUserNumber,CellMLFieldType,URI,FieldComponent,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to get the field component for.
    INTEGER(INTG), INTENT(IN) :: CellMLFieldType !<The type of CellML field to get the component for. \see OPENCMISS_CellMLFieldTypes,OPENCMISS
    CHARACTER(LEN=*), INTENT(IN) :: URI !<The URI to get the corresponding field component for.
    INTEGER(INTG), INTENT(OUT) :: FieldComponent !<On return, the field component corresponding to the URI.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSCellMLFieldComponentGetNumberC",Err,ERROR,*999)
 
    NULLIFY(CELLML)
    CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,CELLML,Err,ERROR,*999)
    IF(ASSOCIATED(CELLML)) THEN
      CALL CELLML_FIELD_COMPONENT_GET(CELLML,CellMLFieldType,URI,FieldComponent,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCellMLFieldComponentGetNumberC")
    RETURN
999 CALL ERRORS("CMISSCellMLFieldComponentGetNumberC",Err,ERROR)
    CALL EXITS("CMISSCellMLFieldComponentGetNumberC")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLFieldComponentGetNumberC

  !  
  !================================================================================================================================
  !  
 
  !>Returns the field component number that corresponds to a character string URI for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLFieldComponentGetObjC(CellML,CellMLFieldType,URI,FieldComponent,Err)
  
    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to get the field component for.
    INTEGER(INTG), INTENT(IN) :: CellMLFieldType !<The type of CellML field to get the component for. \see OPENCMISS_CellMLFieldTypes,OPENCMISS
    CHARACTER(LEN=*), INTENT(IN) :: URI !<The URI to get the corresponding field component for.
    INTEGER(INTG), INTENT(OUT) :: FieldComponent !<On return, the field component corresponding to the URI.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSCellMLFieldComponentGetObjC",Err,ERROR,*999)
 
    CALL CELLML_FIELD_COMPONENT_GET(CellML%CELLML,CellMLFieldType,URI,FieldComponent,Err,ERROR,*999)

    CALL EXITS("CMISSCellMLFieldComponentGetObjC")
    RETURN
999 CALL ERRORS("CMISSCellMLFieldComponentGetObjC",Err,ERROR)
    CALL EXITS("CMISSCellMLFieldComponentGetObjC")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLFieldComponentGetObjC
 
  !  
  !================================================================================================================================
  !  
 
  !>Returns the field component number that corresponds to a varying string URI for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLFieldComponentGetNumberVS(CellMLUserNumber,CellMLFieldType,URI,FieldComponent,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to get the field component for.
    INTEGER(INTG), INTENT(IN) :: CellMLFieldType !<The type of CellML field to get the component for. \see OPENCMISS_CellMLFieldTypes,OPENCMISS
    TYPE(VARYING_STRING), INTENT(IN) :: URI !<The URI to get the corresponding field component for.
    INTEGER(INTG), INTENT(OUT) :: FieldComponent !<On return, the field component corresponding to the URI.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSCellMLFieldComponentGetNumberVS",Err,ERROR,*999)
 
    NULLIFY(CELLML)
    CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,CELLML,Err,ERROR,*999)
    IF(ASSOCIATED(CELLML)) THEN
      CALL CELLML_FIELD_COMPONENT_GET(CELLML,CellMLFieldType,URI,FieldComponent,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCellMLFieldComponentGetNumberVS")
    RETURN
999 CALL ERRORS("CMISSCellMLFieldComponentGetNumberVS",Err,ERROR)
    CALL EXITS("CMISSCellMLFieldComponentGetNumberVS")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLFieldComponentGetNumberVS

  !  
  !================================================================================================================================
  !  
 
  !>Returns the field component number that corresponds to a varying string URI for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLFieldComponentGetObjVS(CellML,CellMLFieldType,URI,FieldComponent,Err)
  
    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to get the field component for.
    INTEGER(INTG), INTENT(IN) :: CellMLFieldType !<The type of CellML field to get the component for. \see OPENCMISS_CellMLFieldTypes,OPENCMISS
    TYPE(VARYING_STRING), INTENT(IN) :: URI !<The URI to get the corresponding field component for.
    INTEGER(INTG), INTENT(OUT) :: FieldComponent !<On return, the field component corresponding to the URI.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSCellMLFieldComponentGetObjVS",Err,ERROR,*999)
 
    CALL CELLML_FIELD_COMPONENT_GET(CellML%CELLML,CellMLFieldType,URI,FieldComponent,Err,ERROR,*999)

    CALL EXITS("CMISSCellMLFieldComponentGetObjVS")
    RETURN
999 CALL ERRORS("CMISSCellMLFieldComponentGetObjVS",Err,ERROR)
    CALL EXITS("CMISSCellMLFieldComponentGetObjVS")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLFieldComponentGetObjVS
 
  !  
  !================================================================================================================================
  !  
 
  !>Adds a specific variable to a CellML intermediate field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLIntermediateFieldAddNumberC(CellMLUserNumber,CellMLModelUserNumber,URI,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to add to the intermediate field for.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to add to the intermediate field for
    CHARACTER(LEN=*), INTENT(IN) :: URI !<The URI of the model variable to add to the intermediate field for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSCellMLIntermediateFieldAddNumberC",Err,ERROR,*999)
 
    NULLIFY(CELLML)
     CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,CELLML,Err,ERROR,*999)
    IF(ASSOCIATED(CELLML)) THEN
      CALL CELLML_INTERMEDIATE_FIELD_ADD(CELLML,CellMLModelUserNumber,URI,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCellMLIntermediateFieldAddNumberC")
    RETURN
999 CALL ERRORS("CMISSCellMLIntermediateFieldAddNumberC",Err,ERROR)
    CALL EXITS("CMISSCellMLIntermediateFieldAddNumberC")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLIntermediateFieldAddNumberC

  !  
  !================================================================================================================================
  !  
 
  !>Adds a specific variable to a CellML intermediate field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLIntermediateFieldAddObjC(CellML,CellMLModelUserNumber,URI,Err)
  
    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to add to the intermediate field for.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to add to the intermediate field for
    CHARACTER(LEN=*), INTENT(IN) :: URI !<The URI of the model variable to add to the intermediate field for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSCellMLIntermediateFieldAddObjC",Err,ERROR,*999)
 
    CALL CELLML_INTERMEDIATE_FIELD_ADD(CellML%CELLML,CellMLModelUserNumber,URI,Err,ERROR,*999)

    CALL EXITS("CMISSCellMLIntermediateFieldAddObjC")
    RETURN
999 CALL ERRORS("CMISSCellMLIntermediateFieldAddObjC",Err,ERROR)
    CALL EXITS("CMISSCellMLIntermediateFieldAddObjC")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLIntermediateFieldAddObjC
 
  !  
  !================================================================================================================================
  !  
 
  !>Adds a specific variable to a CellML intermediate field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLIntermediateFieldAddNumberVS(CellMLUserNumber,CellMLModelUserNumber,URI,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to add to the intermediate field for.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to add to the intermediate field for
    TYPE(VARYING_STRING), INTENT(IN) :: URI !<The URI of the model variable to add to the intermediate field for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSCellMLIntermediateFieldAddNumberVS",Err,ERROR,*999)
 
    NULLIFY(CELLML)
    CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,CELLML,Err,ERROR,*999)
    IF(ASSOCIATED(CELLML)) THEN
      CALL CELLML_INTERMEDIATE_FIELD_ADD(CELLML,CellMLModelUserNumber,URI,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCellMLIntermediateFieldAddNumberVS")
    RETURN
999 CALL ERRORS("CMISSCellMLIntermediateFieldAddNumberVS",Err,ERROR)
    CALL EXITS("CMISSCellMLIntermediateFieldAddNumberVS")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLIntermediateFieldAddNumberVS

  !  
  !================================================================================================================================
  !  
 
  !>Adds a specific variable to a CellML intermediate field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLIntermediateFieldAddObjVS(CellML,CellMLModelUserNumber,URI,Err)
  
    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to add to the intermediate field for.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to add to the intermediate field for
    TYPE(VARYING_STRING), INTENT(IN) :: URI !<The URI of the model variable to add to the intermediate field for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSCellMLIntermediateFieldAddObjVS",Err,ERROR,*999)
 
    CALL CELLML_INTERMEDIATE_FIELD_ADD(CellML%CELLML,CellMLModelUserNumber,URI,Err,ERROR,*999)

    CALL EXITS("CMISSCellMLIntermediateFieldAddObjVS")
    RETURN
999 CALL ERRORS("CMISSCellMLIntermediateFieldAddObjVS",Err,ERROR)
    CALL EXITS("CMISSCellMLIntermediateFieldAddObjVS")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLIntermediateFieldAddObjVS
 
  !  
  !================================================================================================================================
  !  
 
  !>Finishes the creation of CellML intermediate field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLIntermediateFieldCreateFinishNumber(CellMLUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to finish creating the intermediate field for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSCellMLIntermediateFieldCreateFinishNumber",Err,ERROR,*999)
 
    NULLIFY(CELLML)
    CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,CELLML,Err,ERROR,*999)
    IF(ASSOCIATED(CELLML)) THEN
      CALL CELLML_INTERMEDIATE_FIELD_CREATE_FINISH(CELLML,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCellMLIntermediateFieldCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLIntermediateFieldCreateFinishNumber",Err,ERROR)
    CALL EXITS("CMISSCellMLIntermediateFieldCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLIntermediateFieldCreateFinishNumber

  !  
  !================================================================================================================================
  !  
 
  !>Finish the creation of CellML intermediate field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLIntermediateFieldCreateFinishObj(CellML,Err)
  
    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to finish the creation of the intermediate field for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSCellMLIntermediateFieldCreateFinishObj",Err,ERROR,*999)
 
    CALL CELLML_INTERMEDIATE_FIELD_CREATE_FINISH(CellML%CELLML,Err,ERROR,*999)

    CALL EXITS("CMISSCellMLIntermediateFieldCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSCellMLIntermediateFieldCreateFinishObj",Err,ERROR)
    CALL EXITS("CMISSCellMLIntermediateFieldCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLIntermediateFieldCreateFinishObj

  !  
  !================================================================================================================================
  !  

  !>Starts the creation of CellML intermediate field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLIntermediateFieldCreateStartNumber(CellMLIntermediateFieldUserNumber,CellMLUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLIntermediateFieldUserNumber !<The user number of the CellML intermediate field to start creating.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML environment to start creating the intermediate field for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSCellMLIntermediateFieldCreateStartNumber",Err,ERROR,*999)
 
    NULLIFY(FIELD)
    NULLIFY(CELLML)
    CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,CELLML,Err,ERROR,*999)
    IF(ASSOCIATED(CELLML)) THEN
      CALL CELLML_INTERMEDIATE_FIELD_CREATE_START(CellMLIntermediateFieldUserNumber,CELLML,FIELD,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCellMLIntermediateFieldCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLIntermediateFieldCreateStartNumber",Err,ERROR)
    CALL EXITS("CMISSCellMLIntermediateFieldCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLIntermediateFieldCreateStartNumber

  !  
  !================================================================================================================================
  !  
 
  !>Start the creation of CellML intermediate field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLIntermediateFieldCreateStartObj(CellMLIntermediateFieldUserNumber,CellML,Field,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLIntermediateFieldUserNumber !<The user number of the CellML intermediate field to start creating.
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to start the creation of intermediate field for.
    TYPE(CMISSFieldType), INTENT(INOUT) :: Field !<On return, the created CellML intermediate field.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSCellMLIntermediateFieldCreateStartObj",Err,ERROR,*999)
 
    CALL CELLML_INTERMEDIATE_FIELD_CREATE_START(CellMLIntermediateFieldUserNumber,CellML%CELLML,Field%FIELD,Err,ERROR,*999)

    CALL EXITS("CMISSCellMLIntermediateFieldCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSCellMLIntermediateFieldCreateStartObj",Err,ERROR)
    CALL EXITS("CMISSCellMLIntermediateFieldCreateStartObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLIntermediateFieldCreateStartObj

  !  
  !================================================================================================================================
  !  
 
  !>Returns the CellML intermediate field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLIntermediateFieldGetNumber(CellMLUserNumber,CellMLIntermediateFieldUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to get the CellML intermediate field for.
    INTEGER(INTG), INTENT(OUT) :: CellMLIntermediateFieldUserNumber !<On return, the user number of the CellML intermediate field.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSCellMLIntermediateFieldGetNumber",Err,ERROR,*999)
 
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,CELLML,Err,ERROR,*999)
    IF(ASSOCIATED(CELLML)) THEN
      CALL CELLML_INTERMEDIATE_FIELD_GET(CELLML,FIELD,Err,ERROR,*999)
      CellMLIntermediateFieldUserNumber = FIELD%USER_NUMBER
    ELSE
      LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCellMLIntermediateFieldGetNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLIntermediateFieldGetNumber",Err,ERROR)
    CALL EXITS("CMISSCellMLIntermediateFieldGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLIntermediateFieldGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the CellML intermediate field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLIntermediateFieldGetObj(CellML,Field,Err)
  
    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to get the intermediate field for.
    TYPE(CMISSFieldType), INTENT(INOUT) :: Field !<On return, the CellML intermediate field.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSCellMLIntermediateFieldGetObj",Err,ERROR,*999)
 
    CALL CELLML_INTERMEDIATE_FIELD_GET(CellML%CELLML,Field%FIELD,Err,ERROR,*999)

    CALL EXITS("CMISSCellMLIntermediateFieldGetObj")
    RETURN
999 CALL ERRORS("CMISSCellMLIntermediateFieldGetObj",Err,ERROR)
    CALL EXITS("CMISSCellMLIntermediateFieldGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLIntermediateFieldGetObj
 
  !  
  !================================================================================================================================
  !  
 
  !>Override a specific parameter variable from a model in a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLParameterAddNumberC(CellMLUserNumber,CellMLModelUserNumber,URI,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to add to the parameters for.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to add to the parameters for
    CHARACTER(LEN=*), INTENT(IN) :: URI !<The URI of the parameter variable to add.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSCellMLParameterAddNumberC",Err,ERROR,*999)
 
    NULLIFY(CELLML)
     CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,CELLML,Err,ERROR,*999)
    IF(ASSOCIATED(CELLML)) THEN
      CALL CELLML_PARAMETER_ADD(CELLML,CellMLModelUserNumber,URI,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCellMLParameterAddNumberC")
    RETURN
999 CALL ERRORS("CMISSCellMLParameterAddNumberC",Err,ERROR)
    CALL EXITS("CMISSCellMLParameterAddNumberC")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLParameterAddNumberC

  !  
  !================================================================================================================================
  !  
 
  !>Override a specific parameter variable from a model in a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLParameterAddObjC(CellML,CellMLModelUserNumber,URI,Err)
  
    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to add the parameter for.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to add to the parameters for
    CHARACTER(LEN=*), INTENT(IN) :: URI !<The URI of the parameter variable to add.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSCellMLParameterAddObjC",Err,ERROR,*999)
 
    CALL CELLML_PARAMETER_ADD(CellML%CELLML,CellMLModelUserNumber,URI,Err,ERROR,*999)

    CALL EXITS("CMISSCellMLParameterAddObjC")
    RETURN
999 CALL ERRORS("CMISSCellMLParameterAddObjC",Err,ERROR)
    CALL EXITS("CMISSCellMLParameterAddObjC")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLParameterAddObjC
 
  !  
  !================================================================================================================================
  !  
 
  !>Override a specific parameter variable from a model in a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLParameterAddNumberVS(CellMLUserNumber,CellMLModelUserNumber,URI,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to add to the parameters for.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to add to the parameters for
    TYPE(VARYING_STRING), INTENT(IN) :: URI !<The URI of the parameter variable to add.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSCellMLParameterAddNumberVS",Err,ERROR,*999)
 
    NULLIFY(CELLML)
     CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,CELLML,Err,ERROR,*999)
    IF(ASSOCIATED(CELLML)) THEN
      CALL CELLML_PARAMETER_ADD(CELLML,CellMLModelUserNumber,URI,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCellMLParameterAddNumberVS")
    RETURN
999 CALL ERRORS("CMISSCellMLParameterAddNumberVS",Err,ERROR)
    CALL EXITS("CMISSCellMLParameterAddNumberVS")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLParameterAddNumberVS

  !  
  !================================================================================================================================
  !  
 
  !>Override a specific parameter variable from a model in a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLParameterAddObjVS(CellML,CellMLModelUserNumber,URI,Err)
  
    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to add the parameter for.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to add to the parameters for
    TYPE(VARYING_STRING), INTENT(IN) :: URI !<The URI of the parameter variable to add.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSCellMLParameterAddObjVS",Err,ERROR,*999)
 
    CALL CELLML_PARAMETER_ADD(CellML%CELLML,CellMLModelUserNumber,URI,Err,ERROR,*999)

    CALL EXITS("CMISSCellMLParameterAddObjVS")
    RETURN
999 CALL ERRORS("CMISSCellMLParameterAddObjVS",Err,ERROR)
    CALL EXITS("CMISSCellMLParameterAddObjVS")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLParameterAddObjVS
 
  !  
  !================================================================================================================================
  !  
 
  !>Finishes the creation of CellML parameters for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLParametersCreateFinishNumber(CellMLUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to finish creating the parameters for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSCellMLParametersCreateFinishNumber",Err,ERROR,*999)
 
    NULLIFY(CELLML)
    CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,CELLML,Err,ERROR,*999)
    IF(ASSOCIATED(CELLML)) THEN
      CALL CELLML_PARAMETERS_CREATE_FINISH(CELLML,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCellMLParametersCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLParametersCreateFinishNumber",Err,ERROR)
    CALL EXITS("CMISSCellMLParametersCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLParametersCreateFinishNumber

  !  
  !================================================================================================================================
  !  
 
  !>Finish the creation of CellML parameters for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLParametersCreateFinishObj(CellML,Err)
  
    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to finish the creation of the parameters for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSCellMLParametersCreateFinishObj",Err,ERROR,*999)
 
    CALL CELLML_PARAMETERS_CREATE_FINISH(CellML%CELLML,Err,ERROR,*999)

    CALL EXITS("CMISSCellMLParametersCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSCellMLParametersCreateFinishObj",Err,ERROR)
    CALL EXITS("CMISSCellMLParametersCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLParametersCreateFinishObj

  !  
  !================================================================================================================================
  !  

  !>Starts the creation of CellML parameters for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLParametersCreateStartNumber(CellMLUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to start creating the parameters for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSCellMLParametersCreateStartNumber",Err,ERROR,*999)
 
    NULLIFY(CELLML)
    CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,CELLML,Err,ERROR,*999)
    IF(ASSOCIATED(CELLML)) THEN
      CALL CELLML_PARAMETERS_CREATE_START(CELLML,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCellMLParametersCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLParametersCreateStartNumber",Err,ERROR)
    CALL EXITS("CMISSCellMLParametersCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLParametersCreateStartNumber

  !  
  !================================================================================================================================
  !  
 
  !>Start the creation of CellML parameters for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLParametersCreateStartObj(CellML,Err)
  
    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to start the creation of parameters for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSCellMLParametersCreateStartObj",Err,ERROR,*999)
 
    CALL CELLML_PARAMETERS_CREATE_START(CellML%CELLML,Err,ERROR,*999)

    CALL EXITS("CMISSCellMLParametersCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSCellMLParametersCreateStartObj",Err,ERROR)
    CALL EXITS("CMISSCellMLParametersCreateStartObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLParametersCreateStartObj

  !  
  !================================================================================================================================
  !  
 
  !>Finishes the creation of CellML parameters field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLParametersFieldCreateFinishNumber(CellMLUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to finish creating the parameters field for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSCellMLParametersFieldCreateFinishNumber",Err,ERROR,*999)
 
    NULLIFY(CELLML)
    CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,CELLML,Err,ERROR,*999)
    IF(ASSOCIATED(CELLML)) THEN
      CALL CELLML_PARAMETERS_FIELD_CREATE_FINISH(CELLML,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCellMLParametersFieldCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLParametersFieldCreateFinishNumber",Err,ERROR)
    CALL EXITS("CMISSCellMLParametersFieldCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLParametersFieldCreateFinishNumber

  !  
  !================================================================================================================================
  !  
 
  !>Finish the creation of CellML parameters field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLParametersFieldCreateFinishObj(CellML,Err)
  
    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to finish the creation of the parameters field for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSCellMLParametersFieldCreateFinishObj",Err,ERROR,*999)
 
    CALL CELLML_PARAMETERS_FIELD_CREATE_FINISH(CellML%CELLML,Err,ERROR,*999)

    CALL EXITS("CMISSCellMLParametersFieldCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSCellMLParametersFieldCreateFinishObj",Err,ERROR)
    CALL EXITS("CMISSCellMLParametersFieldCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLParametersFieldCreateFinishObj

  !  
  !================================================================================================================================
  !  

  !>Starts the creation of CellML parameters field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLParametersFieldCreateStartNumber(CellMLParametersFieldUserNumber,CellMLUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLParametersFieldUserNumber !<The user number of the CellML parameters field to start creating.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML environment to start creating the parameters field for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSCellMLParametersFieldCreateStartNumber",Err,ERROR,*999)
 
    NULLIFY(FIELD)
    NULLIFY(CELLML)
    CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,CELLML,Err,ERROR,*999)
    IF(ASSOCIATED(CELLML)) THEN
      CALL CELLML_PARAMETERS_FIELD_CREATE_START(CellMLParametersFieldUserNumber,CELLML,FIELD,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCellMLParametersFieldCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLParametersFieldCreateStartNumber",Err,ERROR)
    CALL EXITS("CMISSCellMLParametersFieldCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLParametersFieldCreateStartNumber

  !  
  !================================================================================================================================
  !  
 
  !>Start the creation of CellML parameters field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLParametersFieldCreateStartObj(CellMLParametersFieldUserNumber,CellML,Field,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLParametersFieldUserNumber !<The user number of the CellML parameters field to start creating.
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to start the creation of parameters field for.
    TYPE(CMISSFieldType), INTENT(INOUT) :: Field !<On return, the created CellML parameters field.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSCellMLParametersFieldCreateStartObj",Err,ERROR,*999)
 
    CALL CELLML_PARAMETERS_FIELD_CREATE_START(CellMLParametersFieldUserNumber,CellML%CELLML,Field%FIELD,Err,ERROR,*999)

    CALL EXITS("CMISSCellMLParametersFieldCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSCellMLParametersFieldCreateStartObj",Err,ERROR)
    CALL EXITS("CMISSCellMLParametersFieldCreateStartObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLParametersFieldCreateStartObj

  !  
  !================================================================================================================================
  !  
 
  !>Returns the CellML parameters field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLParametersFieldGetNumber(CellMLUserNumber,CellMLParametersFieldUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to get the CellML parameters field for.
    INTEGER(INTG), INTENT(OUT) :: CellMLParametersFieldUserNumber !<On return, the user number of the CellML parameters field.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSCellMLParametersFieldGetNumber",Err,ERROR,*999)
 
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,CELLML,Err,ERROR,*999)
    IF(ASSOCIATED(CELLML)) THEN
      CALL CELLML_PARAMETERS_FIELD_GET(CELLML,FIELD,Err,ERROR,*999)
      CellMLParametersFieldUserNumber = FIELD%USER_NUMBER
    ELSE
      LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCellMLParametersFieldGetNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLParametersFieldGetNumber",Err,ERROR)
    CALL EXITS("CMISSCellMLParametersFieldGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLParametersFieldGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the CellML parameters field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLParametersFieldGetObj(CellML,Field,Err)
  
    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to get the parameters field for.
    TYPE(CMISSFieldType), INTENT(INOUT) :: Field !<On return, the CellML parameters field.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSCellMLParametersFieldGetObj",Err,ERROR,*999)
 
    CALL CELLML_PARAMETERS_FIELD_GET(CellML%CELLML,Field%FIELD,Err,ERROR,*999)

    CALL EXITS("CMISSCellMLParametersFieldGetObj")
    RETURN
999 CALL ERRORS("CMISSCellMLParametersFieldGetObj",Err,ERROR)
    CALL EXITS("CMISSCellMLParametersFieldGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLParametersFieldGetObj
 
  !  
  !================================================================================================================================
  !  
 
  !>Validiate and instantiate a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLGenerateNumber(CellMLUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to generate.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSCellMLGenerateNumber",Err,ERROR,*999)
 
    NULLIFY(CELLML)
    CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,CELLML,Err,ERROR,*999)
    IF(ASSOCIATED(CELLML)) THEN
      CALL CELLML_GENERATE(CELLML,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCellMLGenerateNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLGenerateNumber",Err,ERROR)
    CALL EXITS("CMISSCellMLGenerateNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLGenerateNumber

  !  
  !================================================================================================================================
  !  
 
  !>Validiate and instantiate a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLGenerateObj(CellML,Err)
  
    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to generate.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSCellMLGenerateObj",Err,ERROR,*999)
 
    CALL CELLML_GENERATE(CellML%CELLML,Err,ERROR,*999)

    CALL EXITS("CMISSCellMLGenerateObj")
    RETURN
999 CALL ERRORS("CMISSCellMLGenerateObj",Err,ERROR)
    CALL EXITS("CMISSCellMLGenerateObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCellMLGenerateObj
 

!!==================================================================================================================================
!!
!! COMP_ENVIRONMENT
!!
!!==================================================================================================================================

  !>Returns the computational node number of the running process.
  SUBROUTINE CMISSComputationalNodeNumberGet(NodeNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: NodeNumber !<On return, the computational node number.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    
    CALL ENTERS("CMISSComputationalNodeNumberGet",ERR,ERROR,*999)

    NodeNumber = COMPUTATIONAL_NODE_NUMBER_GET(Err,ERROR)

    CALL EXITS("CMISSComputationalNodeNumberGet")
    RETURN
999 CALL ERRORS("CMISSComputationalNodeNumberGet",Err,ERROR)
    CALL EXITS("CMISSComputationalNodeNumberGet")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSComputationalNodeNumberGet

  !
  !================================================================================================================================
  !

  !>Returns the number of computational nodes for the running process.
  SUBROUTINE CMISSComputationalNumberOfNodesGet(NumberOfNodes,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: NumberOfNodes !<On return, the number of computational nodes.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    
    CALL ENTERS("CMISSComputationalNumberOfNodesGet",ERR,ERROR,*999)

    NumberOfNodes = COMPUTATIONAL_NODES_NUMBER_GET(Err,ERROR)

    CALL EXITS("CMISSComputationalNumberOfNodesGet")
    RETURN
999 CALL ERRORS("CMISSComputationalNumberOfNodesGet",Err,ERROR)
    CALL EXITS("CMISSComputationalNumberOfNodesGet")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSComputationalNumberOfNodesGet

!!==================================================================================================================================
!!
!! CONTROL_LOOP_ROUTINES
!!
!!==================================================================================================================================

  !>Gets the current time parameters for a time control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopCurrentTimesGetNumber0(ProblemUserNumber,ControlLoopIdentifier,CurrentTime,TimeIncrement,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier.
    REAL(DP), INTENT(OUT) :: CurrentTime !<On return, the current time of the time control loop.
    REAL(DP), INTENT(OUT) :: TimeIncrement !<On return, the current time increment of the time control loop.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopCurrentTimesGetNumber0",Err,ERROR,*999)
 
    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,ControlLoopIdentifier,CONTROL_LOOP,Err,ERROR,*999)
      CALL CONTROL_LOOP_CURRENT_TIMES_GET(CONTROL_LOOP,CurrentTime,TimeIncrement,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopCurrentTimesGetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoopCurrentTimesGetNumber0",Err,ERROR)
    CALL EXITS("CMISSControlLoopCurrentTimesGetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopCurrentTimesGetNumber0

  !
  !================================================================================================================================
  !  
  
  !>Gets the current time parameters for a time control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopCurrentTimesGetNumber1(ProblemUserNumber,ControlLoopIdentifiers,CurrentTime,TimeIncrement,Err)
  
    !Argument variables
     INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to get the control loop for.
    REAL(DP), INTENT(OUT) :: CurrentTime !<On return, the current time of the time control loop.
    REAL(DP), INTENT(OUT) :: TimeIncrement !<On return, the current time increment of the time control loop.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopCurrentTimesGetNumber1",Err,ERROR,*999)
    
    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,ControlLoopIdentifiers,CONTROL_LOOP,Err,ERROR,*999)
      CALL CONTROL_LOOP_CURRENT_TIMES_GET(CONTROL_LOOP,CurrentTime,TimeIncrement,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopCurrentTimesGetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoopCurrentTimesGetNumber1",Err,ERROR)
    CALL EXITS("CMISSControlLoopCurrentTimesGetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopCurrentTimesGetNumber1

  !
  !================================================================================================================================
  !  
  
  !>Gets the current time parameters for a time control loop identified by an object.
  SUBROUTINE CMISSControlLoopCurrentTimesGetObj(ControlLoop,CurrentTime,TimeIncrement,Err)
  
    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(IN) :: ControlLoop !<The control loop to get the current times for.
    REAL(DP), INTENT(OUT) :: CurrentTime !<On return, the current time of the time control loop.
    REAL(DP), INTENT(OUT) :: TimeIncrement !<On return, the current time increment of the time control loop.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopCurrentTimesGetObj",Err,ERROR,*999)
    
    CALL CONTROL_LOOP_CURRENT_TIMES_GET(ControlLoop%CONTROL_LOOP,CurrentTime,TimeIncrement,Err,ERROR,*999)

    CALL EXITS("CMISSControlLoopCurrentTimesGetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoopCurrentTimesGetObj",Err,ERROR)
    CALL EXITS("CMISSControlLoopCurrentTimesGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopCurrentTimesGetObj

  !
  !================================================================================================================================
  !  
  
  !>Destroys a control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopDestroyNumber0(ProblemUserNumber,ControlLoopIdentifier,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to destroy the control loop for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopDestroyNumber0",Err,ERROR,*999)
    
    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,ControlLoopIdentifier,CONTROL_LOOP,Err,ERROR,*999)
      CALL CONTROL_LOOP_DESTROY(CONTROL_LOOP,Err,ERROR,*999)
   ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF
    
    CALL EXITS("CMISSControlLoopDestroyNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoopDestroyNumber0",Err,ERROR)
    CALL EXITS("CMISSControlLoopDestroyNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopDestroyNumber0

  !
  !================================================================================================================================
  !  
  
  !>Destroys a control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopDestroyNumber1(ProblemUserNumber,ControlLoopIdentifiers,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to destroy the control loop for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopDestroyNumber1",Err,ERROR,*999)
    
    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,ControlLoopIdentifiers,CONTROL_LOOP,Err,ERROR,*999)
      CALL CONTROL_LOOP_DESTROY(CONTROL_LOOP,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopDestroyNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoopDestroyNumber1",Err,ERROR)
    CALL EXITS("CMISSControlLoopDestroyNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopDestroyNumber1
  
  !
  !================================================================================================================================
  !  
  
  !>Destroys a control loop identified by an object.
  SUBROUTINE CMISSControlLoopDestroyObj(ControlLoop,Err)
  
    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: ControlLoop !<The control loop to destroy.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopDestroyObj",Err,ERROR,*999)
    
    CALL CONTROL_LOOP_DESTROY(ControlLoop%CONTROL_LOOP,Err,ERROR,*999)

    CALL EXITS("CMISSControlLoopDestroyObj")
    RETURN
999 CALL ERRORS("CMISSControlLoopDestroyObj",Err,ERROR)
    CALL EXITS("CMISSControlLoopDestroyObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopDestroyObj
 
  !
  !================================================================================================================================
  !  
  
  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root identified by user numbers.
  SUBROUTINE CMISSControlLoopGetNumber00(ProblemUserNumber,ControlLoopRootIdentifier,ControlLoopIdentifier,ControlLoop,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopRootIdentifier !<The root control loop identifier.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier.
    TYPE(CMISSControlLoopType), INTENT(OUT) :: ControlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: ROOT_CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopGetNumber00",Err,ERROR,*999)
    
    NULLIFY(ROOT_CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,ControlLoopRootIdentifier,ROOT_CONTROL_LOOP,Err,ERROR,*999)
      CALL CONTROL_LOOP_GET(ROOT_CONTROL_LOOP,ControlLoopIdentifier,ControlLoop%CONTROL_LOOP,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopGetNumber00")
    RETURN    
999 CALL ERRORS("CMISSControlLoopGetNumber00",Err,ERROR)
    CALL EXITS("CMISSControlLoopGetNumber00")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopGetNumber00

  !
  !================================================================================================================================
  !  
  
  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root identified by user numbers.
  SUBROUTINE CMISSControlLoopGetNumber10(ProblemUserNumber,ControlLoopRootIdentifiers,ControlLoopIdentifier,ControlLoop,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopRootIdentifiers(:) !<The root control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier.
    TYPE(CMISSControlLoopType), INTENT(OUT) :: ControlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: ROOT_CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopGetNumber10",Err,ERROR,*999)
 
    NULLIFY(ROOT_CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,ControlLoopRootIdentifiers,ROOT_CONTROL_LOOP,Err,ERROR,*999)
      CALL CONTROL_LOOP_GET(ROOT_CONTROL_LOOP,ControlLoopIdentifier,ControlLoop%CONTROL_LOOP,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopGetNumber10")
    RETURN
999 CALL ERRORS("CMISSControlLoopGetNumber10",Err,ERROR)
    CALL EXITS("CMISSControlLoopGetNumber10")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopGetNumber10

  !
  !================================================================================================================================
  !  
  
  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root identified by user numbers.
  SUBROUTINE CMISSControlLoopGetNumber01(ProblemUserNumber,ControlLoopRootIdentifier,ControlLoopIdentifiers,ControlLoop,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopRootIdentifier !<The root control loop identifier.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<The control loop identifiers.
    TYPE(CMISSControlLoopType), INTENT(OUT) :: ControlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: ROOT_CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopGetNumber01",Err,ERROR,*999)
    
    NULLIFY(ROOT_CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,ControlLoopRootIdentifier,ROOT_CONTROL_LOOP,Err,ERROR,*999)
      CALL CONTROL_LOOP_GET(ROOT_CONTROL_LOOP,ControlLoopIdentifiers,ControlLoop%CONTROL_LOOP,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopGetNumber01")
    RETURN
999 CALL ERRORS("CMISSControlLoopGetNumber01",Err,ERROR)
    CALL EXITS("CMISSControlLoopGetNumber01")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopGetNumber01

  !
  !================================================================================================================================
  !  
  
  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root identified by user numbers.
  SUBROUTINE CMISSControlLoopGetNumber11(ProblemUserNumber,ControlLoopRootIdentifiers,ControlLoopIdentifiers,ControlLoop,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopRootIdentifiers(:) !<The root control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<The control loop identifiers.
    TYPE(CMISSControlLoopType), INTENT(OUT) :: ControlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: ROOT_CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopGetNumber11",Err,ERROR,*999)
    
    NULLIFY(ROOT_CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,ControlLoopRootIdentifiers,ROOT_CONTROL_LOOP,Err,ERROR,*999)
      CALL CONTROL_LOOP_GET(ROOT_CONTROL_LOOP,ControlLoopIdentifiers,ControlLoop%CONTROL_LOOP,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopGetNumber11")
    RETURN
999 CALL ERRORS("CMISSControlLoopGetNumber11",Err,ERROR)
    CALL EXITS("CMISSControlLoopGetNumber11")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopGetNumber11

  !
  !================================================================================================================================
  !  
  
  !>Destroys a control loop identified by an object.
  SUBROUTINE CMISSControlLoopGetObj0(ControlLoopRoot,ControlLoopIdentifier,ControlLoop,Err)
  
    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(IN) :: ControlLoopRoot !<The root control loop.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier.
    TYPE(CMISSControlLoopType), INTENT(OUT) :: ControlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopGetObj0",Err,ERROR,*999)
    
    CALL CONTROL_LOOP_GET(ControlLoopRoot%CONTROL_LOOP,ControlLoopIdentifier,ControlLoop%CONTROL_LOOP,Err,ERROR,*999)

    CALL EXITS("CMISSControlLoopGetObj0")
    RETURN
999 CALL ERRORS("CMISSControlLoopGetObj0",Err,ERROR)
    CALL EXITS("CMISSControlLoopGetObj0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopGetObj0
  
  !
  !================================================================================================================================
  !  
  
  !>Destroys a control loop identified by an object.
  SUBROUTINE CMISSControlLoopGetObj1(ControlLoopRoot,ControlLoopIdentifiers,ControlLoop,Err)
  
    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(IN) :: ControlLoopRoot !<The root control loop.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<The control loop identifiers.
    TYPE(CMISSControlLoopType), INTENT(OUT) :: ControlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopGetObj1",Err,ERROR,*999)

    CALL CONTROL_LOOP_GET(ControlLoopRoot%CONTROL_LOOP,ControlLoopIdentifiers,ControlLoop%CONTROL_LOOP,Err,ERROR,*999)

    CALL EXITS("CMISSControlLoopGetObj1")
    RETURN
999 CALL ERRORS("CMISSControlLoopGetObj1",Err,ERROR)
    CALL EXITS("CMISSControlLoopGetObj1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopGetObj1

  !
  !================================================================================================================================
  !  
  
  !>Sets/changes the iteration parameters for a fixed control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopIterationsSetNumber0(ProblemUserNumber,ControlLoopIdentifier,StartIteration,StopIteration, &
    & IterationIncrement,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to set the iteration parameters for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: StartIteration !<The start iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: StopIteration !<The stop iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: IterationIncrement !<The iteration increment of the fixed control loop to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopIterationsSetNumber0",Err,ERROR,*999)
    
    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,ControlLoopIdentifier,CONTROL_LOOP,Err,ERROR,*999)
      CALL CONTROL_LOOP_ITERATIONS_SET(CONTROL_LOOP,StartIteration,StopIteration,IterationIncrement,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopIterationsSetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoopIterationsSetNumber0",Err,ERROR)
    CALL EXITS("CMISSControlLoopIterationsSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopIterationsSetNumber0

  !
  !================================================================================================================================
  !  
  
  !>Sets/changes the iteration parameters for a fixed control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopIterationsSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,StartIteration,StopIteration, &
    & IterationIncrement,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to set the iteration parameters for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: StartIteration !<The start iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: StopIteration !<The stop iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: IterationIncrement !<The iteration increment of the fixed control loop to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopIterationsSetNumber1",Err,ERROR,*999)
    
    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,ControlLoopIdentifiers,CONTROL_LOOP,Err,ERROR,*999)
      CALL CONTROL_LOOP_ITERATIONS_SET(CONTROL_LOOP,StartIteration,StopIteration,IterationIncrement,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopIterationsSetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoopIterationsSetNumber1",Err,ERROR)
    CALL EXITS("CMISSControlLoopIterationsSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopIterationsSetNumber1

  !================================================================================================================================
  !  
  
  !>Sets/changes the iteration parameters for a fixed control loop identified by an object.
  SUBROUTINE CMISSControlLoopIterationsSetObj(ControlLoop,StartIteration,StopIteration,IterationIncrement,Err)
  
    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: ControlLoop !<The control loop to set the iteration parameters for.
    INTEGER(INTG), INTENT(IN) :: StartIteration !<The start iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: StopIteration !<The stop iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: IterationIncrement !<The iteration increment of the fixed control loop to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopIterationsSetObj",Err,ERROR,*999)
    
    CALL CONTROL_LOOP_ITERATIONS_SET(ControlLoop%CONTROL_LOOP,StartIteration,StopIteration,IterationIncrement,Err,ERROR,*999)

    CALL EXITS("CMISSControlLoopIterationsSetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoopIterationsSetObj",Err,ERROR)
    CALL EXITS("CMISSControlLoopIterationsSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopIterationsSetObj

  !
  !================================================================================================================================
  !  
  
  !>Sets/changes the maximum iterations for a while control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopMaximumIterationsSetNumber0(ProblemUserNumber,ControlLoopIdentifier,MaximumIterations,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: MaximumIterations !<The maximum iterations of the while control loop to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopMaximumIterationsSetNumber0",Err,ERROR,*999)
    
    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,ControlLoopIdentifier,CONTROL_LOOP,Err,ERROR,*999)
      CALL CONTROL_LOOP_MAXIMUM_ITERATIONS_SET(CONTROL_LOOP,MaximumIterations,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopMaximumIterationsSetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoopMaximumIterationsSetNumber0",Err,ERROR)
    CALL EXITS("CMISSControlLoopMaximumIterationsSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopMaximumIterationsSetNumber0

  !
  !================================================================================================================================
  !  
  
  !>Sets/changes the maximum iterations for a while control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopMaximumIterationsSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,MaximumIterations,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: MaximumIterations !<The maximum iterations of the while control loop to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopMaximumIterationsSetNumber1",Err,ERROR,*999)
    
    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,ControlLoopIdentifiers,CONTROL_LOOP,Err,ERROR,*999)
      CALL CONTROL_LOOP_MAXIMUM_ITERATIONS_SET(CONTROL_LOOP,MaximumIterations,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF
    
    CALL EXITS("CMISSControlLoopMaximumIterationsSetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoopMaximumIterationsSetNumber1",Err,ERROR)
    CALL EXITS("CMISSControlLoopMaximumIterationsSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopMaximumIterationsSetNumber1

  !
  !================================================================================================================================
  !  
  
  !>Sets/changes the maximum iterations for a while control loop identified by an object.
  SUBROUTINE CMISSControlLoopMaximumIterationsSetObj(ControlLoop,MaximumIterations,Err)
  
    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: ControlLoop !<The control loop to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: MaximumIterations !<The maximum iterations of the while control loop to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopMaximumIterationsSetObj",Err,ERROR,*999)
    
    CALL CONTROL_LOOP_MAXIMUM_ITERATIONS_SET(ControlLoop%CONTROL_LOOP,MaximumIterations,Err,ERROR,*999)

    CALL EXITS("CMISSControlLoopMaximumIterationsSetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoopMaximumIterationsSetObj",Err,ERROR)
    CALL EXITS("CMISSControlLoopMaximumIterationsSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopMaximumIterationsSetObj

  !
  !================================================================================================================================
  !  
  
  !>Returns the number of sub-control loops for a control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopNumberOfSubLoopsGetNumber0(ProblemUserNumber,ControlLoopIdentifier,NumberOfSubLoops,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to get the number of sub loops for for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(OUT) :: NumberOfSubLoops !<On return, the number of sub loops for the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopNumberOfSubLoopsGetNumber0",Err,ERROR,*999)
    
    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,ControlLoopIdentifier,CONTROL_LOOP,Err,ERROR,*999)
      CALL CONTROL_LOOP_NUMBER_OF_SUB_LOOPS_GET(CONTROL_LOOP,NumberOfSubLoops,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopNumberOfSubLoopsGetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoopNumberOfSubLoopsGetNumber0",Err,ERROR)
    CALL EXITS("CMISSControlLoopNumberOfSubLoopsGetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopNumberOfSubLoopsGetNumber0

  !
  !================================================================================================================================
  !  
  
  !>Returns the number of sub-control loops for a control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopNumberOfSubLoopsGetNumber1(ProblemUserNumber,ControlLoopIdentifiers,NumberOfSubLoops,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to get the number of sub loops for for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(OUT) :: NumberOfSubLoops !<On return, the number of sub loops for the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopNumberOfSubLoopsGetNumber1",Err,ERROR,*999)
    
    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,ControlLoopIdentifiers,CONTROL_LOOP,Err,ERROR,*999)
      CALL CONTROL_LOOP_NUMBER_OF_SUB_LOOPS_GET(CONTROL_LOOP,NumberOfSubLoops,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopNumberOfSubLoopsGetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoopNumberOfSubLoopsGetNumber1",Err,ERROR)
    CALL EXITS("CMISSControlLoopNumberOfSubLoopsGetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopNumberOfSubLoopsGetNumber1

  !
  !================================================================================================================================
  !  
  
  !>Returns the number of sub-control loops for a control loop identified by an object.
  SUBROUTINE CMISSControlLoopNumberOfSubLoopsGetObj(ControlLoop,NumberOfSubLoops,Err)
  
    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(IN) :: ControlLoop !<The control loop to get the number of sub loops for.
    INTEGER(INTG), INTENT(OUT) :: NumberOfSubLoops !<On return, the number of sub loops for the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopNumberOfSubLoopsGetObj",Err,ERROR,*999)
    
    CALL CONTROL_LOOP_NUMBER_OF_SUB_LOOPS_GET(ControlLoop%CONTROL_LOOP,NumberOfSubLoops,Err,ERROR,*999)

    CALL EXITS("CMISSControlLoopNumberOfSubLoopsGetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoopNumberOfSubLoopsGetObj",Err,ERROR)
    CALL EXITS("CMISSControlLoopNumberOfSubLoopsGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopNumberOfSubLoopsGetObj

  !
  !================================================================================================================================
  !  
  
  !>Sets/changes the number of sub-control loops for a control loop identified by user numbers. \todo is this really public???
  SUBROUTINE CMISSControlLoopNumberOfSubLoopsSetNumber0(ProblemUserNumber,ControlLoopIdentifier,NumberOfSubLoops,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to set the number of sub loops for for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: NumberOfSubLoops !<The number of sub loops for the specified control loop to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopNumberOfSubLoopsSetNumber",Err,ERROR,*999)
    
    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,ControlLoopIdentifier,CONTROL_LOOP,Err,ERROR,*999)
      CALL CONTROL_LOOP_NUMBER_OF_SUB_LOOPS_SET(CONTROL_LOOP,NumberOfSubLoops,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopNumberOfSubLoopsSetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoopNumberOfSubLoopsSetNumber0",Err,ERROR)
    CALL EXITS("CMISSControlLoopNumberOfSubLoopsSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopNumberOfSubLoopsSetNumber0

  !
  !================================================================================================================================
  !  
  
  !>Sets/changes the number of sub-control loops for a control loop identified by user numbers. \todo is this really public???
  SUBROUTINE CMISSControlLoopNumberOfSubLoopsSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,NumberOfSubLoops,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to set the number of sub loops for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: NumberOfSubLoops !<The number of sub loops for the specified control loop to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopNumberOfSubLoopsSetNumber1",Err,ERROR,*999)
    
    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,ControlLoopIdentifiers,CONTROL_LOOP,Err,ERROR,*999)
      CALL CONTROL_LOOP_NUMBER_OF_SUB_LOOPS_SET(CONTROL_LOOP,NumberOfSubLoops,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF
    
    CALL EXITS("CMISSControlLoopNumberOfSubLoopsSetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoopNumberOfSubLoopsSetNumber1",Err,ERROR)
    CALL EXITS("CMISSControlLoopNumberOfSubLoopsSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopNumberOfSubLoopsSetNumber1

  !
  !================================================================================================================================
  !  
  
  !>Sets/changes the number of sub-control loops for a control loop identified by an object. \todo is this really public???
  SUBROUTINE CMISSControlLoopNumberOfSubLoopsSetObj(ControlLoop,NumberOfSubLoops,Err)
  
    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: ControlLoop !<The control loop to set the number of sub loops for.
    INTEGER(INTG), INTENT(IN) :: NumberOfSubLoops !<The number of sub loops for the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopNumberOfSubLoopsSetObj",Err,ERROR,*999)
    
    CALL CONTROL_LOOP_NUMBER_OF_SUB_LOOPS_SET(ControlLoop%CONTROL_LOOP,NumberOfSubLoops,Err,ERROR,*999)

    CALL EXITS("CMISSControlLoopNumberOfSubLoopsSetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoopNumberOfSubLoopsSetObj",Err,ERROR)
    CALL EXITS("CMISSControlLoopNumberOfSubLoopsSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopNumberOfSubLoopsSetObj

  !
  !================================================================================================================================
  !  
  
  !>Sets/changes the output parameters for a time control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopTimeOutputSetNumber0(ProblemUserNumber,ControlLoopIdentifier,OutputFrequency,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to set the output parameters for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: OutputFrequency !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopTimeOutputSetNumber0",Err,ERROR,*999)
    
    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,ControlLoopIdentifier,CONTROL_LOOP,Err,ERROR,*999)
      CALL CONTROL_LOOP_TIME_OUTPUT_SET(CONTROL_LOOP,OutputFrequency,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopTimeOutputSetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoopTimeOutputSetNumber0",Err,ERROR)
    CALL EXITS("CMISSControlLoopTimeOutputSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopTimeOutputSetNumber0

  !
  !================================================================================================================================
  !  
  
  !>Sets/changes the output parameters for a time control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopTimeOutputSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,OutputFrequency,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to get the output parameters for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: OutputFrequency !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM

    CALL ENTERS("CMISSControlLoopTimeOutputSetNumber1",Err,ERROR,*999)
    
    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,ControlLoopIdentifiers,CONTROL_LOOP,Err,ERROR,*999)
      CALL CONTROL_LOOP_TIME_OUTPUT_SET(CONTROL_LOOP,OutputFrequency,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopTimeOutputSetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoopTimeOutputSetNumber1",Err,ERROR)
    CALL EXITS("CMISSControlLoopTimeOutputSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopTimeOutputSetNumber1

  !
  !================================================================================================================================
  !  
  
  !>Sets/changes the output parameters for a time control loop identified by an object.
  SUBROUTINE CMISSControlLoopTimeOutputSetObj(ControlLoop,OutputFrequency,Err)
  
    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: ControlLoop !<The control loop to set the output parameters for.
    INTEGER(INTG), INTENT(IN) ::  OutputFrequency !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopTimeOutputSetObj",Err,ERROR,*999)
    
    CALL CONTROL_LOOP_TIME_OUTPUT_SET(ControlLoop%CONTROL_LOOP,OutputFrequency,Err,ERROR,*999)

    CALL EXITS("CMISSControlLoopTimeOutputSetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoopTimeOutputSetObj",Err,ERROR)
    CALL EXITS("CMISSControlLoopTimeOuputSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopTimeOutputSetObj

  !
  !================================================================================================================================
  !  
  
  !>Sets/changes the input parameters for a time control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopTimeInputSetNumber0(ProblemUserNumber,ControlLoopIdentifier,InputOption,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to set the output parameters for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: InputOption !<The input option modulo to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopTimeInputSetNumber0",Err,ERROR,*999)
    
    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,ControlLoopIdentifier,CONTROL_LOOP,Err,ERROR,*999)
      CALL CONTROL_LOOP_TIME_OUTPUT_SET(CONTROL_LOOP,InputOption,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopTimeInputSetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoopTimeInputSetNumber0",Err,ERROR)
    CALL EXITS("CMISSControlLoopTimeInputSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopTimeInputSetNumber0

  !
  !================================================================================================================================
  !  
  
  !>Sets/changes the input parameters for a time control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopTimeInputSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,InputOption,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to get the output parameters for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: InputOption !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM

    CALL ENTERS("CMISSControlLoopTimeInputSetNumber1",Err,ERROR,*999)
    
    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,ControlLoopIdentifiers,CONTROL_LOOP,Err,ERROR,*999)
      CALL CONTROL_LOOP_TIME_OUTPUT_SET(CONTROL_LOOP,InputOption,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopTimeInputSetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoopTimeInputSetNumber1",Err,ERROR)
    CALL EXITS("CMISSControlLoopTimeInputSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopTimeInputSetNumber1

  !
  !================================================================================================================================
  !  
  
  !>Sets/changes the input parameters for a time control loop identified by an object.
  SUBROUTINE CMISSControlLoopTimeInputSetObj(ControlLoop,InputOption,Err)
  
    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: ControlLoop !<The control loop to set the output parameters for.
    INTEGER(INTG), INTENT(IN) ::  InputOption !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopTimeInputSetObj",Err,ERROR,*999)
    
    CALL CONTROL_LOOP_TIME_INPUT_SET(ControlLoop%CONTROL_LOOP,InputOption,Err,ERROR,*999)

    CALL EXITS("CMISSControlLoopTimeInputSetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoopTimeInputSetObj",Err,ERROR)
    CALL EXITS("CMISSControlLoopTimeInputSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopTimeInputSetObj


  !
  !================================================================================================================================
  !  
  
  !>Returns the time parameters for a time control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopTimesGetNumber0(ProblemUserNumber,ControlLoopIdentifier,StartTime,StopTime,TimeIncrement, &
    & CurrentTime,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to get the time parameters for for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier.
    REAL(DP), INTENT(OUT) :: StartTime !<On return, the start time for the time control loop.
    REAL(DP), INTENT(OUT) :: StopTime !<On return, the stop time for the time control loop.
    REAL(DP), INTENT(OUT) :: TimeIncrement !<On return, the time increment for the time control loop.
    REAL(DP), INTENT(OUT) :: CurrentTime !<On return, the current time for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopTimesGetNumber0",Err,ERROR,*999)
    
    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,ControlLoopIdentifier,CONTROL_LOOP,Err,ERROR,*999)
      CALL CONTROL_LOOP_TIMES_GET(CONTROL_LOOP,StartTime,StopTime,TimeIncrement,CurrentTime,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopTimesGetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoopTimesGetNumber0",Err,ERROR)
    CALL EXITS("CMISSControlLoopTimesGetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopTimesGetNumber0

  !
  !================================================================================================================================
  !  
 
  !>Returns the time parameters for a time control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopTimesGetNumber1(ProblemUserNumber,ControlLoopIdentifiers,StartTime,StopTime,TimeIncrement, &
    & CurrentTime,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to get the time parameters for for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<The control loop identifier.
    REAL(DP), INTENT(OUT) :: StartTime !<On return, the start time for the time control loop.
    REAL(DP), INTENT(OUT) :: StopTime !<On return, the stop time for the time control loop.
    REAL(DP), INTENT(OUT) :: TimeIncrement !<On return, the time increment for the time control loop.
    REAL(DP), INTENT(OUT) :: CurrentTime !<On return, the current time for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopTimesGetNumber1",Err,ERROR,*999)
    
    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,ControlLoopIdentifiers,CONTROL_LOOP,Err,ERROR,*999)
      CALL CONTROL_LOOP_TIMES_GET(CONTROL_LOOP,StartTime,StopTime,TimeIncrement,CurrentTime,Err,ERROR,*999)
   ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF
    
    CALL EXITS("CMISSControlLoopTimesGetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoopTimesGetNumber1",Err,ERROR)
    CALL EXITS("CMISSControlLoopTimesGetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopTimesGetNumber1

  !
  !================================================================================================================================
  !  
 
  !>Returns the time parameters for a time control loop identified by an object.
  SUBROUTINE CMISSControlLoopTimesGetObj(ControlLoop,StartTime,StopTime,TimeIncrement,CurrentTime,Err)
  
    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(IN) :: ControlLoop !<The control loop to get the times for.
    REAL(DP), INTENT(OUT) :: StartTime !<On return, the start time for the time control loop.
    REAL(DP), INTENT(OUT) :: StopTime !<On return, the stop time for the time control loop.
    REAL(DP), INTENT(OUT) :: TimeIncrement !<On return, the time increment for the time control loop.
    REAL(DP), INTENT(OUT) :: CurrentTime !<On return, the current time for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopTimesGetObj",Err,ERROR,*999)
    
    CALL CONTROL_LOOP_TIMES_GET(ControlLoop%CONTROL_LOOP,StartTime,StopTime,TimeIncrement,CurrentTime,Err,ERROR,*999)

    CALL EXITS("CMISSControlLoopTimesGetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoopTimesGetObj",Err,ERROR)
    CALL EXITS("CMISSControlLoopTimesGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopTimesGetObj

  !
  !================================================================================================================================
  !  
  
  !>Sets/changes the time parameters for a time control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopTimesSetNumber0(ProblemUserNumber,ControlLoopIdentifier,StartTime,StopTime,TimeIncrement,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to get the time parameters for for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier.
    REAL(DP), INTENT(IN) :: StartTime !<The start time for the time control loop to set.
    REAL(DP), INTENT(IN) :: StopTime !<The stop time for the time control loop to set.
    REAL(DP), INTENT(IN) :: TimeIncrement !<The time increment for the time control loop to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopTimesSetNumber0",Err,ERROR,*999)
    
    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,ControlLoopIdentifier,CONTROL_LOOP,Err,ERROR,*999)
      CALL CONTROL_LOOP_TIMES_SET(CONTROL_LOOP,StartTime,StopTime,TimeIncrement,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopTimesSetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoopTimesSetNumber0",Err,ERROR)
    CALL EXITS("CMISSControlLoopTimesSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopTimesSetNumber0

  !
  !================================================================================================================================
  !  
  
  !>Sets/changes the time parameters for a time control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopTimesSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,StartTime,StopTime,TimeIncrement,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to get the time parameters for for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<The control loop identifier.
    REAL(DP), INTENT(IN) :: StartTime !<The start time for the time control loop to set.
    REAL(DP), INTENT(IN) :: StopTime !<The stop time for the time control loop to set.
    REAL(DP), INTENT(IN) :: TimeIncrement !<The time increment for the time control loop to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM

    CALL ENTERS("CMISSControlLoopTimesSetNumber1",Err,ERROR,*999)
    
    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,ControlLoopIdentifiers,CONTROL_LOOP,Err,ERROR,*999)
      CALL CONTROL_LOOP_TIMES_SET(CONTROL_LOOP,StartTime,StopTime,TimeIncrement,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopTimesSetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoopTimesSetNumber1",Err,ERROR)
    CALL EXITS("CMISSControlLoopTimesSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopTimesSetNumber1

  !
  !================================================================================================================================
  !  
  
  !>Sets/changes the time parameters for a time control loop identified by an object.
  SUBROUTINE CMISSControlLoopTimesSetObj(ControlLoop,StartTime,StopTime,TimeIncrement,Err)
  
    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: ControlLoop !<The control loop to set the times for.
    REAL(DP), INTENT(IN) :: StartTime !<The start time for the time control loop to set.
    REAL(DP), INTENT(IN) :: StopTime !<The stop time for the time control loop to set.
    REAL(DP), INTENT(IN) :: TimeIncrement !<The time increment for the time control loop to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopTimesSetObj",Err,ERROR,*999)
    
    CALL CONTROL_LOOP_TIMES_SET(ControlLoop%CONTROL_LOOP,StartTime,StopTime,TimeIncrement,Err,ERROR,*999)

    CALL EXITS("CMISSControlLoopTimesSetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoopTimesSetObj",Err,ERROR)
    CALL EXITS("CMISSControlLoopTimesSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopTimesSetObj

  !  
  !================================================================================================================================
  !  
  
  !>Sets/changes the loop type for a control loop identified by user numbers. \todo is this really public???
  SUBROUTINE CMISSControlLoopTypeSetNumber0(ProblemUserNumber,ControlLoopIdentifier,LoopType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to set the loop type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: LoopType !<The type of control loop to set. \see OPENCMISS_ProblemControlLoopTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopTypeSetNumber0",Err,ERROR,*999)
    
    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,ControlLoopIdentifier,CONTROL_LOOP,Err,ERROR,*999)
      CALL CONTROL_LOOP_TYPE_SET(CONTROL_LOOP,LoopType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoopTypeSetNumber0",Err,ERROR)
    CALL EXITS("CMISSControlLoopTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopTypeSetNumber0

  !  
  !================================================================================================================================
  !  
  
  !>Sets/changes the loop type for a control loop identified by user numbers. \todo is this really public???
  SUBROUTINE CMISSControlLoopTypeSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,LoopType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to set the loop type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: LoopType !<The type of control loop to set. \see OPENCMISS_ProblemControlLoopTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopTypeSetNumber1",Err,ERROR,*999)
    
    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,ControlLoopIdentifiers,CONTROL_LOOP,Err,ERROR,*999)
      CALL CONTROL_LOOP_TYPE_SET(CONTROL_LOOP,LoopType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoopTypeSetNumber1",Err,ERROR)
    CALL EXITS("CMISSControlLoopTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopTypeSetNumber1

  !  
  !================================================================================================================================
  !  
  
  !>Sets/changes the loop type for a control loop identified by an object. \todo is this really public???
  SUBROUTINE CMISSControlLoopTypeSetObj(ControlLoop,LoopType,Err)
  
    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: ControlLoop !<The control loop to set the loop type for.
    INTEGER(INTG), INTENT(IN) :: LoopType !<The type of control loop to set. \see OPENCMISS_ProblemControlLoopTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopTypeSetObj",Err,ERROR,*999)

    CALL CONTROL_LOOP_TYPE_SET(ControlLoop%CONTROL_LOOP,LoopType,Err,ERROR,*999)

    CALL EXITS("CMISSControlLoopTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoopTypeSetObj",Err,ERROR)
    CALL EXITS("CMISSControlLoopTypeSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSControlLoopTypeSetObj

!!==================================================================================================================================
!!
!! COORDINATE_ROUTINES
!!
!!==================================================================================================================================
  
  !>Finishes the creation of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystemCreateFinishNumber(CoordinateSystemUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CoordinateSystemUserNumber !<The user number of the coordinate system to finish creating.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystemCreateFinishNumber",Err,ERROR,*999)
 
    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(CoordinateSystemUserNumber,COORDINATE_SYSTEM,Err,ERROR,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_CREATE_FINISH(COORDINATE_SYSTEM,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(CoordinateSystemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Coordinate System Create')
#endif

    CALL EXITS("CMISSCoordinateSystemCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemCreateFinishNumber",Err,ERROR)
    CALL EXITS("CMISSCoordinateSystemCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCoordinateSystemCreateFinishNumber

  !  
  !================================================================================================================================
  !
  
  !>Finishes the creation of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystemCreateFinishObj(CoordinateSystem,Err)
  
    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT) :: CoordinateSystem !<The coordinate system to finish creating.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
 
    CALL ENTERS("CMISSCoordinateSystemCreateFinishObj",Err,ERROR,*999)
 
    CALL COORDINATE_SYSTEM_CREATE_FINISH(CoordinateSystem%COORDINATE_SYSTEM,Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Coordinate System Create')
#endif

    CALL EXITS("CMISSCoordinateSystemCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemCreateFinishObj",Err,ERROR)
    CALL EXITS("CMISSCoordinateSystemCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCoordinateSystemCreateFinishObj

  !  
  !================================================================================================================================
  !
  
  !>Starts the creation of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystemCreateStartNumber(CoordinateSystemUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CoordinateSystemUserNumber !<The user number of the coordinate system to start creating.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM

    CALL ENTERS("CMISSCoordinateSystemCreateStartNumber",Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Coordinate System Create')
#endif
 
    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_CREATE_START(CoordinateSystemUserNumber,COORDINATE_SYSTEM,Err,ERROR,*999)

    CALL EXITS("CMISSCoordinateSystemCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemCreateStartNumber",Err,ERROR)
    CALL EXITS("CMISSCoordinateSystemCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCoordinateSystemCreateStartNumber

  !  
  !================================================================================================================================
  !
  
  !>Starts the creation of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystemCreateStartObj(CoordinateSystemUserNumber,CoordinateSystem,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CoordinateSystemUserNumber !<The user number of the coordinate system to start creating.
    TYPE(CMISSCoordinateSystemType), INTENT(OUT) :: CoordinateSystem !<On return, the coordinate system that has been created.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
 
    CALL ENTERS("CMISSCoordinateSystemCreateStartObj",Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Coordinate System Create')
#endif
 
    CALL COORDINATE_SYSTEM_CREATE_START(CoordinateSystemUserNumber,CoordinateSystem%COORDINATE_SYSTEM,Err,ERROR,*999)

    CALL EXITS("CMISSCoordinateSystemCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemCreateStartObj",Err,ERROR)
    CALL EXITS("CMISSCoordinateSystemCreateStartObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCoordinateSystemCreateStartObj

  !  
  !================================================================================================================================
  !

  !>Destroys a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystemDestroyNumber(CoordinateSystemUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CoordinateSystemUserNumber !<The user number of the coordinate system to destroy.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystemDestroyNumber",Err,ERROR,*999)
 
    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(CoordinateSystemUserNumber,COORDINATE_SYSTEM,Err,ERROR,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_DESTROY(COORDINATE_SYSTEM,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(CoordinateSystemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCoordinateSystemDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemDestroyNumber",Err,ERROR)
    CALL EXITS("CMISSCoordinateSystemDestroyNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCoordinateSystemDestroyNumber

  !  
  !================================================================================================================================
  !
  
  !>Destroys a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystemDestroyObj(CoordinateSystem,Err)
  
    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT) :: CoordinateSystem !<The coordinate system to destroy.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
 
    CALL ENTERS("CMISSCoordinateSysteDestroyObj",Err,ERROR,*999)
 
    CALL COORDINATE_SYSTEM_DESTROY(CoordinateSystem%COORDINATE_SYSTEM,Err,ERROR,*999)

    CALL EXITS("CMISSCoordinateSystemDestroyObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemDestroyObj",Err,ERROR)
    CALL EXITS("CMISSCoordinateSystemDestroyObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCoordinateSystemDestroyObj

  !  
  !================================================================================================================================
  !  

  !>Returns the dimension of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystemDimensionGetNumber(CoordinateSystemUserNumber,CoordinateSystemDimension,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CoordinateSystemUserNumber !<The user number of the coordinate system to get the dimension for.
    INTEGER(INTG), INTENT(OUT) :: CoordinateSystemDimension !<On return, the dimension of the coordinate system
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystemDimensionGetNumber",Err,ERROR,*999)
 
    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(CoordinateSystemUserNumber,COORDINATE_SYSTEM,Err,ERROR,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_DIMENSION_GET(COORDINATE_SYSTEM,CoordinateSystemDimension,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(CoordinateSystemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCoordinateSystemDimensionGetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemDimensionGetNumber",Err,ERROR)
    CALL EXITS("CMISSCoordinateSystemDimensionGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCoordinateSystemDimensionGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the dimension of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystemDimensionGetObj(CoordinateSystem,CoordinateSystemDimension,Err)
  
    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(IN) :: CoordinateSystem !<The coordinate system to get the dimension for.
    INTEGER(INTG), INTENT(OUT) :: CoordinateSystemDimension !<On return, the dimension of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystemDimensionGetObj",Err,ERROR,*999)
    
    CALL COORDINATE_SYSTEM_DIMENSION_GET(CoordinateSystem%COORDINATE_SYSTEM,CoordinateSystemDimension,Err,ERROR,*999)

    CALL EXITS("CMISSCoordinateSystemDimensionGetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemDimensionGetObj",Err,ERROR)
    CALL EXITS("CMISSCoordinateSystemDimensionGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCoordinateSystemDimensionGetObj

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the dimension of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystemDimensionSetNumber(CoordinateSystemUserNumber,CoordinateSystemDimension,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CoordinateSystemUserNumber !<The user number of the coordinate system to set the dimension for.
    INTEGER(INTG), INTENT(IN) :: CoordinateSystemDimension !<The dimension of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystemDimensionSetNumber",Err,ERROR,*999)
    
    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(CoordinateSystemUserNumber,COORDINATE_SYSTEM,Err,ERROR,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_DIMENSION_SET(COORDINATE_SYSTEM,CoordinateSystemDimension,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(CoordinateSystemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCoordinateSystemDimensionSetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemDimensionSetNumber",Err,ERROR)
    CALL EXITS("CMISSCoordinateSystemDimensionSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCoordinateSystemDimensionSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the dimension of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystemDimensionSetObj(CoordinateSystem,CoordinateSystemDimension,Err)
  
    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT)  :: CoordinateSystem !<The coordinate system to set the dimension for.
    INTEGER(INTG), INTENT(IN) :: CoordinateSystemDimension !<The dimension of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystemDimensionSetObj",Err,ERROR,*999)
    
    CALL COORDINATE_SYSTEM_DIMENSION_SET(CoordinateSystem%COORDINATE_SYSTEM,CoordinateSystemDimension,Err,ERROR,*999)

    CALL EXITS("CMISSCoordinateSystemDimensionSetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemDimensionSetObj",Err,ERROR)
    CALL EXITS("CMISSCoordinateSystemDimensionSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCoordinateSystemDimensionSetObj

  !  
  !================================================================================================================================
  !  
 
  !>Returns the focus of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystemFocusGetNumber(CoordinateSystemUserNumber,Focus,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CoordinateSystemUserNumber !<The user number of the coordinate system to get the focus for.
    REAL(DP), INTENT(OUT) :: Focus !<On return, the focus of the coordinate system
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystemFocusGetNumber",Err,ERROR,*999)
 
    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(CoordinateSystemUserNumber,COORDINATE_SYSTEM,Err,ERROR,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_FOCUS_GET(COORDINATE_SYSTEM,Focus,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(CoordinateSystemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCoordinateSystemFocusGetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemFocusGetNumber",Err,ERROR)
    CALL EXITS("CMISSCoordinateSystemFocusGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCoordinateSystemFocusGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the focus of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystemFocusGetObj(CoordinateSystem,Focus,Err)
  
    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(IN) :: CoordinateSystem !<The coordinate system to get the focus for.
    REAL(DP), INTENT(OUT) :: Focus !<On return, the focus of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystemFocusGetObj",Err,ERROR,*999)
    
    CALL COORDINATE_SYSTEM_FOCUS_GET(CoordinateSystem%COORDINATE_SYSTEM,Focus,Err,ERROR,*999)

    CALL EXITS("CMISSCoordinateSystemFocusGetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemFocusGetObj",Err,ERROR)
    CALL EXITS("CMISSCoordinateSystemFocusGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCoordinateSystemFocusGetObj

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the focus of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystemFocusSetNumber(CoordinateSystemUserNumber,Focus,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CoordinateSystemUserNumber !<The user number of the coordinate system to set the focus for.
    REAL(DP), INTENT(IN) :: Focus !<The focus of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystemFocusSetNumber",Err,ERROR,*999)
 
    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(CoordinateSystemUserNumber,COORDINATE_SYSTEM,Err,ERROR,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_FOCUS_SET(COORDINATE_SYSTEM,Focus,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(CoordinateSystemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCoordinateSystemFocusSetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemFocusSetNumber",Err,ERROR)
    CALL EXITS("CMISSCoordinateSystemFocusSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCoordinateSystemFocusSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the focus of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystemFocusSetObj(CoordinateSystem,Focus,Err)
  
    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT) :: CoordinateSystem !<The coordinate system to set the focus for.
    REAL(DP), INTENT(IN) :: Focus !<The focus of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystemFocusSetObj",Err,ERROR,*999)
    
    CALL COORDINATE_SYSTEM_FOCUS_SET(CoordinateSystem%COORDINATE_SYSTEM,Focus,Err,ERROR,*999)

    CALL EXITS("CMISSCoordinateSystemFocusSetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemFocusSetObj",Err,ERROR)
    CALL EXITS("CMISSCoordinateSystemFocusSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCoordinateSystemFocusSetObj

  !  
  !================================================================================================================================
  !  
 
  !>Returns the radial interpolation type of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystemRadialInterpolationGetNumber(CoordinateSystemUserNumber,RadialInterpolationType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CoordinateSystemUserNumber !<The user number of the coordinate system to get the radial interpolation for.
    INTEGER(INTG), INTENT(OUT) :: RadialInterpolationType !<On return, the radial interpolation type of the coordinate system \see OPENCMISS_CoordinateRadialInterpolations
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystemRadialInterpolationGetNumber",Err,ERROR,*999)
 
    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(CoordinateSystemUserNumber,COORDINATE_SYSTEM,Err,ERROR,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_RADIAL_INTERPOLATION_TYPE_GET(COORDINATE_SYSTEM,RadialInterpolationType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(CoordinateSystemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCoordinateSystemRadialInterpolationGetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemRadialInterpolationGetNumber",Err,ERROR)
    CALL EXITS("CMISSCoordinateSystemRadialInterpolationGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCoordinateSystemRadialInterpolationGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the radial interpolation type of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystemRadialInterpolationGetObj(CoordinateSystem,RadialInterpolationType,Err)
  
    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT) :: CoordinateSystem !<The coordinate system to get the radial interpolation type for.
    INTEGER(INTG), INTENT(OUT) :: RadialInterpolationType !<On return, the radial interpolation type of the coordinate system. \see OPENCMISS_CoordinateRadialInterpolations
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystemRadialInterpolationGetObj",Err,ERROR,*999)
    
    CALL COORDINATE_SYSTEM_RADIAL_INTERPOLATION_TYPE_GET(CoordinateSystem%COORDINATE_SYSTEM,RadialInterpolationType,Err,ERROR,*999)

    CALL EXITS("CMISSCoordinateSystemRadialInterpolationGetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemRadialInterpolationGetObj",Err,ERROR)
    CALL EXITS("CMISSCoordinateSystemRadialInterpolationGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCoordinateSystemRadialInterpolationGetObj

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the radial interpolation type of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystemRadialInterpolationSetNumber(CoordinateSystemUserNumber,RadialInterpolationType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CoordinateSystemUserNumber !<The user number of the coordinate system to set the radial interpolation for.
    INTEGER(INTG), INTENT(IN) :: RadialInterpolationType !<The radial interpolation type of the coordinate system to set.\see OPENCMISS_CoordinateRadialInterpolations
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystemRadialInterpolationSetNumber",Err,ERROR,*999)
 
    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(CoordinateSystemUserNumber,COORDINATE_SYSTEM,Err,ERROR,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_RADIAL_INTERPOLATION_TYPE_SET(COORDINATE_SYSTEM,RadialInterpolationType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(CoordinateSystemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCoordinateSystemRadialInterpolationSetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemRadialInterpolationSetNumber",Err,ERROR)
    CALL EXITS("CMISSCoordinateSystemRadialInterpolationSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCoordinateSystemRadialInterpolationSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the radial interpolation type of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystemRadialInterpolationSetObj(CoordinateSystem,RadialInterpolationType,Err)
  
    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT)  :: CoordinateSystem !<The coordinate system to set the radial interpolation type for.
    INTEGER(INTG), INTENT(IN) :: RadialInterpolationType !<The radial interpolation type of the coordinate system to set. \see OPENCMISS_CoordinateRadialInterpolations
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystemRadialInterpolationSetObj",Err,ERROR,*999)
    
    CALL COORDINATE_SYSTEM_RADIAL_INTERPOLATION_TYPE_SET(CoordinateSystem%COORDINATE_SYSTEM,RadialInterpolationType,Err,ERROR,*999)

    CALL EXITS("CMISSCoordinateSystemRadialInterpolationSetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemRadialInterpolationSetObj",Err,ERROR)
    CALL EXITS("CMISSCoordinateSystemRadialInterpolationSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCoordinateSystemRadialInterpolationSetObj

  !  
  !================================================================================================================================
  !  
 
  !>Returns the type of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystemTypeGetNumber(CoordinateSystemUserNumber,CoordinateSystemType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CoordinateSystemUserNumber !<The user number of the coordinate system to get the type for.
    INTEGER(INTG), INTENT(OUT) :: CoordinateSystemType !<On return, the type of the coordinate system. \see OPENCMISS_CoordinateSystemTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystemTypeGetNumber",Err,ERROR,*999)
 
    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(CoordinateSystemUserNumber,COORDINATE_SYSTEM,Err,ERROR,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_TYPE_GET(COORDINATE_SYSTEM,CoordinateSystemType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(CoordinateSystemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCoordinateSystemTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemTypeGetNumber",Err,ERROR)
    CALL EXITS("CMISSCoordinateSystemTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCoordinateSystemTypeGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the type of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystemTypeGetObj(CoordinateSystem,CoordinateSystemType,Err)
  
    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(IN) :: CoordinateSystem !<The coordinate system to get the type for.
    INTEGER(INTG), INTENT(OUT) :: CoordinateSystemType !<On return, the type of the coordinate system. \see OPENCMISS_CoordinateSystemTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystemTypeGetObj",Err,ERROR,*999)
    
    CALL COORDINATE_SYSTEM_TYPE_GET(CoordinateSystem%COORDINATE_SYSTEM,CoordinateSystemType,Err,ERROR,*999)

    CALL EXITS("CMISSCoordinateSystemTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemTypeGetObj",Err,ERROR)
    CALL EXITS("CMISSCoordinateSystemTypeGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCoordinateSystemTypeGetObj

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the type of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystemTypeSetNumber(CoordinateSystemUserNumber,CoordinateSystemType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CoordinateSystemUserNumber !<The user number of the coordinate system to set the type for.
    INTEGER(INTG), INTENT(IN) :: CoordinateSystemType !<The type of the coordinate system to set. \see OPENCMISS_CoordinateSystemTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystemTypeSetNumber",Err,ERROR,*999)
 
    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(CoordinateSystemUserNumber,COORDINATE_SYSTEM,Err,ERROR,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_TYPE_SET(COORDINATE_SYSTEM,CoordinateSystemType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(CoordinateSystemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCoordinateSystemTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemTypeSetNumber",Err,ERROR)
    CALL EXITS("CMISSCoordinateSystemTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCoordinateSystemTypeSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the type of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystemTypeSetObj(CoordinateSystem,CoordinateSystemType,Err)
  
    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT) :: CoordinateSystem !<The coordinate system to set the type for.
    INTEGER(INTG), INTENT(IN) :: CoordinateSystemType !<The type of the coordinate system to set. \see OPENCMISS_CoordinateSystemTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystemTypeSetObj",Err,ERROR,*999)
    
    CALL COORDINATE_SYSTEM_TYPE_SET(CoordinateSystem%COORDINATE_SYSTEM,CoordinateSystemType,Err,ERROR,*999)

    CALL EXITS("CMISSCoordinateSystemTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemTypeSetObj",Err,ERROR)
    CALL EXITS("CMISSCoordinateSystemTypeSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCoordinateSystemTypeSetObj
  
  !  
  !================================================================================================================================
  !  
 
  !>Returns the origin of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystemOriginGetNumber(CoordinateSystemUserNumber,Origin,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CoordinateSystemUserNumber !<The user number of the coordinate system to get the origin for.
    REAL(DP), INTENT(OUT) :: Origin(:) !<On return, the orign of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystemOriginGetNumber",Err,ERROR,*999)
 
    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(CoordinateSystemUserNumber,COORDINATE_SYSTEM,Err,ERROR,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_ORIGIN_GET(COORDINATE_SYSTEM,Origin,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(CoordinateSystemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCoordinateSystemOriginGetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemOriginGetNumber",Err,ERROR)
    CALL EXITS("CMISSCoordinateSystemOriginGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCoordinateSystemOriginGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the origin of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystemOriginGetObj(CoordinateSystem,Origin,Err)
  
    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(IN) :: CoordinateSystem !<The coordinate system to get the origin for.
    REAL(DP), INTENT(OUT) :: Origin(:) !<On return, the origin of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystemOriginGetObj",Err,ERROR,*999)
    
    CALL COORDINATE_SYSTEM_ORIGIN_GET(CoordinateSystem%COORDINATE_SYSTEM,Origin,Err,ERROR,*999)

    CALL EXITS("CMISSCoordinateSystemOriginGetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemOriginGetObj",Err,ERROR)
    CALL EXITS("CMISSCoordinateSystemOriginGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCoordinateSystemOriginGetObj

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the origin of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystemOriginSetNumber(CoordinateSystemUserNumber,Origin,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CoordinateSystemUserNumber !<The user number of the coordinate system to set the origin for.
    REAL(DP), INTENT(IN) :: Origin(:) !<The orign of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystemOriginSetNumber",Err,ERROR,*999)
 
    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(CoordinateSystemUserNumber,COORDINATE_SYSTEM,Err,ERROR,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_ORIGIN_SET(COORDINATE_SYSTEM,Origin,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(CoordinateSystemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCoordinateSystemOriginSetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemOriginSetNumber",Err,ERROR)
    CALL EXITS("CMISSCoordinateSystemOriginSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCoordinateSystemOriginSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the origin of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystemOriginSetObj(CoordinateSystem,Origin,Err)
  
    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(IN) :: CoordinateSystem !<The coordinate system to set the origin for.
    REAL(DP), INTENT(IN) :: Origin(:) !<The origin of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystemOriginSetObj",Err,ERROR,*999)
    
    CALL COORDINATE_SYSTEM_ORIGIN_SET(CoordinateSystem%COORDINATE_SYSTEM,Origin,Err,ERROR,*999)

    CALL EXITS("CMISSCoordinateSystemOriginSetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemOriginSetObj",Err,ERROR)
    CALL EXITS("CMISSCoordinateSystemOriginSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCoordinateSystemOriginSetObj

  !  
  !================================================================================================================================
  !  
 
  !>Returns the orientation of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystemOrientationGetNumber(CoordinateSystemUserNumber,Orientation,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CoordinateSystemUserNumber !<The user number of the coordinate system to get the orientation for.
    REAL(DP), INTENT(OUT) :: Orientation(:,:) !<On return, the orientation of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystemOrientationGetNumber",Err,ERROR,*999)
 
    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(CoordinateSystemUserNumber,COORDINATE_SYSTEM,Err,ERROR,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_ORIENTATION_GET(COORDINATE_SYSTEM,ORIENTATION,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(CoordinateSystemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCoordinateSystemOrientationGetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemOrientationGetNumber",Err,ERROR)
    CALL EXITS("CMISSCoordinateSystemOrientationGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCoordinateSystemOrientationGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the orientation of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystemOrientationGetObj(CoordinateSystem,Orientation,Err)
  
    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(IN) :: CoordinateSystem !<The coordinate system to get the orientation for.
    REAL(DP), INTENT(OUT) :: Orientation(:,:) !<On return, the orientation of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystemOrientationGetObj",Err,ERROR,*999)
    
    CALL COORDINATE_SYSTEM_ORIENTATION_GET(CoordinateSystem%COORDINATE_SYSTEM,Orientation,Err,ERROR,*999)

    CALL EXITS("CMISSCoordinateSystemOrientationGetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemOrientationGetObj",Err,ERROR)
    CALL EXITS("CMISSCoordinateSystemOrientationGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCoordinateSystemOrientationGetObj

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the orientation of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystemOrientationSetNumber(CoordinateSystemUserNumber,Orientation,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CoordinateSystemUserNumber !<The user number of the coordinate system to set the orientation for.
    REAL(DP), INTENT(IN) :: Orientation(:,:) !<The orientation of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystemOrientationSetNumber",Err,ERROR,*999)
 
    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(CoordinateSystemUserNumber,COORDINATE_SYSTEM,Err,ERROR,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_ORIENTATION_SET(COORDINATE_SYSTEM,ORIENTATION,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(CoordinateSystemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSCoordinateSystemOrientationSetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemOrientationSetNumber",Err,ERROR)
    CALL EXITS("CMISSCoordinateSystemOrientationSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCoordinateSystemOrientationSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the orientation of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystemOrientationSetObj(CoordinateSystem,Orientation,Err)
  
    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT) :: CoordinateSystem !<The coordinate system to set the orientation for.
    REAL(DP), INTENT(IN) :: Orientation(:,:) !<The orientation of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystemOrientationSetObj",Err,ERROR,*999)
    
    CALL COORDINATE_SYSTEM_ORIENTATION_SET(CoordinateSystem%COORDINATE_SYSTEM,Orientation,Err,ERROR,*999)

    CALL EXITS("CMISSCoordinateSystemOrientationSetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemOrientationSetObj",Err,ERROR)
    CALL EXITS("CMISSCoordinateSystemOrientationSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSCoordinateSystemOrientationSetObj

!!==================================================================================================================================
!!
!! EQUATIONS_ROUTINES
!!
!!==================================================================================================================================

  !>Destroys equations for equations identified by a user number.
  SUBROUTINE CMISSEquationsDestroyNumber(RegionUserNumber,EquationsSetUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations to destroy.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to destroy the equations for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSEquationsDestroyNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,ERROR,*999)
        CALL EQUATIONS_DESTROY(EQUATIONS,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsDestroyNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsDestroyNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsDestroyNumber

  !  
  !================================================================================================================================
  !  
 
  !>Destroy equations for equations identified by an object.
  SUBROUTINE CMISSEquationsDestroyObj(Equations,Err)
  
    !Argument variables
    TYPE(CMISSEquationsType), INTENT(INOUT) :: Equations !<The equations to destroy.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSEquationsDestroyObj",Err,ERROR,*999)
 
    CALL EQUATIONS_DESTROY(Equations%EQUATIONS,Err,ERROR,*999)

    CALL EXITS("CMISSEquationsDestroyObj")
    RETURN
999 CALL ERRORS("CMISSEquationsDestroyObj",Err,ERROR)
    CALL EXITS("CMISSEquationsDestroyObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsDestroyObj
  
  !  
  !================================================================================================================================
  !  
 
  !>Gets the linearity type for equations identified by a user number.
  SUBROUTINE CMISSEquationsLinearityTypeGetNumber(RegionUserNumber,EquationsSetUserNumber,LinearityType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations to get the linearity type for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to get the linearity type for.
    INTEGER(INTG), INTENT(OUT) :: LinearityType !<On return, the linearity type of the equations \see OPENCMISS_EquationsLinearityTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSEquationsLinearityTypeGetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,ERROR,*999)
        CALL EQUATIONS_LINEARITY_TYPE_GET(EQUATIONS,LinearityType,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsLinearityTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsLinearityTypeGetNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsLinearityTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsLinearityTypeGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Gets the linearity type for equations identified by an object.
  SUBROUTINE CMISSEquationsLinearityTypeGetObj(Equations,LinearityType,Err)
  
    !Argument variables
    TYPE(CMISSEquationsType), INTENT(IN) :: Equations !<The equations to get the linearity type for.
    INTEGER(INTG), INTENT(OUT) :: LinearityType !<On return, the linearity type of the equations \see OPENCMISS_EquationsLinearityTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSEquationsLinearityTypeGetObj",Err,ERROR,*999)
 
    CALL EQUATIONS_LINEARITY_TYPE_GET(Equations%EQUATIONS,LinearityType,Err,ERROR,*999)

    CALL EXITS("CMISSEquationsLinearityTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsLinearityTypeGetObj",Err,ERROR)
    CALL EXITS("CMISSEquationsLinearityTypeGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsLinearityTypeGetObj

  !  
  !================================================================================================================================
  !  
 
  !>Gets the lumping type for equations identified by a user number.
  SUBROUTINE CMISSEquationsLumpingTypeGetNumber(RegionUserNumber,EquationsSetUserNumber,LumpingType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations to get the lumping type for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to get the lumping type for.
    INTEGER(INTG), INTENT(OUT) :: LumpingType !<On return, the lumping type of the equations \see OPENCMISS_EquationsLumpingTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSEquationsLumpingTypeGetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,ERROR,*999)
        CALL EQUATIONS_LUMPING_TYPE_GET(EQUATIONS,LumpingType,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsLumpingTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsLumpingTypeGetNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsLumpingTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsLumpingTypeGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Gets the lumping type for equations identified by an object.
  SUBROUTINE CMISSEquationsLumpingTypeGetObj(Equations,LumpingType,Err)
  
    !Argument variables
    TYPE(CMISSEquationsType), INTENT(IN) :: Equations !<The equations to get the lumping type for.
    INTEGER(INTG), INTENT(OUT) :: LumpingType !<On return, the lumping type of the equations \see OPENCMISS_EquationsLumpingTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSEquationsLumpingTypeGetObj",Err,ERROR,*999)
 
    CALL EQUATIONS_LUMPING_TYPE_GET(Equations%EQUATIONS,LumpingType,Err,ERROR,*999)

    CALL EXITS("CMISSEquationsLumpingTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsLumpingTypeGetObj",Err,ERROR)
    CALL EXITS("CMISSEquationsLumpingTypeGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsLumpingTypeGetObj

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the lumping type for equations identified by a user number.
  SUBROUTINE CMISSEquationsLumpingTypeSetNumber(RegionUserNumber,EquationsSetUserNumber,LumpingType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations to set the lumping type for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to set the lumping type for.
    INTEGER(INTG), INTENT(IN) :: LumpingType !<The lumping type of the equations to set\see OPENCMISS_EquationsLumpingTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSEquationsLumpingTypeSetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,ERROR,*999)
        CALL EQUATIONS_LUMPING_TYPE_SET(EQUATIONS,LumpingType,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsLumpingTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsLumpingTypeSetNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsLumpingTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsLumpingTypeSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the lumping type for equations identified by an object.
  SUBROUTINE CMISSEquationsLumpingTypeSetObj(Equations,LumpingType,Err)
  
    !Argument variables
    TYPE(CMISSEquationsType), INTENT(INOUT) :: Equations !<The equations to set the lumping type for.
    INTEGER(INTG), INTENT(IN) :: LumpingType !<The lumping type of the equations to set\see OPENCMISS_EquationsLumpingTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSEquationsLumpingTypeSetObj",Err,ERROR,*999)
 
    CALL EQUATIONS_LUMPING_TYPE_SET(Equations%EQUATIONS,LumpingType,Err,ERROR,*999)

    CALL EXITS("CMISSEquationsLumpingTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsLumpingTypeSetObj",Err,ERROR)
    CALL EXITS("CMISSEquationsLumpingTypeSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsLumpingTypeSetObj

  !  
  !================================================================================================================================
  !  
 
  !>Gets the output type for equations identified by a user number.
  SUBROUTINE CMISSEquationsOutputTypeGetNumber(RegionUserNumber,EquationsSetUserNumber,OutputType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations to get the output type for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: OutputType !<On return, the output type of the equations \see OPENCMISS_EquationsOutputTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSEquationsOutputTypeGetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,ERROR,*999)
        CALL EQUATIONS_OUTPUT_TYPE_GET(EQUATIONS,OutputType,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsOutputTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsOutputTypeGetNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsOutputTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsOutputTypeGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Gets the output type for equations identified by an object.
  SUBROUTINE CMISSEquationsOutputTypeGetObj(Equations,OutputType,Err)
  
    !Argument variables
    TYPE(CMISSEquationsType), INTENT(IN) :: Equations !<The equations to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: OutputType !<On return, the output type of the equations \see OPENCMISS_EquationsOutputTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSEquationsOutputTypeGetObj",Err,ERROR,*999)
 
    CALL EQUATIONS_OUTPUT_TYPE_GET(Equations%EQUATIONS,OutputType,Err,ERROR,*999)

    CALL EXITS("CMISSEquationsOutputTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsOutputTypeGetObj",Err,ERROR)
    CALL EXITS("CMISSEquationsOutputTypeGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsOutputTypeGetObj

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the output type for equations identified by a user number.
  SUBROUTINE CMISSEquationsOutputTypeSetNumber(RegionUserNumber,EquationsSetUserNumber,OutputType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations to set the output type for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to set the output type for.
    INTEGER(INTG), INTENT(IN) :: OutputType !<The output type of the equations to set \see OPENCMISS_EquationsOutputTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSEquationsOutputTypeSetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,ERROR,*999)
        CALL EQUATIONS_OUTPUT_TYPE_SET(EQUATIONS,OutputType,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsOutputTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsOutputTypeSetNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsOutputTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsOutputTypeSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the output type for equations identified by an object.
  SUBROUTINE CMISSEquationsOutputTypeSetObj(Equations,OutputType,Err)
  
    !Argument variables
    TYPE(CMISSEquationsType), INTENT(INOUT) :: Equations !<The equations to set the output type for.
    INTEGER(INTG), INTENT(IN) :: OutputType !<The output type of the equations to set \see OPENCMISS_EquationsOutputTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSEquationsOutputTypeSetObj",Err,ERROR,*999)
 
    CALL EQUATIONS_OUTPUT_TYPE_SET(Equations%EQUATIONS,OutputType,Err,ERROR,*999)

    CALL EXITS("CMISSEquationsOutputTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsOutputTypeSetObj",Err,ERROR)
    CALL EXITS("CMISSEquationsOutputTypeSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsOutputTypeSetObj

  !  
  !================================================================================================================================
  !  
 
  !>Gets the sparsity type for equations identified by a user number.
  SUBROUTINE CMISSEquationsSparsityTypeGetNumber(RegionUserNumber,EquationsSetUserNumber,SparsityType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations to get the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to get the sparsity type for.
    INTEGER(INTG), INTENT(OUT) :: SparsityType !<On return, the sparsity type of the equations \see OPENCMISS_EquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSEquationsSparsityTypeGetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,ERROR,*999)
        CALL EQUATIONS_SPARSITY_TYPE_GET(EQUATIONS,SparsityType,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSparsityTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSparsityTypeGetNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsSparsityTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSparsityTypeGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Gets the sparsity type for equations identified by an object.
  SUBROUTINE CMISSEquationsSparsityTypeGetObj(Equations,SparsityType,Err)
  
    !Argument variables
    TYPE(CMISSEquationsType), INTENT(IN) :: Equations !<The equations to get the sparsity type for.
    INTEGER(INTG), INTENT(OUT) :: SparsityType !<On return, the sparsity type of the equations \see OPENCMISS_EquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSEquationsSparsityTypeGetObj",Err,ERROR,*999)
 
    CALL EQUATIONS_SPARSITY_TYPE_GET(Equations%EQUATIONS,SparsityType,Err,ERROR,*999)

    CALL EXITS("CMISSEquationsSparsityTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSparsityTypeGetObj",Err,ERROR)
    CALL EXITS("CMISSEquationsSparsityTypeGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSparsityTypeGetObj

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the sparsity type for equations identified by a user number.
  SUBROUTINE CMISSEquationsSparsityTypeSetNumber(RegionUserNumber,EquationsSetUserNumber,SparsityType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: SparsityType !<The sparsity type of the equations to set \see OPENCMISS_EquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSEquationsSparsityTypeSetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,ERROR,*999)
        CALL EQUATIONS_SPARSITY_TYPE_SET(EQUATIONS,SparsityType,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSparsityTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSparsityTypeSetNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsSparsityTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSparsityTypeSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the sparsity type for equations identified by an object.
  SUBROUTINE CMISSEquationsSparsityTypeSetObj(Equations,SparsityType,Err)
  
    !Argument variables
    TYPE(CMISSEquationsType), INTENT(INOUT) :: Equations !<The equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: SparsityType !<The sparsity type of the equations to set \see OPENCMISS_EquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSEquationsSparsityTypeSetObj",Err,ERROR,*999)
 
    CALL EQUATIONS_SPARSITY_TYPE_SET(Equations%EQUATIONS,SparsityType,Err,ERROR,*999)

    CALL EXITS("CMISSEquationsSparsityTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSparsityTypeSetObj",Err,ERROR)
    CALL EXITS("CMISSEquationsSparsityTypeSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSparsityTypeSetObj

  !  
  !================================================================================================================================
  !  
 
  !>Gets the time dependence type for equations identified by a user number.
  SUBROUTINE CMISSEquationsTimeDependenceTypeGetNumber(RegionUserNumber,EquationsSetUserNumber,TimeDependenceType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations to get the time dependence type for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to get the time dependence type for.
    INTEGER(INTG), INTENT(OUT) :: TimeDependenceType !<On return, the time dependence type of the equations \see OPENCMISS_EquationsTimeDependenceTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSEquationsTimeDependenceTypeGetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,ERROR,*999)
        CALL EQUATIONS_TIME_DEPENDENCE_TYPE_GET(EQUATIONS,TimeDependenceType,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsTimeDependenceTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsTimeDependenceTypeGetNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsTimeDependenceTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsTimeDependenceTypeGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Gets the time dependence type for equations identified by an object.
  SUBROUTINE CMISSEquationsTimeDependenceTypeGetObj(Equations,TimeDependenceType,Err)
  
    !Argument variables
    TYPE(CMISSEquationsType), INTENT(IN) :: Equations !<The equations to get the time dependence type for.
    INTEGER(INTG), INTENT(OUT) :: TimeDependenceType !<On return, the time dependence type of the equations \see OPENCMISS_EquationsTimeDependenceTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSEquationsTimeDependenceTypeGetObj",Err,ERROR,*999)
 
    CALL EQUATIONS_TIME_DEPENDENCE_TYPE_GET(Equations%EQUATIONS,TimeDependenceType,Err,ERROR,*999)

    CALL EXITS("CMISSEquationsTimeDependenceTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsTimeDependenceTypeGetObj",Err,ERROR)
    CALL EXITS("CMISSEquationsTimeDependenceTypeGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsTimeDependenceTypeGetObj


!!==================================================================================================================================
!!
!! EQUATIONS_SET_ROUTINES
!!
!!==================================================================================================================================

  !>Finish the creation of a analytic solution for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetAnalyticCreateFinishNumber(RegionUserNumber,EquationsSetUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations set to finish.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSEquationsSetAnalyticCreateFinishNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_ANALYTIC_CREATE_FINISH(EQUATIONS_SET,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetAnalyticCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetAnalyticCreateFinishNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsSetAnalyticCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetAnalyticCreateFinishNumber

  !  
  !================================================================================================================================
  !  
 
  !>Finish the creation of a analytic solution for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetAnalyticCreateFinishObj(EquationsSet,Err)
  
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: EquationsSet !<The equations set to finish.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSEquationsSetAnalyticCreateFinishObj",Err,ERROR,*999)
 
    CALL EQUATIONS_SET_ANALYTIC_CREATE_FINISH(EquationsSet%EQUATIONS_SET,Err,ERROR,*999)

    CALL EXITS("CMISSEquationsSetAnalyticCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetAnalyticCreateFinishObj",Err,ERROR)
    CALL EXITS("CMISSEquationsSetAnalyticCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetAnalyticCreateFinishObj

  !  
  !================================================================================================================================
  !  

  !>Start the creation of a analytic solution for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetAnalyticCreateStartNumber(RegionUserNumber,EquationsSetUserNumber,AnalyticFunctionType, &
    & AnalyticFieldUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations set to finish.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: AnalyticFunctionType !<The analytic function type to use. \see OPENCMISS_EquationsSetAnalyticFunctionTypes
    INTEGER(INTG), INTENT(IN) :: AnalyticFieldUserNumber !<The user number of the field for the analytic function
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(FIELD_TYPE), POINTER :: ANALYTIC_FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetAnalyticCreateStartNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(ANALYTIC_FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL FIELD_USER_NUMBER_FIND(AnalyticFieldUserNumber,REGION,ANALYTIC_FIELD,ERR,ERROR,*999)
        CALL EQUATIONS_SET_ANALYTIC_CREATE_START(EQUATIONS_SET,AnalyticFunctionType,AnalyticFieldUserNumber,ANALYTIC_FIELD, &
          & Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetAnalyticCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetAnalyticCreateStartNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsSetAnalyticCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetAnalyticCreateStartNumber

  !  
  !================================================================================================================================
  !  

  !>Start the creation of an analytic solution for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetAnalyticCreateStartObj(EquationsSet,AnalyticFunctionType,AnalyticFieldUserNumber,AnalyticField,Err)
  
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(OUT) :: EquationsSet !<The equations set to start the analytic creation on.
    INTEGER(INTG), INTENT(IN) :: AnalyticFunctionType !<The analytic function type to use. \see OPENCMISS_EquationsSetAnalyticFunctionTypes
    INTEGER(INTG), INTENT(IN) :: AnalyticFieldUserNumber !<The user number of the field for the analytic function
    TYPE(CMISSFieldType), INTENT(INOUT) :: AnalyticField !<If associated on entry, the user created analytic field which has the same user number as the specified analytic field user number. If not associated on entry, on return, the created analytic field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
 
    CALL ENTERS("CMISSEquationsSetAnalyticCreateStartObj",Err,ERROR,*999)
 
    CALL EQUATIONS_SET_ANALYTIC_CREATE_START(EquationsSet%EQUATIONS_SET,AnalyticFunctionType,AnalyticFieldUserNumber, &
      & AnalyticField%FIELD,Err,ERROR,*999)
    
    CALL EXITS("CMISSEquationsSetAnalyticCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetAnalyticCreateStartObj",Err,ERROR)
    CALL EXITS("CMISSEquationsSetAnalyticCreateStartObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetAnalyticCreateStartObj

  !  
  !================================================================================================================================
  !  

  !>Destroy the analytic solution for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetAnalyticDestroyNumber(RegionUserNumber,EquationsSetUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations set to destroy.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to destroy.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
     TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetAnalyticDestroyNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_ANALYTIC_DESTROY(EQUATIONS_SET,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetAnalyticDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetAnalyticDestroyNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsSetAnalyticDestroyNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetAnalyticDestroyNumber

  !  
  !================================================================================================================================
  !  

  !>Destroy the analytic solution for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetAnalyticDestroyObj(EquationsSet,Err)
  
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: EquationsSet !<The equations set to destroy the analytic for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
 
    CALL ENTERS("CMISSEquationsSetAnalyticDestroyObj",Err,ERROR,*999)
 
    CALL EQUATIONS_SET_ANALYTIC_DESTROY(EquationsSet%EQUATIONS_SET,Err,ERROR,*999)
    
    CALL EXITS("CMISSEquationsSetAnalyticDestroyObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetAnalyticDestroyObj",Err,ERROR)
    CALL EXITS("CMISSEquationsSetAnalyticDestroyObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetAnalyticDestroyObj

  !  
  !================================================================================================================================
  !  

  !>Set boundary conditions for an equation set according to the analytic equations for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetBoundaryConditionsAnalyticNumber(RegionUserNumber,EquationsSetUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations set to set the analytic boundary conditions.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to set the analytic boundary conditions.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetBoundaryConditionsAnalyticNumber",Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Analytic Boundary Conditions Create')
#endif

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_BOUNDARY_CONDITIONS_ANALYTIC(EQUATIONS_SET,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Analytic Boundary Conditions Create')
#endif

    CALL EXITS("CMISSEquationsSetBoundaryConditionsAnalyticNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetBoundaryConditionsAnalyticNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsSetBoundaryConditionsAnalyticNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetBoundaryConditionsAnalyticNumber

  !  
  !================================================================================================================================
  !  

  !>Set boundary conditions for an equation set according to the analytic equations for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetBoundaryConditionsAnalyticObj(EquationsSet,Err)
  
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: EquationsSet !<The equations set to set the analytic boundary conditions.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
 
    CALL ENTERS("CMISSEquationsSetBoundaryConditionsAnalyticObj",Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Analytic Boundary Conditions Create')
#endif

    CALL EQUATIONS_SET_BOUNDARY_CONDITIONS_ANALYTIC(EquationsSet%EQUATIONS_SET,Err,ERROR,*999)
    
#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Analytic Boundary Conditions Create')
#endif

    CALL EXITS("CMISSEquationsSetBoundaryConditionsAnalyticObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetBoundaryConditionsAnalyticObj",Err,ERROR)
    CALL EXITS("CMISSEquationsSetBoundaryConditionsAnalyticObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetBoundaryConditionsAnalyticObj

  !  
  !================================================================================================================================
  !  
 
  !>Finish the creation of boundary conditions for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetBoundaryConditionsCreateFinishNumber(RegionUserNumber,EquationsSetUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the boundary conditions to finish.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to finish the creation of boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSEquationsSetBoundaryConditionsCreateFinishNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_BOUNDARY_CONDITIONS_CREATE_FINISH(EQUATIONS_SET,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Boundary Conditions Create')
#endif

    CALL EXITS("CMISSEquationsSetBoundaryConditionsCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetBoundaryConditionsCreateFinishNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsSetBoundaryConditionsCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetBoundaryConditionsCreateFinishNumber

  !  
  !================================================================================================================================
  !  
 
  !>Finish the creation of a boundary conditions for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetBoundaryConditionsCreateFinishObj(EquationsSet,Err)
  
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: EquationsSet !<The equations set to finish the creation of boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSEquationsSetBoundaryConditionsCreateFinishObj",Err,ERROR,*999)
 
    CALL EQUATIONS_SET_BOUNDARY_CONDITIONS_CREATE_FINISH(EquationsSet%EQUATIONS_SET,Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Boundary Conditions Create')
#endif

    CALL EXITS("CMISSEquationsSetBoundaryConditionsCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetBoundaryConditionsCreateFinishObj",Err,ERROR)
    CALL EXITS("CMISSEquationsSetBoundaryConditionsCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetBoundaryConditionsCreateFinishObj

  !  
  !================================================================================================================================
  !  

  !>Start the creation of boundary conditions for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetBoundaryConditionsCreateStartNumber(RegionUserNumber,EquationsSetUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the boundary conditions to start the creation of.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to start the creation of boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetBoundaryConditionsCreateStartNumber",Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Boundary Conditions Create')
#endif
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(BOUNDARY_CONDITIONS)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_BOUNDARY_CONDITIONS_CREATE_START(EQUATIONS_SET,BOUNDARY_CONDITIONS,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetBoundaryConditionsCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetBoundaryConditionsCreateStartNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsSetBoundaryConditionsCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetBoundaryConditionsCreateStartNumber

  !  
  !================================================================================================================================
  !  

  !>Start the creation of boundary conditions for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetBoundaryConditionsCreateStartObj(EquationsSet,BoundaryConditions,Err)
  
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(OUT) :: EquationsSet !<The equations set to start the creation of boundary conditions on.
    TYPE(CMISSBoundaryConditionsType), INTENT(INOUT) :: BoundaryConditions !<On return, the created boundary conditions.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
 
    CALL ENTERS("CMISSEquationsSetBoundaryConditionsCreateStartObj",Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Boundary Conditions Create')
#endif
 
    CALL EQUATIONS_SET_BOUNDARY_CONDITIONS_CREATE_START(EquationsSet%EQUATIONS_SET,BoundaryConditions%BOUNDARY_CONDITIONS, &
      & Err,ERROR,*999)
    
    CALL EXITS("CMISSEquationsSetBoundaryConditionsCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetBoundaryConditionsCreateStartObj",Err,ERROR)
    CALL EXITS("CMISSEquationsSetBoundaryConditionsCreateStartObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetBoundaryConditionsCreateStartObj

  !  
  !================================================================================================================================
  !  

  !>Destroy the boundary conditions for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetBoundaryConditionsDestroyNumber(RegionUserNumber,EquationsSetUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations set to destory the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetBoundaryConditionsDestroyNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_BOUNDARY_CONDITIONS_DESTROY(EQUATIONS_SET,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetBoundaryConditionsDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetBoundaryConditionsDestroyNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsSetBoundaryConditionsDestroyNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetBoundaryConditionsDestroyNumber

  !  
  !================================================================================================================================
  !  

  !>Destroy the boundary conditions for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetBoundaryConditionsDestroyObj(EquationsSet,Err)
  
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: EquationsSet !<The equations set to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
 
    CALL ENTERS("CMISSEquationsSetBoundaryConditionsDestroyObj",Err,ERROR,*999)
 
    CALL EQUATIONS_SET_BOUNDARY_CONDITIONS_DESTROY(EquationsSet%EQUATIONS_SET,Err,ERROR,*999)
    
    CALL EXITS("CMISSEquationsSetBoundaryConditionsDestroyObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetBoundaryConditionsDestroyObj",Err,ERROR)
    CALL EXITS("CMISSEquationsSetBoundaryConditionsDestroyObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetBoundaryConditionsDestroyObj

  !  
  !================================================================================================================================
  !  
 
  !>Finish the creation of an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetCreateFinishNumber(RegionUserNumber,EquationsSetUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations set to finish.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSEquationsSetCreateFinishNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_CREATE_FINISH(EQUATIONS_SET,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Equations Set Create')
#endif

    CALL EXITS("CMISSEquationsSetCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetCreateFinishNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsSetreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetCreateFinishNumber

  !  
  !================================================================================================================================
  !  
 
  !>Finish the creation of an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetCreateFinishObj(EquationsSet,Err)
  
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: EquationsSet !<The equations set to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSEquationsSetCreateFinishObj",Err,ERROR,*999)
 
    CALL EQUATIONS_SET_CREATE_FINISH(EquationsSet%EQUATIONS_SET,Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Equations Set Create')
#endif

    CALL EXITS("CMISSEquationsSetCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetCreateFinishObj",Err,ERROR)
    CALL EXITS("CMISSEquationsSetCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetCreateFinishObj

  !  
  !================================================================================================================================
  !  

  !>Start the creation of an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetCreateStartNumber(EquationsSetUserNumber,RegionUserNumber,GeomFibreFieldUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to be created.
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region to start the creation of an equations set on.
    INTEGER(INTG), INTENT(IN) :: GeomFibreFieldUserNumber !<The user number of the Geometric/Fibre field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(FIELD_TYPE), POINTER :: GEOM_FIBRE_FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetCreateStartNumber",Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Equations Set Create')
#endif
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(GEOM_FIBRE_FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(GeomFibreFieldUserNumber,REGION,GEOM_FIBRE_FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(GEOM_FIBRE_FIELD)) THEN
        CALL EQUATIONS_SET_CREATE_START(EquationsSetUserNumber,REGION,GEOM_FIBRE_FIELD,EQUATIONS_SET,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(GeomFibreFieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetCreateStartNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsSetCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetCreateStartNumber

  !  
  !================================================================================================================================
  !  

  !>Start the creation of an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetCreateStartObj(EquationsSetUserNumber,Region,GeomFibreField,EquationsSet,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to be created.
    TYPE(CMISSRegionType), INTENT(IN) :: Region !<The region to create the equations set on.
    TYPE(CMISSFieldType), INTENT(IN) :: GeomFibreField !<The Geometric/Fibre field for the creation of the equations set.
    TYPE(CMISSEquationsSetType), INTENT(OUT) :: EquationsSet !<On return, the created equations set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
 
    CALL ENTERS("CMISSEquationsSetCreateStartObj",Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Equations Set Create')
#endif
 
    CALL EQUATIONS_SET_CREATE_START(EquationsSetUserNumber,Region%REGION,GeomFibreField%FIELD,EquationsSet%EQUATIONS_SET, &
      & Err,ERROR,*999)
    
    CALL EXITS("CMISSEquationsSetCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetCreateStartObj",Err,ERROR)
    CALL EXITS("CMISSEquationsSetCreateStartObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetCreateStartObj

  !  
  !================================================================================================================================
  !  

  !>Destroy an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetDestroyNumber(RegionUserNumber,EquationsSetUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations set to destory.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to destroy.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
     TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetDestroyNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_DESTROY(EQUATIONS_SET,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetDestroyNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsSetDestroyNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetDestroyNumber

  !  
  !================================================================================================================================
  !  

  !>Destroy an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetDestroyObj(EquationsSet,Err)
  
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: EquationsSet !<The equations set to destroy.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
 
    CALL ENTERS("CMISSEquationsSetDestroyObj",Err,ERROR,*999)
 
    CALL EQUATIONS_SET_DESTROY(EquationsSet%EQUATIONS_SET,Err,ERROR,*999)
    
    CALL EXITS("CMISSEquationsSetDestroyObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetDestroyObj",Err,ERROR)
    CALL EXITS("CMISSEquationsSetDestroyObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetDestroyObj

  !  
  !================================================================================================================================
  !  

  !>Finish the creation of dependent variables for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetDependentCreateFinishNumber(RegionUserNumber,EquationsSetUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations set to finish the creation of dependent variables for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to finish the creation of dependent variables for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSEquationsSetDependentCreateFinishNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_DEPENDENT_CREATE_FINISH(EQUATIONS_SET,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetDependentCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetDependentCreateFinishNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsSetDependentCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetDependentCreateFinishNumber

  !  
  !================================================================================================================================
  !  
 
  !>Finish the creation of dependent variables for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetDependentCreateFinishObj(EquationsSet,Err)
  
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: EquationsSet !<The equations set to finish the creation of dependent variables for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSEquationsSetDependentCreateFinishObj",Err,ERROR,*999)
 
    CALL EQUATIONS_SET_DEPENDENT_CREATE_FINISH(EquationsSet%EQUATIONS_SET,Err,ERROR,*999)

    CALL EXITS("CMISSEquationsSetDependentCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetDependentCreateFinishObj",Err,ERROR)
    CALL EXITS("CMISSEquationsSetDependentCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetDependentCreateFinishObj

  !  
  !================================================================================================================================
  !  

  !>Start the creation of dependent variables for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetDependentCreateStartNumber(RegionUserNumber,EquationsSetUserNumber,DependentFieldUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations set to start the creation of dependent variables for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to start the creation of dependent variables for.
    INTEGER(INTG), INTENT(IN) :: DependentFieldUserNumber !<The user number of the dependent field.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetDependentCreateStartNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(DEPENDENT_FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL FIELD_USER_NUMBER_FIND(DependentFieldUserNumber,REGION,DEPENDENT_FIELD,ERR,ERROR,*999)
        CALL EQUATIONS_SET_DEPENDENT_CREATE_START(EQUATIONS_SET,DependentFieldUserNumber,DEPENDENT_FIELD,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetDependentCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetDependentCreateStartNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsSetDependentCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetDependentCreateStartNumber

  !  
  !================================================================================================================================
  !  

  !>Start the creation of dependent variables for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetDependentCreateStartObj(EquationsSet,DependentFieldUserNumber,DependentField,Err)
  
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(OUT) :: EquationsSet !<The equations set to start the creation of dependent variables on.
    INTEGER(INTG), INTENT(IN) :: DependentFieldUserNumber !<The user number of the dependent field.
    TYPE(CMISSFieldType), INTENT(INOUT) :: DependentField !<If associated on entry, the user created dependent field which has the same user number as the specified dependent field user number. If not associated on entry, on return, the created dependent field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
 
    CALL ENTERS("CMISSEquationsSetDependentCreateStartObj",Err,ERROR,*999)
 
    CALL EQUATIONS_SET_DEPENDENT_CREATE_START(EquationsSet%EQUATIONS_SET,DependentFieldUserNumber,DependentField%FIELD, &
      & Err,ERROR,*999)
    
    CALL EXITS("CMISSEquationsSetDependentCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetDependentCreateStartObj",Err,ERROR)
    CALL EXITS("CMISSEquationsSetDependentCreateStartObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetDependentCreateStartObj

  !  
  !================================================================================================================================
  !  

  !>Destroy the dependent variables for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetDependentDestroyNumber(RegionUserNumber,EquationsSetUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations set to destroy the dependent variables for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to destroy the dependent variables for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetDependentDestroyNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_DEPENDENT_DESTROY(EQUATIONS_SET,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetDependentDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetDependentDestroyNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsSetDependentDestroyNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetDependentDestroyNumber

  !  
  !================================================================================================================================
  !  

  !>Destroy the dependent variables for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetDependentDestroyObj(EquationsSet,Err)
  
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: EquationsSet !<The equations set to destroy the dependent variables for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
 
    CALL ENTERS("CMISSEquationsSetDependentDestroyObj",Err,ERROR,*999)
 
    CALL EQUATIONS_SET_DEPENDENT_DESTROY(EquationsSet%EQUATIONS_SET,Err,ERROR,*999)
    
    CALL EXITS("CMISSEquationsSetDependentDestroyObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetDependentDestroyObj",Err,ERROR)
    CALL EXITS("CMISSEquationsSetDependentDestroyObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetDependentDestroyObj

  !  
  !================================================================================================================================
  !  

  !>Finish the creation of equations for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetEquationsCreateFinishNumber(RegionUserNumber,EquationsSetUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations set to finish the creation of equations for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to finish the creation of equations for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSEquationsSetEquationsCreateFinishNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_CREATE_FINISH(EQUATIONS_SET,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetEquationsCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetEquationsCreateFinishNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsSetEquationsCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetEquationsCreateFinishNumber

  !  
  !================================================================================================================================
  !  
 
  !>Finish the creation of equations for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetEquationsCreateFinishObj(EquationsSet,Err)
  
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: EquationsSet !<The equations set to finish the creation of equations for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSEquationsSetEquationsCreateFinishObj",Err,ERROR,*999)
 
    CALL EQUATIONS_SET_EQUATIONS_CREATE_FINISH(EquationsSet%EQUATIONS_SET,Err,ERROR,*999)

    CALL EXITS("CMISSEquationsSetEquationsCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetEquationsCreateFinishObj",Err,ERROR)
    CALL EXITS("CMISSEquationsSetEquationsCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetEquationsCreateFinishObj

  !  
  !================================================================================================================================
  !  

  !>Start the creation of equations for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetEquationsCreateStartNumber(RegionUserNumber,EquationsSetUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations set to start the creation of equations for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to start the creation of equations for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetEquationsCreateStartNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_CREATE_START(EQUATIONS_SET,EQUATIONS,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetEquationsCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetEquationsCreateStartNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsSetEquationsCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetEquationsCreateStartNumber

  !  
  !================================================================================================================================
  !  

  !>Start the creation of equations for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetEquationsCreateStartObj(EquationsSet,Equations,Err)
  
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(OUT) :: EquationsSet !<The equations set to start the creation of equations on.
    TYPE(CMISSEquationsType), INTENT(INOUT) :: Equations !<On return, the created equations.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
 
    CALL ENTERS("CMISSEquationsSetEquationsCreateStartObj",Err,ERROR,*999)
 
    CALL EQUATIONS_SET_EQUATIONS_CREATE_START(EquationsSet%EQUATIONS_SET,Equations%EQUATIONS,Err,ERROR,*999)
    
    CALL EXITS("CMISSEquationsSetEquationsCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetEquationsCreateStartObj",Err,ERROR)
    CALL EXITS("CMISSEquationsSetEquationsCreateStartObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetEquationsCreateStartObj

  !  
  !================================================================================================================================
  !  

  !>Destroy the equations for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetEquationsDestroyNumber(RegionUserNumber,EquationsSetUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations set to destroy the equations for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to destroy the equations for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetEquationsDestroyNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_DESTROY(EQUATIONS_SET,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetEquationsDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetEquationsDestroyNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsSetEquationsDestroyNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetEquationsDestroyNumber

  !  
  !================================================================================================================================
  !  

  !>Destroy the equations for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetEquationsDestroyObj(EquationsSet,Err)
  
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: EquationsSet !<The equations set to destroy the equations for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
 
    CALL ENTERS("CMISSEquationsSetEquationsDestroyObj",Err,ERROR,*999)
 
    CALL EQUATIONS_SET_EQUATIONS_DESTROY(EquationsSet%EQUATIONS_SET,Err,ERROR,*999)
    
    CALL EXITS("CMISSEquationsSetEquationsDestroyObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetEquationsDestroyObj",Err,ERROR)
    CALL EXITS("CMISSEquationsSetEquationsDestroyObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetEquationsDestroyObj

  !  
  !================================================================================================================================
  !  

  !>Finish the creation of independent variables for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetIndependentCreateFinishNumber(RegionUserNumber,EquationsSetUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations set to finish the creation of independent variables for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to finish the creation of independent variables for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSEquationsSetIndependentCreateFinishNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_INDEPENDENT_CREATE_FINISH(EQUATIONS_SET,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetIndependentCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetIndependentCreateFinishNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsSetIndependentCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetIndependentCreateFinishNumber

  !  
  !================================================================================================================================
  !  
 
  !>Finish the creation of independent variables for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetIndependentCreateFinishObj(EquationsSet,Err)
  
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: EquationsSet !<The equations set to finish the creation of independent variables for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSEquationsSetIndependentCreateFinishObj",Err,ERROR,*999)
 
    CALL EQUATIONS_SET_INDEPENDENT_CREATE_FINISH(EquationsSet%EQUATIONS_SET,Err,ERROR,*999)

    CALL EXITS("CMISSEquationsSetIndependentCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetIndependentCreateFinishObj",Err,ERROR)
    CALL EXITS("CMISSEquationsSetIndependentCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetIndependentCreateFinishObj

  !  
  !================================================================================================================================
  !  

  !>Start the creation of independent variables for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetIndependentCreateStartNumber(RegionUserNumber,EquationsSetUserNumber,IndependentFieldUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations set to start the creation of independent variables for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to start the creation of independent variables for.
    INTEGER(INTG), INTENT(IN) :: IndependentFieldUserNumber !<The user number of the independent field.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(FIELD_TYPE), POINTER :: INDEPENDENT_FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetDependentCreateStartNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(INDEPENDENT_FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL FIELD_USER_NUMBER_FIND(IndependentFieldUserNumber,REGION,INDEPENDENT_FIELD,ERR,ERROR,*999)
        CALL EQUATIONS_SET_DEPENDENT_CREATE_START(EQUATIONS_SET,IndependentFieldUserNumber,INDEPENDENT_FIELD,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetIndependentCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetIndependentCreateStartNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsSetIndependentCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetIndependentCreateStartNumber

  !  
  !================================================================================================================================
  !  

  !>Start the creation of independent variables for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetIndependentCreateStartObj(EquationsSet,IndependentFieldUserNumber,IndependentField,Err)
  
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(OUT) :: EquationsSet !<The equations set to start the creation of independent variables on.
    INTEGER(INTG), INTENT(IN) :: IndependentFieldUserNumber !<The user number of the dependent field.
    TYPE(CMISSFieldType), INTENT(INOUT) :: IndependentField !<If associated on entry, the user created independent field which has the same user number as the specified independent field user number. If not associated on entry, on return, the created independent field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
 
    CALL ENTERS("CMISSEquationsSetIndependentCreateStartObj",Err,ERROR,*999)
 
    CALL EQUATIONS_SET_INDEPENDENT_CREATE_START(EquationsSet%EQUATIONS_SET,IndependentFieldUserNumber,IndependentField%FIELD, &
      & Err,ERROR,*999)
    
    CALL EXITS("CMISSEquationsSetIndependentCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetIndependentCreateStartObj",Err,ERROR)
    CALL EXITS("CMISSEquationsSetIndependentCreateStartObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetIndependentCreateStartObj

  !  
  !================================================================================================================================
  !  

  !>Destroy the independent variables for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetIndependentDestroyNumber(RegionUserNumber,EquationsSetUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations set to destroy the independent variables for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to destroy the independent variables for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetIndependentDestroyNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_INDEPENDENT_DESTROY(EQUATIONS_SET,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetIndependentDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetIndependentDestroyNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsSetIndependentDestroyNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetIndependentDestroyNumber

  !  
  !================================================================================================================================
  !  

  !>Destroy the independent variables for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetIndependentDestroyObj(EquationsSet,Err)
  
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: EquationsSet !<The equations set to destroy the independent variables for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
 
    CALL ENTERS("CMISSEquationsSetIndependentDestroyObj",Err,ERROR,*999)
 
    CALL EQUATIONS_SET_INDEPENDENT_DESTROY(EquationsSet%EQUATIONS_SET,Err,ERROR,*999)
    
    CALL EXITS("CMISSEquationsSetIndependentDestroyObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetIndependentDestroyObj",Err,ERROR)
    CALL EXITS("CMISSEquationsSetIndependentDestroyObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetIndependentDestroyObj

  !  
  !================================================================================================================================
  !  

  !  
  !================================================================================================================================
  !  

  !>Finish the creation of materials for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetMaterialsCreateFinishNumber(RegionUserNumber,EquationsSetUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations set to finish the creation of materials for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to finish the creation of materials for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSEquationsSetMaterialsCreateFinishNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_MATERIALS_CREATE_FINISH(EQUATIONS_SET,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetMaterialsCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetMaterialsCreateFinishNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsSetMaterialsCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetMaterialsCreateFinishNumber

  !  
  !================================================================================================================================
  !  
 
  !>Finish the creation of materials for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetMaterialsCreateFinishObj(EquationsSet,Err)
  
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: EquationsSet !<The equations set to finish the creation of materials for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSEquationsSetMaterialsCreateFinishObj",Err,ERROR,*999)
 
    CALL EQUATIONS_SET_MATERIALS_CREATE_FINISH(EquationsSet%EQUATIONS_SET,Err,ERROR,*999)

    CALL EXITS("CMISSEquationsSetMaterialsCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetMaterialsCreateFinishObj",Err,ERROR)
    CALL EXITS("CMISSEquationsSetMaterialsCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetMaterialsCreateFinishObj

  !  
  !================================================================================================================================
  !  

  !>Start the creation of materials for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetMaterialsCreateStartNumber(RegionUserNumber,EquationsSetUserNumber,MaterialsFieldUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations set to start the creation of materials for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to start the creation of materials for.
    INTEGER(INTG), INTENT(IN) :: MaterialsFieldUserNumber !<The user number of the materials field.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(FIELD_TYPE), POINTER :: MATERIALS_FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetMaterialsCreateStartNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(MATERIALS_FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL FIELD_USER_NUMBER_FIND(MaterialsFieldUserNumber,REGION,MATERIALS_FIELD,ERR,ERROR,*999)
        CALL EQUATIONS_SET_MATERIALS_CREATE_START(EQUATIONS_SET,MaterialsFieldUserNumber,MATERIALS_FIELD,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetMaterialsCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetMaterialsCreateStartNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsSetMaterialsCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetMaterialsCreateStartNumber

  !  
  !================================================================================================================================
  !  

  !>Start the creation of materials for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetMaterialsCreateStartObj(EquationsSet,MaterialsFieldUserNumber,MaterialsField,Err)
  
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(OUT) :: EquationsSet !<The equations set to start the creation of materials on.
    INTEGER(INTG), INTENT(IN) :: MaterialsFieldUserNumber !<The user number of the materials field.
    TYPE(CMISSFieldType), INTENT(INOUT) :: MaterialsField !<If associated on entry, the user created materials field which has the same user number as the specified materials field user number. If not associated on entry, on return, the created materials field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
 
    CALL ENTERS("CMISSEquationsSetMaterialsCreateStartObj",Err,ERROR,*999)
 
    CALL EQUATIONS_SET_MATERIALS_CREATE_START(EquationsSet%EQUATIONS_SET,MaterialsFieldUserNumber,MaterialsField%FIELD, &
      & Err,ERROR,*999)
    
    CALL EXITS("CMISSEquationsSetMaterialsCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetMaterialsCreateStartObj",Err,ERROR)
    CALL EXITS("CMISSEquationsSetMaterialsCreateStartObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetMaterialsCreateStartObj

  !  
  !================================================================================================================================
  !  

  !>Destroy the materials for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetMaterialsDestroyNumber(RegionUserNumber,EquationsSetUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations set to destroy the materials for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to destroy the materials for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetMaterialsDestroyNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_MATERIALS_DESTROY(EQUATIONS_SET,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetMaterialsDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetMaterialsDestroyNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsSetMaterialsDestroyNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetMaterialsDestroyNumber

  !  
  !================================================================================================================================
  !  

  !>Destroy the materials for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetMaterialsDestroyObj(EquationsSet,Err)
  
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: EquationsSet !<The equations set to destroy the materials for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
 
    CALL ENTERS("CMISSEquationsSetMaterialsDestroyObj",Err,ERROR,*999)
 
    CALL EQUATIONS_SET_MATERIALS_DESTROY(EquationsSet%EQUATIONS_SET,Err,ERROR,*999)
    
    CALL EXITS("CMISSEquationsSetMaterialsDestroyObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetMaterialsDestroyObj",Err,ERROR)
    CALL EXITS("CMISSEquationsSetMaterialsDestroyObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetMaterialsDestroyObj

  !  
  !================================================================================================================================
  !  

  !>Returns the solution method for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetSolutionMethodGetNumber(RegionUserNumber,EquationsSetUserNumber,SolutionMethod,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations set to get the solution method for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to get the solution method for.
    INTEGER(INTG), INTENT(OUT) :: SolutionMethod !<On return, the solution method. \see OPENCMISS_EquationsSetSolutionMethods
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSEquationsSetSolutionMethodGetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_SOLUTION_METHOD_GET(EQUATIONS_SET,SolutionMethod,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetSolutionMethodGetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetSolutionMethodGetNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsSetSolutionMethodGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetSolutionMethodGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the solution method for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetSolutionMethodGetObj(EquationsSet,SolutionMethod,Err)
  
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: EquationsSet !<The equations set to get the solution method for.
    INTEGER(INTG), INTENT(OUT) :: SolutionMethod !<On Return, the solution method. \see OPENCMISS_EquationsSetSolutionMethods
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSEquationsSetSolutionMethodGetObj",Err,ERROR,*999)
 
    CALL EQUATIONS_SET_SOLUTION_METHOD_GET(EquationsSet%EQUATIONS_SET,SolutionMethod,Err,ERROR,*999)

    CALL EXITS("CMISSEquationsSetSolutionMethodGetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetSolutionMethodGetObj",Err,ERROR)
    CALL EXITS("CMISSEquationsSetSolutionMethodGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetSolutionMethodGetObj

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the solution method for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetSolutionMethodSetNumber(RegionUserNumber,EquationsSetUserNumber,SolutionMethod,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations set to set the solution method for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to set the solution method for.
    INTEGER(INTG), INTENT(IN) :: SolutionMethod !<The solution method to set. \see OPENCMISS_EquationsSetSolutionMethods
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSEquationsSetSolutionMethodSetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_SOLUTION_METHOD_SET(EQUATIONS_SET,SolutionMethod,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetSolutionMethodSetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetSolutionMethodSetNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsSetSolutionMethodSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetSolutionMethodSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the solution method for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetSolutionMethodSetObj(EquationsSet,SolutionMethod,Err)
  
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: EquationsSet !<The equations set to set the solution method for.
    INTEGER(INTG), INTENT(IN) :: SolutionMethod !<The solution method to set. \see OPENCMISS_EquationsSetSolutionMethods
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSEquationsSetSolutionMethodSetObj",Err,ERROR,*999)
 
    CALL EQUATIONS_SET_SOLUTION_METHOD_SET(EquationsSet%EQUATIONS_SET,SolutionMethod,Err,ERROR,*999)

    CALL EXITS("CMISSEquationsSetSolutionMethodSetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetSolutionMethodSetObj",Err,ERROR)
    CALL EXITS("CMISSEquationsSetSolutionMethodSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetSolutionMethodSetObj

  !  
  !================================================================================================================================
  !  

  !>Finish the creation of a source for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetSourceCreateFinishNumber(RegionUserNumber,EquationsSetUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations set to finish the creation of a source for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to finish the creation of a source for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSEquationsSetSourceCreateFinishNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_SOURCE_CREATE_FINISH(EQUATIONS_SET,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetSourceCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetSourceCreateFinishNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsSetSourceCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetSourceCreateFinishNumber

  !  
  !================================================================================================================================
  !  
 
  !>Finish the creation of a source for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetSourceCreateFinishObj(EquationsSet,Err)
  
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: EquationsSet !<The equations set to finish the creation of a source for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSEquationsSetSourceCreateFinishObj",Err,ERROR,*999)
 
    CALL EQUATIONS_SET_SOURCE_CREATE_FINISH(EquationsSet%EQUATIONS_SET,Err,ERROR,*999)

    CALL EXITS("CMISSEquationsSetSourceCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetSourceCreateFinishObj",Err,ERROR)
    CALL EXITS("CMISSEquationsSetSourceCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetSourceCreateFinishObj

  !  
  !================================================================================================================================
  !  

  !>Start the creation of a source for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetSourceCreateStartNumber(RegionUserNumber,EquationsSetUserNumber,SourceFieldUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations set to start the creation of a source for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to start the creation of a source for.
    INTEGER(INTG), INTENT(IN) :: SourceFieldUserNumber !<The user number of the source field.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(FIELD_TYPE), POINTER :: SOURCE_FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetSourceCreateStartNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(SOURCE_FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL FIELD_USER_NUMBER_FIND(SourceFieldUserNumber,REGION,SOURCE_FIELD,ERR,ERROR,*999)
        CALL EQUATIONS_SET_SOURCE_CREATE_START(EQUATIONS_SET,SourceFieldUserNumber,SOURCE_FIELD,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetSourceCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetSourceCreateStartNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsSetSourceCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetSourceCreateStartNumber

  !  
  !================================================================================================================================
  !  

  !>Start the creation of a source for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetSourceCreateStartObj(EquationsSet,SourceFieldUserNumber,SourceField,Err)
  
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(OUT) :: EquationsSet !<The equations set to start the creation of a source on.
    INTEGER(INTG), INTENT(IN) :: SourceFieldUserNumber !<The user number of the source field.
    TYPE(CMISSFieldType), INTENT(INOUT) :: SourceField !<If associated on entry, the user created source field which has the same user number as the specified source field user number. If not associated on entry, on return, the created source field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
 
    CALL ENTERS("CMISSEquationsSetSourceCreateStartObj",Err,ERROR,*999)
 
    CALL EQUATIONS_SET_SOURCE_CREATE_START(EquationsSet%EQUATIONS_SET,SourceFieldUserNumber,SourceField%FIELD,Err,ERROR,*999)
    
    CALL EXITS("CMISSEquationsSetSourceCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetSourceCreateStartObj",Err,ERROR)
    CALL EXITS("CMISSEquationsSetSourceCreateStartObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetSourceCreateStartObj

  !  
  !================================================================================================================================
  !  

  !>Destroy the source for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetSourceDestroyNumber(RegionUserNumber,EquationsSetUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations set to destroy the source for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to destroy the source for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetSourceDestroyNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_SOURCE_DESTROY(EQUATIONS_SET,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetSourceDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetSourceDestroyNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsSetSourceDestroyNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetSourceDestroyNumber

  !  
  !================================================================================================================================
  !  

  !>Destroy the source for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetSourceDestroyObj(EquationsSet,Err)
  
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: EquationsSet !<The equations set to destroy the source for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
 
    CALL ENTERS("CMISSEquationsSetSourceDestroyObj",Err,ERROR,*999)
 
    CALL EQUATIONS_SET_SOURCE_DESTROY(EquationsSet%EQUATIONS_SET,Err,ERROR,*999)
    
    CALL EXITS("CMISSEquationsSetSourceDestroyObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetSourceDestroyObj",Err,ERROR)
    CALL EXITS("CMISSEquationsSetSourceDestroyObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetSourceDestroyObj

  !  
  !================================================================================================================================
  !  

  !>Returns the equations set specification i.e., equations set class, type and subtype for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetSpecificationGetNumber(RegionUserNumber,EquationsSetUserNumber,EquationsSetClass, &
    & EquationsSetType,EquationsSetSubtype,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations set to get the specification for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to get the specification for.
    INTEGER(INTG), INTENT(OUT) :: EquationsSetClass !<On return, the equations set class. \see OPENCMISS_EquationsSetClasses
    INTEGER(INTG), INTENT(OUT) :: EquationsSetType !<On return, the equations set type. \see OPENCMISS_EquationsSetTypes
    INTEGER(INTG), INTENT(OUT) :: EquationsSetSubtype !<On return, the equations set subtype. \see OPENCMISS_EquationsSetSubtypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSEquationsSetSpecificationGetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_SPECIFICATION_GET(EQUATIONS_SET,EquationsSetClass,EquationsSetType,EquationsSetSubtype,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetSpecificationGetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetSpecificationGetNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsSetSpecificationGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetSpecificationGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the equations set specification i.e., equations set class, type and subtype for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetSpecificationGetObj(EquationsSet,EquationsSetClass,EquationsSetType,EquationsSetSubtype,Err)
  
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(IN) :: EquationsSet !<The equations set to get the specification for.
    INTEGER(INTG), INTENT(OUT) :: EquationsSetClass !<On return, the equations set class. \see OPENCMISS_EquationsSetClasses
    INTEGER(INTG), INTENT(OUT) :: EquationsSetType !<On return, the equations set type. \see OPENCMISS_EquationsSetTypes
    INTEGER(INTG), INTENT(OUT) :: EquationsSetSubtype !<On return, the equations set subtype. \see OPENCMISS_EquationsSetSubtypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSEquationsSetSpecificationGetObj",Err,ERROR,*999)
 
    CALL EQUATIONS_SET_SPECIFICATION_GET(EquationsSet%EQUATIONS_SET,EquationsSetClass,EquationsSetType,EquationsSetSubtype, &
      & Err,ERROR,*999)

    CALL EXITS("CMISSEquationsSetSpecificationGetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetSpecificationGetObj",Err,ERROR)
    CALL EXITS("CMISSEquationsSetSpecificationGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetSpecificationGetObj

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the equations set specification i.e., equations set class, type and subtype for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetSpecificationSetNumber(RegionUserNumber,EquationsSetUserNumber,EquationsSetClass, &
    & EquationsSetType,EquationsSetSubtype,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the Region containing the equations set to set the specification for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to set the specification for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetClass !<The equations set class to set. \see OPENCMISS_EquationsSetClasses
    INTEGER(INTG), INTENT(IN) :: EquationsSetType !<The equations set type to set. \see OPENCMISS_EquationsSetTypes
    INTEGER(INTG), INTENT(IN) :: EquationsSetSubtype !<The equations set subtype to set. \see OPENCMISS_EquationsSetSubtypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSEquationsSetSpecificationSetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_SPECIFICATION_SET(EQUATIONS_SET,EquationsSetClass,EquationsSetType,EquationsSetSubtype,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetSpecificationSetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetSpecificationSetNumber",Err,ERROR)
    CALL EXITS("CMISSEquationsSetSpecificationSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetSpecificationSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the equations set specification i.e., equations set class, type and subtype for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetSpecificationSetObj(EquationsSet,EquationsSetClass,EquationsSetType,EquationsSetSubtype,Err)
  
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: EquationsSet !<The equations set to set the specification for.
    INTEGER(INTG), INTENT(IN) :: EquationsSetClass !<The equations set class to set. \see OPENCMISS_EquationsSetClasses
    INTEGER(INTG), INTENT(IN) :: EquationsSetType !<The equations set type to set. \see OPENCMISS_EquationsSetTypes
    INTEGER(INTG), INTENT(IN) :: EquationsSetSubtype !<The equations set subtype to set. \see OPENCMISS_EquationsSetSubtypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSEquationsSetSpecificationSetObj",Err,ERROR,*999)
 
    CALL EQUATIONS_SET_SPECIFICATION_SET(EquationsSet%EQUATIONS_SET,EquationsSetClass,EquationsSetType,EquationsSetSubtype, &
      & Err,ERROR,*999)

    CALL EXITS("CMISSEquationsSetSpecificationSetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetSpecificationSetObj",Err,ERROR)
    CALL EXITS("CMISSEquationsSetSpecificationSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSEquationsSetSpecificationSetObj

!!==================================================================================================================================
!!
!! FIELD_ROUTINES
!!
!!==================================================================================================================================

  !>Returns the interpolation type for a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldComponentInterpolationGetNumber(RegionUserNumber,FieldUserNumber,VariableType,ComponentNumber, &
    & InterpolationType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the interpolation type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to get the interpolation type for.
    INTEGER(INTG), INTENT(OUT) :: InterpolationType !<On return, the interpolation type. \see OPENCMISS_FieldInterpolationTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldComponentInterpolationGetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_INTERPOLATION_GET(FIELD,VariableType,ComponentNumber,InterpolationType,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldComponentInterpolationGetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldComponentInterpolationGetNumber",Err,ERROR)
    CALL EXITS("CMISSFieldComponentInterpolationGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldComponentInterpolationGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the interpolation type for a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldComponentInterpolationGetObj(Field,VariableType,ComponentNumber,InterpolationType,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the interpolation type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to get the interpolation type for.
    INTEGER(INTG), INTENT(OUT) :: InterpolationType !<On return, the interpolation type. \see OPENCMISS_FieldInterpolationTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldComponentInterpolationGetObj",Err,ERROR,*999)
 
    CALL FIELD_COMPONENT_INTERPOLATION_GET(Field%FIELD,VariableType,ComponentNumber,InterpolationType,Err,ERROR,*999)

    CALL EXITS("CMISSFieldComponentInterpolationGetObj")
    RETURN
999 CALL ERRORS("CMISSFieldComponentInterpolationGetObj",Err,ERROR)
    CALL EXITS("CMISSFieldComponentInterpolationGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldComponentInterpolationGetObj

  !  
  !================================================================================================================================
  !   

  !>Sets/changes the interpolation type for a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldComponentInterpolationSetNumber(RegionUserNumber,FieldUserNumber,VariableType,ComponentNumber, &
    & InterpolationType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to set the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to set the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to set the interpolation type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to set the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: InterpolationType !<The interpolation type to set. \see OPENCMISS_FieldInterpolationTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldComponentInterpolationSetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_INTERPOLATION_SET(FIELD,VariableType,ComponentNumber,InterpolationType,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldComponentInterpolationSetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldComponentInterpolationSetNumber",Err,ERROR)
    CALL EXITS("CMISSFieldComponentInterpolationSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldComponentInterpolationSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the interpolation type for a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldComponentInterpolationSetObj(Field,VariableType,ComponentNumber,InterpolationType,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to set the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to set the interpolation type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to set the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: InterpolationType !<The interpolation type to set. \see OPENCMISS_FieldInterpolationTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldComponentInterpolationSetObj",Err,ERROR,*999)
 
    CALL FIELD_COMPONENT_INTERPOLATION_SET(Field%FIELD,VariableType,ComponentNumber,InterpolationType,Err,ERROR,*999)

    CALL EXITS("CMISSFieldComponentInterpolationSetObj")
    RETURN
999 CALL ERRORS("CMISSFieldComponentInterpolationSetObj",Err,ERROR)
    CALL EXITS("CMISSFieldComponentInterpolationSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldComponentInterpolationSetObj

  !  
  !================================================================================================================================
  !  

  !>Returns the character string label for a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldComponentLabelGetCNumber(RegionUserNumber,FieldUserNumber,VariableType,ComponentNumber,Label,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the label for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: Label !<On return, the field variable component label.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldComponentLabelGetCNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_LABEL_GET(FIELD,VariableType,ComponentNumber,Label,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldComponentLabelGetCNumber")
    RETURN
999 CALL ERRORS("CMISSFieldComponentLabelGetCNumber",Err,ERROR)
    CALL EXITS("CMISSFieldComponentLabelGetCNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldComponentLabelGetCNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the character string label for a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldComponentLabelGetCObj(Field,VariableType,ComponentNumber,Label,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the label for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the label for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: Label !<On return, the field variable component label.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldComponentLabelGetCObj",Err,ERROR,*999)
 
    CALL FIELD_COMPONENT_LABEL_GET(Field%FIELD,VariableType,ComponentNumber,Label,Err,ERROR,*999)

    CALL EXITS("CMISSFieldComponentLabelGetCObj")
    RETURN
999 CALL ERRORS("CMISSFieldComponentLabelGetCObj",Err,ERROR)
    CALL EXITS("CMISSFieldComponentLabelGetCObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldComponentLabelGetCObj

  !  
  !================================================================================================================================
  !  

  !>Returns the varying string label for a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldComponentLabelGetVSNumber(RegionUserNumber,FieldUserNumber,VariableType,ComponentNumber,Label,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the label for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: Label !<On return, the field variable component label.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldComponentLabelGetVSNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_LABEL_GET(FIELD,VariableType,ComponentNumber,Label,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldComponentLabelGetVSNumber")
    RETURN
999 CALL ERRORS("CMISSFieldComponentLabelGetVSNumber",Err,ERROR)
    CALL EXITS("CMISSFieldComponentLabelGetVSNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldComponentLabelGetVSNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the varying string label for a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldComponentLabelGetVSObj(Field,VariableType,ComponentNumber,Label,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the label for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the label for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: Label !<On return, the field variable component label.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldComponentLabelGetVSObj",Err,ERROR,*999)
 
    CALL FIELD_COMPONENT_LABEL_GET(Field%FIELD,VariableType,ComponentNumber,Label,Err,ERROR,*999)

    CALL EXITS("CMISSFieldComponentLabelGetVSObj")
    RETURN
999 CALL ERRORS("CMISSFieldComponentLabelGetVSObj",Err,ERROR)
    CALL EXITS("CMISSFieldComponentLabelGetVSObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldComponentLabelGetVSObj

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the character string label for a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldComponentLabelSetCNumber(RegionUserNumber,FieldUserNumber,VariableType,ComponentNumber,Label,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to set the label for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: Label !<The field variable component label to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldComponentLabelSetCNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_LABEL_SET(FIELD,VariableType,ComponentNumber,Label,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldComponentLabelSetCNumber")
    RETURN
999 CALL ERRORS("CMISSFieldComponentLabelSetCNumber",Err,ERROR)
    CALL EXITS("CMISSFieldComponentLabelSetCNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldComponentLabelSetCNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the character string label for a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldComponentLabelSetCObj(Field,VariableType,ComponentNumber,Label,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to set the label for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to set the label for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: Label !<The field variable component label to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldComponentLabelSetCObj",Err,ERROR,*999)
 
    CALL FIELD_COMPONENT_LABEL_SET(Field%FIELD,VariableType,ComponentNumber,Label,Err,ERROR,*999)

    CALL EXITS("CMISSFieldComponentLabelSetCObj")
    RETURN
999 CALL ERRORS("CMISSFieldComponentLabelSetCObj",Err,ERROR)
    CALL EXITS("CMISSFieldComponentLabelSetCObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldComponentLabelSetCObj

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the varying string label for a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldComponentLabelSetVSNumber(RegionUserNumber,FieldUserNumber,VariableType,ComponentNumber,Label,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to set the label for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: Label !<The field variable component label to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldComponentLabelSetVSNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_LABEL_SET(FIELD,VariableType,ComponentNumber,Label,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldComponentLabelSetVSNumber")
    RETURN
999 CALL ERRORS("CMISSFieldComponentLabelSetVSNumber",Err,ERROR)
    CALL EXITS("CMISSFieldComponentLabelSetVSNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldComponentLabelSetVSNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the varying string label for a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldComponentLabelSetVSObj(Field,VariableType,ComponentNumber,Label,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to set the label for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to set the label for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: Label !<The field variable component label to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldComponentLabelSetVSObj",Err,ERROR,*999)
 
    CALL FIELD_COMPONENT_LABEL_SET(Field%FIELD,VariableType,ComponentNumber,Label,Err,ERROR,*999)

    CALL EXITS("CMISSFieldComponentLabelSetVSObj")
    RETURN
999 CALL ERRORS("CMISSFieldComponentLabelSetVSObj",Err,ERROR)
    CALL EXITS("CMISSFieldComponentLabelSetVSObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldComponentLabelSetVSObj

  !  
  !================================================================================================================================
  !   

  !>Returns the mesh component number for a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldComponentMeshComponentGetNumber(RegionUserNumber,FieldUserNumber,VariableType,ComponentNumber, &
    & MeshComponent,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the mesh component number for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to get the mesh component number for.
    INTEGER(INTG), INTENT(OUT) :: MeshComponent !<On return, the mesh component number.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldComponentMeshComponentGetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_MESH_COMPONENT_GET(FIELD,VariableType,ComponentNumber,MeshComponent,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldComponentMeshComponentGetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldComponentMeshComponentGetNumber",Err,ERROR)
    CALL EXITS("CMISSFieldComponentMeshComponentGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldComponentMeshComponentGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the mesh component number for a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldComponentMeshComponentGetObj(Field,VariableType,ComponentNumber,MeshComponent,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the mesh component number for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to get the mesh component number for.
    INTEGER(INTG), INTENT(OUT) :: MeshComponent !<On return, the mesh component number.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldComponentMeshComponentGetObj",Err,ERROR,*999)
 
    CALL FIELD_COMPONENT_MESH_COMPONENT_GET(Field%FIELD,VariableType,ComponentNumber,MeshComponent,Err,ERROR,*999)

    CALL EXITS("CMISSFieldComponentMeshComponentGetObj")
    RETURN
999 CALL ERRORS("CMISSFieldComponentMeshComponentGetObj",Err,ERROR)
    CALL EXITS("CMISSFieldComponentMeshComponentGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldComponentMeshComponentGetObj

  !  
  !================================================================================================================================
  !   

  !>Sets/changes the mesh component number for a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldComponentMeshComponentSetNumber(RegionUserNumber,FieldUserNumber,VariableType,ComponentNumber, &
    & MeshComponent,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to set the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to set the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to set the mesh component number for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to set the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: MeshComponent !<The mesh component number to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldComponentMeshComponentSetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_MESH_COMPONENT_SET(FIELD,VariableType,ComponentNumber,MeshComponent,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldComponentMeshComponentSetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldComponentMeshComponentSetNumber",Err,ERROR)
    CALL EXITS("CMISSFieldComponentMeshComponentSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldComponentMeshComponentSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the mesh component number for a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldComponentMeshComponentSetObj(Field,VariableType,ComponentNumber,MeshComponent,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to set the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to set the mesh component number for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to set the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: MeshComponent !<The mesh component number to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldComponentMeshComponentSetObj",Err,ERROR,*999)
 
    CALL FIELD_COMPONENT_MESH_COMPONENT_SET(Field%FIELD,VariableType,ComponentNumber,MeshComponent,Err,ERROR,*999)

    CALL EXITS("CMISSFieldComponentMeshComponentSetObj")
    RETURN
999 CALL ERRORS("CMISSFieldComponentMeshComponentSetObj",Err,ERROR)
    CALL EXITS("CMISSFieldComponentMeshComponentSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldComponentMeshComponentSetObj

  !  
  !================================================================================================================================
  !   

  !>Initialises the values of parameter set of a field variable component to an integer constant value for a field identified by a user number.
  SUBROUTINE CMISSFieldComponentValuesInitialiseIntgNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to initialise the field variable component for for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to initialise the field variable component for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: Value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldComponentValuesInitialiseIntgNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_VALUES_INITIALISE(FIELD,VariableType,FieldSetType,ComponentNumber,Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldComponentValuesInitialiseIntgNumber")
    RETURN
999 CALL ERRORS("CMISSFieldComponentValuesInitialiseIntgNumber",Err,ERROR)
    CALL EXITS("CMISSFieldComponentValuesInitialiseIntgNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldComponentValuesInitialiseIntgNumber

  !  
  !================================================================================================================================
  !  
 
  !>Initialises the values of parameter set of a field variable component to an integer constant value for a field identified by an object.
  SUBROUTINE CMISSFieldComponentValuesInitialiseIntgObj(Field,VariableType,FieldSetType,ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to initialise the field variable component for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: Value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldComponentValuesInitialiseIntgObj",Err,ERROR,*999)
 
    CALL FIELD_COMPONENT_VALUES_INITIALISE(Field%FIELD,VariableType,FieldSetType,ComponentNumber,Value,Err,ERROR,*999)

    CALL EXITS("CMISSFieldComponentValuesInitialiseIntgObj")
    RETURN
999 CALL ERRORS("CMISSFieldComponentValuesInitialiseIntgObj",Err,ERROR)
    CALL EXITS("CMISSFieldComponentValuesInitialiseIntgObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldComponentValuesInitialiseIntgObj
  !  
  !================================================================================================================================
  !   

  !>Initialises the values of parameter set of a field variable component to a single precision constant value for a field identified by a user number.
  SUBROUTINE CMISSFieldComponentValuesInitialiseSPNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to initialise the field variable component for for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to initialise the field variable component for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to initialise the field variable component for.
    REAL(SP), INTENT(IN) :: Value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldComponentValuesInitialiseSPNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_VALUES_INITIALISE(FIELD,VariableType,FieldSetType,ComponentNumber,Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldComponentValuesInitialiseSPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldComponentValuesInitialiseSPNumber",Err,ERROR)
    CALL EXITS("CMISSFieldComponentValuesInitialiseSPNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldComponentValuesInitialiseSPNumber

  !  
  !================================================================================================================================
  !  
 
  !>Initialises the values of parameter set of a field variable component to a single precision constant value for a field identified by an object.
  SUBROUTINE CMISSFieldComponentValuesInitialiseSPObj(Field,VariableType,FieldSetType,ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to initialise the field variable component for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to initialise the field variable component for.
    REAL(SP), INTENT(IN) :: Value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldComponentValuesInitialiseSPObj",Err,ERROR,*999)
 
    CALL FIELD_COMPONENT_VALUES_INITIALISE(Field%FIELD,VariableType,FieldSetType,ComponentNumber,Value,Err,ERROR,*999)

    CALL EXITS("CMISSFieldComponentValuesInitialiseSPObj")
    RETURN
999 CALL ERRORS("CMISSFieldComponentValuesInitialiseSPObj",Err,ERROR)
    CALL EXITS("CMISSFieldComponentValuesInitialiseSPObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldComponentValuesInitialiseSPObj
  !  
  !================================================================================================================================
  !   

  !>Initialises the values of parameter set of a field variable component to a double precision constant value for a field identified by a user number.
  SUBROUTINE CMISSFieldComponentValuesInitialiseDPNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to initialise the field variable component for for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to initialise the field variable component for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to initialise the field variable component for.
    REAL(DP), INTENT(IN) :: Value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldComponentValuesInitialiseDPNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_VALUES_INITIALISE(FIELD,VariableType,FieldSetType,ComponentNumber,Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldComponentValuesInitialiseDPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldComponentValuesInitialiseDPNumber",Err,ERROR)
    CALL EXITS("CMISSFieldComponentValuesInitialiseDPNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldComponentValuesInitialiseDPNumber

  !  
  !================================================================================================================================
  !  
 
  !>Initialises the values of parameter set of a field variable component to a double precision constant value for a field identified by an object.
  SUBROUTINE CMISSFieldComponentValuesInitialiseDPObj(Field,VariableType,FieldSetType,ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to initialise the field variable component for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to initialise the field variable component for.
    REAL(DP), INTENT(IN) :: Value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldComponentValuesInitialiseDPObj",Err,ERROR,*999)
 
    CALL FIELD_COMPONENT_VALUES_INITIALISE(Field%FIELD,VariableType,FieldSetType,ComponentNumber,Value,Err,ERROR,*999)

    CALL EXITS("CMISSFieldComponentValuesInitialiseDPObj")
    RETURN
999 CALL ERRORS("CMISSFieldComponentValuesInitialiseDPObj",Err,ERROR)
    CALL EXITS("CMISSFieldComponentValuesInitialiseDPObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldComponentValuesInitialiseDPObj
  !  
  !================================================================================================================================
  !   

  !>Initialises the values of parameter set of a field variable component to a logical constant value for a field identified by a user number.
  SUBROUTINE CMISSFieldComponentValuesInitialiseLNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to initialise the field variable component for for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to initialise the field variable component for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to initialise the field variable component for.
    LOGICAL, INTENT(IN) :: Value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldComponentValuesInitialiseLNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_VALUES_INITIALISE(FIELD,VariableType,FieldSetType,ComponentNumber,Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldComponentValuesInitialiseLNumber")
    RETURN
999 CALL ERRORS("CMISSFieldComponentValuesInitialiseLNumber",Err,ERROR)
    CALL EXITS("CMISSFieldComponentValuesInitialiseLNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldComponentValuesInitialiseLNumber

  !  
  !================================================================================================================================
  !  
 
  !>Initialises the values of parameter set of a field variable component to a logical constant value for a field identified by an object.
  SUBROUTINE CMISSFieldComponentValuesInitialiseLObj(Field,VariableType,FieldSetType,ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to initialise the field variable component for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to initialise the field variable component for.
    LOGICAL, INTENT(IN) :: Value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldComponentValuesInitialiseLObj",Err,ERROR,*999)
 
    CALL FIELD_COMPONENT_VALUES_INITIALISE(Field%FIELD,VariableType,FieldSetType,ComponentNumber,Value,Err,ERROR,*999)

    CALL EXITS("CMISSFieldComponentValuesInitialiseLObj")
    RETURN
999 CALL ERRORS("CMISSFieldComponentValuesInitialiseLObj",Err,ERROR)
    CALL EXITS("CMISSFieldComponentValuesInitialiseLObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldComponentValuesInitialiseLObj

  !  
  !================================================================================================================================
  !   

  !>Returns the data type for a field variable for a field identified by a user number.
  SUBROUTINE CMISSFieldDataTypeGetNumber(RegionUserNumber,FieldUserNumber,VariableType,DataType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the data type for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the data type for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the data type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: DataType !<On return, the field variable data type. \see OPENCMISS_FieldDataTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldDataTypeGetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DATA_TYPE_GET(FIELD,VariableType,DataType,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldDataTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldDataTypeGetNumber",Err,ERROR)
    CALL EXITS("CMISSFieldDataTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldDataTypeGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the data type for a field variable for a field identified by an object.
  SUBROUTINE CMISSFieldDataTypeGetObj(Field,VariableType,DataType,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the data type for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the data type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: DataType !<On return, the field variable data type. \see OPENCMISS_FieldDataTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldDataTypeGetObj",Err,ERROR,*999)
 
    CALL FIELD_DATA_TYPE_GET(Field%FIELD,VariableType,DataType,Err,ERROR,*999)

    CALL EXITS("CMISSFieldDataTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSFieldDataTypeGetObj",Err,ERROR)
    CALL EXITS("CMISSFieldDataTypeGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldDataTypeGetObj

  !  
  !================================================================================================================================
  !   

  !>Sets/changes the data type for a field variable for a field identified by a user number.
  SUBROUTINE CMISSFieldDataTypeSetNumber(RegionUserNumber,FieldUserNumber,VariableType,DataType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to set the data type for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to set the data type for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to set the data type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: DataType !<The field variable data type to set. \see OPENCMISS_FieldDataTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldDataTypeSetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DATA_TYPE_SET(FIELD,VariableType,DataType,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldDataTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldDataTypeSetNumber",Err,ERROR)
    CALL EXITS("CMISSFieldDataTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldDataTypeSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the data type for a field variable for a field identified by an object.
  SUBROUTINE CMISSFieldDataTypeSetObj(Field,VariableType,DataType,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to set the data type for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to set the data type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: DataType !<The field variable data type to set. \see OPENCMISS_FieldDataTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldDataTypeSetObj",Err,ERROR,*999)
 
    CALL FIELD_DATA_TYPE_SET(Field%FIELD,VariableType,DataType,Err,ERROR,*999)

    CALL EXITS("CMISSFieldDataTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSFieldDataTypeSetObj",Err,ERROR)
    CALL EXITS("CMISSFieldDataTypeSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldDataTypeSetObj

  !  
  !================================================================================================================================
  !   

  !>Returns the DOF order type for a field variable for a field identified by a user number.
  SUBROUTINE CMISSFieldDOFOrderTypeGetNumber(RegionUserNumber,FieldUserNumber,VariableType,DOFOrderType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the DOF Order type for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the DOF Order type for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the DOF Order type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: DOFOrderType !<On return, the field variable DOF Order type. \see OPENCMISS_FieldDOFOrderTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldDOFOrderTypeGetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DOF_ORDER_TYPE_GET(FIELD,VariableType,DOFOrderType,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldDOFOrderTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldDOFOrderTypeGetNumber",Err,ERROR)
    CALL EXITS("CMISSFieldDOFOrderTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldDOFOrderTypeGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the DOF Order type for a field variable for a field identified by an object.
  SUBROUTINE CMISSFieldDOFOrderTypeGetObj(Field,VariableType,DOFOrderType,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the DOF order type for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the DOF order type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: DOFOrderType !<On return, the field variable DOF order type. \see OPENCMISS_FieldDOFOrderTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldDOFOrderTypeGetObj",Err,ERROR,*999)
 
    CALL FIELD_DOF_ORDER_TYPE_GET(Field%FIELD,VariableType,DOFOrderType,Err,ERROR,*999)

    CALL EXITS("CMISSFieldDOFOrderTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSFieldDOFOrderTypeGetObj",Err,ERROR)
    CALL EXITS("CMISSFieldDOFOrderTypeGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldDOFOrderTypeGetObj

  !  
  !================================================================================================================================
  !   

  !>Sets/changes the DOF order type for a field variable for a field identified by a user number.
  SUBROUTINE CMISSFieldDOFOrderTypeSetNumber(RegionUserNumber,FieldUserNumber,VariableType,DOFOrderType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to set the DOF Order type for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to set the DOF Order type for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to set the DOF Order type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: DOFOrderType !<The field variable DOF Order type to set. \see OPENCMISS_FieldDOFOrderTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldDOFOrderTypeSetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DOF_ORDER_TYPE_SET(FIELD,VariableType,DOFOrderType,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldDOFOrderTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldDOFOrderTypeSetNumber",Err,ERROR)
    CALL EXITS("CMISSFieldDOFOrderTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldDOFOrderTypeSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the DOF Order type for a field variable for a field identified by an object.
  SUBROUTINE CMISSFieldDOFOrderTypeSetObj(Field,VariableType,DOFOrderType,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to set the DOF order type for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to set the DOF order type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: DOFOrderType !<The field variable DOF order type to set. \see OPENCMISS_FieldDOFOrderTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldDOFOrderTypeSetObj",Err,ERROR,*999)
 
    CALL FIELD_DOF_ORDER_TYPE_SET(Field%FIELD,VariableType,DOFOrderType,Err,ERROR,*999)

    CALL EXITS("CMISSFieldDOFOrderTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSFieldDOFOrderTypeSetObj",Err,ERROR)
    CALL EXITS("CMISSFieldDOFOrderTypeSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldDOFOrderTypeSetObj

  !  
  !================================================================================================================================
  !   

  !>Finishes the creation of a field identified by a user number.
  SUBROUTINE CMISSFieldCreateFinishNumber(RegionUserNumber,FieldUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldCreateFinishNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_CREATE_FINISH(FIELD,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Field Create')
#endif

    CALL EXITS("CMISSFieldCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSFieldCreateFinishNumber",Err,ERROR)
    CALL EXITS("CMISSFieldCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldCreateFinishNumber

  !  
  !================================================================================================================================
  !  
 
  !>Finishes the creation of a field identified by an object.
  SUBROUTINE CMISSFieldCreateFinishObj(Field,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(INOUT) :: Field !<The field to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldCreateFinishObj",Err,ERROR,*999)
 
    CALL FIELD_CREATE_FINISH(Field%FIELD,Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Field Create')
#endif

    CALL EXITS("CMISSFieldCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSFieldCreateFinishObj",Err,ERROR)
    CALL EXITS("CMISSFieldCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldCreateFinishObj

  !  
  !================================================================================================================================
  !   

  !>Starts the creation of a field identified by a user number.
  SUBROUTINE CMISSFieldCreateStartNumber(FieldUserNumber,RegionUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to start the creation of.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to start the creation of.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldCreateStartNumber",Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Field Create')
#endif
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_CREATE_START(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSFieldCreateStartNumber",Err,ERROR)
    CALL EXITS("CMISSFieldCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldCreateStartNumber

  !  
  !================================================================================================================================
  !  
 
  !>Starts the creation of a field identified by an object.
  SUBROUTINE CMISSFieldCreateStartObj(FieldUserNumber,Region,Field,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to start the creation of.
    TYPE(CMISSRegionType), INTENT(IN) :: Region !<The region to create the field on.
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<On return, the created field.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldCreateStartObj",Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Field Create')
#endif
 
    CALL FIELD_CREATE_START(FieldUserNumber,Region%REGION,Field%FIELD,Err,ERROR,*999)

    CALL EXITS("CMISSFieldCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSFieldCreateStartObj",Err,ERROR)
    CALL EXITS("CMISSFieldCreateStartObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldCreateStartObj

  !  
  !================================================================================================================================
  !   

  !>Returns the dependent type for a field identified by a user number.
  SUBROUTINE CMISSFieldDependentTypeGetNumber(RegionUserNumber,FieldUserNumber,DependentType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the dependent type for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the dependent type for.
    INTEGER(INTG), INTENT(OUT) :: DependentType !<On return, the field dependent type. \see OPENCMISS_FieldDependentTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldDependentTypeGetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DEPENDENT_TYPE_GET(FIELD,DependentType,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldDependentTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldDependentTypeGetNumber",Err,ERROR)
    CALL EXITS("CMISSFieldDependentTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldDependentTypeGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the dependent type for a field identified by an object.
  SUBROUTINE CMISSFieldDependentTypeGetObj(Field,DependentType,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the dependent type for.
    INTEGER(INTG), INTENT(OUT) :: DependentType !<On return, the field dependent type. \see OPENCMISS_FieldDependentTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldDependentTypeGetObj",Err,ERROR,*999)
 
    CALL FIELD_DEPENDENT_TYPE_GET(Field%FIELD,DependentType,Err,ERROR,*999)

    CALL EXITS("CMISSFieldDependentTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSFieldDependentTypeGetObj",Err,ERROR)
    CALL EXITS("CMISSFieldDependentTypeGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldDependentTypeGetObj

  !  
  !================================================================================================================================
  !   

  !>Sets/changes the dependent type for a field identified by a user number.
  SUBROUTINE CMISSFieldDependentTypeSetNumber(RegionUserNumber,FieldUserNumber,DependentType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the dependent type for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the dependent type for.
    INTEGER(INTG), INTENT(IN) :: DependentType !<The field dependent type to set. \see OPENCMISS_FieldDependentTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldDependentTypeSetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DEPENDENT_TYPE_SET(FIELD,DependentType,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldDependentTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldDependentTypeSetNumber",Err,ERROR)
    CALL EXITS("CMISSFieldDependentTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldDependentTypeSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the dependent type for a field identified by an object.
  SUBROUTINE CMISSFieldDependentTypeSetObj(Field,DependentType,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to set the dependent type for.
    INTEGER(INTG), INTENT(IN) :: DependentType !<The field dependent type to set. \see OPENCMISS_FieldDependentTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldDependentTypeSetObj",Err,ERROR,*999)
 
    CALL FIELD_DEPENDENT_TYPE_SET(Field%FIELD,DependentType,Err,ERROR,*999)

    CALL EXITS("CMISSFieldDependentTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSFieldDependentTypeSetObj",Err,ERROR)
    CALL EXITS("CMISSFieldDependentTypeSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldDependentTypeSetObj

  !  
  !================================================================================================================================
  !   

  !>Destroys a field identified by a user number.
  SUBROUTINE CMISSFieldDestroyNumber(RegionUserNumber,FieldUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to destroy.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to destroy.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldDestroyNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DESTROY(FIELD,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSFieldDestroyNumber",Err,ERROR)
    CALL EXITS("CMISSFieldDestroyNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldDestroyNumber

  !  
  !================================================================================================================================
  !  
 
  !>Destroys a field identified by an object.
  SUBROUTINE CMISSFieldDestroyObj(Field,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to destroy.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldDestroyObj",Err,ERROR,*999)
 
    CALL FIELD_DESTROY(Field%FIELD,Err,ERROR,*999)

    CALL EXITS("CMISSFieldDestroyObj")
    RETURN
999 CALL ERRORS("CMISSFieldDestroyObj",Err,ERROR)
    CALL EXITS("CMISSFieldDestroyObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldDestroyObj

  !  
  !================================================================================================================================
  !   

  !>Returns the dimension for a field identified by a user number.
  SUBROUTINE CMISSFieldDimensionGetNumber(RegionUserNumber,FieldUserNumber,VariableType,DIMENSION,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the dimension for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the dimension for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the dimension for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: Dimension !<On return, the field dimension. \see OPENCMISS_FieldDimensionTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldDimensionGetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DIMENSION_GET(FIELD,VariableType,DIMENSION,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldDimensionGetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldDimensionGetNumber",Err,ERROR)
    CALL EXITS("CMISSFieldDimensionGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldDimensionGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the dimension for a field identified by an object.
  SUBROUTINE CMISSFieldDimensionGetObj(Field,VariableType,DIMENSION,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the dimension for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the dimension for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: Dimension !<On return, the field dimension. \see OPENCMISS_FieldDimension
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldDimensionGetObj",Err,ERROR,*999)
 
    CALL FIELD_DIMENSION_GET(Field%FIELD,VariableType,DIMENSION,Err,ERROR,*999)

    CALL EXITS("CMISSFieldDimensionGetObj")
    RETURN
999 CALL ERRORS("CMISSFieldDimensionGetObj",Err,ERROR)
    CALL EXITS("CMISSFieldDimensionGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldDimensionGetObj

  !  
  !================================================================================================================================
  !   

  !>Sets/changes the dimension for a field identified by a user number.
  SUBROUTINE CMISSFieldDimensionSetNumber(RegionUserNumber,FieldUserNumber,VariableType,DIMENSION,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to set the dimension for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to set the dimension for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the dimension for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: Dimension !<The field dimension to set. \see OPENCMISS_FieldDimensionTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldDimensionSetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DIMENSION_SET(FIELD,VariableType,DIMENSION,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldDimensionSetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldDimensionSetNumber",Err,ERROR)
    CALL EXITS("CMISSFieldDimensionSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldDimensionSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the dimension for a field identified by an object.
  SUBROUTINE CMISSFieldDimensionSetObj(Field,VariableType,Dimension,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to set the dimension for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the dimension for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: Dimension !<The field dimension to set. \see OPENCMISS_FieldDimension
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldDimensionSetObj",Err,ERROR,*999)
 
    CALL FIELD_DIMENSION_SET(Field%FIELD,VariableType,DIMENSION,Err,ERROR,*999)

    CALL EXITS("CMISSFieldDimensionSetObj")
    RETURN
999 CALL ERRORS("CMISSFieldDimensionSetObj",Err,ERROR)
    CALL EXITS("CMISSFieldDimensionSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldDimensionSetObj

  !  
  !================================================================================================================================
  !   

  !>Returns the geometric field for a field identified by a user number.
  SUBROUTINE CMISSFieldGeometricFieldGetNumber(RegionUserNumber,FieldUserNumber,GeometricFieldUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the geometric field for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the geometric field for.
    INTEGER(INTG), INTENT(OUT) :: GeometricFieldUserNumber !<On return, the field geometric field user number. 
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD,GEOMETRIC_FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldGeometricFieldGetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    NULLIFY(GEOMETRIC_FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_GEOMETRIC_FIELD_GET(FIELD,GEOMETRIC_FIELD,Err,ERROR,*999)
        GeometricFieldUserNumber=GEOMETRIC_FIELD%USER_NUMBER
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldGeometricFieldGetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldGeometricFieldGetNumber",Err,ERROR)
    CALL EXITS("CMISSFieldGeometricFieldGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldGeometricFieldGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the geometric field for a field identified by an object.
  SUBROUTINE CMISSFieldGeometricFieldGetObj(Field,GeometricField,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the geometric field for.
    TYPE(CMISSFieldType), INTENT(OUT) :: GeometricField !<On return, the geometric field for the field.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldGeometricFieldGetObj",Err,ERROR,*999)
 
    CALL FIELD_GEOMETRIC_FIELD_GET(Field%FIELD,GeometricField%FIELD,Err,ERROR,*999)

    CALL EXITS("CMISSFieldGeometricFieldGetObj")
    RETURN
999 CALL ERRORS("CMISSFieldGeometricFieldGetObj",Err,ERROR)
    CALL EXITS("CMISSFieldGeometricFieldGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldGeometricFieldGetObj

  !  
  !================================================================================================================================
  !   

  !>Sets/changes the geometric field for a field identified by a user number.
  SUBROUTINE CMISSFieldGeometricFieldSetNumber(RegionUserNumber,FieldUserNumber,GeometricFieldUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to set the geometric field for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to set the geometric field for.
    INTEGER(INTG), INTENT(OUT) :: GeometricFieldUserNumber !<The field geometric field user number to set. 
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD,GEOMETRIC_FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldGeometricFieldSetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    NULLIFY(GEOMETRIC_FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_USER_NUMBER_FIND(GeometricFieldUserNumber,REGION,GEOMETRIC_FIELD,Err,ERROR,*999)
        IF(ASSOCIATED(GEOMETRIC_FIELD)) THEN
          CALL FIELD_GEOMETRIC_FIELD_SET(FIELD,GEOMETRIC_FIELD,Err,ERROR,*999)
        ELSE
          LOCAL_ERROR="A geometric field with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(GeometricFieldUserNumber,"*",Err,ERROR))// &
            & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldGeometricFieldSetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldGeometricFieldSetNumber",Err,ERROR)
    CALL EXITS("CMISSFieldGeometricFieldSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldGeometricFieldSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the geometric field for a field identified by an object.
  SUBROUTINE CMISSFieldGeometricFieldSetObj(Field,GeometricField,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to set the geometric field for.
    TYPE(CMISSFieldType), INTENT(IN) :: GeometricField !<The geometric field for the field to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldGeometricFieldSetObj",Err,ERROR,*999)
 
    CALL FIELD_GEOMETRIC_FIELD_SET(Field%FIELD,GeometricField%FIELD,Err,ERROR,*999)

    CALL EXITS("CMISSFieldGeometricFieldSetObj")
    RETURN
999 CALL ERRORS("CMISSFieldGeometricFieldSetObj",Err,ERROR)
    CALL EXITS("CMISSFieldGeometricFieldSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldGeometricFieldSetObj

  !  
  !================================================================================================================================
  !  

  !>Returns the character string label for a field identified by a user number.
  SUBROUTINE CMISSFieldLabelGetCNumber(RegionUserNumber,FieldUserNumber,Label,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: Label !<On return, the field label.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldLabelGetCNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_LABEL_GET(FIELD,Label,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldLabelGetCNumber")
    RETURN
999 CALL ERRORS("CMISSFieldLabelGetCNumber",Err,ERROR)
    CALL EXITS("CMISSFieldLabelGetCNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldLabelGetCNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the character string label for a field identified by an object.
  SUBROUTINE CMISSFieldLabelGetCObj(Field,Label,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: Label !<On return, the field label.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldLabelGetCObj",Err,ERROR,*999)
 
    CALL FIELD_LABEL_GET(Field%FIELD,Label,Err,ERROR,*999)

    CALL EXITS("CMISSFieldLabelGetCObj")
    RETURN
999 CALL ERRORS("CMISSFieldLabelGetCObj",Err,ERROR)
    CALL EXITS("CMISSFieldLabelGetCObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldLabelGetCObj

  !  
  !================================================================================================================================
  !  

  !>Returns the varying string label for a field identified by a user number.
  SUBROUTINE CMISSFieldLabelGetVSNumber(RegionUserNumber,FieldUserNumber,Label,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: Label !<On return, the field label.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldLabelGetVSNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_LABEL_GET(FIELD,Label,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldLabelGetVSNumber")
    RETURN
999 CALL ERRORS("CMISSFieldLabelGetVSNumber",Err,ERROR)
    CALL EXITS("CMISSFieldLabelGetVSNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldLabelGetVSNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the varying string label for a field identified by an object.
  SUBROUTINE CMISSFieldLabelGetVSObj(Field,Label,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: Label !<On return, the field label.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldLabelGetVSObj",Err,ERROR,*999)
 
    CALL FIELD_LABEL_GET(Field%FIELD,Label,Err,ERROR,*999)

    CALL EXITS("CMISSFieldLabelGetVSObj")
    RETURN
999 CALL ERRORS("CMISSFieldLabelGetVSObj",Err,ERROR)
    CALL EXITS("CMISSFieldLabelGetVSObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldLabelGetVSObj

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the character string label for a field identified by a user number.
  SUBROUTINE CMISSFieldLabelSetCNumber(RegionUserNumber,FieldUserNumber,Label,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: Label !<The field label to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldLabelSetCNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_LABEL_SET(FIELD,Label,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldLabelSetCNumber")
    RETURN
999 CALL ERRORS("CMISSFieldLabelSetCNumber",Err,ERROR)
    CALL EXITS("CMISSFieldLabelSetCNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldLabelSetCNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the character string label for a field identified by an object.
  SUBROUTINE CMISSFieldLabelSetCObj(Field,Label,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: Label !<The field label to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldLabelSetCObj",Err,ERROR,*999)
 
    CALL FIELD_LABEL_SET(Field%FIELD,Label,Err,ERROR,*999)

    CALL EXITS("CMISSFieldLabelSetCObj")
    RETURN
999 CALL ERRORS("CMISSFieldLabelSetCObj",Err,ERROR)
    CALL EXITS("CMISSFieldLabelSetCObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldLabelSetCObj

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the varying string label for a field identified by a user number.
  SUBROUTINE CMISSFieldLabelSetVSNumber(RegionUserNumber,FieldUserNumber,Label,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: Label !<The field label to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldLabelSetVSNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_LABEL_SET(FIELD,Label,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldLabelSetVSNumber")
    RETURN
999 CALL ERRORS("CMISSFieldLabelSetVSNumber",Err,ERROR)
    CALL EXITS("CMISSFieldLabelSetVSNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldLabelSetVSNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the varying string label for a field identified by an object.
  SUBROUTINE CMISSFieldLabelSetVSObj(Field,Label,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: Label !<The field label to set
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldLabelSetVSObj",Err,ERROR,*999)
 
    CALL FIELD_LABEL_SET(Field%FIELD,Label,Err,ERROR,*999)

    CALL EXITS("CMISSFieldLabelSetVSObj")
    RETURN
999 CALL ERRORS("CMISSFieldLabelSetVSObj",Err,ERROR)
    CALL EXITS("CMISSFieldLabelSetVSObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldLabelSetVSObj

  !  
  !================================================================================================================================
  !   

  !>Returns the mesh decomposition for a field identified by a user number.
  SUBROUTINE CMISSFieldMeshDecompositionGetNumber(RegionUserNumber,FieldUserNumber,DecompositionUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the mesh decomposition for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the mesh decomposition for.
    INTEGER(INTG), INTENT(OUT) :: DecompositionUserNumber !<On return, the field decomposition user number. 
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldMeshDecompositionGetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_MESH_DECOMPOSITION_GET(FIELD,DECOMPOSITION,Err,ERROR,*999)
        DecompositionUserNumber=DECOMPOSITION%USER_NUMBER
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldMeshDecompositionGetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldMeshDecompositionGetNumber",Err,ERROR)
    CALL EXITS("CMISSFieldMeshDecompositionGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldMeshDecompositionGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the mesh decomposition for a field identified by an object.
  SUBROUTINE CMISSFieldMeshDecompositionGetObj(Field,MeshDecomposition,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the mesh decomposition for.
    TYPE(CMISSDecompositionType), INTENT(OUT) :: MeshDecomposition !<On return, the mesh decomposition for the field.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldMeshDecompositionGetObj",Err,ERROR,*999)
 
    CALL FIELD_MESH_DECOMPOSITION_GET(Field%FIELD,MeshDecomposition%DECOMPOSITION,Err,ERROR,*999)

    CALL EXITS("CMISSFieldMeshDecompositionGetObj")
    RETURN
999 CALL ERRORS("CMISSFieldMeshDecompositionGetObj",Err,ERROR)
    CALL EXITS("CMISSFieldMeshDecompositionGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldMeshDecompositionGetObj

  !  
  !================================================================================================================================
  !   

  !>Sets/changes the mesh decomposition for a field identified by a user number.
  SUBROUTINE CMISSFieldMeshDecompositionSetNumber(RegionUserNumber,FieldUserNumber,MeshUserNumber,DecompositionUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to set the mesh decomposition for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to set the mesh decomposition for.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber !<The user number of the mesh to set the mesh decomposition for.
    INTEGER(INTG), INTENT(IN) :: DecompositionUserNumber !<The field mesh decomposition user number to set. 
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldMeshDecompositionSetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL MESH_USER_NUMBER_FIND(MeshUserNumber,REGION,MESH,Err,ERROR,*999)
        IF(ASSOCIATED(MESH)) THEN
          CALL DECOMPOSITION_USER_NUMBER_FIND(DecompositionUserNumber,MESH,DECOMPOSITION,Err,ERROR,*999)
          IF(ASSOCIATED(DECOMPOSITION)) THEN
            CALL FIELD_MESH_DECOMPOSITION_SET(FIELD,DECOMPOSITION,Err,ERROR,*999)
          ELSE
            LOCAL_ERROR="A decomposition with a user number of "//TRIM(NUMBER_TO_VSTRING(DecompositionUserNumber,"*",Err,ERROR))// &
              & " does not exist on mesh number "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))// &
            & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldMeshDecompositionSetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldMeshDecompositionSetNumber",Err,ERROR)
    CALL EXITS("CMISSFieldMeshDecompositionSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldMeshDecompositionSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the mesh decomposition for a field identified by an object.
  SUBROUTINE CMISSFieldMeshDecompositionSetObj(Field,MeshDecomposition,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the mesh decomposition for.
    TYPE(CMISSDecompositionType), INTENT(IN) :: MeshDecomposition !<The mesh decomposition for the field to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldMeshDecompositionSetObj",Err,ERROR,*999)
 
    CALL FIELD_MESH_DECOMPOSITION_SET(Field%FIELD,MeshDecomposition%DECOMPOSITION,Err,ERROR,*999)

    CALL EXITS("CMISSFieldMeshDecompositionSetObj")
    RETURN
999 CALL ERRORS("CMISSFieldMeshDecompositionSetObj",Err,ERROR)
    CALL EXITS("CMISSFieldMeshDecompositionSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldMeshDecompositionSetObj

  !  
  !================================================================================================================================
  !   

  !>Returns the number of componenets for a field variable for a field identified by a user number.
  SUBROUTINE CMISSFieldNumberOfComponentsGetNumber(RegionUserNumber,FieldUserNumber,VariableType,NumberOfComponents,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the number of components for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the number of components for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the dependent field to get the number of components for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: NumberOfComponents !<On return, the number of components in the field variable.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldNumberOfComponentsGetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_NUMBER_OF_COMPONENTS_GET(FIELD,VariableType,NumberOfComponents,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldNumberOfComponentsGetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldNumberOfComponentsGetNumber",Err,ERROR)
    CALL EXITS("CMISSFieldNumberOfComponentsGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldNumberOfComponentsGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the number of components for a field variable for a field identified by an object.
  SUBROUTINE CMISSFieldNumberOfComponentsGetObj(Field,VariableType,NumberOfComponents,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the number of components for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the dependent field to get the number of components for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: NumberOfComponents !<On return, the number of components in the field variable.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldNumberOfComponentsGetObj",Err,ERROR,*999)
 
    CALL FIELD_NUMBER_OF_COMPONENTS_GET(Field%FIELD,VariableType,NumberOfComponents,Err,ERROR,*999)

    CALL EXITS("CMISSFieldNumberOfComponentsGetObj")
    RETURN
999 CALL ERRORS("CMISSFieldNumberOfComponentsGetObj",Err,ERROR)
    CALL EXITS("CMISSFieldNumberOfComponentsGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldNumberOfComponentsGetObj

  !  
  !================================================================================================================================
  !   

  !>Sets/changes the number of componenets for a field variable for a field identified by a user number.
  SUBROUTINE CMISSFieldNumberOfComponentsSetNumber(RegionUserNumber,FieldUserNumber,VariableType,NumberOfComponents,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the dependent field to set the number of components for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: NumberOfComponents !<The number of components in the field variable to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldNumberOfComponentsSetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_NUMBER_OF_COMPONENTS_SET(FIELD,VariableType,NumberOfComponents,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldNumberOfComponentsSetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldNumberOfComponentsSetNumber",Err,ERROR)
    CALL EXITS("CMISSFieldNumberOfComponentsSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldNumberOfComponentsSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the number of components for a field variable for a field identified by an object.
  SUBROUTINE CMISSFieldNumberOfComponentsSetObj(Field,VariableType,NumberOfComponents,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the dependent field to set the number of components for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: NumberOfComponents !<The number of components in the field variable to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldNumberOfComponentsSetObj",Err,ERROR,*999)
 
    CALL FIELD_NUMBER_OF_COMPONENTS_SET(Field%FIELD,VariableType,NumberOfComponents,Err,ERROR,*999)

    CALL EXITS("CMISSFieldNumberOfComponentsSetObj")
    RETURN
999 CALL ERRORS("CMISSFieldNumberOfComponentsSetObj",Err,ERROR)
    CALL EXITS("CMISSFieldNumberOfComponentsSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldNumberOfComponentsSetObj

  !  
  !================================================================================================================================
  !   

  !>Returns the number of variables for a field identified by a user number.
  SUBROUTINE CMISSFieldNumberOfVariablesGetNumber(RegionUserNumber,FieldUserNumber,NumberOfVariables,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the number of variables for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the number of variables for.
    INTEGER(INTG), INTENT(OUT) :: NumberOfVariables !<On return, the number of variables in the field.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldNumberOfVariablesGetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_NUMBER_OF_VARIABLES_GET(FIELD,NumberOfVariables,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldNumberOfVariablesGetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldNumberOfVariablesGetNumber",Err,ERROR)
    CALL EXITS("CMISSFieldNumberOfVariablesGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldNumberOfVariablesGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the number of variables for a field identified by an object.
  SUBROUTINE CMISSFieldNumberOfVariablesGetObj(Field,NumberOfVariables,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the number of variables for.
    INTEGER(INTG), INTENT(OUT) :: NumberOfVariables !<On return, the number of variables in the field.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldNumberOfVariablesGetObj",Err,ERROR,*999)
 
    CALL FIELD_NUMBER_OF_VARIABLES_GET(Field%FIELD,NumberOfVariables,Err,ERROR,*999)

    CALL EXITS("CMISSFieldNumberOfVariablesGetObj")
    RETURN
999 CALL ERRORS("CMISSFieldNumberOfVariablesGetObj",Err,ERROR)
    CALL EXITS("CMISSFieldNumberOfVariablesGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldNumberOfVariablesGetObj

  !  
  !================================================================================================================================
  !   

  !>Sets/chnages the number of variables for a field identified by a user number.
  SUBROUTINE CMISSFieldNumberOfVariablesSetNumber(RegionUserNumber,FieldUserNumber,NumberOfVariables,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to set the number of variables for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to set the number of variables for.
    INTEGER(INTG), INTENT(IN) :: NumberOfVariables !<The number of variables in the field to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldNumberOfVariablesSetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_NUMBER_OF_VARIABLES_SET(FIELD,NumberOfVariables,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldNumberOfVariablesSetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldNumberOfVariablesSetNumber",Err,ERROR)
    CALL EXITS("CMISSFieldNumberOfVariablesSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldNumberOfVariablesSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the number of variables for a field identified by an object.
  SUBROUTINE CMISSFieldNumberOfVariablesSetObj(Field,NumberOfVariables,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to set the number of variables for.
    INTEGER(INTG), INTENT(IN) :: NumberOfVariables !<The number of variables in the field to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldNumberOfVariablesSetObj",Err,ERROR,*999)
 
    CALL FIELD_NUMBER_OF_VARIABLES_SET(Field%FIELD,NumberOfVariables,Err,ERROR,*999)

    CALL EXITS("CMISSFieldNumberOfVariablesSetObj")
    RETURN
999 CALL ERRORS("CMISSFieldNumberOfVariablesSetObj",Err,ERROR)
    CALL EXITS("CMISSFieldNumberOfVariablesSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldNumberOfVariablesSetObj

  !  
  !================================================================================================================================
  !   

  !>Adds the given integer value to the given parameter set for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetAddConstantIntgNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: Value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetAddConstantIntgNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_CONSTANT(FIELD,VariableType,FieldSetType,ComponentNumber,Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetAddConstantIntgNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddConstantIntgNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetAddConstantIntgNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetAddConstantIntgNumber

  !  
  !================================================================================================================================
  !  
 
  !>Adds the given integer value to the given parameter set for the constant of the field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetAddConstantIntgObj(Field,VariableType,FieldSetType,ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: Value !<The value to add to the field parameter set.
     INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetAddConstantIntgObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_ADD_CONSTANT(Field%FIELD,VariableType,FieldSetType,ComponentNumber,Value,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetAddConstantIntgObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddConstantIntgObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetAddConstantIntgObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetAddConstantIntgObj

  !  
  !================================================================================================================================
  !   

  !>Adds the given single precision value to the given parameter set for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetAddConstantSPNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    REAL(SP), INTENT(IN) :: Value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetAddConstantSPNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_CONSTANT(FIELD,VariableType,FieldSetType,ComponentNumber,Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetAddConstantSPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddConstantSPNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetAddConstantSPNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetAddConstantSPNumber

  !  
  !================================================================================================================================
  !  
 
  !>Adds the given single precision value to the given parameter set for the constant of the field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetAddConstantSPObj(Field,VariableType,FieldSetType,ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    REAL(SP), INTENT(IN) :: Value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetAddConstantSPObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_ADD_CONSTANT(Field%FIELD,VariableType,FieldSetType,ComponentNumber,Value,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetAddConstantSPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddConstantSPObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetAddConstantSPObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetAddConstantSPObj

  !  
  !================================================================================================================================
  !   

  !>Adds the given double precision value to the given parameter set for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetAddConstantDPNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    REAL(DP), INTENT(IN) :: Value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetAddConstantDPNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_CONSTANT(FIELD,VariableType,FieldSetType,ComponentNumber,Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetAddConstantDPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddConstantDPNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetAddConstantDPNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetAddConstantDPNumber

  !  
  !================================================================================================================================
  !  
 
  !>Adds the given double precision value to the given parameter set for the constant of the field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetAddConstantDPObj(Field,VariableType,FieldSetType,ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    REAL(DP), INTENT(IN) :: Value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetAddConstantDPObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_ADD_CONSTANT(Field%FIELD,VariableType,FieldSetType,ComponentNumber,Value,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetAddConstantDPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddConstantDPObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetAddConstantDPObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetAddConstantDPObj

  !  
  !================================================================================================================================
  !   

  !>Adds the given logical value to the given parameter set for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetAddConstantLNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    LOGICAL, INTENT(IN) :: Value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetAddConstantLNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_CONSTANT(FIELD,VariableType,FieldSetType,ComponentNumber,Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetAddConstantLNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddConstantLNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetAddConstantLNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetAddConstantLNumber

  !  
  !================================================================================================================================
  !  
 
  !>Adds the given logical value to the given parameter set for the constant of the field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetAddConstantLObj(Field,VariableType,FieldSetType,ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    LOGICAL, INTENT(IN) :: Value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetAddConstantLObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_ADD_CONSTANT(Field%FIELD,VariableType,FieldSetType,ComponentNumber,Value,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetAddConstantLbj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddConstantLObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetAddConstantLObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetAddConstantLObj
  
  !  
  !================================================================================================================================
  !   

  !>Adds the given integer value to an element in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetAddElementIntgNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & UserElementNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to add the value to the element in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to add the value to the element. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: UserElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: Value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetAddElementIntgNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_ELEMENT(FIELD,VariableType,FieldSetType,UserElementNumber,ComponentNumber,Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetAddElementIntgNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddElementIntgNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetAddElementIntgNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetAddElementIntgNumber

  !  
  !================================================================================================================================
  !  
 
  !>Adds the given integer value to an element in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetAddElementIntgObj(Field,VariableType,FieldSetType,userElementNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to add the value to the element in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to add the value to the element. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: UserElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: Value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetAddElementIntgObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_ADD_ELEMENT(Field%FIELD,VariableType,FieldSetType,UserElementNumber,ComponentNumber,Value, &
      & Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetAddElementIntgObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddElementIntgObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetAddElementIntgObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetAddElementIntgObj

  !  
  !================================================================================================================================
  !   

  !>Adds the given single precision value to an element in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetAddElementSPNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & UserElementNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to add the value to the element in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to add the value to the element. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: UserElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    REAL(SP), INTENT(IN) :: Value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetAddElementSPNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_ELEMENT(FIELD,VariableType,FieldSetType,UserElementNumber,ComponentNumber,Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetAddElementSPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddElementSPNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetAddElementSPNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetAddElementSPNumber

  !  
  !================================================================================================================================
  !  
 
  !>Adds the given single precision value to an element in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetAddElementSPObj(Field,VariableType,FieldSetType,UserElementNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to add the value to the element in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to add the value to the element. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: UserElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    REAL(SP), INTENT(IN) :: Value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetAddElementSPObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_ADD_ELEMENT(Field%FIELD,VariableType,FieldSetType,UserElementNumber,ComponentNumber,Value, &
      & Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetAddElementSPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddElementSPObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetAddElementSPObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetAddElementSPObj

  !  
  !================================================================================================================================
  !   

  !>Adds the given double precision value to an element in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetAddElementDPNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & UserElementNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to add the value to the element in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to add the value to the element. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: UserElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    REAL(DP), INTENT(IN) :: Value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetAddElementDPNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_ELEMENT(FIELD,VariableType,FieldSetType,UserElementNumber,ComponentNumber,Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetAddElementDPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddElementDPNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetAddElementDPNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetAddElementDPNumber

  !  
  !================================================================================================================================
  !  
 
  !>Adds the given double precision value to an element in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetAddElementDPObj(Field,VariableType,FieldSetType,UserElementNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to add the value to the element in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to add the value to the element. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: UserElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    REAL(DP), INTENT(IN) :: Value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetAddElementDPObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_ADD_ELEMENT(Field%FIELD,VariableType,FieldSetType,UserElementNumber,ComponentNumber,Value, &
      & Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetAddElementDPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddElementDPObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetAddElementDPObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetAddElementDPObj

  !  
  !================================================================================================================================
  !   

  !>Adds the given logical value to an element in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetAddElementLNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & UserElementNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to add the value to the element in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to add the value to the element. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: UserElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    LOGICAL, INTENT(IN) :: Value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetAddElementLNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_ELEMENT(FIELD,VariableType,FieldSetType,UserElementNumber,ComponentNumber,Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetAddElementLNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddElementLNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetAddElementLNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetAddElementLNumber

  !  
  !================================================================================================================================
  !  
 
  !>Adds the given logical value to an element in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetAddElementLObj(Field,VariableType,FieldSetType,UserElementNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to add the value to the element in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to add the value to the element. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: UserElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    LOGICAL, INTENT(IN) :: Value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetAddElementLObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_ADD_ELEMENT(Field%FIELD,VariableType,FieldSetType,UserElementNumber,ComponentNumber,Value, &
      & Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetAddElementLObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddElementLObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetAddElementLObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetAddElementLObj

  !  
  !================================================================================================================================
  !   

  !>Adds the given integer value to an node in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetAddNodeIntgNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType,DerivativeNumber, &
    & UserNodeNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to add the value to the node in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to add the value to the node. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: UserNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: Value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetAddNodeIntgNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_NODE(FIELD,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber,ComponentNumber, &
          & Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetAddNodeIntgNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddNodeIntgNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetAddNodeIntgNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetAddNodeIntgNumber

  !  
  !================================================================================================================================
  !  
 
  !>Adds the given integer value to an node in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetAddNodeIntgObj(Field,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber, &
    & ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to add the value to the node in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to add the value to the node. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: UserNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: Value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetAddNodeIntgObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_ADD_NODE(Field%FIELD,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber,ComponentNumber,Value, &
      & Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetAddNodeIntgObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddNodeIntgObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetAddNodeIntgObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetAddNodeIntgObj

  !  
  !================================================================================================================================
  !   

  !>Adds the given single precision value to an node in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetAddNodeSPNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType,DerivativeNumber, &
    & UserNodeNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to add the value to the node in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to add the value to the node. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: UserNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    REAL(SP), INTENT(IN) :: Value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetAddNodeSPNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_NODE(FIELD,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber,ComponentNumber, &
          & Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetAddNodeSPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddNodeSPNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetAddNodeSPNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetAddNodeSPNumber

  !  
  !================================================================================================================================
  !  
 
  !>Adds the given single precision value to an node in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetAddNodeSPObj(Field,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber, &
    & ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to add the value to the node in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to add the value to the node. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: UserNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    REAL(SP), INTENT(IN) :: Value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetAddNodeSPObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_ADD_NODE(Field%FIELD,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber, &
      & ComponentNumber,Value,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetAddNodeSPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddNodeSPObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetAddNodeSPObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetAddNodeSPObj

  !  
  !================================================================================================================================
  !   

  !>Adds the given double precision value to an node in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetAddNodeDPNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType,DerivativeNumber, &
    & UserNodeNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to add the value to the node in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to add the value to the node. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: UserNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    REAL(DP), INTENT(IN) :: Value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetAddNodeDPNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_NODE(FIELD,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber,ComponentNumber, &
          & Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetAddNodeDPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddNodeDPNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetAddNodeDPNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetAddNodeDPNumber

  !  
  !================================================================================================================================
  !  
 
  !>Adds the given double precision value to an node in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetAddNodeDPObj(Field,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber, &
    & ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to add the value to the node in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to add the value to the node. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: UserNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    REAL(DP), INTENT(IN) :: Value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetAddNodeDPObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_ADD_NODE(Field%FIELD,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber, &
      & ComponentNumber,Value,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetAddNodeDPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddNodeDPObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetAddNodeDPObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetAddNodeDPObj

  !  
  !================================================================================================================================
  !   

  !>Adds the given logical value to an node in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetAddNodeLNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType,DerivativeNumber, &
    & UserNodeNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to add the value to the node in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to add the value to the node. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: UserNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    LOGICAL, INTENT(IN) :: Value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetAddNodeLNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_NODE(FIELD,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber,ComponentNumber, &
          & Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetAddNodeLNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddNodeLNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetAddNodeLNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetAddNodeLNumber

  !  
  !================================================================================================================================
  !  
 
  !>Adds the given logical value to an node in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetAddNodeLObj(Field,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber,ComponentNumber, &
    & Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to add the value to the node in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to add the value to the node. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: UserNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    LOGICAL, INTENT(IN) :: Value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetAddNodeLObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_ADD_NODE(Field%FIELD,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber,ComponentNumber, &
      & Value,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetAddNodeLObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddNodeLObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetAddNodeLObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetAddNodeLObj

  !  
  !================================================================================================================================
  !   

  !>Creates a new parameter set of type set type for a field variable for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetCreateNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to create the parameter set on.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to create the parameter set on.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to create the parameter set on. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to create. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetCreateNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_CREATE(FIELD,VariableType,FieldSetType,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetCreateNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetCreateNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetCreateNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetCreateNumber

  !  
  !================================================================================================================================
  !  
 
  !>Creates a new parameter set of type set type for a field variable for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetCreateObj(Field,VariableType,FieldSetType,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to create the field parameter set on.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to create the parameter set on. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to create. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetCreateObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_CREATE(Field%FIELD,VariableType,FieldSetType,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetCreateObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetCreateObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetCreateObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetCreateObj

  !  
  !================================================================================================================================
  !   

  !>Destroys the specified parameter set type for a field variable for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetDestroyNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to destroy the parameter set for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to destroy the parameter set for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to destroy the parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to destroy. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetDestroyNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DESTROY(FIELD,VariableType,FieldSetType,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDestroyNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetDestroyNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetDestroyNumber

  !  
  !================================================================================================================================
  !  
 
  !>Destroys the specified parameter set type for a field variable for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetDestroyObj(Field,VariableType,FieldSetType,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to destroy the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to destroy the parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to destroy. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetDestroyObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_DESTROY(Field%FIELD,VariableType,FieldSetType,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetDestroyObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDestroyObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetDestroyObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetDestroyObj

  !  
  !================================================================================================================================
  !   

  !>Returns a pointer to the specified field parameter set local integer data array for a field identified by an user number. The pointer must be restored with a call to OPENCMISS::CMISSFieldParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE CMISSFieldParameterSetDataGetIntgNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType,Parameters,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the parameter set data to get. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(INOUT), POINTER :: Parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetDataGetIntgNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DATA_GET(FIELD,VariableType,FieldSetType,Parameters,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetDataGetIntgNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDataGetIntgNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetDataGetIntgNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetDataGetIntgNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns a pointer to the specified field parameter set local integer data array for a field identified by an object. The pointer must be restored with a call to OPENCMISS::CMISSFieldParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE CMISSFieldParameterSetDataGetIntgObj(Field,VariableType,FieldSetType,Parameters,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the parameter set data to get. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(INOUT), POINTER :: Parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetDataGetIntgObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_DATA_GET(Field%FIELD,VariableType,FieldSetType,Parameters,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetDataGetIntgObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDataGetIntgObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetDataGetIntgObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetDataGetIntgObj

  !  
  !================================================================================================================================
  !   

  !>Returns a pointer to the specified field parameter set local single precision data array for a field identified by an user number. The pointer must be restored with a call to OPENCMISS::CMISSFieldParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE CMISSFieldParameterSetDataGetSPNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType,Parameters,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the parameter set data to get. \see OPENCMISS_FieldParameterSetTypes
    REAL(SP), INTENT(INOUT), POINTER :: Parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetDataGetSPNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DATA_GET(FIELD,VariableType,FieldSetType,Parameters,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetDataGetSPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDataGetSPNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetDataGetSPNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetDataGetSPNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns a pointer to the specified field parameter set local single precision data array for a field identified by an object. The pointer must be restored with a call to OPENCMISS::CMISSFieldParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE CMISSFieldParameterSetDataGetSPObj(Field,VariableType,FieldSetType,Parameters,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the parameter set data to get. \see OPENCMISS_FieldParameterSetTypes
    REAL(SP), INTENT(INOUT), POINTER :: Parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetDataGetSPObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_DATA_GET(Field%FIELD,VariableType,FieldSetType,Parameters,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetDataGetSPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDataGetSPObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetDataGetSPObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetDataGetSPObj

  !  
  !================================================================================================================================
  !   

  !>Returns a pointer to the specified field parameter set local double precision data array for a field identified by an user number. The pointer must be restored with a call to OPENCMISS::CMISSFieldParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE CMISSFieldParameterSetDataGetDPNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType,Parameters,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the parameter set data to get. \see OPENCMISS_FieldParameterSetTypes
    REAL(DP), INTENT(INOUT), POINTER :: Parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetDataGetDPNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DATA_GET(FIELD,VariableType,FieldSetType,Parameters,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetDataGetDPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDataGetDPNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetDataGetDPNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetDataGetDPNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns a pointer to the specified field parameter set local double precision data array for a field identified by an object. The pointer must be restored with a call to OPENCMISS::CMISSFieldParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE CMISSFieldParameterSetDataGetDPObj(Field,VariableType,FieldSetType,Parameters,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the parameter set data to get. \see OPENCMISS_FieldParameterSetTypes
    REAL(DP), INTENT(INOUT), POINTER :: Parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetDataGetDPObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_DATA_GET(Field%FIELD,VariableType,FieldSetType,Parameters,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetDataGetDPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDataGetDPObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetDataGetDPObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetDataGetDPObj

  !  
  !================================================================================================================================
  !   

  !>Returns a pointer to the specified field parameter set local logical data array for a field identified by an user number. The pointer must be restored with a call to OPENCMISS::CMISSFieldParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE CMISSFieldParameterSetDataGetLNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType,Parameters,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the parameter set data to get. \see OPENCMISS_FieldParameterSetTypes
    LOGICAL, INTENT(INOUT), POINTER :: Parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetDataGetLNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DATA_GET(FIELD,VariableType,FieldSetType,Parameters,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetDataGetLNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDataGetLNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetDataGetLNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetDataGetLNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns a pointer to the specified field parameter set local logical data array for a field identified by an object. The pointer must be restored with a call to OPENCMISS::CMISSFieldParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE CMISSFieldParameterSetDataGetLObj(Field,VariableType,FieldSetType,Parameters,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the parameter set data to get. \see OPENCMISS_FieldParameterSetTypes
    LOGICAL, INTENT(INOUT), POINTER :: Parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetDataGetLObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_DATA_GET(Field%FIELD,VariableType,FieldSetType,Parameters,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetDataGetLObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDataGetLObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetDataGetLObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetDataGetLObj

  !  
  !================================================================================================================================
  !   

  !>Restores the specified field variable parameter set local integer array that was obtained with an OPENCMISS::CMISSFieldParameterSetDataGet call for a field that is specified with an user number.
  SUBROUTINE CMISSFieldParameterSetDataRestoreIntgNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType,Parameters,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to restore the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the parameter set data to restore. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(INOUT), POINTER :: Parameters(:) !<A pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetDataRestoreIntgNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FIELD,VariableType,FieldSetType,Parameters,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetDataRestoreIntgNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDataRestoreIntgNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetDataRestoreIntgNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetDataRestoreIntgNumber

  !  
  !================================================================================================================================
  !  
 
  !>Restores the specified field variable parameter set local integer array that was obtained with an OPENCMISS::CMISSFieldParameterSetDataGet call for a field that is specified with an object.
  SUBROUTINE CMISSFieldParameterSetDataRestoreIntgObj(Field,VariableType,FieldSetType,Parameters,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to restore the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to restore the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the parameter set data to restore. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(INOUT), POINTER :: Parameters(:) !<A pointer to the parameter set data to restore.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetDataRestoreIntgObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_DATA_RESTORE(Field%FIELD,VariableType,FieldSetType,Parameters,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetDataRestoreIntgObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDataRestoreIntgObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetDataRestoreIntgObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetDataRestoreIntgObj

  !  
  !================================================================================================================================
  !   

  !>Restores the specified field variable parameter set local single precision array that was obtained with an OPENCMISS::CMISSFieldParameterSetDataGet call for a field that is specified with an user number.
  SUBROUTINE CMISSFieldParameterSetDataRestoreSPNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType,Parameters,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to restore the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the parameter set data to restore. \see OPENCMISS_FieldParameterSetTypes
    REAL(SP), INTENT(INOUT), POINTER :: Parameters(:) !<A pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetDataRestoreSPNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FIELD,VariableType,FieldSetType,Parameters,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetDataRestoreSPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDataRestoreSPNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetDataRestoreSPNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetDataRestoreSPNumber

  !  
  !================================================================================================================================
  !  
 
  !>>Restores the specified field variable parameter set local single precision array that was obtained with an OPENCMISS::CMISSFieldParameterSetDataGet call for a field that is specified with an object.
  SUBROUTINE CMISSFieldParameterSetDataRestoreSPObj(Field,VariableType,FieldSetType,Parameters,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to restore the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to restore the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the parameter set data to restore. \see OPENCMISS_FieldParameterSetTypes
    REAL(SP), INTENT(INOUT), POINTER :: Parameters(:) !<A pointer to the parameter set data to restore.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetDataRestoreSPObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_DATA_RESTORE(Field%FIELD,VariableType,FieldSetType,Parameters,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetDataRestoreSPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDataRestoreSPObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetDataRestoreSPObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetDataRestoreSPObj

  !  
  !================================================================================================================================
  !   

  !>Restores the specified field variable parameter set local double precision array that was obtained with an OPENCMISS::CMISSFieldParameterSetDataGet call for a field that is specified with an user number.
  SUBROUTINE CMISSFieldParameterSetDataRestoreDPNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType,Parameters,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to restore the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the parameter set data to restore. \see OPENCMISS_FieldParameterSetTypes
    REAL(DP), INTENT(INOUT), POINTER :: Parameters(:) !<A pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetDataRestoreDPNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FIELD,VariableType,FieldSetType,Parameters,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetDataRestoreDPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDataRestoreDPNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetDataRestoreDPNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetDataRestoreDPNumber

  !  
  !================================================================================================================================
  !  
 
  !>>Restores the specified field variable parameter set local double precision array that was obtained with an OPENCMISS::CMISSFieldParameterSetDataGet call for a field that is specified with an object.
  SUBROUTINE CMISSFieldParameterSetDataRestoreDPObj(Field,VariableType,FieldSetType,Parameters,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to restore the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to restore the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the parameter set data to restore. \see OPENCMISS_FieldParameterSetTypes
    REAL(DP), INTENT(INOUT), POINTER :: Parameters(:) !<A pointer to the parameter set data to restore.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetDataRestoreDPObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_DATA_RESTORE(Field%FIELD,VariableType,FieldSetType,Parameters,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetDataRestoreDPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDataRestoreDPObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetDataRestoreDPObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetDataRestoreDPObj

  !  
  !================================================================================================================================
  !   

  !>Restores the specified field variable parameter set local logical array that was obtained with an OPENCMISS::CMISSFieldParameterSetDataGet call for a field that is specified with an user number.
  SUBROUTINE CMISSFieldParameterSetDataRestoreLNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType,Parameters,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to restore the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the parameter set data to restore. \see OPENCMISS_FieldParameterSetTypes
    LOGICAL, INTENT(INOUT), POINTER :: Parameters(:) !<A pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetDataRestoreLNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FIELD,VariableType,FieldSetType,Parameters,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetDataRestoreLNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDataRestoreLNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetDataRestoreLNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetDataRestoreLNumber

  !  
  !================================================================================================================================
  !  
 
  !>>Restores the specified field variable parameter set local logical array that was obtained with an OPENCMISS::CMISSFieldParameterSetDataGet call for a field that is specified with an object.
  SUBROUTINE CMISSFieldParameterSetDataRestoreLObj(Field,VariableType,FieldSetType,Parameters,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to restore the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to restore the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the parameter set data to restore. \see OPENCMISS_FieldParameterSetTypes
    LOGICAL, INTENT(INOUT), POINTER :: Parameters(:) !<A pointer to the parameter set data to restore.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetDataRestoreLObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_DATA_RESTORE(Field%FIELD,VariableType,FieldSetType,Parameters,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetDataRestoreLObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDataRestoreLObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetDataRestoreLObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetDataRestoreLObj

  !  
  !================================================================================================================================
  !   

  !>Returns from the given parameter set an integer value for the specified constant of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetGetConstantIntgNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & ComponentNumber,VALUE,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the constant value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to get the constant value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetGetConstantIntgNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_CONSTANT(FIELD,VariableType,FieldSetType,ComponentNumber,Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetGetConstantIntgNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetConstantIntgNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetGetConstantIntgNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetGetConstantIntgNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns from the given parameter set an integer value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetGetConstantIntgObj(Field,VariableType,FieldSetType,ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the constant value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to get the constant value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetGetConstantIntgObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_GET_CONSTANT(Field%FIELD,VariableType,FieldSetType,ComponentNumber,Value,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetGetConstantIntgObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetConstantIntgObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetGetConstantIntgObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetGetConstantIntgObj

  !  
  !================================================================================================================================
  !   

  !>Returns from the given parameter set a single precision value for the specified constant of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetGetConstantSPNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the constant value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to get the constant value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    REAL(SP), INTENT(OUT) :: Value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetGetConstantSPNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_CONSTANT(FIELD,VariableType,FieldSetType,ComponentNumber,Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetGetConstantSPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetConstantSPNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetGetConstantSPNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetGetConstantSPNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns from the given parameter set a single precision value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetGetConstantSPObj(Field,VariableType,FieldSetType,ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the constant value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to get the constant value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    REAL(SP), INTENT(OUT) :: Value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetGetConstantSPObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_GET_CONSTANT(Field%FIELD,VariableType,FieldSetType,ComponentNumber,Value,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetGetConstantSPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetConstantSPObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetGetConstantSPObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetGetConstantSPObj

  !  
  !================================================================================================================================
  !   

  !>Returns from the given parameter set a double precision value for the specified constant of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetGetConstantDPNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the constant value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to get the constant value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    REAL(DP), INTENT(OUT) :: Value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetGetConstantDPNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_CONSTANT(FIELD,VariableType,FieldSetType,ComponentNumber,Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetGetConstantDPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetConstantDPNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetGetConstantDPNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetGetConstantDPNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns from the given parameter set a double precision value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetGetConstantDPObj(Field,VariableType,FieldSetType,ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the constant value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to get the constant value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    REAL(DP), INTENT(OUT) :: Value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetGetConstantDPObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_GET_CONSTANT(Field%FIELD,VariableType,FieldSetType,ComponentNumber,Value,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetGetConstantDPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetConstantDPObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetGetConstantDPObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetGetConstantDPObj

  !  
  !================================================================================================================================
  !   

  !>Returns from the given parameter set a logical value for the specified constant of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetGetConstantLNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the constant value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to get the constant value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    LOGICAL, INTENT(OUT) :: Value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetGetConstantLNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_CONSTANT(FIELD,VariableType,FieldSetType,ComponentNumber,Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetGetConstantLNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetConstantLNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetGetConstantLNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetGetConstantLNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns from the given parameter set a logical value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetGetConstantLObj(Field,VariableType,FieldSetType,ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the constant value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to get the constant value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    LOGICAL, INTENT(OUT) :: Value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetGetConstantLObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_GET_CONSTANT(Field%FIELD,VariableType,FieldSetType,ComponentNumber,Value,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetGetConstantLObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetConstantLObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetGetConstantLObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetGetConstantLObj

  !  
  !================================================================================================================================
  !   

  !>Returns from the given parameter set an integer value for the specified element of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetGetElementIntgNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & UserElementNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: UserElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetGetElementIntgNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_ELEMENT(FIELD,VariableType,FieldSetType,UserElementNumber,ComponentNumber,Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetGetElementIntgNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetElementIntgNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetGetElementIntgNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetGetElementIntgNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns from the given parameter set an integer value for the specified element of a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetGetElementIntgObj(Field,VariableType,FieldSetType,UserElementNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: UserElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetGetElementIntgObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_GET_ELEMENT(Field%FIELD,VariableType,FieldSetType,UserElementNumber,ComponentNumber,Value, &
      & Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetGetElementIntgObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetElementIntgObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetGetElementIntgObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetGetElementIntgObj

  !  
  !================================================================================================================================
  !   

  !>Returns from the given parameter set a single precision value for the specified element of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetGetElementSPNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & UserElementNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: UserElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to get the element value from the field parameter set.
    REAL(SP), INTENT(OUT) :: Value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetGetElementSPNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_ELEMENT(FIELD,VariableType,FieldSetType,UserElementNumber,ComponentNumber,Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetGetElementSPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetElementSPNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetGetElementSPNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetGetElementSPNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns from the given parameter set a single precision value for the specified element of a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetGetElementSPObj(Field,VariableType,FieldSetType,UserElementNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: UserElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to get the element value from the field parameter set.
    REAL(SP), INTENT(OUT) :: Value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetGetElementSPObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_GET_ELEMENT(Field%FIELD,VariableType,FieldSetType,UserElementNumber,ComponentNumber,VALUE, &
      & Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetGetElementSPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetElementSPObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetGetElementSPObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetGetElementSPObj

  !  
  !================================================================================================================================
  !   

  !>Returns from the given parameter set a double precision value for the specified element of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetGetElementDPNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & UserElementNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: UserElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to get the element value from the field parameter set.
    REAL(DP), INTENT(OUT) :: Value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetGetElementDPNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_ELEMENT(FIELD,VariableType,FieldSetType,UserElementNumber,ComponentNumber,Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetGetElementDPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetElementDPNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetGetElementDPNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetGetElementDPNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns from the given parameter set a double precision value for the specified element of a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetGetElementDPObj(Field,VariableType,FieldSetType,UserElementNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: UserElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to get the element value from the field parameter set.
    REAL(DP), INTENT(OUT) :: Value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetGetElementDPObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_GET_ELEMENT(Field%FIELD,VariableType,FieldSetType,UserElementNumber,ComponentNumber,Value, &
      & Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetGetElementDPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetElementDPObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetGetElementDPObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetGetElementDPObj

  !  
  !================================================================================================================================
  !   

  !>Returns from the given parameter set a logical value for the specified element of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetGetElementLNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & UserElementNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: UserElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to get the element value from the field parameter set.
    LOGICAL, INTENT(OUT) :: Value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetGetElementLNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_ELEMENT(FIELD,VariableType,FieldSetType,UserElementNumber,ComponentNumber,Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetGetElementLNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetElementLNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetGetElementLNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetGetElementLNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns from the given parameter set a logical value for the specified element of a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetGetElementLObj(Field,VariableType,FieldSetType,UserElementNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: UserElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to get the element value from the field parameter set.
    LOGICAL, INTENT(OUT) :: Value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetGetElementLObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_GET_ELEMENT(Field%FIELD,VariableType,FieldSetType,UserElementNumber,ComponentNumber,VALUE, &
      & Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetGetElementLObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetElementLObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetGetElementLObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetGetElementLObj

  !  
  !================================================================================================================================
  !   

  !>Returns from the given parameter set an integer value for the specified node and derivative of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetGetNodeIntgNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & DerivativeNumber,UserNodeNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the nodal value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to get the nodal value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: UserNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetGetNodeIntgNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_NODE(FIELD,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber,ComponentNumber, &
          & Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetGetNodeIntgNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetNodeIntgNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetGetNodeIntgNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetGetNodeIntgNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns from the given parameter set an integer value for the specified node and derivative of a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetGetNodeIntgObj(Field,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber, &
    & ComponentNumber,VALUE,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the nodal value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to get the nodal value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: UserNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetGetNodeIntgObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_GET_NODE(Field%FIELD,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber,ComponentNumber, &
      & Value,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetGetNodeIntgObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetNodeIntgObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetGetNodeIntgObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetGetNodeIntgObj

  !  
  !================================================================================================================================
  !   

  !>Returns from the given parameter set a single precision value for the specified node and derivative of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetGetNodeSPNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & DerivativeNumber,UserNodeNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the nodal value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to get the nodal value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: UserNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    REAL(SP), INTENT(OUT) :: Value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetGetNodeSPNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_NODE(FIELD,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber,ComponentNumber, &
          & Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetGetNodeSPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetNodeSPNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetGetNodeSPNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetGetNodeSPNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns from the given parameter set a single precision value for the specified node and derivative of a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetGetNodeSPObj(Field,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber, &
    & ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the nodal value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to get the nodal value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: UserNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    REAL(SP), INTENT(OUT) :: Value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetGetNodeSPObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_GET_NODE(Field%FIELD,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber,ComponentNumber, &
      & Value,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetGetNodeSPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetNodeSPObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetGetNodeSPObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetGetNodeSPObj

  !  
  !================================================================================================================================
  !   

  !>Returns from the given parameter set a double precision value for the specified node and derivative of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetGetNodeDPNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & DerivativeNumber,UserNodeNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the nodal value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to get the nodal value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: UserNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    REAL(DP), INTENT(OUT) :: Value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetGetNodeDPNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_NODE(FIELD,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber,ComponentNumber, &
          & Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetGetNodeDPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetNodeDPNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetGetNodeDPNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetGetNodeDPNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns from the given parameter set a double precision value for the specified node and derivative of a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetGetNodeDPObj(Field,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber, &
    & ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the nodal value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to get the nodal value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: UserNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    REAL(DP), INTENT(OUT) :: Value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetGetNodeDPObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_GET_NODE(Field%FIELD,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber,ComponentNumber, &
      & Value,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetGetNodeDPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetNodeDPObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetGetNodeDPObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetGetNodeDPObj

  !  
  !================================================================================================================================
  !   

  !>Returns from the given parameter set a logical value for the specified node and derivative of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetGetNodeLNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & DerivativeNumber,UserNodeNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the nodal value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to get the nodal value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: UserNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    LOGICAL, INTENT(OUT) :: Value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetGetNodeLNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_NODE(FIELD,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber,ComponentNumber, &
          & Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetGetNodeLNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetNodeLNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetGetNodeLNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetGetNodeLNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns from the given parameter set a logical value for the specified node and derivative of a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetGetNodeLObj(Field,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber, &
    & ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the nodal value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to get the nodal value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: UserNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    LOGICAL, INTENT(OUT) :: Value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetGetNodeLObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_GET_NODE(Field%FIELD,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber,ComponentNumber, &
      & Value,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetGetNodeLObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetNodeLObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetGetNodeLObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetGetNodeLObj

  !  
  !================================================================================================================================
  !   

  !>Updates the given parameter set with the given integer value for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetUpdateConstantIntgNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: Value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetUpdateConstantIntgNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(FIELD,VariableType,FieldSetType,ComponentNumber,Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetUpdateConstantIntgNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateConstantIntgNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetUpdateConstantIntgNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetUpdateConstantIntgNumber

  !  
  !================================================================================================================================
  !  
 
  !>Updates the given parameter set with the given integer value for the constant of the field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetUpdateConstantIntgObj(Field,VariableType,FieldSetType,ComponentNumber,VALUE,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: Value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetUpdateConstantIntgObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(Field%FIELD,VariableType,FieldSetType,ComponentNumber,Value,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetUpdateConstantIntgObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateConstantIntgObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetUpdateConstantIntgObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetUpdateConstantIntgObj

  !  
  !================================================================================================================================
  !   

  !>Updates the given parameter set with the given single precision value for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetUpdateConstantSPNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(SP), INTENT(IN) :: Value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetUpdateConstantSPNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(FIELD,VariableType,FieldSetType,ComponentNumber,Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetUpdateConstantSPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateConstantSPNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetUpdateConstantSPNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetUpdateConstantSPNumber

  !  
  !================================================================================================================================
  !  
 
  !>Updates the given parameter set with the given single precision value for the constant of the field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetUpdateConstantSPObj(Field,VariableType,FieldSetType,ComponentNumber,VALUE,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(SP), INTENT(IN) :: Value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetUpdateConstantSPObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(Field%FIELD,VariableType,FieldSetType,ComponentNumber,Value,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetUpdateConstantSPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateConstantSPObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetUpdateConstantSPObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetUpdateConstantSPObj

  !  
  !================================================================================================================================
  !   

  !>Updates the given parameter set with the given double precision value for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetUpdateConstantDPNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(DP), INTENT(IN) :: Value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetUpdateConstantDPNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(FIELD,VariableType,FieldSetType,ComponentNumber,Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetUpdateConstantDPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateConstantDPNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetUpdateConstantDPNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetUpdateConstantDPNumber

  !  
  !================================================================================================================================
  !  
 
  !>Updates the given parameter set with the given double precision value for the constant of the field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetUpdateConstantDPObj(Field,VariableType,FieldSetType,ComponentNumber,VALUE,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(DP), INTENT(IN) :: Value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetUpdateConstantDPObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(Field%FIELD,VariableType,FieldSetType,ComponentNumber,Value,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetUpdateConstantDPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateConstantDPObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetUpdateConstantDPObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetUpdateConstantDPObj

  !  
  !================================================================================================================================
  !   

  !>Updates the given parameter set with the given logical value for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetUpdateConstantLNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    LOGICAL, INTENT(IN) :: Value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetUpdateConstantLNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(FIELD,VariableType,FieldSetType,ComponentNumber,Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetUpdateConstantLNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateConstantLNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetUpdateConstantLNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetUpdateConstantLNumber

  !  
  !================================================================================================================================
  !  
 
  !>Updates the given parameter set with the given logical value for the constant of the field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetUpdateConstantLObj(Field,VariableType,FieldSetType,ComponentNumber,VALUE,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    LOGICAL, INTENT(IN) :: Value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetUpdateConstantLObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(Field%FIELD,VariableType,FieldSetType,ComponentNumber,Value,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetUpdateConstantLObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateConstantLObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetUpdateConstantLObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetUpdateConstantLObj

  !  
  !================================================================================================================================
  !   

  !>Updates the given parameter set with the given integer value for the element of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetUpdateElementIntgNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & UserElementNumber,ComponentNumber,VALUE,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to update the element value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to update the element value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: UserElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: Value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetUpdateElementIntgNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_ELEMENT(FIELD,VariableType,FieldSetType,userElementNumber,ComponentNumber,Value, &
          & Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetUpdateElementIntgNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateElementIntgNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetUpdateElementIntgNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetUpdateElementIntgNumber

  !  
  !================================================================================================================================
  !  
 
  !>Updates the given parameter set with the given integer value for the element of the field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetUpdateElementIntgObj(Field,VariableType,FieldSetType,UserElementNumber,ComponentNumber, &
    & Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: UserElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: Value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetUpdateElementIntgObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_UPDATE_ELEMENT(Field%FIELD,VariableType,FieldSetType,UserElementNumber,ComponentNumber,Value, &
      & Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetUpdateElementIntgObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateElementIntgObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetUpdateElementIntgObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetUpdateElementIntgObj

  !  
  !================================================================================================================================
  !   

  !>Updates the given parameter set with the given single precision value for the element of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetUpdateElementSPNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & UserElementNumber,ComponentNumber,VALUE,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to update the element value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to update the element value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: UserElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to update the element value for the field parameter set.
    REAL(SP), INTENT(IN) :: Value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetUpdateElementSPNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_ELEMENT(FIELD,VariableType,FieldSetType,userElementNumber,ComponentNumber,Value, &
          & Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetUpdateElementSPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateElementSPNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetUpdateElementSPNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetUpdateElementSPNumber

  !  
  !================================================================================================================================
  !  
 
  !>Updates the given parameter set with the given single precision value for the element of the field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetUpdateElementSPObj(Field,VariableType,FieldSetType,UserElementNumber,ComponentNumber, &
    & Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: UserElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(SP), INTENT(IN) :: Value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetUpdateElementSPObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_UPDATE_ELEMENT(Field%FIELD,VariableType,FieldSetType,UserElementNumber,ComponentNumber,Value, &
      & Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetUpdateElementSPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateElementSPObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetUpdateElementSPObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetUpdateElementSPObj

  !  
  !================================================================================================================================
  !   

  !>Updates the given parameter set with the given double precision value for the element of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetUpdateElementDPNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & UserElementNumber,ComponentNumber,VALUE,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to update the element value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to update the element value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: UserElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to update the element value for the field parameter set.
    REAL(DP), INTENT(IN) :: Value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetUpdateElementDPNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_ELEMENT(FIELD,VariableType,FieldSetType,userElementNumber,ComponentNumber,Value, &
          & Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetUpdateElementDPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateElementDPNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetUpdateElementDPNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetUpdateElementDPNumber

  !  
  !================================================================================================================================
  !  
 
  !>Updates the given parameter set with the given double precision value for the element of the field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetUpdateElementDPObj(Field,VariableType,FieldSetType,UserElementNumber,ComponentNumber, &
    & Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: UserElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(DP), INTENT(IN) :: VALUE !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetUpdateElementDPObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_UPDATE_ELEMENT(Field%FIELD,VariableType,FieldSetType,UserElementNumber,ComponentNumber,Value, &
      & Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetUpdateElementDPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateElementDPObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetUpdateElementDPObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetUpdateElementDPObj

  !  
  !================================================================================================================================
  !   

  !>Updates the given parameter set with the given logical value for the element of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetUpdateElementLNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & UserElementNumber,ComponentNumber,VALUE,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to update the element value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to update the element value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: UserElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to update the element value for the field parameter set.
    LOGICAL, INTENT(IN) :: Value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetUpdateElementLNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_ELEMENT(FIELD,VariableType,FieldSetType,userElementNumber,ComponentNumber,Value, &
          & Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetUpdateElementLNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateElementLNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetUpdateElementLNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetUpdateElementLNumber

  !  
  !================================================================================================================================
  !  
 
  !>Updates the given parameter set with the given logical value for the element of the field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetUpdateElementLObj(Field,VariableType,FieldSetType,UserElementNumber,ComponentNumber, &
    & Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: UserElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    LOGICAL, INTENT(IN) :: Value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetUpdateElementLObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_UPDATE_ELEMENT(Field%FIELD,VariableType,FieldSetType,UserElementNumber,ComponentNumber,Value, &
      & Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetUpdateElementLObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateElementLObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetUpdateElementLObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetUpdateElementLObj

  !  
  !================================================================================================================================
  !   

  !>Finishes the parameter set update for a field variable for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetUpdateFinishNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to finish the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to finish the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to finish the parameter set update for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type to finish the update for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetUpdateFinishNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_FINISH(FIELD,VariableType,FieldSetType,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetUpdateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateFinishNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetUpdateFinishNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetUpdateFinishNumber

  !  
  !================================================================================================================================
  !  
 
  !>Finishes the parameter set update for a field variable for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetUpdateFinishObj(Field,VariableType,FieldSetType,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to finishe the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to finish the parameter set update for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type to finish the update for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetUpdateFinishObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_UPDATE_FINISH(Field%FIELD,VariableType,FieldSetType,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetUpdateFinishObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateFinishObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetUpdateFinishObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetUpdateFinishObj

  !  
  !================================================================================================================================
  !   

  !>Updates the given parameter set with the given integer value for the node and derivative of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetUpdateNodeIntgNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & DerivativeNumber,UserNodeNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to update the nodal value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to update the nodal value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: UserNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: Value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetUpdateNodeIntgNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_NODE(FIELD,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber,ComponentNumber, &
          & Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetUpdateNodeIntgNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateNodeIntgNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetUpdateNodeIntgNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetUpdateNodeIntgNumber

  !  
  !================================================================================================================================
  !  
 
  !>Updates the given parameter set with the given integer value for the node and derivative of the field variable component for a field identified by an object.

  SUBROUTINE CMISSFieldParameterSetUpdateNodeIntgObj(Field,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber, &
    & ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to update the nodal value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to update the nodal value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: UserNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: Value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetUpdateNodeIntgObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_UPDATE_NODE(Field%FIELD,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber,ComponentNumber, &
      & Value,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetUpdateNodeIntgObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateNodeIntgObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetUpdateNodeIntgObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetUpdateNodeIntgObj

  !  
  !================================================================================================================================
  !   

  !>Updates the given parameter set with the given single precision value for the node and derivative of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetUpdateNodeSPNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & DerivativeNumber,UserNodeNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to update the nodal value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to update the nodal value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: UserNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    REAL(SP), INTENT(IN) :: Value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetUpdateNodeSPNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_NODE(FIELD,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber,ComponentNumber, &
          & Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetUpdateNodeSPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateNodeSPNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetUpdateNodeSPNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetUpdateNodeSPNumber

  !  
  !================================================================================================================================
  !  
 
  !>Updates the given parameter set with the given single precision value for the node and derivative of the field variable component for a field identified by an object.

  SUBROUTINE CMISSFieldParameterSetUpdateNodeSPObj(Field,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber, &
    & ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to update the nodal value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to update the nodal value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: UserNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    REAL(SP), INTENT(IN) :: Value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetUpdateNodeSPObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_UPDATE_NODE(Field%FIELD,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber,ComponentNumber, &
      & Value,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetUpdateNodeSPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateNodeSPObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetUpdateNodeSPObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetUpdateNodeSPObj

  !  
  !================================================================================================================================
  !   

  !>Updates the given parameter set with the given double precision value for the node and derivative of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetUpdateNodeDPNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & DerivativeNumber,UserNodeNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to update the nodal value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to update the nodal value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: UserNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    REAL(DP), INTENT(IN) :: Value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetUpdateNodeDPNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_NODE(FIELD,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber,ComponentNumber, &
          & Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetUpdateNodeDPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateNodeDPNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetUpdateNodeDPNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetUpdateNodeDPNumber

  !  
  !================================================================================================================================
  !  
 
  !>Updates the given parameter set with the given double precision value for the node and derivative of the field variable component for a field identified by an object.

  SUBROUTINE CMISSFieldParameterSetUpdateNodeDPObj(Field,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber, &
    & ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to update the nodal value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to update the nodal value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: UserNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    REAL(DP), INTENT(IN) :: Value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetUpdateNodeDPObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_UPDATE_NODE(Field%FIELD,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber,ComponentNumber, &
      & Value,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetUpdateNodeDPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateNodeDPObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetUpdateNodeDPObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetUpdateNodeDPObj

  !  
  !================================================================================================================================
  !   

  !>Updates the given parameter set with the given logical value for the node and derivative of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetUpdateNodeLNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType, &
    & DerivativeNumber,UserNodeNumber,ComponentNumber,Value,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to update the nodal value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to update the nodal value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: UserNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    LOGICAL, INTENT(IN) :: Value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetUpdateNodeLNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_NODE(FIELD,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber,ComponentNumber, &
          & Value,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetUpdateNodeLNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateNodeLNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetUpdateNodeLNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetUpdateNodeLNumber

  !  
  !================================================================================================================================
  !  
 
  !>Updates the given parameter set with the given logical value for the node and derivative of the field variable component for a field identified by an object.

  SUBROUTINE CMISSFieldParameterSetUpdateNodeLObj(Field,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber, &
    & ComponentNumber,Value,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to update the nodal value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type of the field to update the nodal value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: DerivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: UserNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: ComponentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    LOGICAL, INTENT(IN) :: Value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetUpdateNodeLObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_UPDATE_NODE(Field%FIELD,VariableType,FieldSetType,DerivativeNumber,UserNodeNumber,ComponentNumber, &
      & Value,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetUpdateNodeLObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateNodeLObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetUpdateNodeLObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetUpdateNodeLObj

  !  
  !================================================================================================================================
  !   

  !>Starts the parameter set update for a field variable for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetUpdateStartNumber(RegionUserNumber,FieldUserNumber,VariableType,FieldSetType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to start the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to start the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to start the parameter set update for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type to start the update for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldParameterSetUpdateStartNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_START(FIELD,VariableType,FieldSetType,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetUpdateStartNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateStartNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetUpdateStartNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetUpdateStartNumber

  !  
  !================================================================================================================================
  !  
 
  !>Starts the parameter set update for a field variable for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetUpdateStartObj(Field,VariableType,FieldSetType,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to start the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to start the parameter set update for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: FieldSetType !<The parameter set type to start the update for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldParameterSetUpdateStartObj",Err,ERROR,*999)
 
    CALL FIELD_PARAMETER_SET_UPDATE_START(Field%FIELD,VariableType,FieldSetType,Err,ERROR,*999)

    CALL EXITS("CMISSFieldParameterSetUpdateStartObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateStartObj",Err,ERROR)
    CALL EXITS("CMISSFieldParameterSetUpdateStartObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldParameterSetUpdateStartObj

  !  
  !================================================================================================================================
  !   

  !>Copy the parameters from the parameter set of a component of a field variable to the paramters of a parameter set of
  !>a component of another field variable, where both fields are identified by user numbers.
  SUBROUTINE CMISSFieldParametersToFieldParametersComponentCopyNumber(FromRegionUserNumber,FromFieldUserNumber,FromVariableType, &
      & FromParameterSetType, FromComponentNumber,ToRegionUserNumber,ToFieldUserNumber,ToVariableType,ToParameterSetType, &
      & ToComponentNumber,Err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: FromRegionUserNumber !<The user number of the region containing the field to copy from
    INTEGER(INTG), INTENT(IN) :: FromFieldUserNumber !<The field to copy from
    INTEGER(INTG), INTENT(IN) :: FromVariableType !<The field variable type to copy from
    INTEGER(INTG), INTENT(IN) :: FromParameterSetType !<The field parameter set type to copy from
    INTEGER(INTG), INTENT(IN) :: FromComponentNumber !<The field variable component number to copy from
    INTEGER(INTG), INTENT(IN) :: ToRegionUserNumber !<The user number of the region containing the field to copy to
    INTEGER(INTG), INTENT(IN) :: ToFieldUserNumber !<The field to copy to
    INTEGER(INTG), INTENT(IN) :: ToVariableType !<The field variable type to copy to
    INTEGER(INTG), INTENT(IN) :: ToParameterSetType !<The parameter set type to copy to
    INTEGER(INTG), INTENT(IN) :: ToComponentNumber !<The field variable component to copy to
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code
    !Local variables
    TYPE(REGION_TYPE), POINTER :: FROM_REGION
    TYPE(FIELD_TYPE), POINTER :: FROM_FIELD
    TYPE(REGION_TYPE), POINTER :: TO_REGION
    TYPE(FIELD_TYPE), POINTER :: TO_FIELD
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParametersToFieldParametersComponentCopyNumber",Err,ERROR,*999)

    NULLIFY(FROM_REGION)
    NULLIFY(FROM_FIELD)
    NULLIFY(TO_REGION)
    NULLIFY(TO_FIELD)
    CALL REGION_USER_NUMBER_FIND(FromRegionUserNumber,FROM_REGION,Err,ERROR,*999)
    IF(ASSOCIATED(FROM_REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FromFieldUserNumber,FROM_REGION,FROM_FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FROM_FIELD)) THEN
        CALL REGION_USER_NUMBER_FIND(ToRegionUserNumber,TO_REGION,Err,ERROR,*999)
        IF(ASSOCIATED(TO_REGION)) THEN
          CALL FIELD_USER_NUMBER_FIND(ToFieldUserNumber,TO_REGION,TO_FIELD,Err,ERROR,*999)
          IF(ASSOCIATED(TO_FIELD)) THEN
            CALL FIELD_PARAMETERS_TO_FIELD_PARAMETERS_COMPONENT_COPY(FROM_FIELD,FromVariableType,FromParameterSetType, &
              & FromComponentNumber,TO_FIELD,ToVariableType,ToParameterSetType,ToComponentNumber,Err,ERROR,*999)
          ELSE
            LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(ToFieldUserNumber,"*",Err,ERROR))// &
              & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(ToRegionUserNumber,"*",Err,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(ToRegionUserNumber,"*",Err,ERROR))// &
            & " does not exist."
          CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FromFieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(FromRegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(FromRegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    RETURN
999 CALL ERRORS("CMISSFieldParametersToFieldParametersComponentCopyNumber",Err,ERROR)
    CALL EXITS("CMISSFieldParametersToFieldParametersComponentCopyNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
  
  END SUBROUTINE CMISSFieldParametersToFieldParametersComponentCopyNumber

  !  
  !================================================================================================================================
  !   

  !>Copy the parameters from the parameter set of a component of a field variable to the paramters of a parameter set of
  !>a component of another field variable, where both fields are objects.
  SUBROUTINE CMISSFieldParametersToFieldParametersComponentCopyObj(FromField,FromVariableType,FromParameterSetType, &
    & FromComponentNumber,ToField,ToVariableType,ToParameterSetType,ToComponentNumber,Err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: FromField !<The field to copy from
    INTEGER(INTG), INTENT(IN) :: FromVariableType !<The field variable type to copy from
    INTEGER(INTG), INTENT(IN) :: FromParameterSetType !<The field parameter set type to copy from
    INTEGER(INTG), INTENT(IN) :: FromComponentNumber !<The field variable component number to copy from
    TYPE(CMISSFieldType), INTENT(IN) :: ToField !<The field to copy to
    INTEGER(INTG), INTENT(IN) :: ToVariableType !<The field variable type to copy to
    INTEGER(INTG), INTENT(IN) :: ToParameterSetType !<The parameter set type to copy to
    INTEGER(INTG), INTENT(IN) :: ToComponentNumber !<The field variable component to copy to
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code
    !Local variables

    CALL ENTERS("CMISSFieldParametersToFieldParametersComponentCopyObj",Err,ERROR,*999)

    CALL FIELD_PARAMETERS_TO_FIELD_PARAMETERS_COMPONENT_COPY(FromField%FIELD,FromVariableType,FromParameterSetType, &
      & FromComponentNumber,ToField%FIELD,ToVariableType,ToParameterSetType,ToComponentNumber,Err,ERROR,*999)

    RETURN
999 CALL ERRORS("CMISSFieldParametersToFieldParametersComponentCopyObj",Err,ERROR)
    CALL EXITS("CMISSFieldParametersToFieldParametersComponentCopyObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
  
  END SUBROUTINE CMISSFieldParametersToFieldParametersComponentCopyObj

  !  
  !================================================================================================================================
  !   

  !>Returns the scaling type for a field identified by a user number.
  SUBROUTINE CMISSFieldScalingTypeGetNumber(RegionUserNumber,FieldUserNumber,ScalingType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the scaling type for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the scaling type for.
    INTEGER(INTG), INTENT(OUT) :: ScalingType !<On return, the field scaling type. \see OPENCMISS_FieldScalingTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldScalingTypeGetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_SCALING_TYPE_GET(FIELD,ScalingType,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldScalingTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldScalingTypeGetNumber",Err,ERROR)
    CALL EXITS("CMISSFieldScalingTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldScalingTypeGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the scaling type for a field identified by an object.
  SUBROUTINE CMISSFieldScalingTypeGetObj(Field,ScalingType,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the scaling type for.
    INTEGER(INTG), INTENT(OUT) :: ScalingType !<On return, the field scaling type. \see OPENCMISS_FieldScalingTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldScalingTypeGetObj",Err,ERROR,*999)
 
    CALL FIELD_SCALING_TYPE_GET(Field%FIELD,ScalingType,Err,ERROR,*999)

    CALL EXITS("CMISSFieldScalingTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSFieldScalingTypeGetObj",Err,ERROR)
    CALL EXITS("CMISSFieldScalingTypeGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldScalingTypeGetObj

  !  
  !================================================================================================================================
  !   

  !>Sets/changes the scaling type for a field identified by a user number.
  SUBROUTINE CMISSFieldScalingTypeSetNumber(RegionUserNumber,FieldUserNumber,ScalingType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to set the scaling type for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to set the scaling type for.
    INTEGER(INTG), INTENT(IN) :: ScalingType !<The field scaling type to set. \see OPENCMISS_FieldScalingTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldScalingTypeSetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_SCALING_TYPE_SET(FIELD,ScalingType,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldScalingTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldScalingTypeSetNumber",Err,ERROR)
    CALL EXITS("CMISSFieldScalingTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldScalingTypeSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the scaling type for a field identified by an object.
  SUBROUTINE CMISSFieldScalingTypeSetObj(Field,ScalingType,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to set the scaling type for.
    INTEGER(INTG), INTENT(IN) :: ScalingType !<The field scaling type to set. \see OPENCMISS_FieldScalingTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldScalingTypeSetObj",Err,ERROR,*999)
 
    CALL FIELD_SCALING_TYPE_SET(Field%FIELD,ScalingType,Err,ERROR,*999)

    CALL EXITS("CMISSFieldScalingTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSFieldScalingTypeSetObj",Err,ERROR)
    CALL EXITS("CMISSFieldScalingTypeSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldScalingTypeSetObj

  !  
  !================================================================================================================================
  !   

  !>Returns the field type for a field identified by a user number.
  SUBROUTINE CMISSFieldTypeGetNumber(RegionUserNumber,FieldUserNumber,FieldType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the field type for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the field type for.
    INTEGER(INTG), INTENT(OUT) :: FieldType !<On return, the field type. \see OPENCMISS_FieldTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldTypeGetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_TYPE_GET(FIELD,FieldType,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldTypeGetNumber",Err,ERROR)
    CALL EXITS("CMISSFieldTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldTypeGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the type for a field identified by an object.
  SUBROUTINE CMISSFieldTypeGetObj(Field,FieldType,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the field type for.
    INTEGER(INTG), INTENT(OUT) :: FieldType !<On return, the field type. \see OPENCMISS_FieldTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldTypeGetObj",Err,ERROR,*999)
 
    CALL FIELD_TYPE_GET(Field%FIELD,FieldType,Err,ERROR,*999)

    CALL EXITS("CMISSFieldTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSFieldTypeGetObj",Err,ERROR)
    CALL EXITS("CMISSFieldTypeGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldTypeGetObj

  !  
  !================================================================================================================================
  !   

  !>Sets/changes the field type for a field identified by a user number.
  SUBROUTINE CMISSFieldTypeSetNumber(RegionUserNumber,FieldUserNumber,FieldType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to set the field type for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to set the field type for.
    INTEGER(INTG), INTENT(IN) :: FieldType !<The field type to set. \see OPENCMISS_FieldTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldTypeSetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_TYPE_SET(FIELD,FieldType,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldTypeSetNumber",Err,ERROR)
    CALL EXITS("CMISSFieldTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldTypeSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the type for a field identified by an object.
  SUBROUTINE CMISSFieldTypeSetObj(Field,FieldType,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to set the field type for.
    INTEGER(INTG), INTENT(IN) :: FieldType !<The field type to set. \see OPENCMISS_FieldTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldTypeSetObj",Err,ERROR,*999)
 
    CALL FIELD_TYPE_SET(Field%FIELD,FieldType,Err,ERROR,*999)

    CALL EXITS("CMISSFieldTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSFieldTypeSetObj",Err,ERROR)
    CALL EXITS("CMISSFieldTypeSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldTypeSetObj

  !  
  !================================================================================================================================
  !  

  !>Returns the character string label for a field variable for a field identified by a user number.
  SUBROUTINE CMISSFieldVariableLabelGetCNumber(RegionUserNumber,FieldUserNumber,VariableType,Label,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the field variable label \see OPENCMISS_FieldVariableTypes
    CHARACTER(LEN=*), INTENT(OUT) :: Label !<On return, the field variable label.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldVariableLabelGetCNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_VARIABLE_LABEL_GET(FIELD,VariableType,Label,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldVariableLabelGetCNumber")
    RETURN
999 CALL ERRORS("CMISSFieldVariableLabelGetCNumber",Err,ERROR)
    CALL EXITS("CMISSFieldVariableLabelGetCNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldVariableLabelGetCNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the character string label for a field variable for a field identified by an object.
  SUBROUTINE CMISSFieldVariableLabelGetCObj(Field,VariableType,Label,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the label for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the field variable label \see OPENCMISS_FieldVariableTypes
    CHARACTER(LEN=*), INTENT(OUT) :: Label !<On return, the field variable label.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldVariableLabelGetCObj",Err,ERROR,*999)
 
    CALL FIELD_VARIABLE_LABEL_GET(Field%FIELD,VariableType,Label,Err,ERROR,*999)

    CALL EXITS("CMISSFieldVariableLabelGetCObj")
    RETURN
999 CALL ERRORS("CMISSFieldVariableLabelGetCObj",Err,ERROR)
    CALL EXITS("CMISSFieldVariableLabelGetCObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldVariableLabelGetCObj

  !  
  !================================================================================================================================
  !  

  !>Returns the varying string label for a field variable for a field identified by a user number.
  SUBROUTINE CMISSFieldVariableLabelGetVSNumber(RegionUserNumber,FieldUserNumber,VariableType,Label,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the field variable label \see OPENCMISS_FieldVariableTypes
    TYPE(VARYING_STRING), INTENT(OUT) :: Label !<On return, the field variable label.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldVariableLabelGetVSNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_VARIABLE_LABEL_GET(FIELD,VariableType,Label,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldVariableLabelGetVSNumber")
    RETURN
999 CALL ERRORS("CMISSFieldVariableLabelGetVSNumber",Err,ERROR)
    CALL EXITS("CMISSFieldVariableLabelGetVSNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldVariableLabelGetVSNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the varying string label for a field variable for a field identified by an object.
  SUBROUTINE CMISSFieldVariableLabelGetVSObj(Field,VariableType,Label,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the label for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to get the field variable label \see OPENCMISS_FieldVariableTypes
    TYPE(VARYING_STRING), INTENT(OUT) :: Label !<On return, the field variable label.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldVariableLabelGetVSObj",Err,ERROR,*999)
 
    CALL FIELD_VARIABLE_LABEL_GET(Field%FIELD,VariableType,Label,Err,ERROR,*999)

    CALL EXITS("CMISSFieldVariableLabelGetVSObj")
    RETURN
999 CALL ERRORS("CMISSFieldVariableLabelGetVSObj",Err,ERROR)
    CALL EXITS("CMISSFieldVariableLabelGetVSObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldVariableLabelGetVSObj

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the character string label for a field variable for a field identified by a user number.
  SUBROUTINE CMISSFieldVariableLabelSetCNumber(RegionUserNumber,FieldUserNumber,VariableType,Label,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to set the field variable label \see OPENCMISS_FieldVariableTypes
    CHARACTER(LEN=*), INTENT(IN) :: Label !<The field variable label to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldVariableLabelSetCNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_VARIABLE_LABEL_SET(FIELD,VariableType,Label,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldVariableLabelSetCNumber")
    RETURN
999 CALL ERRORS("CMISSFieldVariableLabelSetCNumber",Err,ERROR)
    CALL EXITS("CMISSFieldVariableLabelSetCNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldVariableLabelSetCNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the character string label for a field variable for a field identified by an object.
  SUBROUTINE CMISSFieldVariableLabelSetCObj(Field,VariableType,Label,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to set the label for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to set the field variable label \see OPENCMISS_FieldVariableTypes
    CHARACTER(LEN=*), INTENT(IN) :: Label !<The field variable label to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldVariableLabelSetCObj",Err,ERROR,*999)
 
    CALL FIELD_VARIABLE_LABEL_SET(Field%FIELD,VariableType,Label,Err,ERROR,*999)

    CALL EXITS("CMISSFieldVariableLabelSetCObj")
    RETURN
999 CALL ERRORS("CMISSFieldVariableLabelSetCObj",Err,ERROR)
    CALL EXITS("CMISSFieldVariableLabelSetCObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldVariableLabelSetCObj

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the varying string label for a field variable for a field identified by a user number.
  SUBROUTINE CMISSFieldVariableLabelSetVSNumber(RegionUserNumber,FieldUserNumber,VariableType,Label,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to set the field variable label \see OPENCMISS_FieldVariableTypes
    TYPE(VARYING_STRING), INTENT(IN) :: Label !<The field variable label to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldVariableLabelSetVSNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_VARIABLE_LABEL_SET(FIELD,VariableType,Label,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldVariableLabelSetVSNumber")
    RETURN
999 CALL ERRORS("CMISSFieldVariableLabelSetVSNumber",Err,ERROR)
    CALL EXITS("CMISSFieldVariableLabelSetVSNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldVariableLabelSetVSNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the varying string label for a field variable for a field identified by an object.
  SUBROUTINE CMISSFieldVariableLabelSetVSObj(Field,VariableType,Label,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to set the label for.
    INTEGER(INTG), INTENT(IN) :: VariableType !<The variable type of the field to set the field variable label \see OPENCMISS_FieldVariableTypes
    TYPE(VARYING_STRING), INTENT(IN) :: Label !<The field variable label to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldVariableLabelSetVSObj",Err,ERROR,*999)
 
    CALL FIELD_VARIABLE_LABEL_SET(Field%FIELD,VariableType,Label,Err,ERROR,*999)

    CALL EXITS("CMISSFieldVariableLabelSetVSObj")
    RETURN
999 CALL ERRORS("CMISSFieldVariableLabelSetVSObj",Err,ERROR)
    CALL EXITS("CMISSFieldVariableLabelSetVSObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldVariableLabelSetVSObj

  !  
  !================================================================================================================================
  !   

  !>Returns the field variable types for a field identified by a user number.
  SUBROUTINE CMISSFieldVariableTypesGetNumber(RegionUserNumber,FieldUserNumber,VariableTypes,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to get the field variable types for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to get the field variable types for.
    INTEGER(INTG), INTENT(OUT) :: VariableTypes(:) !<VariableTypes(variable_idx). On return, the field variable types for the variable_idx'th field variable. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldVariableTypesGetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_VARIABLE_TYPES_GET(FIELD,VariableTypes,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldVariableTypesGetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldVariableTypesGetNumber",Err,ERROR)
    CALL EXITS("CMISSFieldVariableTypesGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldVariableTypesGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the variable types for a field identified by an object.
  SUBROUTINE CMISSFieldVariableTypesGetObj(Field,VariableTypes,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to get the field variable types for.
    INTEGER(INTG), INTENT(OUT) :: VariableTypes(:) !<VariableTypes(variable_idx). On return, the field variable types for the variable_idx'th field variable. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldVariableTypesGetObj",Err,ERROR,*999)
 
    CALL FIELD_VARIABLE_TYPES_GET(Field%FIELD,VariableTypes,Err,ERROR,*999)

    CALL EXITS("CMISSFieldVariableTypesGetObj")
    RETURN
999 CALL ERRORS("CMISSFieldVariableTypesGetObj",Err,ERROR)
    CALL EXITS("CMISSFieldVariableTypesGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldVariableTypesGetObj

  !  
  !================================================================================================================================
  !   

  !>Sets/changes the field variable types for a field identified by a user number.
  SUBROUTINE CMISSFieldVariableTypesSetNumber(RegionUserNumber,FieldUserNumber,VariableTypes,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to set the field variable types for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to set the field variable types for.
    INTEGER(INTG), INTENT(IN) :: VariableTypes(:) !<VariableTypes(variable_idx). The field variable types for the variable_idx'th field variable to set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSFieldVariableTypesSetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_VARIABLE_TYPES_SET(FIELD,VariableTypes,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSFieldVariableTypesSetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldVariableTypesSetNumber",Err,ERROR)
    CALL EXITS("CMISSFieldVariableTypesSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldVariableTypesSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the variable types for a field identified by an object.
  SUBROUTINE CMISSFieldVariableTypesSetObj(Field,VariableTypes,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: Field !<The field to set the field variable types for.
    INTEGER(INTG), INTENT(IN) :: VariableTypes(:) !<VariableTypes(variable_idx). The field variable types for the variable_idx'th field variable to set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldVariableTypesSetObj",Err,ERROR,*999)
 
    CALL FIELD_VARIABLE_TYPES_SET(Field%FIELD,VariableTypes,Err,ERROR,*999)

    CALL EXITS("CMISSFieldVariableTypesSetObj")
    RETURN
999 CALL ERRORS("CMISSFieldVariableTypesSetObj",Err,ERROR)
    CALL EXITS("CMISSFieldVariableTypesSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldVariableTypesSetObj

!!==================================================================================================================================
!!
!! FIELD_IO_ROUTINES
!!
!!==================================================================================================================================

  !>Export element information for fields set identified by an object. \todo number method
  SUBROUTINE CMISSFieldIOElementsExportCCObj(Fields,FileName,Method,Err)
  
    !Argument variables
    TYPE(CMISSFieldsType), INTENT(INOUT) :: Fields !<The fields to export the elements for.
    CHARACTER(LEN=*), INTENT(IN) :: FileName !<The file name to export the elements to
    CHARACTER(LEN=*), INTENT(IN):: Method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldIOElementsExportCCObj",Err,ERROR,*999)
 
    CALL FIELD_IO_ELEMENTS_EXPORT(Fields%FIELDS,VAR_STR(FileName),VAR_STR(Method),Err,ERROR,*999)

    CALL EXITS("CMISSFieldIOElementsExportCCObj")
    RETURN
999 CALL ERRORS("CMISSFieldIOElementsExportCCObj",Err,ERROR)
    CALL EXITS("CMISSFieldIOElementsExportCCObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldIOElementsExportCCObj

  !  
  !================================================================================================================================
  !  


  !>Export element information for fields set identified by an object. \todo number method
  SUBROUTINE CMISSFieldIOElementsExportVSCObj(Fields,FileName,Method,Err)
  
    !Argument variables
    TYPE(CMISSFieldsType), INTENT(INOUT) :: Fields !<The fields to export the elements for.
    TYPE(VARYING_STRING), INTENT(IN) :: FileName !<The file name to export the elements to
    CHARACTER(LEN=*), INTENT(IN):: Method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldIOElementsExportVSCObj",Err,ERROR,*999)
 
    CALL FIELD_IO_ELEMENTS_EXPORT(Fields%FIELDS,FileName,VAR_STR(Method),Err,ERROR,*999)

    CALL EXITS("CMISSFieldIOElementsExportVSCObj")
    RETURN
999 CALL ERRORS("CMISSFieldIOElementsExportVSCObj",Err,ERROR)
    CALL EXITS("CMISSFieldIOElementsExportVSCObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldIOElementsExportVSCObj

  !  
  !================================================================================================================================
  !  


  !>Export element information for fields set identified by an object. \todo number method
  SUBROUTINE CMISSFieldIOElementsExportCVSObj(Fields,FileName,Method,Err)
  
    !Argument variables
    TYPE(CMISSFieldsType), INTENT(INOUT) :: Fields !<The fields to export the elements for.
    CHARACTER(LEN=*), INTENT(IN) :: FileName !<The file name to export the elements to
    TYPE(VARYING_STRING), INTENT(IN):: Method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldIOElementsExportCVSObj",Err,ERROR,*999)
 
    CALL FIELD_IO_ELEMENTS_EXPORT(Fields%FIELDS,VAR_STR(FileName),Method,Err,ERROR,*999)

    CALL EXITS("CMISSFieldIOElementsExportCVSObj")
    RETURN
999 CALL ERRORS("CMISSFieldIOElementsExportCVSObj",Err,ERROR)
    CALL EXITS("CMISSFieldIOElementsExportCVSObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldIOElementsExportCVSObj

  !  
  !================================================================================================================================
  !  

  !>Export element information for fields set identified by an object. \todo number method
  SUBROUTINE CMISSFieldIOElementsExportVSVSObj(Fields,FileName,Method,Err)
  
    !Argument variables
    TYPE(CMISSFieldsType), INTENT(INOUT) :: Fields !<The fields to export the elements for.
    TYPE(VARYING_STRING), INTENT(IN) :: FileName !<The file name to export the elements to
    TYPE(VARYING_STRING), INTENT(IN):: Method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldIOElementsExportVSVSObj",Err,ERROR,*999)
 
    CALL FIELD_IO_ELEMENTS_EXPORT(Fields%FIELDS,FileName,Method,Err,ERROR,*999)

    CALL EXITS("CMISSFieldIOElementsExportVSVSObj")
    RETURN
999 CALL ERRORS("CMISSFieldIOElementsExportVSObj",Err,ERROR)
    CALL EXITS("CMISSFieldIOElementsExportVSObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldIOElementsExportVSVSObj

  !  
  !================================================================================================================================
  !  

  !>Export nodal information for fields set identified by an object. \todo number method
  SUBROUTINE CMISSFieldIONodesExportCCObj(Fields,FileName,Method,Err)
  
    !Argument variables
    TYPE(CMISSFieldsType), INTENT(INOUT) :: Fields !<The fields to export the nodes for.
    CHARACTER(LEN=*), INTENT(IN) :: FileName !<The file name to export the nodes to
    CHARACTER(LEN=*), INTENT(IN):: Method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldIONodesExportCCObj",Err,ERROR,*999)
 
    CALL FIELD_IO_NODES_EXPORT(Fields%FIELDS,VAR_STR(FileName),VAR_STR(Method),Err,ERROR,*999)

    CALL EXITS("CMISSFieldIONodesExportCCObj")
    RETURN
999 CALL ERRORS("CMISSFieldIONodesExportCCObj",Err,ERROR)
    CALL EXITS("CMISSFieldIONodesExportCCObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldIONodesExportCCObj

  !  
  !================================================================================================================================
  !  

  !>Export nodal information for fields set identified by an object. \todo number method
  SUBROUTINE CMISSFieldIONodesExportVSCObj(Fields,FileName,Method,Err)
  
    !Argument variables
    TYPE(CMISSFieldsType), INTENT(INOUT) :: Fields !<The fields to export the nodes for.
    TYPE(VARYING_STRING), INTENT(IN) :: FileName !<The file name to export the nodes to
    CHARACTER(LEN=*), INTENT(IN):: Method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldIONodesExportVSCObj",Err,ERROR,*999)
 
    CALL FIELD_IO_NODES_EXPORT(Fields%FIELDS,FileName,VAR_STR(Method),Err,ERROR,*999)

    CALL EXITS("CMISSFieldIONodesExportVSCObj")
    RETURN
999 CALL ERRORS("CMISSFieldIONodesExportVSCObj",Err,ERROR)
    CALL EXITS("CMISSFieldIONodesExportVSCObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldIONodesExportVSCObj

  !  
  !================================================================================================================================
  !  

  !>Export nodal information for fields set identified by an object. \todo number method
  SUBROUTINE CMISSFieldIONodesExportCVSObj(Fields,FileName,Method,Err)
  
    !Argument variables
    TYPE(CMISSFieldsType), INTENT(INOUT) :: Fields !<The fields to export the nodes for.
    CHARACTER(LEN=*), INTENT(IN) :: FileName !<The file name to export the nodes to
    TYPE(VARYING_STRING), INTENT(IN):: Method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldIONodesExportCVSObj",Err,ERROR,*999)
 
    CALL FIELD_IO_NODES_EXPORT(Fields%FIELDS,VAR_STR(FileName),Method,Err,ERROR,*999)

    CALL EXITS("CMISSFieldIONodesExportCVSObj")
    RETURN
999 CALL ERRORS("CMISSFieldIONodesExportCVSObj",Err,ERROR)
    CALL EXITS("CMISSFieldIONodesExportCVSObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldIONodesExportCVSObj

  !  
  !================================================================================================================================
  !  
 
  !>Export nodal information for fields set identified by an object. \todo number method
  SUBROUTINE CMISSFieldIONodesExportVSVSObj(Fields,FileName,Method,Err)
  
    !Argument variables
    TYPE(CMISSFieldsType), INTENT(INOUT) :: Fields !<The fields to export the nodes for.
    TYPE(VARYING_STRING), INTENT(IN) :: FileName !<The file name to export the nodes to
    TYPE(VARYING_STRING), INTENT(IN):: Method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSFieldIONodesExportVSVSObj",Err,ERROR,*999)
 
    CALL FIELD_IO_NODES_EXPORT(Fields%FIELDS,FileName,Method,Err,ERROR,*999)

    CALL EXITS("CMISSFieldIONodesExportVSVSObj")
    RETURN
999 CALL ERRORS("CMISSFieldIONodesExportVSVSObj",Err,ERROR)
    CALL EXITS("CMISSFieldIONodesExportVSVSObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSFieldIONodesExportVSVSObj

!!==================================================================================================================================
!!
!! GENERATED_MESH_ROUTINES
!!
!!==================================================================================================================================

  !>Returns the basis for a generated mesh identified by a user number.
  SUBROUTINE CMISSGeneratedMeshBasisGetNumber(GeneratedMeshUserNumber,BasisUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: GeneratedMeshUserNumber !<The user number of the generated mesh to get the basis for.
    INTEGER(INTG), INTENT(OUT) :: BasisUserNumber !<On return, the user number of the basis.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSGeneratedMeshBasisGetNumber",Err,ERROR,*999)
 
    NULLIFY(GENERATED_MESH)
    NULLIFY(BASIS)
    CALL GENERATED_MESH_USER_NUMBER_FIND(GeneratedMeshUserNumber,GENERATED_MESH,Err,ERROR,*999)
    IF(ASSOCIATED(GENERATED_MESH)) THEN
      CALL GENERATED_MESH_BASIS_GET(GENERATED_MESH,BASIS,Err,ERROR,*999)
      IF(ASSOCIATED(BASIS)) THEN
        BasisUserNumber=BASIS%USER_NUMBER
      ELSE
        LOCAL_ERROR="The basis is not associated for the generated mesh with a user number of "// &
          & TRIM(NUMBER_TO_VSTRING(GeneratedMeshUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(GeneratedMeshUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSGeneratedMeshBasisGetNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshBasisGetNumber",Err,ERROR)
    CALL EXITS("CMISSGeneratedMeshBasisGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSGeneratedMeshBasisGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the basis for a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshBasisGetObj(GeneratedMesh,Basis,Err)
  
    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: GeneratedMesh !<The generated mesh to get the basis for.
    TYPE(CMISSBasisType), INTENT(INOUT) :: Basis !<On return, the basis.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSGeneratedMeshBasisGetObj",Err,ERROR,*999)
 
    CALL GENERATED_MESH_BASIS_GET(GeneratedMesh%GENERATED_MESH,Basis%BASIS,Err,ERROR,*999)

    CALL EXITS("CMISSGeneratedMeshBasisGetObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshBasisGetObj",Err,ERROR)
    CALL EXITS("CMISSGeneratedMeshBasisGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSGeneratedMeshBasisGetObj

  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the basis for a generated mesh identified by a user number.
  SUBROUTINE CMISSGeneratedMeshBasisSetNumber(GeneratedMeshUserNumber,BasisUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: GeneratedMeshUserNumber !<The user number of the generated mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: BasisUserNumber !<The user number of the basis to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSGeneratedMeshBasisSetNumber",Err,ERROR,*999)
 
    NULLIFY(GENERATED_MESH)
    NULLIFY(BASIS)
    CALL GENERATED_MESH_USER_NUMBER_FIND(GeneratedMeshUserNumber,GENERATED_MESH,Err,ERROR,*999)
    IF(ASSOCIATED(GENERATED_MESH)) THEN
      CALL BASIS_USER_NUMBER_FIND(BasisUserNumber,BASIS,Err,ERROR,*999)
      IF(ASSOCIATED(BASIS)) THEN
        CALL GENERATED_MESH_BASIS_SET(GENERATED_MESH,BASIS,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(BasisUserNumber,"*",Err,ERROR))// &
        & " does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(GeneratedMeshUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSGeneratedMeshBasisSetNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshBasisSetNumber",Err,ERROR)
    CALL EXITS("CMISSGeneratedMeshBasisSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSGeneratedMeshBasisSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the basis for a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshBasisSetObj(GeneratedMesh,Basis,Err)
  
    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: GeneratedMesh !<The generated mesh to set the basis for.
    TYPE(CMISSBasisType), INTENT(IN) :: Basis !<The basis to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSGeneratedMeshBasisSetObj",Err,ERROR,*999)
 
    CALL GENERATED_MESH_BASIS_SET(GeneratedMesh%GENERATED_MESH,Basis%BASIS,Err,ERROR,*999)

    CALL EXITS("CMISSGeneratedMeshBasisSetObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshBasisSetObj",Err,ERROR)
    CALL EXITS("CMISSGeneratedMeshBasisSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSGeneratedMeshBasisSetObj

  !  
  !================================================================================================================================
  !
  
  !>Finishes the creation of a generated mesh identified by a user number.
  SUBROUTINE CMISSGeneratedMeshCreateFinishNumber(GeneratedMeshUserNumber,MeshUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: GeneratedMeshUserNumber !<The user number of the generated mesh to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber !<The user number of the mesh to generate.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSGeneratedMeshCreateFinishNumber",Err,ERROR,*999)
 
    NULLIFY(GENERATED_MESH)
    NULLIFY(MESH)
    CALL GENERATED_MESH_USER_NUMBER_FIND(GeneratedMeshUserNumber,GENERATED_MESH,Err,ERROR,*999)
    IF(ASSOCIATED(GENERATED_MESH)) THEN
      CALL GENERATED_MESH_CREATE_FINISH(GENERATED_MESH,MeshUserNumber,MESH,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(GeneratedMeshUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Generated Mesh Create')
#endif

    CALL EXITS("CMISSGeneratedMeshCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshCreateFinishNumber",Err,ERROR)
    CALL EXITS("CMISSGeneratedMeshCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSGeneratedMeshCreateFinishNumber

  !  
  !================================================================================================================================
  !  
 
  !>Finishes the creation of a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshCreateFinishObj(GeneratedMesh,MeshUserNumber,Mesh,Err)
  
    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: GeneratedMesh !<The generated mesh to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber !<The user number of the mesh to generate.
    TYPE(CMISSMeshType), INTENT(INOUT) :: Mesh !<On return, the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSGeneratedMeshCreateFinishObj",Err,ERROR,*999)
 
    CALL GENERATED_MESH_CREATE_FINISH(GeneratedMesh%GENERATED_MESH,MeshUserNumber,Mesh%MESH,Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Generated Mesh Create')
#endif

    CALL EXITS("CMISSGeneratedMeshCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshCreateFinishObj",Err,ERROR)
    CALL EXITS("CMISSGeneratedMeshCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSGeneratedMeshCreateFinishObj

  !  
  !================================================================================================================================
  !
  
  !>Starts the creation of a generated mesh identified by a user number.
  SUBROUTINE CMISSGeneratedMeshCreateStartNumber(GeneratedMeshUserNumber,RegionUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: GeneratedMeshUserNumber !<The user number of the generated mesh to create.
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region to create the generated mesh in.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSGeneratedMeshCreateStartNumber",Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Generated Mesh Create')
#endif
 
    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_CREATE_START(GeneratedMeshUserNumber,REGION,GENERATED_MESH,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSGeneratedMeshCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshCreateStartNumber",Err,ERROR)
    CALL EXITS("CMISSGeneratedMeshCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSGeneratedMeshCreateStartNumber

  !  
  !================================================================================================================================
  !  
 
  !>Starts the creation of a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshCreateStartObj(GeneratedMeshUserNumber,Region,GeneratedMesh,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: GeneratedMeshUserNumber !<The user number of the generated mesh to create.
    TYPE(CMISSRegionType), INTENT(INOUT) :: Region !<The region to created generated mesh in.
    TYPE(CMISSGeneratedMeshType), INTENT(INOUT) :: GeneratedMesh !<On return, the created generated mesh.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSGeneratedMeshCreateStartObj",Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Generated Mesh Create')
#endif
 
    CALL GENERATED_MESH_CREATE_START(GeneratedMeshUserNumber,REGION%Region,GeneratedMesh%GENERATED_MESH,Err,ERROR,*999)

    CALL EXITS("CMISSGeneratedMeshCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshCreateStartObj",Err,ERROR)
    CALL EXITS("CMISSGeneratedMeshCreateStartObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSGeneratedMeshCreateStartObj

  !  
  !================================================================================================================================
  !
  
  !>Destroys a generated mesh identified by a user number.
  SUBROUTINE CMISSGeneratedMeshDestroyNumber(GeneratedMeshUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: GeneratedMeshUserNumber !<The user number of the generated mesh to destroy.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSGeneratedMeshDestroyNumber",Err,ERROR,*999)
 
    NULLIFY(GENERATED_MESH)
    CALL GENERATED_MESH_USER_NUMBER_FIND(GeneratedMeshUserNumber,GENERATED_MESH,Err,ERROR,*999)
    IF(ASSOCIATED(GENERATED_MESH)) THEN
      CALL GENERATED_MESH_DESTROY(GENERATED_MESH,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(GeneratedMeshUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSGeneratedMeshDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshDestroyNumber",Err,ERROR)
    CALL EXITS("CMISSGeneratedMeshDestroyNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSGeneratedMeshDestroyNumber

  !  
  !================================================================================================================================
  !  
 
  !>Destroys a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshDestroyObj(GeneratedMesh,Err)
  
    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(INOUT) :: GeneratedMesh !<The generated mesh to destroy.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSGeneratedMeshDestroyObj",Err,ERROR,*999)
 
    CALL GENERATED_MESH_DESTROY(GeneratedMesh%GENERATED_MESH,Err,ERROR,*999)

    CALL EXITS("CMISSGeneratedMeshDestroyObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshDestroyObj",Err,ERROR)
    CALL EXITS("CMISSGeneratedMeshDestroyObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSGeneratedMeshDestroyObj

  !  
  !================================================================================================================================
  !  

  !>Returns the extent for a generated mesh identified by a user number.
  SUBROUTINE CMISSGeneratedMeshExtentGetNumber(GeneratedMeshUserNumber,Extent,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: GeneratedMeshUserNumber !<The user number of the generated mesh to get the extent for.
    REAL(DP), INTENT(OUT) :: Extent(:) !<Extent(i). On return, the extent for the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSGeneratedMeshExtentGetNumber",Err,ERROR,*999)
 
    NULLIFY(GENERATED_MESH)
    CALL GENERATED_MESH_USER_NUMBER_FIND(GeneratedMeshUserNumber,GENERATED_MESH,Err,ERROR,*999)
    IF(ASSOCIATED(GENERATED_MESH)) THEN
      CALL GENERATED_MESH_EXTENT_GET(GENERATED_MESH,Extent,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(GeneratedMeshUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSGeneratedMeshExtentGetNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshExtentGetNumber",Err,ERROR)
    CALL EXITS("CMISSGeneratedMeshExtentGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSGeneratedMeshExtentGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the extent for a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshExtentGetObj(GeneratedMesh,Extent,Err)
  
    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: GeneratedMesh !<The generated mesh to get the extent for.
    REAL(DP), INTENT(OUT) :: Extent(:) !<Extent(i). On return, the extent for the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSGeneratedMeshExtentGetObj",Err,ERROR,*999)
 
    CALL GENERATED_MESH_EXTENT_GET(GeneratedMesh%GENERATED_MESH,Extent,Err,ERROR,*999)

    CALL EXITS("CMISSGeneratedMeshExtentGetObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshExtentGetObj",Err,ERROR)
    CALL EXITS("CMISSGeneratedMeshExtentGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSGeneratedMeshExtentGetObj

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the extent for a generated mesh identified by a user number.
  SUBROUTINE CMISSGeneratedMeshExtentSetNumber(GeneratedMeshUserNumber,Extent,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: GeneratedMeshUserNumber !<The user number of the generated mesh to set the extent for.
    REAL(DP), INTENT(IN) :: Extent(:) !<Extent(i). The extent for the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSGeneratedMeshExtentSetNumber",Err,ERROR,*999)
 
    NULLIFY(GENERATED_MESH)
    CALL GENERATED_MESH_USER_NUMBER_FIND(GeneratedMeshUserNumber,GENERATED_MESH,Err,ERROR,*999)
    IF(ASSOCIATED(GENERATED_MESH)) THEN
      CALL GENERATED_MESH_EXTENT_SET(GENERATED_MESH,Extent,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(GeneratedMeshUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSGeneratedMeshExtentSetNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshExtentSetNumber",Err,ERROR)
    CALL EXITS("CMISSGeneratedMeshExtentSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSGeneratedMeshExtentSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the extent for a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshExtentSetObj(GeneratedMesh,Extent,Err)
  
    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: GeneratedMesh !<The generated mesh to set the extent for.
    REAL(DP), INTENT(IN) :: Extent(:) !<Extent(i). the extent for the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSGeneratedMeshExtentSetObj",Err,ERROR,*999)
 
    CALL GENERATED_MESH_EXTENT_SET(GeneratedMesh%GENERATED_MESH,Extent,Err,ERROR,*999)

    CALL EXITS("CMISSGeneratedMeshExtentSetObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshExtentSetObj",Err,ERROR)
    CALL EXITS("CMISSGeneratedMeshExtentSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSGeneratedMeshExtentSetObj

  !  
  !================================================================================================================================
  !  

  !>Returns the number of elements for a generated mesh identified by a user number.
  SUBROUTINE CMISSGeneratedMeshNumberOfElementsGetNumber(GeneratedMeshUserNumber,NumberOfElements,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: GeneratedMeshUserNumber !<The user number of the generated mesh to get the number of elements for.
    INTEGER(INTG), INTENT(OUT) :: NumberOfElements(:) !<NumberOfElements(i). On return, the number of elements in the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSGeneratedMeshNumberOfElementsGetNumber",Err,ERROR,*999)
 
    NULLIFY(GENERATED_MESH)
    CALL GENERATED_MESH_USER_NUMBER_FIND(GeneratedMeshUserNumber,GENERATED_MESH,Err,ERROR,*999)
    IF(ASSOCIATED(GENERATED_MESH)) THEN
      CALL GENERATED_MESH_NUMBER_OF_ELEMENTS_GET(GENERATED_MESH,NumberOfElements,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(GeneratedMeshUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSGeneratedMeshNumberOfElementsGetNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshNumberOfElementsGetNumber",Err,ERROR)
    CALL EXITS("CMISSGeneratedMeshNumberOfElementsGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSGeneratedMeshNumberOfElementsGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the number of elements for a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshNumberOfElementsGetObj(GeneratedMesh,NumberOfElements,Err)
  
    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: GeneratedMesh !<The generated mesh to get the number of elements for.
    INTEGER(INTG), INTENT(OUT) :: NumberOfElements(:) !<NumberOfElements(i). On return, the number of elements in the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSGeneratedMeshNumberOfElementsGetObj",Err,ERROR,*999)
 
    CALL GENERATED_MESH_NUMBER_OF_ELEMENTS_GET(GeneratedMesh%GENERATED_MESH,NumberOfElements,Err,ERROR,*999)

    CALL EXITS("CMISSGeneratedMeshNumberOfElementsGetObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshNumberOfElementsGetObj",Err,ERROR)
    CALL EXITS("CMISSGeneratedMeshNumberOfElementsGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSGeneratedMeshNumberOfElementsGetObj

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the number of elements for a generated mesh identified by a user number.
  SUBROUTINE CMISSGeneratedMeshNumberOfElementsSetNumber(GeneratedMeshUserNumber,NumberOfElements,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: GeneratedMeshUserNumber !<The user number of the generated mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: NumberOfElements(:) !<NumberOfElements(i). The number of elements in the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSGeneratedMeshNumberOfElementsSetNumber",Err,ERROR,*999)
 
    NULLIFY(GENERATED_MESH)
    CALL GENERATED_MESH_USER_NUMBER_FIND(GeneratedMeshUserNumber,GENERATED_MESH,Err,ERROR,*999)
    IF(ASSOCIATED(GENERATED_MESH)) THEN
      CALL GENERATED_MESH_NUMBER_OF_ELEMENTS_SET(GENERATED_MESH,NumberOfElements,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(GeneratedMeshUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSGeneratedMeshNumberOfElementsSetNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshNumberOfElementsSetNumber",Err,ERROR)
    CALL EXITS("CMISSGeneratedMeshNumberOfElementsSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSGeneratedMeshNumberOfElementsSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the number of elements for a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshNumberOfElementsSetObj(GeneratedMesh,NumberOfElements,Err)
  
    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: GeneratedMesh !<The generated mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: NumberOfElements(:) !<NumberOfElements(i). The number of elements in the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSGeneratedMeshNumberOfElementsSetObj",Err,ERROR,*999)
 
    CALL GENERATED_MESH_NUMBER_OF_ELEMENTS_SET(GeneratedMesh%GENERATED_MESH,NumberOfElements,Err,ERROR,*999)

    CALL EXITS("CMISSGeneratedMeshNumberOfElementsSetObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshNumberOfElementsSetObj",Err,ERROR)
    CALL EXITS("CMISSGeneratedMeshNumberOfElementsSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSGeneratedMeshNumberOfElementsSetObj

  !  
  !================================================================================================================================
  !  

  !>Returns the origin of a generated mesh identified by a user number.
  SUBROUTINE CMISSGeneratedMeshOriginGetNumber(GeneratedMeshUserNumber,Origin,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: GeneratedMeshUserNumber !<The user number of the generated mesh to get the origin for.
    REAL(DP), INTENT(OUT) :: Origin(:) !<Origin(i). On return, the origin of the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSGeneratedMeshOriginGetNumber",Err,ERROR,*999)
 
    NULLIFY(GENERATED_MESH)
    CALL GENERATED_MESH_USER_NUMBER_FIND(GeneratedMeshUserNumber,GENERATED_MESH,Err,ERROR,*999)
    IF(ASSOCIATED(GENERATED_MESH)) THEN
      CALL GENERATED_MESH_ORIGIN_GET(GENERATED_MESH,Origin,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(GeneratedMeshUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSGeneratedMeshOriginGetNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshOriginGetNumber",Err,ERROR)
    CALL EXITS("CMISSGeneratedMeshOriginGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSGeneratedMeshOriginGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the origin of a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshOriginGetObj(GeneratedMesh,Origin,Err)
  
    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: GeneratedMesh !<The generated mesh to get the origin for.
    REAL(DP), INTENT(OUT) :: Origin(:) !<Origin(i). On return, the origin of the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSGeneratedMeshOriginGetObj",Err,ERROR,*999)
 
    CALL GENERATED_MESH_ORIGIN_GET(GeneratedMesh%GENERATED_MESH,Origin,Err,ERROR,*999)

    CALL EXITS("CMISSGeneratedMeshOriginGetObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshOriginGetObj",Err,ERROR)
    CALL EXITS("CMISSGeneratedMeshOriginGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSGeneratedMeshOriginGetObj

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the origin of a generated mesh identified by a user number.
  SUBROUTINE CMISSGeneratedMeshOriginSetNumber(GeneratedMeshUserNumber,Origin,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: GeneratedMeshUserNumber !<The user number of the generated mesh to set the origin for.
    REAL(DP), INTENT(IN) :: Origin(:) !<Origin(i). The origin of the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSGeneratedMeshOriginSetNumber",Err,ERROR,*999)
 
    NULLIFY(GENERATED_MESH)
    CALL GENERATED_MESH_USER_NUMBER_FIND(GeneratedMeshUserNumber,GENERATED_MESH,Err,ERROR,*999)
    IF(ASSOCIATED(GENERATED_MESH)) THEN
      CALL GENERATED_MESH_ORIGIN_SET(GENERATED_MESH,Origin,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(GeneratedMeshUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSGeneratedMeshOriginSetNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshOriginSetNumber",Err,ERROR)
    CALL EXITS("CMISSGeneratedMeshOriginSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSGeneratedMeshOriginSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the origin of a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshOriginSetObj(GeneratedMesh,Origin,Err)
  
    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: GeneratedMesh !<The generated mesh to set the origin for.
    REAL(DP), INTENT(IN) :: Origin(:) !<Origin(i). The origin of the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSGeneratedMeshOriginSetObj",Err,ERROR,*999)
 
    CALL GENERATED_MESH_ORIGIN_SET(GeneratedMesh%GENERATED_MESH,Origin,Err,ERROR,*999)

    CALL EXITS("CMISSGeneratedMeshOriginSetObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshOriginSetObj",Err,ERROR)
    CALL EXITS("CMISSGeneratedMeshOriginSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSGeneratedMeshOriginSetObj

  !  
  !================================================================================================================================
  !  

  !>Returns the type of a generated mesh identified by a user number.
  SUBROUTINE CMISSGeneratedMeshTypeGetNumber(GeneratedMeshUserNumber,GeneratedMeshType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: GeneratedMeshUserNumber !<The user number of the generated mesh to get the type for.
    INTEGER(INTG), INTENT(OUT) :: GeneratedMeshType !<On return, the type of the generated mesh. \see OPENCMISS_GeneratedMeshTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSGeneratedMeshTypeGetNumber",Err,ERROR,*999)
 
    NULLIFY(GENERATED_MESH)
    CALL GENERATED_MESH_USER_NUMBER_FIND(GeneratedMeshUserNumber,GENERATED_MESH,Err,ERROR,*999)
    IF(ASSOCIATED(GENERATED_MESH)) THEN
      CALL GENERATED_MESH_TYPE_GET(GENERATED_MESH,GeneratedMeshType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(GeneratedMeshUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSGeneratedMeshTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshTypeGetNumber",Err,ERROR)
    CALL EXITS("CMISSGeneratedMeshTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSGeneratedMeshTypeGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the type of a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshTypeGetObj(GeneratedMesh,GeneratedMeshType,Err)
  
    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: GeneratedMesh !<The generated mesh to get the generated mesh type for.
    INTEGER(INTG), INTENT(OUT) :: GeneratedMeshType !<On return, the type of the generated mesh. \see OPENCMISS_GeneratedMeshTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSGeneratedMeshTypeGetObj",Err,ERROR,*999)
 
    CALL GENERATED_MESH_TYPE_GET(GeneratedMesh%GENERATED_MESH,GeneratedMeshType,Err,ERROR,*999)

    CALL EXITS("CMISSGeneratedMeshTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshTypeGetObj",Err,ERROR)
    CALL EXITS("CMISSGeneratedMeshTypeGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSGeneratedMeshTypeGetObj

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the type of a generated mesh identified by a user number.
  SUBROUTINE CMISSGeneratedMeshTypeSetNumber(GeneratedMeshUserNumber,GeneratedMeshType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: GeneratedMeshUserNumber !<The user number of the generated mesh to set the type for.
    INTEGER(INTG), INTENT(IN) :: GeneratedMeshType !<The type of the generated mesh to set. \see OPENCMISS_GeneratedMeshTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSGeneratedMeshTypeSetNumber",Err,ERROR,*999)
 
    NULLIFY(GENERATED_MESH)
    CALL GENERATED_MESH_USER_NUMBER_FIND(GeneratedMeshUserNumber,GENERATED_MESH,Err,ERROR,*999)
    IF(ASSOCIATED(GENERATED_MESH)) THEN
      CALL GENERATED_MESH_TYPE_SET(GENERATED_MESH,GeneratedMeshType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(GeneratedMeshUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSGeneratedMeshTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshTypeSetNumber",Err,ERROR)
    CALL EXITS("CMISSGeneratedMeshTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSGeneratedMeshTypeSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the type of a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshTypeSetObj(GeneratedMesh,GeneratedMeshType,Err)
  
    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: GeneratedMesh !<The generated mesh to set the generated mesh type for.
    INTEGER(INTG), INTENT(IN) :: GeneratedMeshType !<The type of the generated mesh to set. \see OPENCMISS_GeneratedMeshTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSGeneratedMeshTypeSetObj",Err,ERROR,*999)
 
    CALL GENERATED_MESH_TYPE_SET(GeneratedMesh%GENERATED_MESH,GeneratedMeshType,Err,ERROR,*999)

    CALL EXITS("CMISSGeneratedMeshTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshTypeSetObj",Err,ERROR)
    CALL EXITS("CMISSGeneratedMeshTypeSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSGeneratedMeshTypeSetObj

  !  
  !================================================================================================================================
  !  

  !>Calculates and sets the geometric field parameters for a generated mesh identified by a user number.
  SUBROUTINE CMISSGeneratedMeshGeometricParametersCalculateNumber(RegionUserNumber,FieldUserNumber,GeneratedMeshUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the field to calculate the geometric parameters for.
    INTEGER(INTG), INTENT(IN) :: FieldUserNumber !<The user number of the field to calculate the geometric parameters for.
    INTEGER(INTG), INTENT(IN) :: GeneratedMeshUserNumber !<The user number of the generated mesh to calculate the geometric parameters for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSGeneratedMeshGeometricParametersCalculateNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(FIELD)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(FieldUserNumber,REGION,FIELD,Err,ERROR,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL GENERATED_MESH_USER_NUMBER_FIND(GeneratedMeshUserNumber,GENERATED_MESH,Err,ERROR,*999)
        IF(ASSOCIATED(GENERATED_MESH)) THEN
          CALL GENERATED_MESH_GEOMETRIC_PARAMETERS_CALCULATE(FIELD,GENERATED_MESH,Err,ERROR,*999)
        ELSE
          LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(GeneratedMeshUserNumber,"*",Err,ERROR))// &
            & " does not exist."
          CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(FieldUserNumber,"*",Err,ERROR))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSGeneratedMeshGeometricParametersCalculateNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshGeometricParametersCalculateNumber",Err,ERROR)
    CALL EXITS("CMISSGeneratedMeshGeometricParametersCalculateNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSGeneratedMeshGeometricParametersCalculateNumber

  !  
  !================================================================================================================================
  !  
 
  !>Calculates and sets the geometric field parameters for a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshGeometricParametersCalculateObj(Field,GeneratedMesh,Err)
  
    !Argument variables
    TYPE(CMISSFieldType), INTENT(INOUT) :: Field !<The field to calculate the geometric parameters for
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: GeneratedMesh !<The generated mesh to calculate the geometric parameters for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSGeneratedMeshGeometricParametersCalculateObj",Err,ERROR,*999)
 
    CALL GENERATED_MESH_GEOMETRIC_PARAMETERS_CALCULATE(Field%FIELD,GeneratedMesh%GENERATED_MESH,Err,ERROR,*999)

    CALL EXITS("CMISSGeneratedMeshGeometricParametersCalculateObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshGeometricParametersCalculateObj",Err,ERROR)
    CALL EXITS("CMISSGeneratedMeshGeometricParametersCalculateObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSGeneratedMeshGeometricParametersCalculateObj

!!==================================================================================================================================
!!
!! MESH_ROUTINES
!!
!!==================================================================================================================================

  !>Finishes the creation of a domain decomposition for a decomposition identified by a user number.
  SUBROUTINE CMISSDecompositionCreateFinishNumber(RegionUserNumber,MeshUserNumber,DecompositionUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the mesh to finish the decomposition for.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber !<The user number of the mesh to finish the decomposition for.
    INTEGER(INTG), INTENT(IN) :: DecompositionUserNumber !<The user number of the decomposition to finish.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSDecompositionCreateFinishNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(MeshUserNumber,REGION,MESH,Err,ERROR,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(DecompositionUserNumber,MESH,DECOMPOSITION,Err,ERROR,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_CREATE_FINISH(DECOMPOSITION,Err,ERROR,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(DecompositionUserNumber,"*",Err,ERROR))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Decomposition Create')
#endif

    CALL EXITS("CMISSDecompositionCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSDecompositionCreateFinishNumber",Err,ERROR)
    CALL EXITS("CMISSDecompositionCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSDecompositionCreateFinishNumber

  !  
  !================================================================================================================================
  !  
 
  !>Finishes the creation of a domain decomposition for a decomposition identified by an object.
  SUBROUTINE CMISSDecompositionCreateFinishObj(Decomposition,Err)
  
    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: Decomposition !<The decomposition to finish creating.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSDecompositionCreateFinishObj",Err,ERROR,*999)
 
    CALL DECOMPOSITION_CREATE_FINISH(Decomposition%DECOMPOSITION,Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Decomposition Create')
#endif

    CALL EXITS("CMISSDecompositionCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSDecompositionCreateFinishObj",Err,ERROR)
    CALL EXITS("CMISSDecompositionCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSDecompositionCreateFinishObj

  !  
  !================================================================================================================================
  !  
 
  !>Starts the creation of a domain decomposition for a decomposition identified by a user number.
  SUBROUTINE CMISSDecompositionCreateStartNumber(DecompositionUserNumber,RegionUserNumber,MeshUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: DecompositionUserNumber !<The user number of the decomposition to create.
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the mesh to create the decomposition for.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber !<The user number of the mesh to create the decomposition for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSDecompositionCreateStartNumber",Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Decomposition Create')
#endif
 
    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(MeshUserNumber,REGION,MESH,Err,ERROR,*999)
      IF(ASSOCIATED(MESH)) THEN        
        CALL DECOMPOSITION_CREATE_START(DecompositionUserNumber,MESH,DECOMPOSITION,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSDecompositionCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSDecompositionCreateStartNumber",Err,ERROR)
    CALL EXITS("CMISSDecompositionCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSDecompositionCreateStartNumber

  !  
  !================================================================================================================================
  !  
 
  !>Starts the creation of a domain decomposition for a decomposition identified by an object.
  SUBROUTINE CMISSDecompositionCreateStartObj(DecompositionUserNumber,Mesh,Decomposition,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: DecompositionUserNumber !<The user number of the decomposition to create.
    TYPE(CMISSMeshType), INTENT(IN) :: Mesh !<The mesh to create the decomposition for.
    TYPE(CMISSDecompositionType), INTENT(OUT) :: Decomposition !<On return, the created decomposition.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSDecompositionCreateStartObj",Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Decomposition Create')
#endif
 
    CALL DECOMPOSITION_CREATE_START(DecompositionUserNumber,Mesh%MESH,Decomposition%DECOMPOSITION,Err,ERROR,*999)

    CALL EXITS("CMISSDecompositionCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSDecompositionCreateStartObj",Err,ERROR)
    CALL EXITS("CMISSDecompositionCreateStartObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSDecompositionCreateStartObj

  !  
  !================================================================================================================================
  !  
 
  !>Destroys a decomposition identified by a user number.
  SUBROUTINE CMISSDecompositionDestroyNumber(RegionUserNumber,MeshUserNumber,DecompositionUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the mesh to destroy the decomposition for.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber !<The user number of the mesh to destroy the decomposition for.
    INTEGER(INTG), INTENT(IN) :: DecompositionUserNumber !<The user number of the decomposition to destroy.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSDecompositionDestroyNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(MeshUserNumber,REGION,MESH,Err,ERROR,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(DecompositionUserNumber,MESH,DECOMPOSITION,Err,ERROR,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_DESTROY(DECOMPOSITION,Err,ERROR,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(DecompositionUserNumber,"*",Err,ERROR))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSDecompositionDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSDecompositionDestroyNumber",Err,ERROR)
    CALL EXITS("CMISSDecompositionDestroyNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSDecompositionDestroyNumber

  !  
  !================================================================================================================================
  !  
 
  !>Destroys a decomposition identified by an object.
  SUBROUTINE CMISSDecompositionDestroyObj(Decomposition,Err)
  
    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: Decomposition !<The decomposition to destroy.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSDecompositionDestroyObj",Err,ERROR,*999)
 
    CALL DECOMPOSITION_DESTROY(Decomposition%DECOMPOSITION,Err,ERROR,*999)

    CALL EXITS("CMISSDecompositionDestroyObj")
    RETURN
999 CALL ERRORS("CMISSDecompositionDestroyObj",Err,ERROR)
    CALL EXITS("CMISSDecompositionDestroyObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSDecompositionDestroyObj

  !  
  !================================================================================================================================
  !  
 
  !>Calculates the element domains for a decomposition identified by a user number.
  SUBROUTINE CMISSDecompositionElementDomainCalculateNumber(RegionUserNumber,MeshUserNumber,DecompositionUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the mesh to calculate the element domains for.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber !<The user number of the mesh to calculate the element domains for.
    INTEGER(INTG), INTENT(IN) :: DecompositionUserNumber !<The user number of the decomposition to calculate the element domains for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSDecompositionElementDomainCalculateNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(MeshUserNumber,REGION,MESH,Err,ERROR,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(DecompositionUserNumber,MESH,DECOMPOSITION,Err,ERROR,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_ELEMENT_DOMAIN_CALCULATE(DECOMPOSITION,Err,ERROR,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(DecompositionUserNumber,"*",Err,ERROR))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSDecompositionElementDomainCalculateNumber")
    RETURN
999 CALL ERRORS("CMISSDecompositionElementDomainCalculateNumber",Err,ERROR)
    CALL EXITS("CMISSDecompositionElementDomainCalculateNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSDecompositionElementDomainCalculateNumber

  !  
  !================================================================================================================================
  !  
 
  !>Calculates the element domains for a decomposition identified by an object.
  SUBROUTINE CMISSDecompositionElementDomainCalculateObj(Decomposition,Err)
  
    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: Decomposition !<The decomposition to calcualte the element domains for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSDecompositionElementDomainCalculateObj",Err,ERROR,*999)
 
    CALL DECOMPOSITION_ELEMENT_DOMAIN_CALCULATE(Decomposition%DECOMPOSITION,Err,ERROR,*999)

    CALL EXITS("CMISSDecompositionElementDomainCalculateObj")
    RETURN
999 CALL ERRORS("CMISSDecompositionElementDomainCalculateObj",Err,ERROR)
    CALL EXITS("CMISSDecompositionElementDomainCalculateObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSDecompositionElementDomainCalculateObj
  
  !  
  !================================================================================================================================
  !  
 
  !>Returns the domain for a given element in a decomposition identified by a user number.
  SUBROUTINE CMISSDecompositionElementDomainGetNumber(RegionUserNumber,MeshUserNumber,DecompositionUserNumber, &
    & ElementUserNumber,Domain,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the mesh to get the element domain for.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber !<The user number of the mesh to get the element domain for.
    INTEGER(INTG), INTENT(IN) :: DecompositionUserNumber !<The user number of the decomposition to get the element domain for.
    INTEGER(INTG), INTENT(IN) :: ElementUserNumber !<The user number of the element to get the domain for.
    INTEGER(INTG), INTENT(OUT) :: Domain !<On return, the computational domain of the element.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSDecompositionElementDomainGetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(MeshUserNumber,REGION,MESH,Err,ERROR,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(DecompositionUserNumber,MESH,DECOMPOSITION,Err,ERROR,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_ELEMENT_DOMAIN_GET(DECOMPOSITION,ElementUserNumber,Domain,Err,ERROR,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(DecompositionUserNumber,"*",Err,ERROR))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSDecompositionElementDomainGetNumber")
    RETURN
999 CALL ERRORS("CMISSDecompositionElementDomainGetNumber",Err,ERROR)
    CALL EXITS("CMISSDecompositionElementDomainGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSDecompositionElementDomainGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the domain for a given element in a decomposition identified by an object.
  SUBROUTINE CMISSDecompositionElementDomainGetObj(Decomposition,ElementUserNumber,Domain,Err)
  
    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: Decomposition !<The decomposition to get the domain for.
    INTEGER(INTG), INTENT(IN) :: ElementUserNumber !<The user number of the element to get the domain for.
    INTEGER(INTG), INTENT(OUT) :: Domain !<On return, the computational domain of the element.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSDecompositionElementDomainGetObj",Err,ERROR,*999)
 
    CALL DECOMPOSITION_ELEMENT_DOMAIN_GET(Decomposition%DECOMPOSITION,ElementUserNumber,Domain,Err,ERROR,*999)

    CALL EXITS("CMISSDecompositionElementDomainGetObj")
    RETURN
999 CALL ERRORS("CMISSDecompositionElementDomainGetObj",Err,ERROR)
    CALL EXITS("CMISSDecompositionElementDomainGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSDecompositionElementDomainGetObj
  
  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the domain for a given element in a decomposition identified by a user number.
  SUBROUTINE CMISSDecompositionElementDomainSetNumber(RegionUserNumber,MeshUserNumber,DecompositionUserNumber, &
    & ElementUserNumber,Domain,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the mesh to set the element domain for.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber !<The user number of the mesh to set the element domain for.
    INTEGER(INTG), INTENT(IN) :: DecompositionUserNumber !<The user number of the decomposition to set the element domain for.
    INTEGER(INTG), INTENT(IN) :: ElementUserNumber !<The user number of the element to set the domain for.
    INTEGER(INTG), INTENT(IN) :: Domain !<The computational domain of the element to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSDecompositionElementDomainSetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(MeshUserNumber,REGION,MESH,Err,ERROR,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(DecompositionUserNumber,MESH,DECOMPOSITION,Err,ERROR,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_ELEMENT_DOMAIN_SET(DECOMPOSITION,ElementUserNumber,Domain,Err,ERROR,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(DecompositionUserNumber,"*",Err,ERROR))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSDecompositionElementDomainSetNumber")
    RETURN
999 CALL ERRORS("CMISSDecompositionElementDomainSetNumber",Err,ERROR)
    CALL EXITS("CMISSDecompositionElementDomainSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSDecompositionElementDomainSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the domain for a given element in a decomposition identified by an object.
  SUBROUTINE CMISSDecompositionElementDomainSetObj(Decomposition,ElementUserNumber,Domain,Err)
  
    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: Decomposition !<The decomposition to set the element domain for.
    INTEGER(INTG), INTENT(IN) :: ElementUserNumber !<The user number of the element to set the domain for.
    INTEGER(INTG), INTENT(IN) :: Domain !<The computational domain of the element to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSDecompositionElementDomainSetObj",Err,ERROR,*999)
 
    CALL DECOMPOSITION_ELEMENT_DOMAIN_SET(Decomposition%DECOMPOSITION,ElementUserNumber,Domain,Err,ERROR,*999)

    CALL EXITS("CMISSDecompositionElementDomainSetObj")
    RETURN
999 CALL ERRORS("CMISSDecompositionElementDomainSetObj",Err,ERROR)
    CALL EXITS("CMISSDecompositionElementDomainSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSDecompositionElementDomainSetObj
  
  !  
  !================================================================================================================================
  !  
 
  !>Returns the mesh component number used for the decomposition of a mesh for a decomposition identified by a user number.
  SUBROUTINE CMISSDecompositionMeshComponentGetNumber(RegionUserNumber,MeshUserNumber,DecompositionUserNumber, &
    & MeshComponentNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the mesh to get the decomposition mesh component for.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber !<The user number of the mesh to get the decomposition mesh component for.
    INTEGER(INTG), INTENT(IN) :: DecompositionUserNumber !<The user number of the decomposition to get the mesh component for.
    INTEGER(INTG), INTENT(OUT) :: MeshComponentNumber !<On return, the mesh component number for the decomposition.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSDecompositionMeshComponentGetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(MeshUserNumber,REGION,MESH,Err,ERROR,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(DecompositionUserNumber,MESH,DECOMPOSITION,Err,ERROR,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_MESH_COMPONENT_NUMBER_GET(DECOMPOSITION,MeshComponentNumber,Err,ERROR,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(DecompositionUserNumber,"*",Err,ERROR))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSDecompositionMeshComponentGetNumber")
    RETURN
999 CALL ERRORS("CMISSDecompositionMeshComponentGetNumber",Err,ERROR)
    CALL EXITS("CMISSDecompositionMeshComponentGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSDecompositionMeshComponentGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the mesh component number used for the decomposition of a mesh for a decomposition identified by an object.
  SUBROUTINE CMISSDecompositionMeshComponentGetObj(Decomposition,MeshComponentNumber,Err)
  
    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: Decomposition !<The decomposition to get the mesh component for.
    INTEGER(INTG), INTENT(OUT) :: MeshComponentNumber !<On return, the mesh component number for the decomposition.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSDecompositionMeshComponentGetObj",Err,ERROR,*999)
 
    CALL DECOMPOSITION_MESH_COMPONENT_NUMBER_GET(Decomposition%DECOMPOSITION,MeshComponentNumber,Err,ERROR,*999)

    CALL EXITS("CMISSDecompositionMeshComponentGetObj")
    RETURN
999 CALL ERRORS("CMISSDecompositionMeshComponentGetObj",Err,ERROR)
    CALL EXITS("CMISSDecompositionMeshComponentGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSDecompositionMeshComponentGetObj
  
  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the mesh component number used for the decomposition of a mesh for a decomposition identified by a user number.
  SUBROUTINE CMISSDecompositionMeshComponentSetNumber(RegionUserNumber,MeshUserNumber,DecompositionUserNumber, &
    & MeshComponentNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the mesh to set the decomposition mesh component for.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber !<The user number of the mesh to set the decomposition mesh component for.
    INTEGER(INTG), INTENT(IN) :: DecompositionUserNumber !<The user number of the decomposition to set the mesh component for.
    INTEGER(INTG), INTENT(IN) :: MeshComponentNumber !<The mesh component number for the decomposition to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSDecompositionMeshComponentSetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(MeshUserNumber,REGION,MESH,Err,ERROR,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(DecompositionUserNumber,MESH,DECOMPOSITION,Err,ERROR,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_MESH_COMPONENT_NUMBER_SET(DECOMPOSITION,MeshComponentNumber,Err,ERROR,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(DecompositionUserNumber,"*",Err,ERROR))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSDecompositionMeshComponentSetNumber")
    RETURN
999 CALL ERRORS("CMISSDecompositionMeshComponentSetNumber",Err,ERROR)
    CALL EXITS("CMISSDecompositionMeshComponentSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSDecompositionMeshComponentSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the mesh component number used for the decomposition of a mesh for a decomposition identified by an object.
  SUBROUTINE CMISSDecompositionMeshComponentSetObj(Decomposition,MeshComponentNumber,Err)
  
    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: Decomposition !<The decomposition to Set the mesh component for.
    INTEGER(INTG), INTENT(IN) :: MeshComponentNumber !<The mesh component number for the decomposition to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSDecompositionMeshComponentSetObj",Err,ERROR,*999)
 
    CALL DECOMPOSITION_MESH_COMPONENT_NUMBER_SET(Decomposition%DECOMPOSITION,MeshComponentNumber,Err,ERROR,*999)

    CALL EXITS("CMISSDecompositionMeshComponentSetObj")
    RETURN
999 CALL ERRORS("CMISSDecompositionMeshComponentSetObj",Err,ERROR)
    CALL EXITS("CMISSDecompositionMeshComponentSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSDecompositionMeshComponentSetObj
  
  !  
  !================================================================================================================================
  !  
 
  !>Returns the number of domains for a decomposition identified by a user number.
  SUBROUTINE CMISSDecompositionNumberOfDomainsGetNumber(RegionUserNumber,MeshUserNumber,DecompositionUserNumber, &
    & NumberOfDomains,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the mesh to get the number of domains for.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber !<The user number of the mesh to get the number of domains for.
    INTEGER(INTG), INTENT(IN) :: DecompositionUserNumber !<The user number of the decomposition to get the number of domains for.
    INTEGER(INTG), INTENT(OUT) :: NumberOfDomains !<On return, the number of domains in the decomposition.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSDecompositionNumberOfDomainsGetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(MeshUserNumber,REGION,MESH,Err,ERROR,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(DecompositionUserNumber,MESH,DECOMPOSITION,Err,ERROR,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_NUMBER_OF_DOMAINS_GET(DECOMPOSITION,NumberOfDomains,Err,ERROR,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(DecompositionUserNumber,"*",Err,ERROR))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSDecompositionNumberOfDomainsGetNumber")
    RETURN
999 CALL ERRORS("CMISSDecompositionNumberOfDomainsGetNumber",Err,ERROR)
    CALL EXITS("CMISSDecompositionNumberOfDomainsGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSDecompositionNumberOfDomainsGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the number of domains for a decomposition identified by an object.
  SUBROUTINE CMISSDecompositionNumberOfDomainsGetObj(Decomposition,NumberOfDomains,Err)
  
    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: Decomposition !<The decomposition to get the number of domains for.
    INTEGER(INTG), INTENT(OUT) :: NumberOfDomains !<On return, the number of domains in the decomposition.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSDecompositionNumberOfDomainsGetObj",Err,ERROR,*999)
 
    CALL DECOMPOSITION_NUMBER_OF_DOMAINS_GET(Decomposition%DECOMPOSITION,NumberOfDomains,Err,ERROR,*999)

    CALL EXITS("CMISSDecompositionNumberOfDomainsGetObj")
    RETURN
999 CALL ERRORS("CMISSDecompositionNumberOfDomainsGetObj",Err,ERROR)
    CALL EXITS("CMISSDecompositionNumberOfDomainsGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSDecompositionNumberOfDomainsGetObj
  
  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the number of domains for a decomposition identified by a user number.
  SUBROUTINE CMISSDecompositionNumberOfDomainsSetNumber(RegionUserNumber,MeshUserNumber,DecompositionUserNumber, &
    & NumberOfDomains,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the mesh to set the number of domains for.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber !<The user number of the mesh to set the number of domains for.
    INTEGER(INTG), INTENT(IN) :: DecompositionUserNumber !<The user number of the decomposition to set the number of domains for.
    INTEGER(INTG), INTENT(IN) :: NumberOfDomains !<The number of domains in the decomposition to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSDecompositionNumberOfDomainsSetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(MeshUserNumber,REGION,MESH,Err,ERROR,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(DecompositionUserNumber,MESH,DECOMPOSITION,Err,ERROR,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_NUMBER_OF_DOMAINS_SET(DECOMPOSITION,NumberOfDomains,Err,ERROR,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(DecompositionUserNumber,"*",Err,ERROR))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSDecompositionNumberOfDomainsSetNumber")
    RETURN
999 CALL ERRORS("CMISSDecompositionNumberOfDomainsSetNumber",Err,ERROR)
    CALL EXITS("CMISSDecompositionNumberOfDomainsSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSDecompositionNumberOfDomainsSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the number of domains for a decomposition identified by an object.
  SUBROUTINE CMISSDecompositionNumberOfDomainsSetObj(Decomposition,NumberOfDomains,Err)
  
    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: Decomposition !<The decomposition to set the number of domains for.
    INTEGER(INTG), INTENT(IN) :: NumberOfDomains !<The number of domains in the decomposition to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSDecompositionNumberOfDomainsSetObj",Err,ERROR,*999)
 
    CALL DECOMPOSITION_NUMBER_OF_DOMAINS_SET(Decomposition%DECOMPOSITION,NumberOfDomains,Err,ERROR,*999)

    CALL EXITS("CMISSDecompositionNumberOfDomainsSetObj")
    RETURN
999 CALL ERRORS("CMISSDecompositionNumberOfDomainsSetObj",Err,ERROR)
    CALL EXITS("CMISSDecompositionNumberOfDomainsSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSDecompositionNumberOfDomainsSetObj
  
  !  
  !================================================================================================================================
  !  
 
  !>Returns the type of a decomposition identified by a user number.
  SUBROUTINE CMISSDecompositionTypeGetNumber(RegionUserNumber,MeshUserNumber,DecompositionUserNumber,DecompositionType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the mesh to get the decomposition type for.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber !<The user number of the mesh to get the decomposition type for.
    INTEGER(INTG), INTENT(IN) :: DecompositionUserNumber !<The user number of the decomposition to get the decomposition type for.
    INTEGER(INTG), INTENT(OUT) :: DecompositionType !<On return, the type of the decomposition.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSDecompositionTypeGetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(MeshUserNumber,REGION,MESH,Err,ERROR,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(DecompositionUserNumber,MESH,DECOMPOSITION,Err,ERROR,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_TYPE_GET(DECOMPOSITION,DecompositionType,Err,ERROR,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(DecompositionUserNumber,"*",Err,ERROR))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSDecompositionTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSDecompositionTypeGetNumber",Err,ERROR)
    CALL EXITS("CMISSDecompositionTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSDecompositionTypeGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the type of a decomposition identified by an object.
  SUBROUTINE CMISSDecompositionTypeGetObj(Decomposition,DecompositionType,Err)
  
    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: Decomposition !<The decomposition to get the type for.
    INTEGER(INTG), INTENT(OUT) :: DecompositionType !<On return, the type of the decomposition.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSDecompositionTypeGetObj",Err,ERROR,*999)
 
    CALL DECOMPOSITION_TYPE_GET(Decomposition%DECOMPOSITION,DecompositionType,Err,ERROR,*999)

    CALL EXITS("CMISSDecompositionTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSDecompositionTypeGetObj",Err,ERROR)
    CALL EXITS("CMISSDecompositionTypeGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSDecompositionTypeGetObj
  
  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the type of a decomposition identified by a user number.
  SUBROUTINE CMISSDecompositionTypeSetNumber(RegionUserNumber,MeshUserNumber,DecompositionUserNumber,DecompositionType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the mesh to set the decomposition type for.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber !<The user number of the mesh to set the decomposition type for.
    INTEGER(INTG), INTENT(IN) :: DecompositionUserNumber !<The user number of the decomposition to set the decomposition type for.
    INTEGER(INTG), INTENT(IN) :: DecompositionType !<The type of the decomposition to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSDecompositionTypeSetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(MeshUserNumber,REGION,MESH,Err,ERROR,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(DecompositionUserNumber,MESH,DECOMPOSITION,Err,ERROR,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_TYPE_SET(DECOMPOSITION,DecompositionType,Err,ERROR,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(DecompositionUserNumber,"*",Err,ERROR))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSDecompositionTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSDecompositionTypeSetNumber",Err,ERROR)
    CALL EXITS("CMISSDecompositionTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSDecompositionTypeSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the type of a decomposition identified by an object.
  SUBROUTINE CMISSDecompositionTypeSetObj(Decomposition,DecompositionType,Err)
  
    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: Decomposition !<The decomposition to Set the type for.
    INTEGER(INTG), INTENT(IN) :: DecompositionType !<The type of the decomposition to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSDecompositionTypeSetObj",Err,ERROR,*999)
 
    CALL DECOMPOSITION_TYPE_SET(Decomposition%DECOMPOSITION,DecompositionType,Err,ERROR,*999)

    CALL EXITS("CMISSDecompositionTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSDecompositionTypeSetObj",Err,ERROR)
    CALL EXITS("CMISSDecompositionTypeSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSDecompositionTypeSetObj

  !  
  !================================================================================================================================
  !  

  !>Returns the domain for a given node in a decomposition identified by a user number.
  SUBROUTINE CMISSDecompositionNodeDomainGetNumber(RegionUserNumber,MeshUserNumber,DecompositionUserNumber, &
    & NodeUserNumber,MeshComponentNumber,Domain,Err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the mesh to get the node domain for.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber !<The user number of the mesh to get the node domain for.
    INTEGER(INTG), INTENT(IN) :: DecompositionUserNumber !<The user number of the decomposition to get the node domain for.
    INTEGER(INTG), INTENT(IN) :: NodeUserNumber !<The user number of the node to get the domain for.
    INTEGER(INTG), INTENT(IN) :: MeshComponentNumber !<The user number of the mesh component to get the domain for.
    INTEGER(INTG), INTENT(OUT) :: Domain !<On return, the computational domain of the node.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDecompositionNodeDomainGetNumber",Err,ERROR,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(MeshUserNumber,REGION,MESH,Err,ERROR,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(DecompositionUserNumber,MESH,DECOMPOSITION,Err,ERROR,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_NODE_DOMAIN_GET(DECOMPOSITION,NodeUserNumber,MeshComponentNumber,Domain,Err,ERROR,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(DecompositionUserNumber,"*",Err,ERROR))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSDecompositionNodeDomainGetNumber")
    RETURN
999 CALL ERRORS("CMISSDecompositionNodeDomainGetNumber",Err,ERROR)
    CALL EXITS("CMISSDecompositionNodeDomainGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSDecompositionNodeDomainGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the domain for a given node in a decomposition identified by an object. \todo Maybe swap Node and MeshComponent?
  SUBROUTINE CMISSDecompositionNodeDomainGetObj(Decomposition,NodeUserNumber,MeshComponentNumber,Domain,Err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: Decomposition !<The decomposition to get the domain for.
    INTEGER(INTG), INTENT(IN) :: NodeUserNumber !<The user number of the node to get the domain for.
    INTEGER(INTG), INTENT(IN) :: MeshComponentNumber !<The user number of the mesh component to get the domain for.
    INTEGER(INTG), INTENT(OUT) :: Domain !<On return, the computational domain of the node.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecompositionNodeDomainGetObj",Err,ERROR,*999)

    CALL DECOMPOSITION_NODE_DOMAIN_GET(Decomposition%DECOMPOSITION,NodeUserNumber,MeshComponentNumber,Domain,Err,ERROR,*999)

    CALL EXITS("CMISSDecompositionNodeDomainGetObj")
    RETURN
999 CALL ERRORS("CMISSDecompositionNodeDomainGetObj",Err,ERROR)
    CALL EXITS("CMISSDecompositionNodeDomainGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSDecompositionNodeDomainGetObj

  !
  !================================================================================================================================
  !
  
  !>Finishes the creation of a mesh for a mesh identified by a user number.
  SUBROUTINE CMISSMeshCreateFinishNumber(RegionUserNumber,MeshUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the mesh to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber !<The user number of the mesh to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSMeshCreateFinishNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(MeshUserNumber,REGION,MESH,Err,ERROR,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_CREATE_FINISH(MESH,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Mesh Create')
#endif

    CALL EXITS("CMISSMeshCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSMeshCreateFinishNumber",Err,ERROR)
    CALL EXITS("CMISSMeshCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshCreateFinishNumber

  !  
  !================================================================================================================================
  !  
 
  !>Finishes the creation of a mesh for a mesh identified by an object.
  SUBROUTINE CMISSMeshCreateFinishObj(Mesh,Err)
  
    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: Mesh !<The mesh to finish creating.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSMeshCreateFinishObj",Err,ERROR,*999)
 
    CALL MESH_CREATE_FINISH(Mesh%MESH,Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Mesh Create')
#endif

    CALL EXITS("CMISSMeshCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSMeshCreateFinishObj",Err,ERROR)
    CALL EXITS("CMISSMeshCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshCreateFinishObj

  !  
  !================================================================================================================================
  !  
  
  !>Starts the creation of a mesh for a mesh identified by a user number.
  SUBROUTINE CMISSMeshCreateStartNumber(MeshUserNumber,RegionUserNumber,NumberOfDimensions,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber !<The user number of the mesh to start the creation of.
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the mesh to start the creation of.
    INTEGER(INTG), INTENT(IN) :: NumberOfDimensions !<The number of dimensions for the mesh.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSMeshCreateStartNumber",Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Mesh Create')
#endif
 
    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_CREATE_START(MeshUserNumber,REGION,NumberOfDimensions,MESH,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSMeshCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSMeshCreateStartNumber",Err,ERROR)
    CALL EXITS("CMISSMeshCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshCreateStartNumber

  !  
  !================================================================================================================================
  !  
 
  !>Starts the creation of a mesh for a mesh identified by an object.
  SUBROUTINE CMISSMeshCreateStartObj(MeshUserNumber,Region,NumberOfDimensions,Mesh,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber !<The user number of the mesh to start the creation of.
    TYPE(CMISSRegionType), INTENT(IN) :: Region !<The region containing the mesh to start the creation of.
    INTEGER(INTG), INTENT(IN) :: NumberOfDimensions !<The number of dimensions for the mesh.
    TYPE(CMISSMeshType), INTENT(OUT) :: Mesh !<On return, the created mesh.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSMeshCreateStartObj",Err,ERROR,*999)
 
#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Mesh Create')
#endif

    CALL MESH_CREATE_START(MeshUserNumber,Region%REGION,NumberOfDimensions,Mesh%MESH,Err,ERROR,*999)

    CALL EXITS("CMISSMeshCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSMeshCreateStartObj",Err,ERROR)
    CALL EXITS("CMISSMeshCreateStartObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshCreateStartObj

  !  
  !================================================================================================================================
  !  
  
  !>Destroys a mesh identified by a user number.
  SUBROUTINE CMISSMeshDestroyNumber(RegionUserNumber,MeshUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the mesh to destroy.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber !<The user number of the mesh to destroy.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSMeshDestroyNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(MeshUserNumber,REGION,MESH,Err,ERROR,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_DESTROY(MESH,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSMeshDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSMeshDestroyNumber",Err,ERROR)
    CALL EXITS("CMISSMeshDestroyNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshDestroyNumber

  !  
  !================================================================================================================================
  !  
 
  !>Destroys a mesh identified by an object.
  SUBROUTINE CMISSMeshDestroyObj(Mesh,Err)
  
    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: Mesh !<The mesh to destroy.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSMeshDestroyObj",Err,ERROR,*999)
 
    CALL MESH_DESTROY(Mesh%MESH,Err,ERROR,*999)

    CALL EXITS("CMISSMeshDestroyObj")
    RETURN
999 CALL ERRORS("CMISSMeshDestroyObj",Err,ERROR)
    CALL EXITS("CMISSMeshDestroyObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshDestroyObj

  !  
  !================================================================================================================================
  !  
 
  !>Returns the number of components in a mesh identified by a user number.
  SUBROUTINE CMISSMeshNumberOfComponentsGetNumber(RegionUserNumber,MeshUserNumber,NumberOfComponents,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the mesh to get the number of components for.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber !<The user number of the mesh to get the number of components for.
    INTEGER(INTG), INTENT(OUT) :: NumberOfComponents !<On return, the number of components in the mesh.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSMeshNumberOfComponentsGetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(MeshUserNumber,REGION,MESH,Err,ERROR,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_NUMBER_OF_COMPONENTS_GET(MESH,NumberOfComponents,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSMeshNumberOfComponentsGetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshNumberOfComponentsGetNumber",Err,ERROR)
    CALL EXITS("CMISSMeshNumberOfComponentsGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshNumberOfComponentsGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the number of components in a mesh identified by an object.
  SUBROUTINE CMISSMeshNumberOfComponentsGetObj(Mesh,NumberOfComponents,Err)
  
    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: Mesh !<The mesh to get the number of components for.
    INTEGER(INTG), INTENT(OUT) :: NumberOfComponents !<On return, the number of components in the mesh.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSMeshNumberOfComponentsGetObj",Err,ERROR,*999)
 
    CALL MESH_NUMBER_OF_COMPONENTS_GET(Mesh%MESH,NumberOfComponents,Err,ERROR,*999)

    CALL EXITS("CMISSMeshNumberOfComponentsGetObj")
    RETURN
999 CALL ERRORS("CMISSMeshNumberOfComponentsGetObj",Err,ERROR)
    CALL EXITS("CMISSMeshNumberOfComponentsGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshNumberOfComponentsGetObj
  
  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the number of components in a mesh identified by a user number.
  SUBROUTINE CMISSMeshNumberOfComponentsSetNumber(RegionUserNumber,MeshUserNumber,NumberOfComponents,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the mesh to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber !<The user number of the mesh to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: NumberOfComponents !<The number of components in the mesh to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSMeshNumberOfComponentsSetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(MeshUserNumber,REGION,MESH,Err,ERROR,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_NUMBER_OF_COMPONENTS_SET(MESH,NumberOfComponents,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSMeshNumberOfComponentsSetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshNumberOfComponentsSetNumber",Err,ERROR)
    CALL EXITS("CMISSMeshNumberOfComponentsSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshNumberOfComponentsSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the number of components in a mesh identified by an object.
  SUBROUTINE CMISSMeshNumberOfComponentsSetObj(Mesh,NumberOfComponents,Err)
  
    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: Mesh !<The mesh to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: NumberOfComponents !<The number of components in the mesh to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSMeshNumberOfComponentsSetObj",Err,ERROR,*999)
 
    CALL MESH_NUMBER_OF_COMPONENTS_SET(Mesh%MESH,NumberOfComponents,Err,ERROR,*999)

    CALL EXITS("CMISSMeshNumberOfComponentsSetObj")
    RETURN
999 CALL ERRORS("CMISSMeshNumberOfComponentsSetObj",Err,ERROR)
    CALL EXITS("CMISSMeshNumberOfComponentsSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshNumberOfComponentsSetObj
  
  !  
  !================================================================================================================================
  !  
 
  !>Returns the number of elements in a mesh identified by a user number.
  SUBROUTINE CMISSMeshNumberOfElementsGetNumber(RegionUserNumber,MeshUserNumber,NumberOfElements,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the mesh to get the number of elements for.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber !<The user number of the mesh to get the number of elements for.
    INTEGER(INTG), INTENT(OUT) :: NumberOfElements !<On return, the number of elements in the mesh.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSMeshNumberOfElementsGetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(MeshUserNumber,REGION,MESH,Err,ERROR,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_NUMBER_OF_ELEMENTS_GET(MESH,NumberOfElements,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSMeshNumberOfElementsGetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshNumberOfElementsGetNumber",Err,ERROR)
    CALL EXITS("CMISSMeshNumberOfElementsGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshNumberOfElementsGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the number of elements in a mesh identified by an object.
  SUBROUTINE CMISSMeshNumberOfElementsGetObj(Mesh,NumberOfElements,Err)
  
    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: Mesh !<The mesh to get the number of elements for.
    INTEGER(INTG), INTENT(OUT) :: NumberOfElements !<On return, the number of elements in the mesh.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSMeshNumberOfElementsGetObj",Err,ERROR,*999)
 
    CALL MESH_NUMBER_OF_ELEMENTS_GET(Mesh%MESH,NumberOfElements,Err,ERROR,*999)

    CALL EXITS("CMISSMeshNumberOfElementsGetObj")
    RETURN
999 CALL ERRORS("CMISSMeshNumberOfElementsGetObj",Err,ERROR)
    CALL EXITS("CMISSMeshNumberOfElementsGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshNumberOfElementsGetObj
  
  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the number of elements in a mesh identified by a user number.
  SUBROUTINE CMISSMeshNumberOfElementsSetNumber(RegionUserNumber,MeshUserNumber,NumberOfElements,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber !<The user number of the mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: NumberOfElements !<The number of elements in the mesh to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSMeshNumberOfElementsSetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(MeshUserNumber,REGION,MESH,Err,ERROR,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_NUMBER_OF_ELEMENTS_SET(MESH,NumberOfElements,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSMeshNumberOfElementsSetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshNumberOfElementsSetNumber",Err,ERROR)
    CALL EXITS("CMISSMeshNumberOfElementsSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshNumberOfElementsSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the number of elements in a mesh identified by an object.
  SUBROUTINE CMISSMeshNumberOfElementsSetObj(Mesh,NumberOfElements,Err)
  
    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: Mesh !<The mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: NumberOfElements !<The number of elements in the mesh to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSMeshNumberOfElementsSetObj",Err,ERROR,*999)
 
    CALL MESH_NUMBER_OF_ELEMENTS_SET(Mesh%MESH,NumberOfElements,Err,ERROR,*999)

    CALL EXITS("CMISSMeshNumberOfElementsSetObj")
    RETURN
999 CALL ERRORS("CMISSMeshNumberOfElementsSetObj",Err,ERROR)
    CALL EXITS("CMISSMeshNumberOfElementsSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshNumberOfElementsSetObj
  
  !  
  !================================================================================================================================
  !  
 
  !>Finishes creating elements for a mesh component of a mesh identified by a user number.
  SUBROUTINE CMISSMeshElementsCreateFinishNumber(RegionUserNumber,MeshUserNumber,MeshComponentNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the mesh to finish creating the elements for.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber !<The user number of the mesh to finish creating the elements for.
    INTEGER(INTG), INTENT(IN) :: MeshComponentNumber !<The mesh component number of the mesh to finish creating the elements for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MESH_ELEMENTS_TYPE), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSMeshElementsCreateFinishNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(MeshUserNumber,REGION,MESH,Err,ERROR,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,MeshComponentNumber,MESH_ELEMENTS,Err,ERROR,*999)
        CALL MESH_TOPOLOGY_ELEMENTS_CREATE_FINISH(MESH_ELEMENTS,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSMeshElementsCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSMeshElementsCreateFinishNumber",Err,ERROR)
    CALL EXITS("CMISSMeshElementsCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshElementsCreateFinishNumber

  !  
  !================================================================================================================================
  !  
 
  !>Finishes creating elements for a mesh component of a mesh identified by an object.
  SUBROUTINE CMISSMeshElementsCreateFinishObj(MeshElements,Err)
  
    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(IN) :: MeshElements !<The mesh elements to finish creating.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSMeshElementsCreateFinishObj",Err,ERROR,*999)
 
    CALL MESH_TOPOLOGY_ELEMENTS_CREATE_FINISH(MeshElements%MESH_ELEMENTS,Err,ERROR,*999)

    CALL EXITS("CMISSMeshElementsCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSMeshElementsCreateFinishObj",Err,ERROR)
    CALL EXITS("CMISSMeshElementsCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshElementsCreateFinishObj
  
  !  
  !================================================================================================================================
  !  
 
  !>Starts creating elements for a mesh component of a mesh identified by a user number.
  SUBROUTINE CMISSMeshElementsCreateStartNumber(RegionUserNumber,MeshUserNumber,MeshComponentNumber,BasisUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the mesh to start creating the elements for.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber !<The user number of the mesh to start creating the elements for.
    INTEGER(INTG), INTENT(IN) :: MeshComponentNumber !<The mesh component number of the mesh to start creating the elements for.
    INTEGER(INTG), INTENT(IN) :: BasisUserNumber !<The user number of the default basis to use for the elements.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MESH_ELEMENTS_TYPE), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSMeshElementsCreateStartNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(BASIS)
    NULLIFY(MESH_ELEMENTS)    
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(MeshUserNumber,REGION,MESH,Err,ERROR,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL BASIS_USER_NUMBER_FIND(BasisUserNumber,BASIS,Err,ERROR,*999)
        IF(ASSOCIATED(BASIS)) THEN
          CALL MESH_TOPOLOGY_ELEMENTS_CREATE_START(MESH,MeshComponentNumber,BASIS,MESH_ELEMENTS,Err,ERROR,*999)
        ELSE
          LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(BasisUserNumber,"*",Err,ERROR))// &
            & " does not exist."
          CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSMeshElementsCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSMeshElementsCreateStartNumber",Err,ERROR)
    CALL EXITS("CMISSMeshElementsCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshElementsCreateStartNumber

  !  
  !================================================================================================================================
  !  
 
  !>Starts creating elements for a mesh component of a mesh identified by an object.
  SUBROUTINE CMISSMeshElementsCreateStartObj(Mesh,MeshComponentNumber,Basis,MeshElements,Err)
  
    !Argument variables
    TYPE(CMISSMeshType), INTENT(INOUT) :: Mesh !<The mesh to start the creation of elements for.
    INTEGER(INTG), INTENT(IN) :: MeshComponentNumber !<The mesh component number of the mesh to start creating the elements for.
    TYPE(CMISSBasisType), INTENT(IN) :: Basis !<The default basis to use for the elements. 
    TYPE(CMISSMeshElementsType), INTENT(OUT) :: MeshElements !<On return, the created mesh elements.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSMeshElementsCreateStartObj",Err,ERROR,*999)
 
    CALL MESH_TOPOLOGY_ELEMENTS_CREATE_START(Mesh%MESH,MeshComponentNumber,Basis%BASIS,MeshElements%MESH_ELEMENTS,Err,ERROR,*999)

    CALL EXITS("CMISSMeshElementsCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSMeshElementsCreateStartObj",Err,ERROR)
    CALL EXITS("CMISSMeshElementsCreateStartObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshElementsCreateStartObj
  
  !  
  !================================================================================================================================
  !  
 
  !>Returns the basis for an element in a mesh identified by an user number. \todo should the global element number be a user number?
  SUBROUTINE CMISSMeshElementsBasisGetNumber(RegionUserNumber,MeshUserNumber,MeshComponentNumber,GlobalElementNumber, &
    & BasisUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the mesh to get the basis for.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber !<The user number of the mesh to get the basis for.
    INTEGER(INTG), INTENT(IN) :: MeshComponentNumber !<The mesh component number to get the basis for.
    INTEGER(INTG), INTENT(IN) :: GlobalElementNumber !<The global element number to get the basis for.
    INTEGER(INTG), INTENT(OUT) :: BasisUserNumber !<On return, the user number of the basis for the element.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MESH_ELEMENTS_TYPE), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSMeshElementsBasisGetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    NULLIFY(BASIS)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(MeshUserNumber,REGION,MESH,Err,ERROR,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,MeshComponentNumber,MESH_ELEMENTS,Err,ERROR,*999)
        CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_BASIS_GET(GlobalElementNumber,MESH_ELEMENTS,BASIS,Err,ERROR,*999)
        IF(ASSOCIATED(BASIS)) THEN
          BasisUserNumber = BASIS%USER_NUMBER
        ELSE
          LOCAL_ERROR="The basis is not associated for global element number "// &
            & TRIM(NUMBER_TO_VSTRING(GlobalElementNumber,"*",Err,ERROR))//" of mesh component number "// &
            & TRIM(NUMBER_TO_VSTRING(MeshComponentNumber,"*",Err,ERROR))//" from the mesh with a user number of "//&
            & TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))//" in the region with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSMeshElementsBasisGetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshElementsBasisGetNumber",Err,ERROR)
    CALL EXITS("CMISSMeshElementsBasisGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshElementsBasisGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the basis for an element in a mesh identified by an object. \todo should the global element number be a user number?
  SUBROUTINE CMISSMeshElementsBasisGetObj(MeshElements,GlobalElementNumber,Basis,Err)
  
    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(IN) :: MeshElements !<The mesh elements to get the basis for.
    INTEGER(INTG), INTENT(IN) :: GlobalElementNumber !<The global element number to get the basis for.
    TYPE(CMISSBasisType), INTENT(OUT) :: Basis !<On return, the basis for the element.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSMeshElementsBasisGetObj",Err,ERROR,*999)
 
    CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_BASIS_GET(GlobalElementNumber,MeshElements%MESH_ELEMENTS,Basis%BASIS,Err,ERROR,*999)

    CALL EXITS("CMISSMeshElementsBasisGetObj")
    RETURN
999 CALL ERRORS("CMISSMeshElementsBasisGetObj",Err,ERROR)
    CALL EXITS("CMISSMeshElementsBasisGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshElementsBasisGetObj
  
  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the basis for an element in a mesh identified by an user number. \todo should the global element number be a user number?
  SUBROUTINE CMISSMeshElementsBasisSetNumber(RegionUserNumber,MeshUserNumber,MeshComponentNumber,GlobalElementNumber, &
    & BasisUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber !<The user number of the mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: MeshComponentNumber !<The mesh component number to set the basis for.
    INTEGER(INTG), INTENT(IN) :: GlobalElementNumber !<The global element number to set the basis for.
    INTEGER(INTG), INTENT(IN) :: BasisUserNumber !<The user number of the basis for the element to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MESH_ELEMENTS_TYPE), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSMeshElementsBasisSetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    NULLIFY(BASIS)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(MeshUserNumber,REGION,MESH,Err,ERROR,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,MeshComponentNumber,MESH_ELEMENTS,Err,ERROR,*999)
        CALL BASIS_USER_NUMBER_FIND(BasisUserNumber,BASIS,Err,ERROR,*999)
        IF(ASSOCIATED(BASIS)) THEN
          CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_BASIS_SET(GlobalElementNumber,MESH_ELEMENTS,BASIS,Err,ERROR,*999)
        ELSE
          LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(BasisUserNumber,"*",Err,ERROR))// &
            & " does not exist."
          CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSMeshElementsBasisSetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshElementsBasisSetNumber",Err,ERROR)
    CALL EXITS("CMISSMeshElementsBasisSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshElementsBasisSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the basis for an element in a mesh identified by an object. \todo should the global element number be a user number?
  SUBROUTINE CMISSMeshElementsBasisSetObj(MeshElements,GlobalElementNumber,Basis,Err)
  
    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(IN) :: MeshElements !<The mesh elements to set the basis for.
    INTEGER(INTG), INTENT(IN) :: GlobalElementNumber !<The global element number to set the basis for.
    TYPE(CMISSBasisType), INTENT(IN) :: Basis !<The basis for the element to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSMeshElementsBasisSetObj",Err,ERROR,*999)
 
    CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_BASIS_SET(GlobalElementNumber,MeshElements%MESH_ELEMENTS,Basis%BASIS,Err,ERROR,*999)

    CALL EXITS("CMISSMeshElementsBasisSetObj")
    RETURN
999 CALL ERRORS("CMISSMeshElementsBasisSetObj",Err,ERROR)
    CALL EXITS("CMISSMeshElementsBasisSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshElementsBasisSetObj
  
  !  
  !================================================================================================================================
  !  
 
  !>Returns the element nodes for an element in a mesh identified by an user number. \todo should the global element number be a user number?
  SUBROUTINE CMISSMeshElementsNodesGetNumber(RegionUserNumber,MeshUserNumber,MeshComponentNumber,GlobalElementNumber, &
    & ElementUserNodes,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the mesh to get the element nodes for.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber !<The user number of the mesh to get the element nodes for.
    INTEGER(INTG), INTENT(IN) :: MeshComponentNumber !<The mesh component number to get the element nodes for.
    INTEGER(INTG), INTENT(IN) :: GlobalElementNumber !<The global element number to get the element nodes for.
    INTEGER(INTG), INTENT(OUT) :: ElementUserNodes(:) !<ElementUserNodes(i). On return, the user node number number of the i'th element node.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MESH_ELEMENTS_TYPE), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSMeshElementsNodesGetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(MeshUserNumber,REGION,MESH,Err,ERROR,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,MeshComponentNumber,MESH_ELEMENTS,Err,ERROR,*999)
        CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_NODES_GET(GlobalElementNumber,MESH_ELEMENTS,ElementUserNodes,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSMeshElementsNodesGetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshElementsNodesGetNumber",Err,ERROR)
    CALL EXITS("CMISSMeshElementsNodesGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshElementsNodesGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the element nodes for an element in a mesh identified by an object. \todo should the global element number be a user number?
  SUBROUTINE CMISSMeshElementsNodesGetObj(MeshElements,GlobalElementNumber,ElementUserNodes,Err)
  
    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(IN) :: MeshElements !<The mesh elements to get the element nodes for.
    INTEGER(INTG), INTENT(IN) :: GlobalElementNumber !<The global element number to get the element nodes for.
    INTEGER(INTG), INTENT(OUT) :: ElementUserNodes(:) !<ElementUserNodes(i). On return, the user node number number of the i'th element node.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSMeshElementsNodesGetObj",Err,ERROR,*999)
 
    CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_NODES_GET(GlobalElementNumber,MeshElements%MESH_ELEMENTS,ElementUserNodes,Err,ERROR,*999)

    CALL EXITS("CMISSMeshElementsNodesGetObj")
    RETURN
999 CALL ERRORS("CMISSMeshElementsNodesGetObj",Err,ERROR)
    CALL EXITS("CMISSMeshElementsNodesGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshElementsNodesGetObj
  
  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the element nodes for an element in a mesh identified by an user number. \todo should the global element number be a user number?
  SUBROUTINE CMISSMeshElementsNodesSetNumber(RegionUserNumber,MeshUserNumber,MeshComponentNumber,GlobalElementNumber, &
    & ElementUserNodes,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the mesh to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber !<The user number of the mesh to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: MeshComponentNumber !<The mesh component number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: GlobalElementNumber !<The global element number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: ElementUserNodes(:) !<ElementUserNodes(i). The user node number number of the i'th element node to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MESH_ELEMENTS_TYPE), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSMeshElementsNodesSetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(MeshUserNumber,REGION,MESH,Err,ERROR,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,MeshComponentNumber,MESH_ELEMENTS,Err,ERROR,*999)
        CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_NODES_SET(GlobalElementNumber,MESH_ELEMENTS,ElementUserNodes,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSMeshElementsNodesSetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshElementsNodesSetNumber",Err,ERROR)
    CALL EXITS("CMISSMeshElementsNodesSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshElementsNodesSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the element nodes for an element in a mesh identified by an object. \todo should the global element number be a user number?
  SUBROUTINE CMISSMeshElementsNodesSetObj(MeshElements,GlobalElementNumber,ElementUserNodes,Err)
  
    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(IN) :: MeshElements !<The mesh elements to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: GlobalElementNumber !<The global element number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: ElementUserNodes(:) !<ElementUserNodes(i). The user node number number of the i'th element node to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSMeshElementsNodesSetObj",Err,ERROR,*999)
 
    CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_NODES_SET(GlobalElementNumber,MeshElements%MESH_ELEMENTS,ElementUserNodes,Err,ERROR,*999)

    CALL EXITS("CMISSMeshElementsNodesSetObj")
    RETURN
999 CALL ERRORS("CMISSMeshElementsNodesSetObj",Err,ERROR)
    CALL EXITS("CMISSMeshElementsNodesSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshElementsNodesSetObj
  
  !  
  !================================================================================================================================
  !  
 
  !>Returns the user number for an element in a mesh identified by an user number. 
  SUBROUTINE CMISSMeshElementsUserNumberGetNumber(RegionUserNumber,MeshUserNumber,MeshComponentNumber,ElementGlobalNumber, &
    & ElementUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the mesh to get the element user number for.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber !<The user number of the mesh to get the element user number for.
    INTEGER(INTG), INTENT(IN) :: MeshComponentNumber !<The mesh component number to get the element user number for.
    INTEGER(INTG), INTENT(IN) :: ElementGlobalNumber !<The global element number to get the element user number for.
    INTEGER(INTG), INTENT(OUT) :: ElementUserNumber !<On return, the element user number.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MESH_ELEMENTS_TYPE), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSMeshElementsUserNumberGetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(MeshUserNumber,REGION,MESH,Err,ERROR,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,MeshComponentNumber,MESH_ELEMENTS,Err,ERROR,*999)
        CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_USER_NUMBER_GET(ElementGlobalNumber,ElementUserNumber,MESH_ELEMENTS,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSMeshElementsUserNumberGetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshElementsUserNumberGetNumber",Err,ERROR)
    CALL EXITS("CMISSMeshElementsUserNumberGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshElementsUserNumberGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the element user number for an element in a mesh identified by an object. 
  SUBROUTINE CMISSMeshElementsUserNumberGetObj(MeshElements,ElementGlobalNumber,ElementUserNumber,Err)
  
    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(IN) :: MeshElements !<The mesh elements to get the element nodes for.
    INTEGER(INTG), INTENT(IN) :: ElementGlobalNumber !<The global element number to get the element user number for.
    INTEGER(INTG), INTENT(OUT) :: ElementUserNumber !<On return, the element user number.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSMeshElementsUserNumberGetObj",Err,ERROR,*999)
 
    CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_USER_NUMBER_GET(ElementGlobalNumber,ElementUserNumber,MeshElements%MESH_ELEMENTS, &
      & Err,ERROR,*999)

    CALL EXITS("CMISSMeshElementsUserNumberGetObj")
    RETURN
999 CALL ERRORS("CMISSMeshElementsUserNumberGetObj",Err,ERROR)
    CALL EXITS("CMISSMeshElementsUserNumberGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshElementsUserNumberGetObj
  
  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the user number for an element in a mesh identified by an user number. 
  SUBROUTINE CMISSMeshElementsUserNumberSetNumber(RegionUserNumber,MeshUserNumber,MeshComponentNumber,ElementGlobalNumber, &
    & ElementUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the mesh to set the element user number for.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber !<The user number of the mesh to set the element user number for.
    INTEGER(INTG), INTENT(IN) :: MeshComponentNumber !<The mesh component number to set the element user number for.
    INTEGER(INTG), INTENT(IN) :: ElementGlobalNumber !<The global element number to set the element user number for.
    INTEGER(INTG), INTENT(IN) :: ElementUserNumber !<The element user number to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MESH_ELEMENTS_TYPE), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSMeshElementsUserNumberSetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(MeshUserNumber,REGION,MESH,Err,ERROR,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,MeshComponentNumber,MESH_ELEMENTS,Err,ERROR,*999)
        CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_USER_NUMBER_SET(ElementGlobalNumber,ElementUserNumber,MESH_ELEMENTS,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSMeshElementsUserNumberSetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshElementsUserNumberSetNumber",Err,ERROR)
    CALL EXITS("CMISSMeshElementsUserNumberSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshElementsUserNumberSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the element user number for an element in a mesh identified by an object. 
  SUBROUTINE CMISSMeshElementsUserNumberSetObj(MeshElements,ElementGlobalNumber,ElementUserNumber,Err)
  
    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(IN) :: MeshElements !<The mesh elements to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: ElementGlobalNumber !<The global element number to set the element user number for.
    INTEGER(INTG), INTENT(IN) :: ElementUserNumber !<The element user number to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSMeshElementsUserNumberSetObj",Err,ERROR,*999)
 
    CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_USER_NUMBER_SET(ElementGlobalNumber,ElementUserNumber,MeshElements%MESH_ELEMENTS, &
      & Err,ERROR,*999)

    CALL EXITS("CMISSMeshElementsUserNumberSetObj")
    RETURN
999 CALL ERRORS("CMISSMeshElementsUserNumberSetObj",Err,ERROR)
    CALL EXITS("CMISSMeshElementsUserNumberSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMeshElementsUserNumberSetObj 

!!==================================================================================================================================
!!
!! NODE_ROUTINES
!!
!!==================================================================================================================================

  !>Finishes the process of creating nodes in a region for nodes identified by user number.
  SUBROUTINE CMISSNodesCreateFinishNumber(RegionUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the nodes to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSNodesCreateFinishNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,Err,ERROR,*999)
      CALL NODES_CREATE_FINISH(NODES,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Nodes Create')
#endif

    CALL EXITS("CMISSNodesCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSNodesCreateFinishNumber",Err,ERROR)
    CALL EXITS("CMISSNodesCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSNodesCreateFinishNumber

  !  
  !================================================================================================================================
  !  
 
  !>Finishes the creation of a nodes in a region for nodes identified by an object.
  SUBROUTINE CMISSNodesCreateFinishObj(Nodes,Err)
  
    !Argument variables
    TYPE(CMISSNodesType), INTENT(IN) :: Nodes !<The nodes to finish creating.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSNodesCreateFinishObj",Err,ERROR,*999)
 
    CALL NODES_CREATE_FINISH(Nodes%NODES,Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Nodes Create')
#endif

    CALL EXITS("CMISSNodesCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSNodesCreateFinishObj",Err,ERROR)
    CALL EXITS("CMISSNodesCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSNodesCreateFinishObj

  !  
  !================================================================================================================================
  !
  
  !>Starts the process of creating nodes in a region for nodes identified by user number.
  SUBROUTINE CMISSNodesCreateStartNumber(RegionUserNumber,NumberOfNodes,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the nodes to start the creation of.
    INTEGER(INTG), INTENT(IN) :: NumberOfNodes !<The number of nodes to create.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSNodesCreateStartNumber",Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Nodes Create')
#endif
 
    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL NODES_CREATE_START(REGION,NumberOfNodes,NODES,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSNodesCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSNodesCreateStartNumber",Err,ERROR)
    CALL EXITS("CMISSNodesCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSNodesCreateStartNumber

  !  
  !================================================================================================================================
  !  
 
  !>Starts the creation of a nodes in a region for nodes identified by an object.
  SUBROUTINE CMISSNodesCreateStartObj(Region,NumberOfNodes,Nodes,Err)
  
    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: Region !<The region to start the creation of nodes on.
    INTEGER(INTG), INTENT(IN) :: NumberOfNodes !<The number of nodes to create.
    TYPE(CMISSNodesType), INTENT(IN) :: Nodes !<On return, the created nodes.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSNodesCreateStartObj",Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Nodes Create')
#endif

    CALL NODES_CREATE_START(Region%REGION,NumberOfNodes,Nodes%NODES,Err,ERROR,*999)

    CALL EXITS("CMISSNodesCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSNodesCreateStartObj",Err,ERROR)
    CALL EXITS("CMISSNodesCreateStartObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSNodesCreateStartObj

  !  
  !================================================================================================================================
  !
  
  !>Destroys the nodes in a region for nodes identified by user number.
  SUBROUTINE CMISSNodesDestroyNumber(RegionUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the nodes to destroy.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSNodesDestroyNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,Err,ERROR,*999)
      CALL NODES_DESTROY(NODES,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSNodesDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSNodesDestroyNumber",Err,ERROR)
    CALL EXITS("CMISSNodesDestroyNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSNodesDestroyNumber

  !  
  !================================================================================================================================
  !  
 
  !>Destroys the nodes in a region for nodes identified by an object.
  SUBROUTINE CMISSNodesDestroyObj(Nodes,Err)
  
    !Argument variables
    TYPE(CMISSNodesType), INTENT(IN) :: Nodes !<The nodes to destroy.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSNodeDestroyObj",Err,ERROR,*999)
 
    CALL NODES_DESTROY(Nodes%NODES,Err,ERROR,*999)

    CALL EXITS("CMISSNodesDestroyObj")
    RETURN
999 CALL ERRORS("CMISSNodesDestroyObj",Err,ERROR)
    CALL EXITS("CMISSNodesDestroyObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSNodesDestroyObj

  !  
  !================================================================================================================================
  !
  
  !>Returns the character label for a node in a set of nodes identified by user number. \todo should this be user number??
  SUBROUTINE CMISSNodesLabelGetCNumber(RegionUserNumber,NodeGlobalNumber,Label,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the nodes to get the label for.
    INTEGER(INTG), INTENT(IN) :: NodeGlobalNumber !<The global number of the nodes to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: Label !<On return, the label for the node.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSNodesLabelGetCNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,Err,ERROR,*999)
      CALL NODES_LABEL_GET(NODES,NodeGlobalNumber,Label,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSNodesLabelGetCNumber")
    RETURN
999 CALL ERRORS("CMISSNodesLabelGetCNumber",Err,ERROR)
    CALL EXITS("CMISSNodesLabelGetCNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSNodesLabelGetCNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the character label for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE CMISSNodesLabelGetCObj(Nodes,NodeGlobalNumber,Label,Err)
  
    !Argument variables
    TYPE(CMISSNodesType), INTENT(IN) :: Nodes !<The nodes to get the label for.
    INTEGER(INTG), INTENT(IN) :: NodeGlobalNumber !<The global number of the nodes to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: Label !<On return, the label for the node.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSNodesLabelGetCObj",Err,ERROR,*999)
 
    CALL NODES_LABEL_GET(Nodes%NODES,NodeGlobalNumber,Label,Err,ERROR,*999)

    CALL EXITS("CMISSNodesLabelGetCObj")
    RETURN
999 CALL ERRORS("CMISSNodesLabelGetCObj",Err,ERROR)
    CALL EXITS("CMISSNodesLabelGetCObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSNodesLabelGetCObj

  !  
  !================================================================================================================================
  !
  
  !>Returns the varying string label for a node in a set of nodes identified by user number. \todo should this be user number??
  SUBROUTINE CMISSNodesLabelGetVSNumber(RegionUserNumber,NodeGlobalNumber,Label,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the nodes to get the label for.
    INTEGER(INTG), INTENT(IN) :: NodeGlobalNumber !<The global number of the nodes to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: Label !<On return, the label for the node.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSNodesLabelGetVSNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,Err,ERROR,*999)
      CALL NODES_LABEL_GET(NODES,NodeGlobalNumber,Label,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSNodesLabelGetVSNumber")
    RETURN
999 CALL ERRORS("CMISSNodesLabelGetVSNumber",Err,ERROR)
    CALL EXITS("CMISSNodesLabelGetVSNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSNodesLabelGetVSNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the varying string label for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE CMISSNodesLabelGetVSObj(Nodes,NodeGlobalNumber,Label,Err)
  
    !Argument variables
    TYPE(CMISSNodesType), INTENT(IN) :: Nodes !<The nodes to get the label for.
    INTEGER(INTG), INTENT(IN) :: NodeGlobalNumber !<The global number of the nodes to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: Label !<On return, the label for the node.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSNodesLabelGetVSObj",Err,ERROR,*999)
 
    CALL NODES_LABEL_GET(Nodes%NODES,NodeGlobalNumber,Label,Err,ERROR,*999)

    CALL EXITS("CMISSNodesLabelGetVSObj")
    RETURN
999 CALL ERRORS("CMISSNodesLabelGetVSObj",Err,ERROR)
    CALL EXITS("CMISSNodesLabelGetVSObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSNodesLabelGetVSObj

  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the character label for a node in a set of nodes identified by user number. \todo should this be user number??
  SUBROUTINE CMISSNodesLabelSetCNumber(RegionUserNumber,NodeGlobalNumber,Label,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the nodes to set the label for.
    INTEGER(INTG), INTENT(IN) :: NodeGlobalNumber !<The global number of the nodes to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: Label !<The label for the node to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSNodesLabelSetCNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,Err,ERROR,*999)
      CALL NODES_LABEL_SET(NODES,NodeGlobalNumber,Label,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSNodesLabelSetCNumber")
    RETURN
999 CALL ERRORS("CMISSNodesLabelSetCNumber",Err,ERROR)
    CALL EXITS("CMISSNodesLabelSetCNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSNodesLabelSetCNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the character label for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE CMISSNodesLabelSetCObj(Nodes,NodeGlobalNumber,Label,Err)
  
    !Argument variables
    TYPE(CMISSNodesType), INTENT(IN) :: Nodes !<The nodes to set the label for.
    INTEGER(INTG), INTENT(IN) :: NodeGlobalNumber !<The global number of the nodes to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: Label !<The label for the node to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSNodesLabelSetCObj",Err,ERROR,*999)
 
    CALL NODES_LABEL_SET(Nodes%NODES,NodeGlobalNumber,Label,Err,ERROR,*999)

    CALL EXITS("CMISSNodesLabelSetCObj")
    RETURN
999 CALL ERRORS("CMISSNodesLabelSetCObj",Err,ERROR)
    CALL EXITS("CMISSNodesLabelSetCObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSNodesLabelSetCObj

  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the varying string label for a node in a set of nodes identified by user number. \todo should this be user number??
  SUBROUTINE CMISSNodesLabelSetVSNumber(RegionUserNumber,NodeGlobalNumber,Label,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the nodes to set the label for.
    INTEGER(INTG), INTENT(IN) :: NodeGlobalNumber !<The global number of the nodes to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: Label !<The label for the node to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSNodesLabelSetVSNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,Err,ERROR,*999)
      CALL NODES_LABEL_SET(NODES,NodeGlobalNumber,Label,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSNodesLabelSetVSNumber")
    RETURN
999 CALL ERRORS("CMISSNodesLabelSetVSNumber",Err,ERROR)
    CALL EXITS("CMISSNodesLabelSetVSNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSNodesLabelSetVSNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the varying string label for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE CMISSNodesLabelSetVSObj(Nodes,NodeGlobalNumber,Label,Err)
  
    !Argument variables
    TYPE(CMISSNodesType), INTENT(IN) :: Nodes !<The nodes to set the label for.
    INTEGER(INTG), INTENT(IN) :: NodeGlobalNumber !<The global number of the nodes to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: Label !<The label for the node to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSNodesLabelSetVSObj",Err,ERROR,*999)
 
    CALL NODES_LABEL_SET(Nodes%NODES,NodeGlobalNumber,Label,Err,ERROR,*999)

    CALL EXITS("CMISSNodesLabelSetVSObj")
    RETURN
999 CALL ERRORS("CMISSNodesLabelSetVSObj",Err,ERROR)
    CALL EXITS("CMISSNodesLabelSetVSObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSNodesLabelSetVSObj

  !  
  !================================================================================================================================
  !
  
  !>Returns the user number for a node in a set of nodes identified by user number.
  SUBROUTINE CMISSNodesUserNumberGetNumber(RegionUserNumber,NodeGlobalNumber,NodeUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the nodes to get the node user number for.
    INTEGER(INTG), INTENT(IN) :: NodeGlobalNumber !<The global number of the nodes to get the node user number for.
    INTEGER(INTG), INTENT(OUT) :: NodeUserNumber !<On return, the user number for the node.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSNodesUserNumberGetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,Err,ERROR,*999)
      CALL NODES_USER_NUMBER_GET(NODES,NodeGlobalNumber,NodeUserNumber,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSNodesUserNumberGetNumber")
    RETURN
999 CALL ERRORS("CMISSNodesUserNumberGetNumber",Err,ERROR)
    CALL EXITS("CMISSNodesUserNumberGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSNodesUserNumberGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the user number for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE CMISSNodesUserNumberGetObj(Nodes,NodeGlobalNumber,NodeUserNumber,Err)
  
    !Argument variables
    TYPE(CMISSNodesType), INTENT(IN) :: Nodes !<The nodes to get the node user number for.
    INTEGER(INTG), INTENT(IN) :: NodeGlobalNumber !<The global number of the nodes to get the node user number for.
    INTEGER(INTG), INTENT(OUT) :: NodeUserNumber !<On return, the user number for the node.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSNodesUserNumberGetObj",Err,ERROR,*999)
 
    CALL NODES_USER_NUMBER_GET(Nodes%NODES,NodeGlobalNumber,NodeUserNumber,Err,ERROR,*999)

    CALL EXITS("CMISSNodesUserNumberGetObj")
    RETURN
999 CALL ERRORS("CMISSNodesUserNumberGetObj",Err,ERROR)
    CALL EXITS("CMISSNodesUserNumberGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSNodesUserNumberGetObj

  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the user number for a node in a set of nodes identified by user number.
  SUBROUTINE CMISSNodesUserNumberSetNumber(RegionUserNumber,NodeGlobalNumber,NodeUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the nodes to set the node user number for.
    INTEGER(INTG), INTENT(IN) :: NodeGlobalNumber !<The global number of the nodes to set the node user number for.
    INTEGER(INTG), INTENT(IN) :: NodeUserNumber !<The user number for the node to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSNodesUserNumberSetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,Err,ERROR,*999)
      CALL NODES_USER_NUMBER_SET(NODES,NodeGlobalNumber,NodeUserNumber,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSNodesUserNumberSetNumber")
    RETURN
999 CALL ERRORS("CMISSNodesUserNumberSetNumber",Err,ERROR)
    CALL EXITS("CMISSNodesUserNumberSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSNodesUserNumberSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the user number for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE CMISSNodesUserNumberSetObj(Nodes,NodeGlobalNumber,NodeUserNumber,Err)
  
    !Argument variables
    TYPE(CMISSNodesType), INTENT(IN) :: Nodes !<The nodes to set the node user number for.
    INTEGER(INTG), INTENT(IN) :: NodeGlobalNumber !<The global number of the nodes to set the node user number for.
    INTEGER(INTG), INTENT(IN) :: NodeUserNumber !<The user number for the node to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSNodesUserNumberSetObj",Err,ERROR,*999)
 
    CALL NODES_USER_NUMBER_SET(Nodes%NODES,NodeGlobalNumber,NodeUserNumber,Err,ERROR,*999)

    CALL EXITS("CMISSNodesUserNumberSetObj")
    RETURN
999 CALL ERRORS("CMISSNodesUserNumberSetObj",Err,ERROR)
    CALL EXITS("CMISSNodesUserNumberSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSNodesUserNumberSetObj

!!==================================================================================================================================
!!
!! PROBLEM_ROUTINES
!!
!!==================================================================================================================================

  !>Finishes the process of a problem identified by user number.
  SUBROUTINE CMISSProblemCreateFinishNumber(ProblemUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSProblemCreateFinishNumber",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CREATE_FINISH(PROBLEM,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Problem Create')
#endif

    CALL EXITS("CMISSProblemCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSProblemCreateFinishNumber",Err,ERROR)
    CALL EXITS("CMISSProblemCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemCreateFinishNumber

  !  
  !================================================================================================================================
  !  
 
  !>Finishes the creation of a problem identified by an object.
  SUBROUTINE CMISSProblemCreateFinishObj(Problem,Err)
  
    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: Problem !<The problem to finish creating.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSProblemCreateFinishObj",Err,ERROR,*999)
 
    CALL PROBLEM_CREATE_FINISH(Problem%PROBLEM,Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Problem Create')
#endif

    CALL EXITS("CMISSProblemCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSProblemCreateFinishObj",Err,ERROR)
    CALL EXITS("CMISSProblemCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemCreateFinishObj

  !  
  !================================================================================================================================
  !  
  
  !>Starts the process of a problem identified by user number.
  SUBROUTINE CMISSProblemCreateStartNumber(ProblemUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to start the creation of.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    
    CALL ENTERS("CMISSProblemCreateStartNumber",Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Problem Create')
#endif
 
    CALL PROBLEM_CREATE_START(ProblemUserNumber,PROBLEM,Err,ERROR,*999)

    CALL EXITS("CMISSProblemCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSProblemCreateStartNumber",Err,ERROR)
    CALL EXITS("CMISSProblemCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemCreateStartNumber

  !  
  !================================================================================================================================
  !  
 
  !>Starts the creation of a problem identified by an object.
  SUBROUTINE CMISSProblemCreateStartObj(ProblemUserNumber,Problem,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to start the creation of.
    TYPE(CMISSProblemType), INTENT(INOUT) :: Problem !<On return, the created problem.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSProblemCreateStartObj",Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Problem Create')
#endif
 
    CALL PROBLEM_CREATE_START(ProblemUserNumber,Problem%PROBLEM,Err,ERROR,*999)

    CALL EXITS("CMISSProblemCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSProblemCreateStartObj",Err,ERROR)
    CALL EXITS("CMISSProblemCreateStartObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemCreateStartObj

  !  
  !================================================================================================================================
  !  

  !>Destroys a problem identified by an user number.
  SUBROUTINE CMISSProblemDestroyNumber(ProblemUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to destroy.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSProblemDestroyNumber",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_DESTROY(PROBLEM,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSProblemDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSProblemDestroyNumber",Err,ERROR)
    CALL EXITS("CMISSProblemDestroyNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemDestroyNumber

  !  
  !================================================================================================================================
  !  
 
  !>Destroys a problem identified by an object.
  SUBROUTINE CMISSProblemDestroyObj(Problem,Err)
  
    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: Problem !<The problem to destroy.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSProblemDestroyObj",Err,ERROR,*999)
 
    CALL PROBLEM_DESTROY(Problem%PROBLEM,Err,ERROR,*999)

    CALL EXITS("CMISSProblemDestroyObj")
    RETURN
999 CALL ERRORS("CMISSProblemDestroyObj",Err,ERROR)
    CALL EXITS("CMISSProblemDestroyObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemDestroyObj

  !  
  !================================================================================================================================
  !
  
  !>Finishes the process of creating a control loop for a problem identified by user number.
  SUBROUTINE CMISSProblemControlLoopCreateFinishNumber(ProblemUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to finish creating the control loop for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSProblemControlLoopCreateFinishNumber",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_CREATE_FINISH(PROBLEM,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Problem Control Loop Create')
#endif

    CALL EXITS("CMISSProblemControlLoopCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSProblemControlLoopCreateFinishNumber",Err,ERROR)
    CALL EXITS("CMISSProblemControlLoopCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemControlLoopCreateFinishNumber

  !  
  !================================================================================================================================
  !  
 
  !>Finishes the creation of a control loop on a problem identified by an object.
  SUBROUTINE CMISSProblemControlLoopCreateFinishObj(Problem,Err)
  
    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: Problem !<The problem to finish creating the control loop for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSProblemControlLoopCreateFinishObj",Err,ERROR,*999)
 
    CALL PROBLEM_CONTROL_LOOP_CREATE_FINISH(Problem%PROBLEM,Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Problem Control Loop Create')
#endif

    CALL EXITS("CMISSProblemControlLoopCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSProblemControlLoopCreateFinishObj",Err,ERROR)
    CALL EXITS("CMISSProblemControlLoopCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemControlLoopCreateFinishObj

  !  
  !================================================================================================================================
  !
  
  !>Starts the process of creating a control loop for a problem identified by user number.
  SUBROUTINE CMISSProblemControlLoopCreateStartNumber(ProblemUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to start creating the control loop for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSProblemControlLoopCreateStartNumber",Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Problem Control Loop Create')
#endif

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_CREATE_START(PROBLEM,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSProblemControlLoopCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSProblemControlLoopCreateStartNumber",Err,ERROR)
    CALL EXITS("CMISSProblemControlLoopCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemControlLoopCreateStartNumber

  !  
  !================================================================================================================================
  !  
 
  !>Starts the creation of a control loop on a problem identified by an object.
  SUBROUTINE CMISSProblemControlLoopCreateStartObj(Problem,Err)
  
    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: Problem !<The problem to start creating the control loop for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSProblemControlLoopCreateStartObj",Err,ERROR,*999)
 
#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Problem Control Loop Create')
#endif

    CALL PROBLEM_CONTROL_LOOP_CREATE_START(Problem%PROBLEM,Err,ERROR,*999)

    CALL EXITS("CMISSProblemControlLoopCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSProblemControlLoopCreateStartObj",Err,ERROR)
    CALL EXITS("CMISSProblemControlLoopCreateStartObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemControlLoopCreateStartObj

  !  
  !================================================================================================================================
  !
  
  !>Destroys the control loops for a problem identified by user number.
  SUBROUTINE CMISSProblemControlLoopDestroyNumber(ProblemUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to destroy the control loops for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSProblemControlLoopDestroyNumber",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_DESTROY(PROBLEM,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSProblemControlLoopDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSProblemControlLoopDestroyNumber",Err,ERROR)
    CALL EXITS("CMISSProblemControlLoopDestroyNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemControlLoopDestroyNumber

  !  
  !================================================================================================================================
  !  
 
  !>Destroys the control loops on a problem identified by an object.
  SUBROUTINE CMISSProblemControlLoopDestroyObj(Problem,Err)
  
    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: Problem !<The problem to destroy the control loops for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSProblemControlLoopDestroyObj",Err,ERROR,*999)
 
    CALL PROBLEM_CONTROL_LOOP_DESTROY(Problem%PROBLEM,Err,ERROR,*999)

    CALL EXITS("CMISSProblemControlLoopDestroyObj")
    RETURN
999 CALL ERRORS("CMISSProblemControlLoopDestroyObj",Err,ERROR)
    CALL EXITS("CMISSProblemControlLoopDestroyObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemControlLoopDestroyObj

  !
  !================================================================================================================================
  !  
  
  !>Returns a control loop from a problem identified by an user number.
  SUBROUTINE CMISSProblemControlLoopGetNumber0(ProblemUserNumber,ControlLoopIdentifier,ControlLoop,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier.
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: ControlLoop !<On return, the specified problem control loop.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblemControlLoopGetNumber0",Err,ERROR,*999)
    
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,ControlLoopIdentifier,ControlLoop%CONTROL_LOOP,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF
    
    CALL EXITS("CMISSProblemControlLoopGetNumber0")
    RETURN
999 CALL ERRORS("CMISSProblemControlLoopGetNumber0",Err,ERROR)
    CALL EXITS("CMISSProblemControlLoopGetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemControlLoopGetNumber0

  !
  !================================================================================================================================
  !  
  
  !>Returns a control loop from a problem identified by an user number.
  SUBROUTINE CMISSProblemControlLoopGetNumber1(ProblemUserNumber,ControlLoopIdentifiers,ControlLoop,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to get the control loop for.
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: ControlLoop !<On return, the specified problem control loop.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
     TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblemControlLoopGetNumber1",Err,ERROR,*999)
    
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,ControlLoopIdentifiers,ControlLoop%CONTROL_LOOP,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSProblemControlLoopGetNumber1")
    RETURN
999 CALL ERRORS("CMISSProblemControlLoopGetNumber1",Err,ERROR)
    CALL EXITS("CMISSProblemControlLoopGetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemControlLoopGetNumber1
  
  !
  !================================================================================================================================
  !  
  
  !>Returns a control loop from a problem identified by an object.
  SUBROUTINE CMISSProblemControlLoopGetObj0(Problem,ControlLoopIdentifier,ControlLoop,Err)
  
    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: Problem !<The problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier.
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: ControlLoop !<On return, the specified problem control loop.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemControlLoopGetObj0",Err,ERROR,*999)

    CALL PROBLEM_CONTROL_LOOP_GET(Problem%PROBLEM,ControlLoopIdentifier,ControlLoop%CONTROL_LOOP,Err,ERROR,*999)
     
    CALL EXITS("CMISSProblemControlLoopGetObj0")
    RETURN
999 CALL ERRORS("CMISSProblemControlLoopGetObj0",Err,ERROR)
    CALL EXITS("CMISSProblemControlLoopGetObj0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemControlLoopGetObj0

  !
  !================================================================================================================================
  !  
  
  !>Returns a control loop from a problem identified by an object.
  SUBROUTINE CMISSProblemControlLoopGetObj1(Problem,ControlLoopIdentifiers,ControlLoop,Err)
  
    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: Problem !<The problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to get the control loop for.
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: ControlLoop !<On return, the specified problem control loop.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemControlLoopGetObj1",Err,ERROR,*999)
    
    CALL PROBLEM_CONTROL_LOOP_GET(Problem%PROBLEM,ControlLoopIdentifiers,ControlLoop%CONTROL_LOOP,Err,ERROR,*999)

    CALL EXITS("CMISSProblemControlLoopGetObj1")
    RETURN
999 CALL ERRORS("CMISSProblemControlLoopGetObj1",Err,ERROR)
    CALL EXITS("CMISSProblemControlLoopGetObj1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemControlLoopGetObj1
  
  !  
  !================================================================================================================================
  !    

  !>Solves a problem identified by an user number.
  SUBROUTINE CMISSProblemSolveNumber(ProblemUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to solve.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSProblemSolveNumber",Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Problem Solve')
#endif
 
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVE(PROBLEM,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Problem Solve')
#endif

    CALL EXITS("CMISSProblemSolveNumber")
    RETURN
999 CALL ERRORS("CMISSProblemSolveNumber",Err,ERROR)
    CALL EXITS("CMISSProblemSolveNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemSolveNumber

  !  
  !================================================================================================================================
  !    

  !>Solves a problem identified by an object.
  SUBROUTINE CMISSProblemSolveObj(Problem,Err)
  
    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: Problem !<The problem to solve.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    
    CALL ENTERS("CMISSProblemSolveObj",Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Problem Solve')
#endif

    CALL PROBLEM_SOLVE(Problem%PROBLEM,Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Problem Solve')
#endif

    CALL EXITS("CMISSProblemSolveObj")
    RETURN
999 CALL ERRORS("CMISSProblemSolveObj",Err,ERROR)
    CALL EXITS("CMISSProblemSolveObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemSolveObj

  !
  !================================================================================================================================
  !  
  
  !>Returns a solver from a problem identified by an user number.
  SUBROUTINE CMISSProblemSolverGetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,Solver,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to get the solver for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier to get the solver for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to get the solver for.
    TYPE(CMISSSolverType), INTENT(INOUT) :: Solver !<On return, the specified solver.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblemSolverGetNumber0",Err,ERROR,*999)
    
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,Solver%SOLVER,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF
    
    CALL EXITS("CMISSProblemSolverGetNumber0")
    RETURN
999 CALL ERRORS("CMISSProblemSolverGetNumber0",Err,ERROR)
    CALL EXITS("CMISSProblemSolverGetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemSolverGetNumber0

  !
  !================================================================================================================================
  !  
  
  !>Returns a solver from a problem identified by an user number.
  SUBROUTINE CMISSProblemSolverGetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,Solver,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to get the solver for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to get the solver for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to get the solver for.
    TYPE(CMISSSolverType), INTENT(INOUT) :: Solver !<On return, the specified solver.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
     TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblemSolverGetNumber1",Err,ERROR,*999)
    
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,Solver%SOLVER,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSProblemSolverGetNumber1")
    RETURN
999 CALL ERRORS("CMISSProblemSolverGetNumber1",Err,ERROR)
    CALL EXITS("CMISSProblemSolverGetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemSolverGetNumber1
  
  !
  !================================================================================================================================
  !  
  
  !>Returns a solver from a problem identified by an object.
  SUBROUTINE CMISSProblemSolverGetObj0(Problem,ControlLoopIdentifier,SolverIndex,Solver,Err)
  
    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: Problem !<The problem to get the solver for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier to get the solver for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to get the solver for.
    TYPE(CMISSSolverType), INTENT(INOUT) :: Solver !<On return, the specified solver.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemSolverGetObj0",Err,ERROR,*999)

    CALL PROBLEM_SOLVER_GET(Problem%PROBLEM,ControlLoopIdentifier,SolverIndex,Solver%SOLVER,Err,ERROR,*999)
     
    CALL EXITS("CMISSProblemSolverGetObj0")
    RETURN
999 CALL ERRORS("CMISSProblemSolverGetObj0",Err,ERROR)
    CALL EXITS("CMISSProblemSolverGetObj0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemSolverGetObj0

  !
  !================================================================================================================================
  !  
  
  !>Returns a solver from a problem identified by an object.
  SUBROUTINE CMISSProblemSolverGetObj1(Problem,ControlLoopIdentifiers,SolverIndex,Solver,Err)
  
    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: Problem !<The problem to get the solver for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to get the solver for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to get the solver for.
    TYPE(CMISSSolverType), INTENT(INOUT) :: Solver !<On return, the specified solver.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemSolverGetObj1",Err,ERROR,*999)
    
    CALL PROBLEM_SOLVER_GET(Problem%PROBLEM,ControlLoopIdentifiers,SolverIndex,Solver%SOLVER,Err,ERROR,*999)

    CALL EXITS("CMISSProblemSolverGetObj1")
    RETURN
999 CALL ERRORS("CMISSProblemSolverGetObj1",Err,ERROR)
    CALL EXITS("CMISSProblemSolverGetObj1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemSolverGetObj1
  
  !  
  !================================================================================================================================
  !    

  !>Finishes the process of creating solver equations for a problem identified by user number.
  SUBROUTINE CMISSProblemSolverEquationsCreateFinishNumber(ProblemUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to finish the creation of solver equations for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSProblemSolverEquationsCreateFinishNumber",Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Solver Equations Create')
#endif

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_CREATE_FINISH(PROBLEM,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSProblemSolverEquationsCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSProblemSolverEquationsCreateFinishNumber",Err,ERROR)
    CALL EXITS("CMISSProblemSolverEquationsCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemSolverEquationsCreateFinishNumber

  !  
  !================================================================================================================================
  !  
 
  !>Finishes the creation of solver equations for problem identified by an object.
  SUBROUTINE CMISSProblemSolverEquationsCreateFinishObj(Problem,Err)
  
    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: Problem !<The problem to finish creating the solver equations for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSProblemSolverEquationsCreateFinishObj",Err,ERROR,*999)
 
    CALL PROBLEM_SOLVER_EQUATIONS_CREATE_FINISH(Problem%PROBLEM,Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Solver Equations Create')
#endif

    CALL EXITS("CMISSProblemSolverEquationsCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSProblemSolverEquationsCreateFinishObj",Err,ERROR)
    CALL EXITS("CMISSProblemSolverEquationsCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemSolverEquationsCreateFinishObj

  !  
  !================================================================================================================================
  !    

  !>Starts the process of creating solver equations for a problem identified by user number.
  SUBROUTINE CMISSProblemSolverEquationsCreateStartNumber(ProblemUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to start the creation of solver equations for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSProblemSolverEquationsCreateStartNumber",Err,ERROR,*999)
 
#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Solver Equations Create')
#endif

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_CREATE_START(PROBLEM,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSProblemSolverEquationsCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSProblemSolverEquationsCreateStartNumber",Err,ERROR)
    CALL EXITS("CMISSProblemSolverEquationsCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemSolverEquationsCreateStartNumber

  !  
  !================================================================================================================================
  !  
 
  !>Starts the creation of solver equations for problem identified by an object.
  SUBROUTINE CMISSProblemSolverEquationsCreateStartObj(Problem,Err)
  
    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: Problem !<The problem to start creating the solver equations for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSProblemSolverEquationsCreateStartObj",Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Solver Equations Create')
#endif

    CALL PROBLEM_SOLVER_EQUATIONS_CREATE_START(Problem%PROBLEM,Err,ERROR,*999)

    CALL EXITS("CMISSProblemSolverEquationsCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSProblemSolverEquationsCreateStartObj",Err,ERROR)
    CALL EXITS("CMISSProblemSolverEquationsCreateStartObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemSolverEquationsCreateStartObj

  !  
  !================================================================================================================================
  !    

  !>Destroys the solver equations for a problem identified by an user number.
  SUBROUTINE CMISSProblemSolverEquationsDestroyNumber(ProblemUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to destroy solver equations for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSProblemSolverEquationsDestroyNumber",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_DESTROY(PROBLEM,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSProblemSolverEquationsDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSProblemSolverEquationsDestroyNumber",Err,ERROR)
    CALL EXITS("CMISSProblemSolverEquationsDestroyNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemSolverEquationsDestroyNumber

  !  
  !================================================================================================================================
  !  
 
  !>Destroys the solver equations for problem identified by an object.
  SUBROUTINE CMISSProblemSolverEquationsDestroyObj(Problem,Err)
  
    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: Problem !<The problem to destroy the solver equations for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSProblemSolverEquationsDestroyObj",Err,ERROR,*999)
 
    CALL PROBLEM_SOLVER_EQUATIONS_DESTROY(Problem%PROBLEM,Err,ERROR,*999)

    CALL EXITS("CMISSProblemSolverEquationsDestroyObj")
    RETURN
999 CALL ERRORS("CMISSProblemSolverEquationsDestroyObj",Err,ERROR)
    CALL EXITS("CMISSProblemSolverEquationsDestroyObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemSolverEquationsDestroyObj

  !
  !================================================================================================================================
  !  
  
  !>Returns the solver equations from a problem identified by an user number.
  SUBROUTINE CMISSProblemSolverEquationsGetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,SolverEquations,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to get the solver equations for.
    TYPE(CMISSSolverEquationsType), INTENT(INOUT) :: SolverEquations !<On return, the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblemSolverEquationsGetNumber0",Err,ERROR,*999)
    
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SolverEquations%SOLVER_EQUATIONS,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF
    
    CALL EXITS("CMISSProblemSolverEquationsGetNumber0")
    RETURN
999 CALL ERRORS("CMISSProblemSolverEquationsGetNumber0",Err,ERROR)
    CALL EXITS("CMISSProblemSolverEquationsGetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemSolverEquationsGetNumber0

  !
  !================================================================================================================================
  !  
  
  !>Returns the solver equations from a problem identified by an user number.
  SUBROUTINE CMISSProblemSolverEquationsGetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,SolverEquations,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to get the solver equations for.
    TYPE(CMISSSolverEquationsType), INTENT(INOUT) :: SolverEquations !<On return, the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
     TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblemSolverEquationsGetNumber1",Err,ERROR,*999)
    
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SolverEquations%SOLVER_EQUATIONS,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSProblemSolverEquationsGetNumber1")
    RETURN
999 CALL ERRORS("CMISSProblemSolverEquationsGetNumber1",Err,ERROR)
    CALL EXITS("CMISSProblemSolverEquationsGetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemSolverEquationsGetNumber1
  
  !
  !================================================================================================================================
  !  
  
  !>Returns the solver equations from a problem identified by an object.
  SUBROUTINE CMISSProblemSolverEquationsGetObj0(Problem,ControlLoopIdentifier,SolverIndex,SolverEquations,Err)
  
    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: Problem !<The problem to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to get the solver equations for.
    TYPE(CMISSSolverEquationsType), INTENT(INOUT) :: SolverEquations !<On return, the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemSolverEquationsGetObj0",Err,ERROR,*999)

    CALL PROBLEM_SOLVER_EQUATIONS_GET(Problem%PROBLEM,ControlLoopIdentifier,SolverIndex,SolverEquations%SOLVER_EQUATIONS, &
      & Err,ERROR,*999)
     
    CALL EXITS("CMISSProblemSolverEquationsGetObj0")
    RETURN
999 CALL ERRORS("CMISSProblemSolverEquationsGetObj0",Err,ERROR)
    CALL EXITS("CMISSProblemSolverEquationsGetObj0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemSolverEquationsGetObj0

  !
  !================================================================================================================================
  !  
  
  !>Returns the solver equations from a problem identified by an object.
  SUBROUTINE CMISSProblemSolverEquationsGetObj1(Problem,ControlLoopIdentifiers,SolverIndex,SolverEquations,Err)
  
    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: Problem !<The problem to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to get the solver equations for.
    TYPE(CMISSSolverEquationsType), INTENT(INOUT) :: SolverEquations !<On return, the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemSolverEquationsGetObj1",Err,ERROR,*999)
    
    CALL PROBLEM_SOLVER_EQUATIONS_GET(Problem%PROBLEM,ControlLoopIdentifiers,SolverIndex,SolverEquations%SOLVER_EQUATIONS, &
      & Err,ERROR,*999)

    CALL EXITS("CMISSProblemSolverEquationsGetObj1")
    RETURN
999 CALL ERRORS("CMISSProblemSolverEquationsGetObj1",Err,ERROR)
    CALL EXITS("CMISSProblemSolverEquationsGetObj1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemSolverEquationsGetObj1
  
  !  
  !================================================================================================================================
  !    

  !>Finishes the process of creating solvers for a problem identified by user number.
  SUBROUTINE CMISSProblemSolversCreateFinishNumber(ProblemUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to finish the creation of solvers for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSProblemSolversCreateFinishNumber",Err,ERROR,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVERS_CREATE_FINISH(PROBLEM,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Problem Solvers Create')
#endif

    CALL EXITS("CMISSProblemSolversCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSProblemSolversCreateFinishNumber",Err,ERROR)
    CALL EXITS("CMISSProblemSolversCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemSolversCreateFinishNumber

  !  
  !================================================================================================================================
  !  
 
  !>Finishes the creation of solvers for problem identified by an object.
  SUBROUTINE CMISSProblemSolversCreateFinishObj(Problem,Err)
  
    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: Problem !<The problem to finish creating the solvers for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSProblemSolversCreateFinishObj",Err,ERROR,*999)
 
    CALL PROBLEM_SOLVERS_CREATE_FINISH(Problem%PROBLEM,Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Problem Solvers Create')
#endif

    CALL EXITS("CMISSProblemSolversCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSProblemSolversCreateFinishObj",Err,ERROR)
    CALL EXITS("CMISSProblemSolversCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemSolversCreateFinishObj

  !  
  !================================================================================================================================
  !    

  !>Starts the process of creating solvers for a problem identified by user number.
  SUBROUTINE CMISSProblemSolversCreateStartNumber(ProblemUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to start the creation of solvers for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSProblemSolversCreateStartNumber",Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Problem Solvers Create')
#endif
 
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVERS_CREATE_START(PROBLEM,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSProblemSolversCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSProblemSolversCreateStartNumber",Err,ERROR)
    CALL EXITS("CMISSProblemSolversCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemSolversCreateStartNumber

  !  
  !================================================================================================================================
  !  
 
  !>Starts the creation of solvers for problem identified by an object.
  SUBROUTINE CMISSProblemSolversCreateStartObj(Problem,Err)
  
    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: Problem !<The problem to start creating the solvers for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSProblemSolversCreateStartObj",Err,ERROR,*999)
 
#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Problem Solvers Create')
#endif

    CALL PROBLEM_SOLVERS_CREATE_START(Problem%PROBLEM,Err,ERROR,*999)

    CALL EXITS("CMISSProblemSolversCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSProblemSolversCreateStartObj",Err,ERROR)
    CALL EXITS("CMISSProblemSolversCreateStartObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemSolversCreateStartObj

  !  
  !================================================================================================================================
  !    

  !>Destroys the solvers for a problem identified by an user number.
  SUBROUTINE CMISSProblemSolversDestroyNumber(ProblemUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to destroy the solvers for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSProblemSolversDestroyNumber",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVERS_DESTROY(PROBLEM,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSProblemSolversDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSProblemSolversDestroyNumber",Err,ERROR)
    CALL EXITS("CMISSProblemSolversDestroyNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemSolversDestroyNumber

  !  
  !================================================================================================================================
  !  
 
  !>Destroys the solvers for problem identified by an object.
  SUBROUTINE CMISSProblemSolversDestroyObj(Problem,Err)
  
    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: Problem !<The problem to destroy the solvers for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSProblemSolversDestroyObj",Err,ERROR,*999)
 
    CALL PROBLEM_SOLVERS_DESTROY(Problem%PROBLEM,Err,ERROR,*999)

    CALL EXITS("CMISSProblemSolversDestroyObj")
    RETURN
999 CALL ERRORS("CMISSProblemSolversDestroyObj",Err,ERROR)
    CALL EXITS("CMISSProblemSolversDestroyObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemSolversDestroyObj

  !  
  !================================================================================================================================
  !    

  !>Returns the specification i.e., problem class, type and subtype for a problem identified by an user number.
  SUBROUTINE CMISSProblemSpecificationGetNumber(ProblemUserNumber,ProblemClass,ProblemType,ProblemSubtype,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to get the specification for.
    INTEGER(INTG), INTENT(OUT) :: ProblemClass !<On return, the problem class. \see OPENCMISS_ProblemClasses
    INTEGER(INTG), INTENT(OUT) :: ProblemType !<On return, the problem type. \see OPENCMISS_ProblemTypes
    INTEGER(INTG), INTENT(OUT) :: ProblemSubtype !<On return, the problem subtype. \see OPENCMISS_ProblemSubTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSProblemSpecificationGetNumber",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SPECIFICATION_GET(PROBLEM,ProblemClass,ProblemType,ProblemSubtype,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSProblemSpecificationGetNumber")
    RETURN
999 CALL ERRORS("CMISSProblemSpecificationGetNumber",Err,ERROR)
    CALL EXITS("CMISSProblemSpecificationGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemSpecificationGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the specification i.e., problem class, type and subtype for a problem identified by an object.
  SUBROUTINE CMISSProblemSpecificationGetObj(Problem,ProblemClass,ProblemType,ProblemSubtype,Err)
  
    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: Problem !<The problem to get the specification for.
    INTEGER(INTG), INTENT(OUT) :: ProblemClass !<On return, the problem class. \see OPENCMISS_ProblemClasses
    INTEGER(INTG), INTENT(OUT) :: ProblemType !<On return, the problem type. \see OPENCMISS_ProblemTypes
    INTEGER(INTG), INTENT(OUT) :: ProblemSubtype !<On return, the problem subtype. \see OPENCMISS_ProblemSubTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSProblemSpecificationGetObj",Err,ERROR,*999)
 
    CALL PROBLEM_SPECIFICATION_GET(Problem%PROBLEM,ProblemClass,ProblemType,ProblemSubtype,Err,ERROR,*999)

    CALL EXITS("CMISSProblemSpecificationGetObj")
    RETURN
999 CALL ERRORS("CMISSProblemSpecificationGetObj",Err,ERROR)
    CALL EXITS("CMISSProblemSpecificationGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemSpecificationGetObj

  !  
  !================================================================================================================================
  !    

  !>Sets/changes the specification i.e., problem class, type and subtype for a problem identified by an user number.
  SUBROUTINE CMISSProblemSpecificationSetNumber(ProblemUserNumber,ProblemClass,ProblemType,ProblemSubtype,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem to set the specification for.
    INTEGER(INTG), INTENT(IN) :: ProblemClass !<The problem class to set. \see OPENCMISS_ProblemClasses
    INTEGER(INTG), INTENT(IN) :: ProblemType !<The problem type to set. \see OPENCMISS_ProblemTypes
    INTEGER(INTG), INTENT(IN) :: ProblemSubtype !<The problem subtype to set. \see OPENCMISS_ProblemSubTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSProblemSpecificationSetNumber",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SPECIFICATION_SET(PROBLEM,ProblemClass,ProblemType,ProblemSubtype,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSProblemSpecificationSetNumber")
    RETURN
999 CALL ERRORS("CMISSProblemSpecificationSetNumber",Err,ERROR)
    CALL EXITS("CMISSProblemSpecificationSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemSpecificationSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the specification i.e., problem class, type and subtype for a problem identified by an object.
  SUBROUTINE CMISSProblemSpecificationSetObj(Problem,ProblemClass,ProblemType,ProblemSubtype,Err)
  
    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: Problem !<The problem to get the specification for.
    INTEGER(INTG), INTENT(IN) :: ProblemClass !<The problem class to set. \see OPENCMISS_ProblemClasses
    INTEGER(INTG), INTENT(IN) :: ProblemType !<The problem type to set. \see OPENCMISS_ProblemTypes
    INTEGER(INTG), INTENT(IN) :: ProblemSubtype !<The problem subtype to set. \see OPENCMISS_ProblemSubTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSProblemSpecificationSetObj",Err,ERROR,*999)
 
    CALL PROBLEM_SPECIFICATION_SET(Problem%PROBLEM,ProblemClass,ProblemType,ProblemSubtype,Err,ERROR,*999)

    CALL EXITS("CMISSProblemSpecificationSetObj")
    RETURN
999 CALL ERRORS("CMISSProblemSpecificationSetObj",Err,ERROR)
    CALL EXITS("CMISSProblemSpecificationSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSProblemSpecificationSetObj

!!==================================================================================================================================
!!
!! REGION_ROUTINES
!!
!!==================================================================================================================================

  !>Returns the coordinate system for a region identified by an user number.
  SUBROUTINE CMISSRegionCoordinateSystemGetNumber(RegionUserNumber,CoordinateSystemUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region to get the coordinate system for.
    INTEGER(INTG), INTENT(OUT) :: CoordinateSystemUserNumber !<On return, the coordinate system user number.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSRegionCoordinateSystemGetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(COORDINATE_SYSTEM)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_COORDINATE_SYSTEM_GET(REGION,COORDINATE_SYSTEM,Err,ERROR,*999)
      IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
        CoordinateSystemUserNumber = COORDINATE_SYSTEM%USER_NUMBER
      ELSE
        LOCAL_ERROR="The coordinate system is not associated for region number "// &
          & TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSRegionCoordinateSystemGetNumber")
    RETURN
999 CALL ERRORS("CMISSRegionCoordinateSystemGetNumber",Err,ERROR)
    CALL EXITS("CMISSRegionCoordinateSystemGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSRegionCoordinateSystemGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the coordinate system for a region identified by an object.
  SUBROUTINE CMISSRegionCoordinateSystemGetObj(Region,CoordinateSystem,Err)
  
    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: Region !<The region to get the coordinate system for.
    TYPE(CMISSCoordinateSystemType), INTENT(OUT) :: CoordinateSystem !<On return, the regions coordinate system.
   INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSRegionCoordinateSystemGetObj",Err,ERROR,*999)
 
    CALL REGION_COORDINATE_SYSTEM_GET(Region%REGION,CoordinateSystem%COORDINATE_SYSTEM,Err,ERROR,*999)

    CALL EXITS("CMISSRegionCoordinateSystemGetObj")
    RETURN
999 CALL ERRORS("CMISSRegionCoordinateSystemGetObj",Err,ERROR)
    CALL EXITS("CMISSRegionCoordinateSystemGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSRegionCoordinateSystemGetObj
  
  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the coordinate system for a region identified by an user number.
  SUBROUTINE CMISSRegionCoordinateSystemSetNumber(RegionUserNumber,CoordinateSystemUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region to set the coordinate system for.
    INTEGER(INTG), INTENT(IN) :: CoordinateSystemUserNumber !<The user number of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSRegionCoordinateSystemSetNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(COORDINATE_SYSTEM)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(CoordinateSystemUserNumber,COORDINATE_SYSTEM,Err,ERROR,*999)
      IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
        CALL REGION_COORDINATE_SYSTEM_SET(REGION,COORDINATE_SYSTEM,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A coordinate system with an user number of "// &
          & TRIM(NUMBER_TO_VSTRING(CoordinateSystemUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSRegionCoordinateSystemSetNumber")
    RETURN
999 CALL ERRORS("CMISSRegionCoordinateSystemSetNumber",Err,ERROR)
    CALL EXITS("CMISSRegionCoordinateSystemSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSRegionCoordinateSystemSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the coordinate system for a region identified by an object.
  SUBROUTINE CMISSRegionCoordinateSystemSetObj(Region,CoordinateSystem,Err)
  
    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: Region !<The region to set the coordinate system for.
    TYPE(CMISSCoordinateSystemType), INTENT(IN) :: CoordinateSystem !<The coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSRegionCoordinateSystemSetObj",Err,ERROR,*999)
 
    CALL REGION_COORDINATE_SYSTEM_SET(Region%REGION,CoordinateSystem%COORDINATE_SYSTEM,Err,ERROR,*999)

    CALL EXITS("CMISSRegionCoordinateSystemSetObj")
    RETURN
999 CALL ERRORS("CMISSRegionCoordinateSystemSetObj",Err,ERROR)
    CALL EXITS("CMISSRegionCoordinateSystemSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSRegionCoordinateSystemSetObj

  !  
  !================================================================================================================================
  !  
  
  !>Finishes the process of creating a region identified by user number.
  SUBROUTINE CMISSRegionCreateFinishNumber(RegionUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSRegionCreateFinishNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_CREATE_FINISH(REGION,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Region Create')
#endif

    CALL EXITS("CMISSRegionCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSRegionCreateFinishNumber",Err,ERROR)
    CALL EXITS("CMISSRegionCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSRegionCreateFinishNumber

  !  
  !================================================================================================================================
  !  
 
  !>Finishes the creation of a region identified by an object.
  SUBROUTINE CMISSRegionCreateFinishObj(Region,Err)
  
    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: Region !<The region to finish creating.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSRegionCreateFinishObj",Err,ERROR,*999)
 
    CALL REGION_CREATE_FINISH(Region%REGION,Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Region Create')
#endif

    CALL EXITS("CMISSRegionCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSRegionCreateFinishObj",Err,ERROR)
    CALL EXITS("CMISSRegionCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSRegionCreateFinishObj

  !  
  !================================================================================================================================
  !  
  
  !>Starts the process creating a region identified by user number.
  SUBROUTINE CMISSRegionCreateStartNumber(RegionUserNumber,ParentRegionUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region to start the creation of.
    INTEGER(INTG), INTENT(IN) :: ParentRegionUserNumber !<The user number of the parent region to start the creation of the region in.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: PARENT_REGION,REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSRegionCreateStartNumber",Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Region Create')
#endif

    NULLIFY(PARENT_REGION)
    NULLIFY(REGION)
    CALL REGION_USER_NUMBER_FIND(ParentRegionUserNumber,PARENT_REGION,Err,ERROR,*999)
    IF(ASSOCIATED(PARENT_REGION)) THEN
      CALL REGION_CREATE_START(RegionUserNumber,PARENT_REGION,REGION,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(ParentRegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSRegionCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSRegionCreateStartNumber",Err,ERROR)
    CALL EXITS("CMISSRegionCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSRegionCreateStartNumber

  !  
  !================================================================================================================================
  !  
 
  !>Starts the creation of a region identified by an object.
  SUBROUTINE CMISSRegionCreateStartObj(RegionUserNumber,ParentRegion,Region,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region to start the creation of.
    TYPE(CMISSRegionType), INTENT(IN) :: ParentRegion !<The parent region to  to start the creation of the region in.
    TYPE(CMISSRegionType), INTENT(OUT) :: Region !<On return, the created region.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSRegionCreateStartObj",Err,ERROR,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Region Create')
#endif

    CALL REGION_CREATE_START(RegionUserNumber,ParentRegion%REGION,Region%REGION,Err,ERROR,*999)

    CALL EXITS("CMISSRegionCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSRegionCreateStartObj",Err,ERROR)
    CALL EXITS("CMISSRegionCreateStartObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSRegionCreateStartObj

  !  
  !================================================================================================================================
  !  
  
  !>Destroys a region identified by an user number.
  SUBROUTINE CMISSRegionDestroyNumber(RegionUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region to destroy.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSRegionDestroyNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DESTROY(REGION,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSRegionDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSRegionDestroyNumber",Err,ERROR)
    CALL EXITS("CMISSRegionDestroyNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSRegionDestroyNumber

  !  
  !================================================================================================================================
  !  
 
  !>Destroys a region identified by an object.
  SUBROUTINE CMISSRegionDestroyObj(Region,Err)
  
    !Argument variables
    TYPE(CMISSRegionType), INTENT(INOUT) :: Region !<The region to destroy
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSRegionDestroyObj",Err,ERROR,*999)
 
    CALL REGION_DESTROY(Region%REGION,Err,ERROR,*999)

    CALL EXITS("CMISSRegionDestroyObj")
    RETURN
999 CALL ERRORS("CMISSRegionDestroyObj",Err,ERROR)
    CALL EXITS("CMISSRegionDestroyObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSRegionDestroyObj

  !  
  !================================================================================================================================
  !  

  !>Returns the character string label for a region identified by an user number.
  SUBROUTINE CMISSRegionLabelGetCNumber(RegionUserNumber,Label,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: Label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSRegionLabelGetCNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN      
      CALL REGION_LABEL_GET(REGION,Label,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSRegionLabelGetCNumber")
    RETURN
999 CALL ERRORS("CMISSRegionLabelGetCNumber",Err,ERROR)
    CALL EXITS("CMISSRegionLabelGetCNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSRegionLabelGetCNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the character string label for a region identified by an object.
  SUBROUTINE CMISSRegionLabelGetCObj(Region,Label,Err)
  
    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: Region !<The region to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: Label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSRegionLabelGetCObj",Err,ERROR,*999)
 
    CALL REGION_LABEL_GET(Region%REGION,Label,Err,ERROR,*999)

    CALL EXITS("CMISSRegionLabelGetCObj")
    RETURN
999 CALL ERRORS("CMISSRegionLabelGetCObj",Err,ERROR)
    CALL EXITS("CMISSRegionLabelGetCObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSRegionLabelGetCObj

  !  
  !================================================================================================================================
  !  

  !>Returns the varying string label for a region identified by an user number.
  SUBROUTINE CMISSRegionLabelGetVSNumber(RegionUserNumber,Label,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: Label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSRegionLabelGetVSNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN      
      CALL REGION_LABEL_GET(REGION,Label,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSRegionLabelGetVSNumber")
    RETURN
999 CALL ERRORS("CMISSRegionLabelGetVSNumber",Err,ERROR)
    CALL EXITS("CMISSRegionLabelGetVSNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSRegionLabelGetVSNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the varying string label for a region identified by an object.
  SUBROUTINE CMISSRegionLabelGetVSObj(Region,Label,Err)
  
    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: Region !<The region to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: Label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSRegionLabelGetVSObj",Err,ERROR,*999)
 
    CALL REGION_LABEL_GET(Region%REGION,Label,Err,ERROR,*999)

    CALL EXITS("CMISSRegionLabelGetVSObj")
    RETURN
999 CALL ERRORS("CMISSRegionLabelGetVSObj",Err,ERROR)
    CALL EXITS("CMISSRegionLabelGetVSObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSRegionLabelGetVSObj

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the character string label for a region identified by an user number.
  SUBROUTINE CMISSRegionLabelSetCNumber(RegionUserNumber,Label,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: Label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSRegionLabelSetCNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN      
      CALL REGION_LABEL_SET(REGION,Label,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSRegionLabelSetCNumber")
    RETURN
999 CALL ERRORS("CMISSRegionLabelSetCNumber",Err,ERROR)
    CALL EXITS("CMISSRegionLabelSetCNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSRegionLabelSetCNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the character string label for a region identified by an object.
  SUBROUTINE CMISSRegionLabelSetCObj(Region,Label,Err)
  
    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: Region !<The region to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: Label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSRegionLabelSetCObj",Err,ERROR,*999)
 
    CALL REGION_LABEL_SET(Region%REGION,Label,Err,ERROR,*999)

    CALL EXITS("CMISSRegionLabelSetCObj")
    RETURN
999 CALL ERRORS("CMISSRegionLabelSetCObj",Err,ERROR)
    CALL EXITS("CMISSRegionLabelSetCObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSRegionLabelSetCObj

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the varying string label for a region identified by an user number.
  SUBROUTINE CMISSRegionLabelSetVSNumber(RegionUserNumber,Label,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: Label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSRegionLabelSetVSNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN      
      CALL REGION_LABEL_SET(REGION,CHAR(Label),Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSRegionLabelStVSNumber")
    RETURN
999 CALL ERRORS("CMISSRegionLabelSetVSNumber",Err,ERROR)
    CALL EXITS("CMISSRegionLabelSetVSNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSRegionLabelSetVSNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes string label for a region identified by an object.
  SUBROUTINE CMISSRegionLabelSetVSObj(Region,Label,Err)
  
    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: Region !<The region to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: Label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSRegionLabelSetVSObj",Err,ERROR,*999)
 
    CALL REGION_LABEL_SET(Region%REGION,CHAR(Label),Err,ERROR,*999)

    CALL EXITS("CMISSRegionLabelSetVSObj")
    RETURN
999 CALL ERRORS("CMISSRegionLabelSetVSObj",Err,ERROR)
    CALL EXITS("CMISSRegionLabelSetVSObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSRegionLabelSetVSObj

!!==================================================================================================================================
!!
!! SOLVER_ROUTINES
!!
!!==================================================================================================================================

  !>Returns the solve type for an Euler differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolverDAEEulerSolverTypeGetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,DAEEulerSolverType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to get the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the solver to get the DAE Euler solver type for
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to get the DAE Euler solver type for
    INTEGER(INTG), INTENT(OUT) :: DAEEulerSolverType !<On return, the DAE Euler solver type. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverDAEEulerSolverTypeGetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_DAE_EULER_SOLVER_TYPE_GET(SOLVER,DAEEulerSolverType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverDAEEulerSolverTypeGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverDAEEulerSolverTypeGetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverDAEEulerSolverTypeGetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDAEEulerSolverTypeGetNumber0

  !  
  !================================================================================================================================
  !  

  !>Returns the solve type for an Euler differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolverDAEEulerSolverTypeGetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,DAEEulerSolverType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to get the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to get the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to get the DAE Euler solver type for
    INTEGER(INTG), INTENT(OUT) :: DAEEulerSolverType !<On return, the DAE Euler solver type. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverDAEEulerSolverTypeGetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_DAE_EULER_SOLVER_TYPE_GET(SOLVER,DAEEulerSolverType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverDAEEulerSolverTypeGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverDAEEulerSolverTypeGetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverDAEEulerSolverTypeGetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDAEEulerSolverTypeGetNumber1

  !  
  !================================================================================================================================
  !  
 
  !>Returns the solve type for an Euler differential-algebraic equation solver identified by an object.
  SUBROUTINE CMISSSolverDAEEulerSolverTypeGetObj(Solver,DAEEulerSolverType,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The solver to get the DAE Euler solver type for.
    INTEGER(INTG), INTENT(OUT) :: DAEEulerSolverType !<On return, the DAE Euler solver type. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverDAEEulerSolverTypeGetObj",Err,ERROR,*999)
 
    CALL SOLVER_DAE_EULER_SOLVER_TYPE_GET(Solver%SOLVER,DAEEulerSolverType,Err,ERROR,*999)

    CALL EXITS("CMISSSolverDAEEulerSolverTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSSolverDAEEulerSolverTypeGetObj",Err,ERROR)
    CALL EXITS("CMISSSolverDAEEulerSolverTypeGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDAEEulerSolverTypeGetObj
  
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the solve type for an Euler differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolverDAEEulerSolverTypeSetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,DAEEulerSolverType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to set the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the solver to set the DAE Euler solver type for
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the DAE Euler solver type for
    INTEGER(INTG), INTENT(IN) :: DAEEulerSolverType !<The DAE Euler solver type to set. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverDAEEulerSolverTypeSetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_DAE_EULER_SOLVER_TYPE_SET(SOLVER,DAEEulerSolverType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverDAEEulerSolverTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverDAEEulerSolverTypeSetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverDAEEulerSolverTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDAEEulerSolverTypeSetNumber0

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the solve type for an Euler differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolverDAEEulerSolverTypeSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,DAEEulerSolverType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to set the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the DAE Euler solver type for
    INTEGER(INTG), INTENT(IN) :: DAEEulerSolverType !<The DAE Euler solver type to set. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverDAEEulerSolverTypeSetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_DAE_EULER_SOLVER_TYPE_SET(SOLVER,DAEEulerSolverType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverDAEEulerSolverTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverDAEEulerSolverTypeSetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverDAEEulerSolverTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDAEEulerSolverTypeSetNumber1

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the solve type for an Euler differential-algebraic equation solver identified by an object.
  SUBROUTINE CMISSSolverDAEEulerSolverTypeSetObj(Solver,DAEEulerSolverType,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The solver to set the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: DAEEulerSolverType !<The DAE Euler solver type to set. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverDAEEulerSolverTypeSetObj",Err,ERROR,*999)
 
    CALL SOLVER_DAE_EULER_SOLVER_TYPE_SET(Solver%SOLVER,DAEEulerSolverType,Err,ERROR,*999)

    CALL EXITS("CMISSSolverDAEEulerSolverTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverDAEEulerSolverTypeSetObj",Err,ERROR)
    CALL EXITS("CMISSSolverDAEEulerSolverTypeSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDAEEulerSolverTypeSetObj
  
  !  
  !================================================================================================================================
  !
  
  !>Returns the solve type for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolverDAESolverTypeGetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,DAESolverType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to get the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the solver to get the DAE solver type for
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to get the DAE solver type for
    INTEGER(INTG), INTENT(OUT) :: DAESolverType !<On return, the DAE solver type. \see OPENCMISS_DAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverDAESolverTypeGetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_DAE_SOLVER_TYPE_GET(SOLVER,DAESolverType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverDAESolverTypeGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverDAESolverTypeGetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverDAESolverTypeGetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDAESolverTypeGetNumber0

  !  
  !================================================================================================================================
  !  

  !>Returns the solve type for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolverDAESolverTypeGetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,DAESolverType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to get the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to get the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to get the DAE solver type for
    INTEGER(INTG), INTENT(OUT) :: DAESolverType !<On return, the DAE solver type. \see OPENCMISS_DAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverDAESolverTypeGetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_DAE_SOLVER_TYPE_GET(SOLVER,DAESolverType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverDAESolverTypeGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverDAESolverTypeGetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverDAESolverTypeGetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDAESolverTypeGetNumber1

  !  
  !================================================================================================================================
  !  
 
  !>Returns the solve type for an differential-algebraic equation solver identified by an object.
  SUBROUTINE CMISSSolverDAESolverTypeGetObj(Solver,DAESolverType,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The solver to get the DAE solver type for.
    INTEGER(INTG), INTENT(OUT) :: DAESolverType !<On return, the DAE solver type. \see OPENCMISS_DAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverDAESolverTypeGetObj",Err,ERROR,*999)
 
    CALL SOLVER_DAE_SOLVER_TYPE_GET(Solver%SOLVER,DAESolverType,Err,ERROR,*999)

    CALL EXITS("CMISSSolverDAESolverTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSSolverDAESolverTypeGetObj",Err,ERROR)
    CALL EXITS("CMISSSolverDAESolverTypeGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDAESolverTypeGetObj
  
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the solve type for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolverDAESolverTypeSetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,DAESolverType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to set the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the solver to set the DAE solver type for
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the DAE solver type for
    INTEGER(INTG), INTENT(IN) :: DAESolverType !<The DAE solver type to set. \see OPENCMISS_DAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverDAESolverTypeSetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_DAE_SOLVER_TYPE_SET(SOLVER,DAESolverType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverDAESolverTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverDAESolverTypeSetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverDAESolverTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDAESolverTypeSetNumber0

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the solve type for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolverDAESolverTypeSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,DAESolverType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to set the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the DAE solver type for
    INTEGER(INTG), INTENT(IN) :: DAESolverType !<The DAE solver type to set. \see OPENCMISS_DAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverDAESolverTypeSetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_DAE_SOLVER_TYPE_SET(SOLVER,DAESolverType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverDAESolverTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverDAESolverTypeSetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverDAESolverTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDAESolverTypeSetNumber1

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the solve type for an differential-algebraic equation solver identified by an object.
  SUBROUTINE CMISSSolverDAESolverTypeSetObj(Solver,DAESolverType,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The solver to set the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: DAESolverType !<The DAE solver type to set. \see OPENCMISS_DAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverDAESolverTypeSetObj",Err,ERROR,*999)
 
    CALL SOLVER_DAE_SOLVER_TYPE_SET(Solver%SOLVER,DAESolverType,Err,ERROR,*999)

    CALL EXITS("CMISSSolverDAESolverTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverDAESolverTypeSetObj",Err,ERROR)
    CALL EXITS("CMISSSolverDAESolverTypeSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDAESolverTypeSetObj
  
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the times for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolverDAETimesSetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,StartTime,EndTime,InitialStep,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the DAE times for.
    REAL(DP), INTENT(IN) :: StartTime !<The start time for the differential-algebraic solver.
    REAL(DP), INTENT(IN) :: EndTime !<The end time for the differential-algebraic solver.
    REAL(DP), INTENT(IN) :: InitialStep !<The (initial) time step for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverDAETimesSetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_DAE_TIMES_SET(SOLVER,StartTime,EndTime,InitialStep,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverDAETimesSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverDAETimesSetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverDAETimesSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDAETimesSetNumber0

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the times for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolverDAETimesSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,StartTime,EndTime,InitialStep,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the DAE times for.
    REAL(DP), INTENT(IN) :: StartTime !<The start time for the differential-algebraic solver.
    REAL(DP), INTENT(IN) :: EndTime !<The end time for the differential-algebraic solver.
    REAL(DP), INTENT(IN) :: InitialStep !<The (initial) time step for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverDAETimesSetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_DAE_TIMES_SET(SOLVER,StartTime,EndTime,InitialStep,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverDAETimesSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverDAETimesSetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverDAETimesSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDAETimesSetNumber1

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the times for an differential-algebraic equation solver identified by an object.
  SUBROUTINE CMISSSolverDAETimesSetObj(Solver,StartTime,EndTime,InitialStep,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The solver to set the DAE times for.
    REAL(DP), INTENT(IN) :: StartTime !<The start time for the differential-algebraic solver.
    REAL(DP), INTENT(IN) :: EndTime !<The end time for the differential-algebraic solver.
    REAL(DP), INTENT(IN) :: InitialStep !<The (initial) time step for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverDAETimesSetObj",Err,ERROR,*999)
 
    CALL SOLVER_DAE_TIMES_SET(Solver%SOLVER,StartTime,EndTime,InitialStep,Err,ERROR,*999)

    CALL EXITS("CMISSSolverDAETimesSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverDAETimesSetObj",Err,ERROR)
    CALL EXITS("CMISSSolverDAETimesSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDAETimesSetObj
  
  !  
  !================================================================================================================================
  !
  
  !>Returns the degree of the polynomial used to interpolate time for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicDegreeGetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,Degree,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to get the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the solver to get the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to get the dynamic degree for.
    INTEGER(INTG), INTENT(OUT) :: Degree !<On return, the dynamic degree. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverDynamicDegreeGetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_DYNAMIC_DEGREE_GET(SOLVER,Degree,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicDegreeGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicDegreeGetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverDynamicDegreeGetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDynamicDegreeGetNumber0

  !  
  !================================================================================================================================
  !  

  !>Returns the degree of the polynomial used to interpolate time for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicDegreeGetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,Degree,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to get the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to get the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to get the dynamic degree for
    INTEGER(INTG), INTENT(OUT) :: Degree !<On return, the dynamic degree. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverDynamicDegreeGetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_DYNAMIC_DEGREE_GET(SOLVER,Degree,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicDegreeGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicDegreeGetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverDynamicDegreeGetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDynamicDegreeGetNumber1

  !  
  !================================================================================================================================
  !  
 
  !>Returns the degree of the polynomial used to interpolate time for a dynamic solver identified by an object.
  SUBROUTINE CMISSSolverDynamicDegreeGetObj(Solver,Degree,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The solver to get the dynamic degree for.
    INTEGER(INTG), INTENT(OUT) :: Degree !<On return, the dynamic degree. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverDynamicDegreeGetObj",Err,ERROR,*999)
 
    CALL SOLVER_DYNAMIC_DEGREE_GET(Solver%SOLVER,Degree,Err,ERROR,*999)

    CALL EXITS("CMISSSolverDynamicDegreeGetObj")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicDegreeGetObj",Err,ERROR)
    CALL EXITS("CMISSSolverDynamicDegreeGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDynamicDegreeGetObj
  
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the degree of the polynomial used to interpolate time for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicDegreeSetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,Degree,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the solver to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: Degree !<The dynamic degree to set. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverDynamicDegreeSetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_DYNAMIC_DEGREE_SET(SOLVER,Degree,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicDegreeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicDegreeSetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverDynamicDegreeSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDynamicDegreeSetNumber0

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the degree of the polynomial used to interpolate time for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicDegreeSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,Degree,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the dynamic degree for
    INTEGER(INTG), INTENT(IN) :: Degree !<The dynamic degree to set. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverDynamicDegreeSetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_DYNAMIC_DEGREE_SET(SOLVER,Degree,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicDegreeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicDegreeSetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverDynamicDegreeSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDynamicDegreeSetNumber1

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the degree of the polynomial used to interpolate time for a dynamic solver identified by an object.
  SUBROUTINE CMISSSolverDynamicDegreeSetObj(Solver,Degree,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The solver to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: Degree !<The dynamic degree to set. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverDynamicDegreeSetObj",Err,ERROR,*999)
 
    CALL SOLVER_DYNAMIC_DEGREE_SET(Solver%SOLVER,Degree,Err,ERROR,*999)

    CALL EXITS("CMISSSolverDynamicDegreeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicDegreeSetObj",Err,ERROR)
    CALL EXITS("CMISSSolverDynamicDegreeSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDynamicDegreeSetObj
  
  !  
  !================================================================================================================================
  !
  
  !>Returns the linearity type for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicLinearityTypeGetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,LinearityType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the solver to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(OUT) :: LinearityType !<On return, the dynamic linearity type. \see OPENCMISS_DynamicLinearityTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverDynamicLinearityTypeGetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_DYNAMIC_LINEARITY_TYPE_GET(SOLVER,LinearityType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicLinearityTypeGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicLinearityTypeGetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverDynamicLinearityTypeGetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDynamicLinearityTypeGetNumber0

  !  
  !================================================================================================================================
  !  

  !>Returns the linearity type for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicLinearityTypeGetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,LinearityType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(OUT) :: LinearityType !<On return, the dynamic linearity type. \see OPENCMISS_DynamicLinearityTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverDynamicLinearityTypeGetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_DYNAMIC_LINEARITY_TYPE_GET(SOLVER,LinearityType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicLinearityTypeGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicLinearityTypeGetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverDynamicLinearityTypeGetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDynamicLinearityTypeGetNumber1

  !  
  !================================================================================================================================
  !  
 
  !>Returns the linearity type for a dynamic solver identified by an object.
  SUBROUTINE CMISSSolverDynamicLinearityTypeGetObj(Solver,LinearityType,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The solver to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(OUT) :: LinearityType !<On return, the dynamic linearity type. \see OPENCMISS_DynamicLinearityTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverDynamicLinearityTypeGetObj",Err,ERROR,*999)
 
    CALL SOLVER_DYNAMIC_LINEARITY_TYPE_GET(Solver%SOLVER,LinearityType,Err,ERROR,*999)

    CALL EXITS("CMISSSolverDynamicLinearityTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicLinearityTypeGetObj",Err,ERROR)
    CALL EXITS("CMISSSolverDynamicLinearityTypeGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDynamicLinearityTypeGetObj
    
  !  
  !================================================================================================================================
  !
  
  !>Returns the nonlinear solver associated with a nonlinear dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicNonlinearSolverGetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex, &
    & NonlinearSolverIndex,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the solver to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(OUT) :: NonlinearSolverIndex !<On return, the solver index of the nonlinear solver.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverDynamicNonlinearSolverGetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(NONLINEAR_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_DYNAMIC_NONLINEAR_SOLVER_GET(SOLVER,NONLINEAR_SOLVER,Err,ERROR,*999)
      !todo: get the solver index from nonlinear solver
      NonlinearSolverIndex=NONLINEAR_SOLVER%GLOBAL_NUMBER
      CALL FLAG_ERROR("Not implemented.",Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicNonlinearSolverGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicNonlinearSolverGetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverDynamicNonlinearSolverGetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDynamicNonlinearSolverGetNumber0

  !  
  !================================================================================================================================
  !  

  !>Returns the nonlinear solver associated with a nonlinear dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicNonlinearSolverGetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex, &
    & NonlinearSolverIndex,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(OUT) :: NonlinearSolverIndex !<On return, the dynamic nonlinear solver index. 
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverDynamicNonlinearSolverGetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(NONLINEAR_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_DYNAMIC_NONLINEAR_SOLVER_GET(SOLVER,NONLINEAR_SOLVER,Err,ERROR,*999)
      !todo: get the solver index from nonlinear solver
      NonlinearSolverIndex=NONLINEAR_SOLVER%GLOBAL_NUMBER
      CALL FLAG_ERROR("Not implemented.",Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicNonlinearSolverGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicNonlinearSolverGetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverDynamicNonlinearSolverGetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDynamicNonlinearSolverGetNumber1

  !  
  !================================================================================================================================
  !  
 
  !>Returns the nonlinear solver associated with a nonlinear dynamic solver identified by an object.
  SUBROUTINE CMISSSolverDynamicNonlinearSolverGetObj(Solver,NonlinearSolver,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The solver to get the dynamic nonlinear solver for.
    TYPE(CMISSSolverType), INTENT(INOUT) :: NonlinearSolver  !<On return, the dynamic nonlinear solver. 
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverDynamicNonlinearSolverGetObj",Err,ERROR,*999)
 
    CALL SOLVER_DYNAMIC_NONLINEAR_SOLVER_GET(Solver%SOLVER,NonlinearSolver%SOLVER,Err,ERROR,*999)

    CALL EXITS("CMISSSolverDynamicNonlinearSolverGetObj")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicNonlinearSolverGetObj",Err,ERROR)
    CALL EXITS("CMISSSolverDynamicNonlinearSolverGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDynamicNonlinearSolverGetObj
  
  !  
  !================================================================================================================================
  !
  
  !>Returns the linear solver associated with a linear dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicLinearSolverGetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,LinearSolverIndex,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the solver to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(OUT) :: LinearSolverIndex !<On return, the solver index of the linear solver.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,LINEAR_SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverDynamicLinearSolverGetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(LINEAR_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_DYNAMIC_LINEAR_SOLVER_GET(SOLVER,LINEAR_SOLVER,Err,ERROR,*999)
      !todo: get the solver index from linear solver
      LinearSolverIndex=LINEAR_SOLVER%GLOBAL_NUMBER
      CALL FLAG_ERROR("Not implemented.",Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicLinearSolverGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicLinearSolverGetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverDynamicLinearSolverGetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDynamicLinearSolverGetNumber0

  !  
  !================================================================================================================================
  !  

  !>Returns the linear solver associated with a linear dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicLinearSolverGetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,LinearSolverIndex,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(OUT) :: LinearSolverIndex !<On return, the dynamic linear solver index. 
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,LINEAR_SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverDynamicLinearSolverGetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(LINEAR_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_DYNAMIC_LINEAR_SOLVER_GET(SOLVER,LINEAR_SOLVER,Err,ERROR,*999)
      !todo: get the solver index from linear solver
      LinearSolverIndex=LINEAR_SOLVER%GLOBAL_NUMBER
      CALL FLAG_ERROR("Not implemented.",Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicLinearSolverGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicLinearSolverGetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverDynamicLinearSolverGetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDynamicLinearSolverGetNumber1

  !================================================================================================================================
  !  
 
  !>Returns the linear solver associated with a linear dynamic solver identified by an object.
  SUBROUTINE CMISSSolverDynamicLinearSolverGetObj(Solver,LinearSolver,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The solver to get the dynamic linear solver for.
    TYPE(CMISSSolverType), INTENT(INOUT) :: LinearSolver !<On return, the dynamic linear solver. 
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverDynamicLinearSolverGetObj",Err,ERROR,*999)
 
    CALL SOLVER_DYNAMIC_LINEAR_SOLVER_GET(Solver%SOLVER,LinearSolver%SOLVER,Err,ERROR,*999)

    CALL EXITS("CMISSSolverDynamicLinearSolverGetObj")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicLinearSolverGetObj",Err,ERROR)
    CALL EXITS("CMISSSolverDynamicLinearSolverGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverDynamicLinearSolverGetObj
  
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the scheme for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicSchemeSetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,Scheme,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the solver to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: Scheme !<The dynamic scheme to set. \see OPENCMISS_DynamicSchemeTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverDynamicSchemeSetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_DYNAMIC_SCHEME_SET(SOLVER,Scheme,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicSchemeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicSchemeSetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverDynamicSchemeSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDynamicSchemeSetNumber0

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the scheme for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicSchemeSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,Scheme,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: Scheme !<The dynamic scheme to set. \see OPENCMISS_DynamicSchemeTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverDynamicSchemeSetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_DYNAMIC_SCHEME_SET(SOLVER,Scheme,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicSchemeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicSchemeSetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverDynamicSchemeSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDynamicSchemeSetNumber1

  !================================================================================================================================
  !  
 
  !>Sets/changes the scheme for a dynamic solver identified by an object.
  SUBROUTINE CMISSSolverDynamicSchemeSetObj(Solver,Scheme,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The solver to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: Scheme !<The dynamic scheme to set. \see OPENCMISS_DynamicSchemeTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverDynamicSchemeSetObj",Err,ERROR,*999)
 
    CALL SOLVER_DYNAMIC_SCHEME_SET(Solver%SOLVER,Scheme,Err,ERROR,*999)

    CALL EXITS("CMISSSolverDynamicSchemeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicSchemeSetObj",Err,ERROR)
    CALL EXITS("CMISSSolverDynamicSchemeSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverDynamicSchemeSetObj
    
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the theta value for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicThetaSetNumber00(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,Theta,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the theta for.
    REAL(DP), INTENT(IN) :: Theta !<The dynamic theta to set. 
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverDynamicThetaSetNumber00",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,Theta,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicThetaSetNumber00")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicThetaSetNumber00",Err,ERROR)
    CALL EXITS("CMISSSolverDynamicThetaSetNumber00")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDynamicThetaSetNumber00

  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the theta value for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicThetaSetNumber01(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,Thetas,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the theta for.
    REAL(DP), INTENT(IN) :: Thetas(:) !<Thetas(i). The i'th dynamic theta to set. 
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverDynamicThetaSetNumber01",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,Thetas,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicThetaSetNumber01")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicThetaSetNumber01",Err,ERROR)
    CALL EXITS("CMISSSolverDynamicThetaSetNumber01")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDynamicThetaSetNumber01

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the theta for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicThetaSetNumber10(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,Theta,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the theta for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the theta for.
    REAL(DP), INTENT(IN) :: Theta !<The dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverDynamicThetaSetNumber10",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,Theta,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicThetaSetNumber10")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicThetaSetNumber10",Err,ERROR)
    CALL EXITS("CMISSSolverDynamicThetaSetNumber10")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDynamicThetaSetNumber10

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the theta for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicThetaSetNumber11(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,Thetas,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the theta for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the theta for.
    REAL(DP), INTENT(IN) :: Thetas(:) !<Thetas(i). The i'th dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverDynamicThetaSetNumber11",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,Thetas,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicThetaSetNumber11")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicThetaSetNumber11",Err,ERROR)
    CALL EXITS("CMISSSolverDynamicThetaSetNumber11")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDynamicThetaSetNumber11

  !
  !================================================================================================================================
  !  
 
  !>Sets/changes the theta for a dynamic solver identified by an object.
  SUBROUTINE CMISSSolverDynamicThetaSetObj0(Solver,Theta,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The solver to set the theta for.
    REAL(DP), INTENT(IN) :: Theta !<The dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverDynamicThetaSetObj0",Err,ERROR,*999)
 
    CALL SOLVER_DYNAMIC_THETA_SET(Solver%SOLVER,Theta,Err,ERROR,*999)

    CALL EXITS("CMISSSolverDynamicThetaSetObj0")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicThetaSetObj0",Err,ERROR)
    CALL EXITS("CMISSSolverDynamicThetaSetObj0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverDynamicThetaSetObj0
    
   !
  !================================================================================================================================
  !  
 
  !>Sets/changes the theta for a dynamic solver identified by an object.
  SUBROUTINE CMISSSolverDynamicThetaSetObj1(Solver,Thetas,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The solver to set the theta for.
    REAL(DP), INTENT(IN) :: Thetas(:) !<Thetas(i). The i'th dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverDynamicThetaSetObj1",Err,ERROR,*999)
 
    CALL SOLVER_DYNAMIC_THETA_SET(Solver%SOLVER,Thetas,Err,ERROR,*999)

    CALL EXITS("CMISSSolverDynamicThetaSetObj1")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicThetaSetObj1",Err,ERROR)
    CALL EXITS("CMISSSolverDynamicThetaSetObj1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverDynamicThetaSetObj1
    
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the times for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicTimesSetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,CurrentTime,TimeIncrement,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to set the times for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the solver to set the times for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the times for.
    REAL(DP), INTENT(IN) :: CurrentTime !<The current time to set.
    REAL(DP), INTENT(IN) :: TimeIncrement !<The time increment to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverDynamicTimesSetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_DYNAMIC_TIMES_SET(SOLVER,CurrentTime,TimeIncrement,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicTimesSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicTimesSetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverDynamicTimesSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDynamicTimesSetNumber0

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the times for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicTimesSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,CurrentTime,TimeIncrement,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to set the times for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the times for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the times for.
    REAL(DP), INTENT(IN) :: CurrentTime !<The current time to set.
    REAL(DP), INTENT(IN) :: TimeIncrement !<The time increment to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverDynamicTimeSetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_DYNAMIC_TIMES_SET(SOLVER,CurrentTime,TimeIncrement,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicTimesSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicTimesSetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverDynamicTimesSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverDynamicTimesSetNumber1

  !================================================================================================================================
  !  
 
  !>Sets/changes the times for a dynamic solver identified by an object.
  SUBROUTINE CMISSSolverDynamicTimesSetObj(Solver,CurrentTime,TimeIncrement,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The solver to set the times for.
    REAL(DP), INTENT(IN) :: CurrentTime !<The current time to set.
    REAL(DP), INTENT(IN) :: TimeIncrement !<The time increment to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverDynamicTimesSetObj",Err,ERROR,*999)
 
    CALL SOLVER_DYNAMIC_TIMES_SET(Solver%SOLVER,CurrentTime,TimeIncrement,Err,ERROR,*999)

    CALL EXITS("CMISSSolverDynamicTimesSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicTimesSetObj",Err,ERROR)
    CALL EXITS("CMISSSolverDynamicTimesSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverDynamicTimesSetObj
    
  !  
  !================================================================================================================================
  !
  
  !>Returns the type of library for a solver identified by an user number.
  SUBROUTINE CMISSSolverLibraryTypeGetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,LibraryType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to get the library type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the solver to get the library type for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to get the library type for.
    INTEGER(INTG), INTENT(OUT) :: LibraryType !<On return, the library type for the solver. \see OPENCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverLibraryTypeGetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_LIBRARY_TYPE_GET(SOLVER,LibraryType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverLibraryTypeGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverLibraryTypeGetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverLibraryTypeGetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverLibraryTypeGetNumber0

  !  
  !================================================================================================================================
  !  

  !>Returns the library type for a solver identified by an user number.
  SUBROUTINE CMISSSolverLibraryTypeGetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,LibraryType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to get the library type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to get the library type for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to get the library type for.
    INTEGER(INTG), INTENT(OUT) :: LibraryType !<On return, the library type for the solver. \see OPENCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverLibraryTypeGetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_LIBRARY_TYPE_GET(SOLVER,LibraryType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverLibraryTypeGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverLibraryTypeGetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverLibraryTypeGetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverLibraryTypeGetNumber1

  !================================================================================================================================
  !  
 
  !>Returns the library type for a solver identified by an object.
  SUBROUTINE CMISSSolverLibraryTypeGetObj(Solver,LibraryType,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The solver to get the library type for.
    INTEGER(INTG), INTENT(OUT) :: LibraryType !<On return, the library type for the solver. \see OPENCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverLibraryTypeGetObj",Err,ERROR,*999)
 
    CALL SOLVER_LIBRARY_TYPE_GET(Solver%SOLVER,LibraryType,Err,ERROR,*999)

    CALL EXITS("CMISSSolverLibraryTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSSolverLibraryTypeGetObj",Err,ERROR)
    CALL EXITS("CMISSSolverLibraryTypeGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverLibraryTypeGetObj
    
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the type of library for a solver identified by an user number.
  SUBROUTINE CMISSSolverLibraryTypeSetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,LibraryType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the library type for.
    INTEGER(INTG), INTENT(IN) :: LibraryType !<The library type for the solver to set. \see OPENCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverLibraryTypeSetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_LIBRARY_TYPE_SET(SOLVER,LibraryType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverLibraryTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverLibraryTypeSetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverLibraryTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverLibraryTypeSetNumber0

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the library type for a solver identified by an user number.
  SUBROUTINE CMISSSolverLibraryTypeSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,LibraryType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the library type for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the library type for.
    INTEGER(INTG), INTENT(IN) :: LibraryType !<The library type for the solver to set. \see OPENCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverLibraryTypeSetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_LIBRARY_TYPE_SET(SOLVER,LibraryType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverLibraryTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverLibraryTypeSetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverLibraryTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverLibraryTypeSetNumber1

  !================================================================================================================================
  !  
 
  !>Sets/changes the library type for a solver identified by an object.
  SUBROUTINE CMISSSolverLibraryTypeSetObj(Solver,LibraryType,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: LibraryType !<The library type for the solver to set. \see OPENCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverLibraryTypeSetObj",Err,ERROR,*999)
 
    CALL SOLVER_LIBRARY_TYPE_SET(Solver%SOLVER,LibraryType,Err,ERROR,*999)

    CALL EXITS("CMISSSolverLibraryTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverLibraryTypeSetObj",Err,ERROR)
    CALL EXITS("CMISSSolverLibraryTypeSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverLibraryTypeSetObj
    
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the type of direct linear solver for a solver identified by an user number.
  SUBROUTINE CMISSSolverLinearDirectTypeSetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,DirectSolverType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the direct linear solver to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the direct linear solver to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: DirectSolverType !<The type of the direct linear solver to set. \see OPENCMISS_DirectLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverLinearDirectTypeSetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_LINEAR_DIRECT_TYPE_SET(SOLVER,DirectSolverType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearDirectTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverLinearDirectTypeSetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverLinearDirectTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverLinearDirectTypeSetNumber0

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the type of direct linear solver for a solver identified by an user number.
  SUBROUTINE CMISSSolverLinearDirectTypeSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,DirectSolverType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the direct linear solver to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: DirectSolverType !<The type of the direct linear solver to set. \see OPENCMISS_DirectLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverLinearDirectTypeSetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_LINEAR_DIRECT_TYPE_SET(SOLVER,DirectSolverType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearDirectTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverLinearDirectTypeSetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverLinearDirectTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverLinearDirectTypeSetNumber1

  !================================================================================================================================
  !  
 
  !>Sets/changes the type of direct linear solver for a solver identified by an object.
  SUBROUTINE CMISSSolverLinearDirectTypeSetObj(Solver,DirectSolverType,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: DirectSolverType !<The type of the direct linear solver to set. \see OPENCMISS_DirectLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverLinearDirectTypeSetObj",Err,ERROR,*999)
 
    CALL SOLVER_LINEAR_DIRECT_TYPE_SET(Solver%SOLVER,DirectSolverType,Err,ERROR,*999)

    CALL EXITS("CMISSSolverLinearDirectTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverLinearDirectTypeSetObj",Err,ERROR)
    CALL EXITS("CMISSSolverLinearDirectTypeSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverLinearDirectTypeSetObj
    
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the maximum absolute tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolverLinearIterativeAbsoluteToleranceSetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex, &
    & AbsoluteTolerance,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the iterative linear solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: AbsoluteTolerance !<The absolute tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverLinearIterativeAbsoluteToleranceSetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_LINEAR_ITERATIVE_ABSOLUTE_TOLERANCE_SET(SOLVER,AbsoluteTolerance,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearIterativeAbsoluteToleranceSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeAbsoluteToleranceSetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverLinearIterativeAbsoluteToleranceSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverLinearIterativeAbsoluteToleranceSetNumber0

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the maximum absolute tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolverLinearIterativeAbsoluteToleranceSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex, &
    & AbsoluteTolerance,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the iterative linear solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: AbsoluteTolerance !<The absolute tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverLinearIterativeAbsoluteToleranceSetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_LINEAR_ITERATIVE_ABSOLUTE_TOLERANCE_SET(SOLVER,AbsoluteTolerance,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearIterativeAbsoluteToleranceSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeAbsoluteToleranceSetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverLinearIterativeAbsoluteToleranceSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverLinearIterativeAbsoluteToleranceSetNumber1

  !================================================================================================================================
  !  
 
  !>Sets/changes the maximum absolute tolerance for an iterative linear solver identified by an object.
  SUBROUTINE CMISSSolverLinearIterativeAbsoluteToleranceSetObj(Solver,AbsoluteTolerance,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The iterative linear solver to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: AbsoluteTolerance !<The absolute tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverLinearIterativeAbsoluteToleranceSetObj",Err,ERROR,*999)
 
    CALL SOLVER_LINEAR_ITERATIVE_ABSOLUTE_TOLERANCE_SET(Solver%SOLVER,AbsoluteTolerance,Err,ERROR,*999)

    CALL EXITS("CMISSSolverLinearIterativeAbsoluteToleranceSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeAbsoluteToleranceSetObj",Err,ERROR)
    CALL EXITS("CMISSSolverLinearIterativeAbsoluteToleranceSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverLinearIterativeAbsoluteToleranceSetObj
    
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the maximum divergence tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolverLinearIterativeDivergenceToleranceSetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex, &
    & DivergenceTolerance,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the iterative linear solver to set the divergence tolerance for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the divergence tolerance for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the divergence tolerance for.
    REAL(DP), INTENT(IN) :: DivergenceTolerance !<The divergence tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverLinearIterativeDivergenceToleranceSetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_LINEAR_ITERATIVE_DIVERGENCE_TOLERANCE_SET(SOLVER,DivergenceTolerance,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearIterativeDivergenceToleranceSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeDivergenceToleranceSetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverLinearIterativeDivergenceToleranceSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverLinearIterativeDivergenceToleranceSetNumber0

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the maximum divergence tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolverLinearIterativeDivergenceToleranceSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex, &
    & DivergenceTolerance,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the iterative linear solver to set the divergence tolerance for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the divergence tolerance for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the divergence tolerance for.
    REAL(DP), INTENT(IN) :: DivergenceTolerance !<The divergence tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverLinearIterativeDivergenceToleranceSetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_LINEAR_ITERATIVE_DIVERGENCE_TOLERANCE_SET(SOLVER,DivergenceTolerance,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearIterativeDivergenceToleranceSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeDivergenceToleranceSetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverLinearIterativeDivergenceToleranceSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverLinearIterativeDivergenceToleranceSetNumber1

  !================================================================================================================================
  !  
 
  !>Sets/changes the maximum divergence tolerance for an iterative linear solver identified by an object.
  SUBROUTINE CMISSSolverLinearIterativeDivergenceToleranceSetObj(Solver,DivergenceTolerance,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The iterative linear solver to set the divergence tolerance for.
    REAL(DP), INTENT(IN) :: DivergenceTolerance !<The divergence tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverLinearIterativeDivergenceToleranceSetObj",Err,ERROR,*999)
 
    CALL SOLVER_LINEAR_ITERATIVE_DIVERGENCE_TOLERANCE_SET(Solver%SOLVER,DivergenceTolerance,Err,ERROR,*999)

    CALL EXITS("CMISSSolverLinearIterativeDivergenceToleranceSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeDivergenceToleranceSetObj",Err,ERROR)
    CALL EXITS("CMISSSolverLinearIterativeDivergenceToleranceSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverLinearIterativeDivergenceToleranceSetObj
    
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the GMRES restart value for a GMRES iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolverLinearIterativeGMRESRestartSetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex, &
    & GMRESRestart,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the GMRES iterative linear solver to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the GMRES iterative linear solver to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the GMRES restart value for.
    INTEGER(INTG), INTENT(IN) :: GMRESRestart !<The GMRES restart value to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverLinearIterativeGMRESRestartSetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_LINEAR_ITERATIVE_GMRES_RESTART_SET(SOLVER,GMRESRestart,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearIterativeGMRESRestartSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeGMRESRestartSetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverLinearIterativeGMRESRestartSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverLinearIterativeGMRESRestartSetNumber0

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the GMRES restart value for a GMRES iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolverLinearIterativeGMRESRestartSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex, &
    & GMRESRestart,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the GMRES iterative linear solver to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: GMRESRestart !<The GMRES restart value to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverLinearIterativeGMRESRestartSetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_LINEAR_ITERATIVE_GMRES_RESTART_SET(SOLVER,GMRESRestart,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearIterativeGMRESRestartSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeGMRESRestartSetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverLinearIterativeGMRESRestartSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverLinearIterativeGMRESRestartSetNumber1

  !================================================================================================================================
  !  
 
  !>Sets/changes the GMRES restart value for a GMRES iterative linear solver identified by an object.
  SUBROUTINE CMISSSolverLinearIterativeGMRESRestartSetObj(Solver,GMRESRestart,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The GMRES iterative linear solver to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: GMRESRestart !<The GMRES restart value to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverLinearIterativeGMRESRestartSetObj",Err,ERROR,*999)
 
    CALL SOLVER_LINEAR_ITERATIVE_GMRES_RESTART_SET(Solver%SOLVER,GMRESRestart,Err,ERROR,*999)

    CALL EXITS("CMISSSolverLinearIterativeGMRESRestartSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeGMRESRestartSetObj",Err,ERROR)
    CALL EXITS("CMISSSolverLinearIterativeGMRESRestartSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverLinearIterativeGMRESRestartSetObj
    
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the maximum number of iterations for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolverLinearIterativeMaximumIterationsSetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex, &
    & MaximumIterations,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the iterative linear solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: MaximumIterations !<The maximum iterations to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverLinearIterativeMaximumIterationsSetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_LINEAR_ITERATIVE_MAXIMUM_ITERATIONS_SET(SOLVER,MaximumIterations,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearIterativeMaximumIterationsSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeMaximumIterationsSetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverLinearIterativeMaximumIterationsSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverLinearIterativeMaximumIterationsSetNumber0

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the maximum number of iterations for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolverLinearIterativeMaximumIterationsSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex, &
    & MaximumIterations,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the iterative linear solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: MaximumIterations !<The maximum iterations to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverLinearIterativeMaximumIterationsSetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_LINEAR_ITERATIVE_MAXIMUM_ITERATIONS_SET(SOLVER,MaximumIterations,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearIterativeMaximumIterationsSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeMaximumIterationsSetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverLinearIterativeMaximumIterationsSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverLinearIterativeMaximumIterationsSetNumber1

  !================================================================================================================================
  !  
 
  !>Sets/changes the maximum number of iterations for an iterative linear solver identified by an object.
  SUBROUTINE CMISSSolverLinearIterativeMaximumIterationsSetObj(Solver,MaximumIterations,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The iterative linear solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: MaximumIterations !<The maximum iterations to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverLinearIterativeMaximumIterationsSetObj",Err,ERROR,*999)
 
    CALL SOLVER_LINEAR_ITERATIVE_MAXIMUM_ITERATIONS_SET(Solver%SOLVER,MaximumIterations,Err,ERROR,*999)

    CALL EXITS("CMISSSolverLinearIterativeMaximumIterationsSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeMaximumIterationsSetObj",Err,ERROR)
    CALL EXITS("CMISSSolverLinearIterativeMaximumIterationsSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverLinearIterativeMaximumIterationsSetObj
    
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the preconditioner type for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolverLinearIterativePreconditionerTypeSetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex, &
    & PreconditionerType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the iterative linear solver to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: PreconditionerType !<The preconditioner type to set. \see OPENCMISS_IterativePreconditionerTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverLinearIterativePreconditionerTypeSetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_LINEAR_ITERATIVE_PRECONDITIONER_TYPE_SET(SOLVER,PreconditionerType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearIterativePreconditionerTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativePreconditionerTypeSetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverLinearIterativePreconditionerTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverLinearIterativePreconditionerTypeSetNumber0

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the preconditioner type for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolverLinearIterativePreconditionerTypeSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex, &
    & PreconditionerType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the iterative linear solver to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: PreconditionerType !<The preconditioner type to set. \see OPENCMISS_IterativePreconditionerTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverLinearIterativePreconditionerTypeSetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_LINEAR_ITERATIVE_PRECONDITIONER_TYPE_SET(SOLVER,PreconditionerType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearIterativePreconditionerTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativePreconditionerTypeSetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverLinearIterativePreconditionerTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverLinearIterativePreconditionerTypeSetNumber1

  !================================================================================================================================
  !  
 
  !>Sets/changes the preconditioner type for an iterative linear solver identified by an object.
  SUBROUTINE CMISSSolverLinearIterativePreconditionerTypeSetObj(Solver,PreconditionerType,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The iterative linear solver to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: PreconditionerType !<The preconditioner type to set. \see OPENCMISS_IterativePreconditionerTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverLinearIterativePreconditionerTypeSetObj",Err,ERROR,*999)
 
    CALL SOLVER_LINEAR_ITERATIVE_PRECONDITIONER_TYPE_SET(Solver%SOLVER,PreconditionerType,Err,ERROR,*999)

    CALL EXITS("CMISSSolverLinearIterativePreconditionerTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativePreconditionerTypeSetObj",Err,ERROR)
    CALL EXITS("CMISSSolverLinearIterativePreconditionerTypeSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverLinearIterativePreconditionerTypeSetObj
    
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the maximum relative tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolverLinearIterativeRelativeToleranceSetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex, &
    & RelativeTolerance,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the iterative linear solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: RelativeTolerance !<The relative tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverLinearIterativeRelativeToleranceSetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_LINEAR_ITERATIVE_RELATIVE_TOLERANCE_SET(SOLVER,RelativeTolerance,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearIterativeRelativeToleranceSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeRelativeToleranceSetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverLinearIterativeRelativeToleranceSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverLinearIterativeRelativeToleranceSetNumber0

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the maximum relative tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolverLinearIterativeRelativeToleranceSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex, &
    & RelativeTolerance,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the iterative linear solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: RelativeTolerance !<The relative tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverLinearIterativeRelativeToleranceSetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_LINEAR_ITERATIVE_RELATIVE_TOLERANCE_SET(SOLVER,RelativeTolerance,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearIterativeRelativeToleranceSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeRelativeToleranceSetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverLinearIterativeRelativeToleranceSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverLinearIterativeRelativeToleranceSetNumber1

  !================================================================================================================================
  !  
 
  !>Sets/changes the maximum relative tolerance for an iterative linear solver identified by an object.
  SUBROUTINE CMISSSolverLinearIterativeRelativeToleranceSetObj(Solver,RelativeTolerance,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The iterative linear solver to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: RelativeTolerance !<The relative tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverLinearIterativeRelativeToleranceSetObj",Err,ERROR,*999)
 
    CALL SOLVER_LINEAR_ITERATIVE_RELATIVE_TOLERANCE_SET(Solver%SOLVER,RelativeTolerance,Err,ERROR,*999)

    CALL EXITS("CMISSSolverLinearIterativeRelativeToleranceSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeRelativeToleranceSetObj",Err,ERROR)
    CALL EXITS("CMISSSolverLinearIterativeRelativeToleranceSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverLinearIterativeRelativeToleranceSetObj
    
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the type for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolverLinearIterativeTypeSetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,IterativeSolverType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the iterative linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: IterativeSolverType !<The iterative solver type to set. \see OPENCMISS_IterativeLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverLinearIterativeTypeSetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_LINEAR_ITERATIVE_TYPE_SET(SOLVER,IterativeSolverType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearIterativeTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeTypeSetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverLinearIterativeTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverLinearIterativeTypeSetNumber0

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the type for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolverLinearIterativeTypeSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,IterativeSolverType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the iterative linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: IterativeSolverType !<The iterative solver type to set. \see OPENCMISS_IterativeLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverLinearIterativeTypeSetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_LINEAR_ITERATIVE_TYPE_SET(SOLVER,IterativeSolverType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearIterativeTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeTypeSetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverLinearIterativeTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverLinearIterativeTypeSetNumber1

  !================================================================================================================================
  !  
 
  !>Sets/changes the type for an iterative linear solver identified by an object.
  SUBROUTINE CMISSSolverLinearIterativeTypeSetObj(Solver,IterativeSolverType,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The iterative linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: IterativeSolverType !<The iterative solver type to set. \see OPENCMISS_IterativeLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverLinearIterativeTypeSetObj",Err,ERROR,*999)
 
    CALL SOLVER_LINEAR_ITERATIVE_TYPE_SET(Solver%SOLVER,IterativeSolverType,Err,ERROR,*999)

    CALL EXITS("CMISSSolverLinearIterativeTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeTypeSetObj",Err,ERROR)
    CALL EXITS("CMISSSolverLinearIterativeTypeSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverLinearIterativeTypeSetObj
    
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the type for a linear solver identified by an user number.
  SUBROUTINE CMISSSolverLinearTypeSetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,LinearSolverType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: LinearSolverType !<The linear solver type to set. \see OPENCMISS_LinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverLinearTypeSetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_LINEAR_TYPE_SET(SOLVER,LinearSolverType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverLinearTypeSetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverLinearTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverLinearTypeSetNumber0

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the type for a linear solver identified by an user number.
  SUBROUTINE CMISSSolverLinearTypeSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,LinearSolverType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: LinearSolverType !<The linear solver type to set. \see OPENCMISS_LinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverLinearTypeSetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_LINEAR_TYPE_SET(SOLVER,LinearSolverType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverLinearTypeSetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverLinearTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverLinearTypeSetNumber1

  !================================================================================================================================
  !  
 
  !>Sets/changes the type for a linear solver identified by an object.
  SUBROUTINE CMISSSolverLinearTypeSetObj(Solver,LinearSolverType,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: LinearSolverType !<The linear solver type to set. \see OPENCMISS_LinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverLinearTypeSetObj",Err,ERROR,*999)
 
    CALL SOLVER_LINEAR_TYPE_SET(Solver%SOLVER,LinearSolverType,Err,ERROR,*999)

    CALL EXITS("CMISSSolverLinearTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverLinearTypeSetObj",Err,ERROR)
    CALL EXITS("CMISSSolverLinearTypeSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverLinearTypeSetObj
    
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the absolute tolerance for an Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonAbsoluteToleranceSetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,AbsoluteTolerance,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the Newton solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the Newton solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: AbsoluteTolerance !<The absolute tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverNewtonAbsoluteToleranceSetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_NEWTON_ABSOLUTE_TOLERANCE_SET(SOLVER,AbsoluteTolerance,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonAbsoluteToleranceSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonAbsoluteToleranceSetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonAbsoluteToleranceSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverNewtonAbsoluteToleranceSetNumber0

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the absolute tolerance for a Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonAbsoluteToleranceSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,AbsoluteTolerance, &
    & Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the Newton solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: AbsoluteTolerance !<The absolute tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverNewtonAbsoluteToleranceSetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_NEWTON_ABSOLUTE_TOLERANCE_SET(SOLVER,AbsoluteTolerance,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonAbsoluteToleranceSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonAbsoluteToleranceSetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonAbsoluteToleranceSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverNewtonAbsoluteToleranceSetNumber1

  !================================================================================================================================
  !  
 
  !>Sets/changes the absolute tolerance for a Newton solver identified by an object.
  SUBROUTINE CMISSSolverNewtonAbsoluteToleranceSetObj(Solver,AbsoluteTolerance,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The Newton solver to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: AbsoluteTolerance !<The absolute tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverNewtonAbsoluteToleranceSetObj",Err,ERROR,*999)
 
    CALL SOLVER_NEWTON_ABSOLUTE_TOLERANCE_SET(Solver%SOLVER,AbsoluteTolerance,Err,ERROR,*999)

    CALL EXITS("CMISSSolverNewtonAbsoluteToleranceSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonAbsoluteToleranceSetObj",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonAbsoluteToleranceSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverNewtonAbsoluteToleranceSetObj
    
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the Jacobian calculation type for an Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonJacobianCalculationTypeSetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex, &
    & JacobianCalculationType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: JacobianCalculationType !<The Jacobian calculation type for the Newton solver to set. \see OPENCMISS_JacobianCalculationTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverNewtonJacobianCalculationTypeSetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_NEWTON_JACOBIAN_CALCULATION_TYPE_SET(SOLVER,JacobianCalculationType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonJacobianCalculationTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonJacobianCalculationTypeSetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonJacobianCalculationTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverNewtonJacobianCalculationTypeSetNumber0

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the Jacobian calculation type for a Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonJacobianCalculationTypeSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex, &
    & JacobianCalculationType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: JacobianCalculationType !<The Jacobian calculation type for the Newton solver to set. \see OPENCMISS_JacobianCalculationTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverNewtonJacobianCalculationTypeSetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_NEWTON_JACOBIAN_CALCULATION_TYPE_SET(SOLVER,JacobianCalculationType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonJacobianCalculationTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonJacobianCalculationTypeSetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonJacobianCalculationTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverNewtonJacobianCalculationTypeSetNumber1

  !================================================================================================================================
  !  
 
  !>Sets/changes the Jacobian calculation type for a Newton solver identified by an object.
  SUBROUTINE CMISSSolverNewtonJacobianCalculationTypeSetObj(Solver,JacobianCalculationType,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: JacobianCalculationType !<The Jacobian calculation type for the Newton solver to set. \see OPENCMISS_JacobianCalculationTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverNewtonJacobianCalculationTypeSetObj",Err,ERROR,*999)
 
    CALL SOLVER_NEWTON_JACOBIAN_CALCULATION_TYPE_SET(Solver%SOLVER,JacobianCalculationType,Err,ERROR,*999)

    CALL EXITS("CMISSSolverNewtonJacobianCalculationTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonJacobianCalculationTypeSetObj",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonJacobianCalculationTypeSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverNewtonJacobianCalculationTypeSetObj
    
  !  
  !================================================================================================================================
  !
  
  !>Returns the linear solver associated with a Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonLinearSolverGetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,LinearSolverIndex,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to get the Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the solver to get the Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to get the Newton linear solver for.
    INTEGER(INTG), INTENT(OUT) :: LinearSolverIndex !<On return, the solver index of the linear solver.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,LINEAR_SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverNewtonLinearSolverGetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(LINEAR_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_NEWTON_LINEAR_SOLVER_GET(SOLVER,LINEAR_SOLVER,Err,ERROR,*999)
      !todo: get the solver index from linear solver
      LinearSolverIndex=LINEAR_SOLVER%GLOBAL_NUMBER
      CALL FLAG_ERROR("Not implemented.",Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonLinearSolverGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonLinearSolverGetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonLinearSolverGetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverNewtonLinearSolverGetNumber0

  !  
  !================================================================================================================================
  !  

  !>Returns the linear solver associated with a Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonLinearSolverGetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,LinearSolverIndex,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to get the Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to get the Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to get the Newton linear solver for.
    INTEGER(INTG), INTENT(OUT) :: LinearSolverIndex !<On return, the Newton linear solver index. 
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,LINEAR_SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverNewtonLinearSolverGetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(LINEAR_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_NEWTON_LINEAR_SOLVER_GET(SOLVER,LINEAR_SOLVER,Err,ERROR,*999)
      !todo: get the solver index from linear solver
      LinearSolverIndex=LINEAR_SOLVER%GLOBAL_NUMBER
      CALL FLAG_ERROR("Not implemented.",Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonLinearSolverGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonLinearSolverGetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonLinearSolverGetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverNewtonLinearSolverGetNumber1

  !================================================================================================================================
  !  
 
  !>Returns the linear solver associated with a Newton solver identified by an object.
  SUBROUTINE CMISSSolverNewtonLinearSolverGetObj(Solver,LinearSolver,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The solver to get the Newton linear solver for.
    TYPE(CMISSSolverType), INTENT(INOUT) :: LinearSolver !<On return, the Newton linear solver. 
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverNewtonLinearSolverGetObj",Err,ERROR,*999)
 
    CALL SOLVER_NEWTON_LINEAR_SOLVER_GET(Solver%SOLVER,LinearSolver%SOLVER,Err,ERROR,*999)

    CALL EXITS("CMISSSolverNewtonLinearSolverGetObj")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonLinearSolverGetObj",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonLinearSolverGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverNewtonLinearSolverGetObj
  
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the line search alpha for an Newton linesearch solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonLineSearchAlphaSetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,Alpha,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the Newton line search solver to set the alpha for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the Newton line search solver to set the alpha for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the line search alpha for.
    REAL(DP), INTENT(IN) :: Alpha !<The alpha for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverNewtonLineSearchAlphaSetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_NEWTON_LINESEARCH_ALPHA_SET(SOLVER,Alpha,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonLineSearchAlphaSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonLineSearchAlphaSetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonLineSearchAlphaSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverNewtonLineSearchAlphaSetNumber0

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the line search alpha for a Newton line search solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonLineSearchAlphaSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,Alpha,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the Newton line search solver to set the alpha for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the alpha for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the alpha for.
    REAL(DP), INTENT(IN) :: Alpha !<The alpha for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverNewtonLineSearchAlphaSetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_NEWTON_LINESEARCH_ALPHA_SET(SOLVER,Alpha,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonLineSearchAlphaSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonLineSearchAlphaSetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonLineSearchAlphaSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverNewtonLineSearchAlphaSetNumber1

  !================================================================================================================================
  !  
 
  !>Sets/changes the line search alpha for a Newton line search solver identified by an object.
  SUBROUTINE CMISSSolverNewtonLineSearchAlphaSetObj(Solver,Alpha,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The Newton line search solver to set the alpha for.
    REAL(DP), INTENT(IN) :: Alpha !<The alpha for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverNewtonLineSearchAlphaSetObj",Err,ERROR,*999)
 
    CALL SOLVER_NEWTON_LINESEARCH_ALPHA_SET(Solver%SOLVER,Alpha,Err,ERROR,*999)

    CALL EXITS("CMISSSolverNewtonLineSearchAlphaSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonLineSearchAlphaSetObj",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonLineSearchAlphaSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverNewtonLineSearchAlphaSetObj
    
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the line search maximum step for an Newton linesearch solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonLineSearchMaxStepSetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,MaxStep,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the Newton line search solver to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the Newton line search solver to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the line search maximum step for.
    REAL(DP), INTENT(IN) :: MaxStep !<The maximum step for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverNewtonLineSearchMaxStepSetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_NEWTON_LINESEARCH_MAXSTEP_SET(SOLVER,MaxStep,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonLineSearchMaxStepSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonLineSearchMaxStepSetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonLineSearchMaxStepSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverNewtonLineSearchMaxStepSetNumber0

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the line search maximum step for a Newton line search solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonLineSearchMaxStepSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,MaxStep,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the Newton line search solver to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the maximum step for.
    REAL(DP), INTENT(IN) :: MaxStep !<The maximum step for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverNewtonLineSearchMaxStepSetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_NEWTON_LINESEARCH_MAXSTEP_SET(SOLVER,MaxStep,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonLineSearchMaxStepSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonLineSearchMaxStepSetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonLineSearchMaxStepSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverNewtonLineSearchMaxStepSetNumber1

  !================================================================================================================================
  !  
 
  !>Sets/changes the line search maximum step for a Newton line search solver identified by an object.
  SUBROUTINE CMISSSolverNewtonLineSearchMaxStepSetObj(Solver,MaxStep,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The Newton line search solver to set the maximum step for.
    REAL(DP), INTENT(IN) :: MaxStep !<The maximum step for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverNewtonLineSearchMaxStepSetObj",Err,ERROR,*999)
 
    CALL SOLVER_NEWTON_LINESEARCH_MAXSTEP_SET(Solver%SOLVER,MaxStep,Err,ERROR,*999)

    CALL EXITS("CMISSSolverNewtonLineSearchMaxStepSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonLineSearchMaxStepSetObj",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonLineSearchMaxStepSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverNewtonLineSearchMaxStepSetObj
    
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the line search step tolerance for an Newton linesearch solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonLineSearchStepTolSetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,StepTol,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the Newton line search solver to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the Newton line search solver to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the line search step tolerance for.
    REAL(DP), INTENT(IN) :: StepTol !<The step tolerance for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverNewtonLineSearchStepTolSetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_NEWTON_LINESEARCH_STEPTOL_SET(SOLVER,StepTol,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonLineSearchStepTolSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonLineSearchStepTolSetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonLineSearchStepTolSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverNewtonLineSearchStepTolSetNumber0

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the line search step tolerance for a Newton line search solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonLineSearchStepTolSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,StepTol,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the Newton line search solver to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the step tolerance for.
    REAL(DP), INTENT(IN) :: StepTol !<The step tolerance for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverNewtonLineSearchStepTolSetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_NEWTON_LINESEARCH_STEPTOL_SET(SOLVER,StepTol,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonLineSearchStepTolSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonLineSearchStepTolSetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonLineSearchStepTolSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverNewtonLineSearchStepTolSetNumber1

  !================================================================================================================================
  !  
 
  !>Sets/changes the line search step tolerance for a Newton line search solver identified by an object.
  SUBROUTINE CMISSSolverNewtonLineSearchStepTolSetObj(Solver,StepTol,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The Newton line search solver to set the step tolerance for.
    REAL(DP), INTENT(IN) :: StepTol !<The step tolerance for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverNewtonLineSearchStepTolSetObj",Err,ERROR,*999)
 
    CALL SOLVER_NEWTON_LINESEARCH_STEPTOL_SET(Solver%SOLVER,StepTol,Err,ERROR,*999)

    CALL EXITS("CMISSSolverNewtonLineSearchStepTolSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonLineSearchStepTolSetObj",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonLineSearchStepTolSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverNewtonLineSearchStepTolSetObj
    
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the line search type for an Newton linesearch solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonLineSearchTypeSetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,LineSearchType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: LineSearchType !<The type of line search for the Newton line search solver to set. \see OPENCMISS_NewtonLineSearchTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverNewtonLineSearchTypeSetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_NEWTON_LINESEARCH_TYPE_SET(SOLVER,LineSearchType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonLineSearchTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonLineSearchTypeSetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonLineSearchTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverNewtonLineSearchTypeSetNumber0

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the type of line search for a Newton line search solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonLineSearchTypeSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,LineSearchType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: LineSearchType !<The type of line search for the Newton line search solver to set. \see OPENCMISS_NewtonLineSearchTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverNewtonLineSearchTypeSetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_NEWTON_LINESEARCH_TYPE_SET(SOLVER,LineSearchType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonLineSearchTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonLineSearchTypeSetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonLineSearchTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverNewtonLineSearchTypeSetNumber1

  !================================================================================================================================
  !  
 
  !>Sets/changes the type of line search for a Newton line search solver identified by an object.
  SUBROUTINE CMISSSolverNewtonLineSearchTypeSetObj(Solver,LineSearchType,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: LineSearchType !<The type of line search for the Newton line search solver to set. \see OPENCMISS_NewtonLineSearchTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverNewtonLineSearchTypeSetObj",Err,ERROR,*999)
 
    CALL SOLVER_NEWTON_LINESEARCH_TYPE_SET(Solver%SOLVER,LineSearchType,Err,ERROR,*999)

    CALL EXITS("CMISSSolverNewtonLineSearchTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonLineSearchTypeSetObj",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonLineSearchTypeSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverNewtonLineSearchTypeSetObj
    
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the maximum number of function evaluations for an Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonMaximumFunctionEvaluationsSetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex, &
    & MaximumFunctionEvaluations,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the Newton solver to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the Newton solver to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: MaximumFunctionEvaluations !<The maximum number of function evaluations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverNewtonMaximumFunctionEvaluationsSetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_NEWTON_MAXIMUM_FUNCTION_EVALUATIONS_SET(SOLVER,MaximumFunctionEvaluations,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonMaximumFunctionEvaluationsSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonMaximumFunctionEvaluationsSetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonMaximumFunctionEvaluationsSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverNewtonMaximumFunctionEvaluationsSetNumber0

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the maximum number of function evaluations for a Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonMaximumFunctionEvaluationsSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex, &
    & MaximumFunctionEvaluations,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the Newton solver to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: MaximumFunctionEvaluations !<The maximum number of function evaluations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverNewtonMaximumFunctionEvaluationsSetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_NEWTON_MAXIMUM_FUNCTION_EVALUATIONS_SET(SOLVER,MaximumFunctionEvaluations,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonMaximumFunctionEvaluationsSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonMaximumFunctionEvaluationsSetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonMaximumFunctionEvaluationsSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverNewtonMaximumFunctionEvaluationsSetNumber1

  !================================================================================================================================
  !  
 
  !>Sets/changes the maximum number of function evaluations for a Newton solver identified by an object.
  SUBROUTINE CMISSSolverNewtonMaximumFunctionEvaluationsSetObj(Solver,MaximumFunctionEvaluations,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The Newton solver to set the maximum number of function evaluations for.
    INTEGER(INTG), INTENT(IN) :: MaximumFunctionEvaluations !<The maximum number of function evaluations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverNewtonMaximumFunctionEvaluationsSetObj",Err,ERROR,*999)
 
    CALL SOLVER_NEWTON_MAXIMUM_FUNCTION_EVALUATIONS_SET(Solver%SOLVER,MaximumFunctionEvaluations,Err,ERROR,*999)

    CALL EXITS("CMISSSolverNewtonMaximumFunctionEvaluationsSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonMaximumFunctionEvaluationsSetObj",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonMaximumFunctionEvaluationsSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverNewtonMaximumFunctionEvaluationsSetObj
    
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the maximum number of iterations for an Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonMaximumIterationsSetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,MaximumIterations,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the Newton solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the Newton solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: MaximumIterations !<The maximum number of iterations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverNewtonMaximumIterationsSetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_NEWTON_MAXIMUM_ITERATIONS_SET(SOLVER,MaximumIterations,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonMaximumIterationsSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonMaximumIterationsSetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonMaximumIterationsSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverNewtonMaximumIterationsSetNumber0

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the maximum number of iterations for a Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonMaximumIterationsSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,MaximumIterations, &
    & Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the Newton solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: MaximumIterations !<The maximum number of iterations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverNewtonMaximumIterationsSetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_NEWTON_MAXIMUM_ITERATIONS_SET(SOLVER,MaximumIterations,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonMaximumIterationsSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonMaximumIterationsSetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonMaximumIterationsSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverNewtonMaximumIterationsSetNumber1

  !================================================================================================================================
  !  
 
  !>Sets/changes the maximum number of iterations for a Newton solver identified by an object.
  SUBROUTINE CMISSSolverNewtonMaximumIterationsSetObj(Solver,MaximumIterations,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The Newton solver to set the maximum number of iterations for.
    INTEGER(INTG), INTENT(IN) :: MaximumIterations !<The maximum number of iterations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverNewtonMaximumIterationsSetObj",Err,ERROR,*999)
 
    CALL SOLVER_NEWTON_MAXIMUM_ITERATIONS_SET(Solver%SOLVER,MaximumIterations,Err,ERROR,*999)

    CALL EXITS("CMISSSolverNewtonMaximumIterationsSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonMaximumIterationsSetObj",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonMaximumIterationsSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverNewtonMaximumIterationsSetObj
    
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the relative tolerance for an Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonRelativeToleranceSetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,RelativeTolerance,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the Newton solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the Newton solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: RelativeTolerance !<The relative tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverNewtonRelativeToleranceSetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_NEWTON_RELATIVE_TOLERANCE_SET(SOLVER,RelativeTolerance,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonRelativeToleranceSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonRelativeToleranceSetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonRelativeToleranceSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverNewtonRelativeToleranceSetNumber0

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the relative tolerance for a Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonRelativeToleranceSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,RelativeTolerance, &
    & Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the Newton solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: RelativeTolerance !<The relative tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverNewtonRelativeToleranceSetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_NEWTON_RELATIVE_TOLERANCE_SET(SOLVER,RelativeTolerance,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonRelativeToleranceSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonRelativeToleranceSetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonRelativeToleranceSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverNewtonRelativeToleranceSetNumber1

  !================================================================================================================================
  !  
 
  !>Sets/changes the relative tolerance for a Newton solver identified by an object.
  SUBROUTINE CMISSSolverNewtonRelativeToleranceSetObj(Solver,RelativeTolerance,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The Newton solver to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: RelativeTolerance !<The relative tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverNewtonRelativeToleranceSetObj",Err,ERROR,*999)
 
    CALL SOLVER_NEWTON_RELATIVE_TOLERANCE_SET(Solver%SOLVER,RelativeTolerance,Err,ERROR,*999)

    CALL EXITS("CMISSSolverNewtonRelativeToleranceSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonRelativeToleranceSetObj",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonRelativeToleranceSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverNewtonRelativeToleranceSetObj
    
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the solution tolerance for an Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonSolutionToleranceSetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,SolutionTolerance,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the Newton solver to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the Newton solver to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the solution tolerance for.
    REAL(DP), INTENT(IN) :: SolutionTolerance !<The solution tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverNewtonSolutionToleranceSetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_NEWTON_SOLUTION_TOLERANCE_SET(SOLVER,SolutionTolerance,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonSolutionToleranceSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonSolutionToleranceSetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonSolutionToleranceSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverNewtonSolutionToleranceSetNumber0

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the solution tolerance for a Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonSolutionToleranceSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,SolutionTolerance, &
    & Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the Newton solver to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the solution tolerance for.
    REAL(DP), INTENT(IN) :: SolutionTolerance !<The absolulte tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverNewtonSolutionToleranceSetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_NEWTON_SOLUTION_TOLERANCE_SET(SOLVER,SolutionTolerance,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonSolutionToleranceSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonSolutionToleranceSetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonSolutionToleranceSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverNewtonSolutionToleranceSetNumber1

  !================================================================================================================================
  !  
 
  !>Sets/changes the solution tolerance for a Newton solver identified by an object.
  SUBROUTINE CMISSSolverNewtonSolutionToleranceSetObj(Solver,SolutionTolerance,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The Newton solver to set the solution tolerance for.
    REAL(DP), INTENT(IN) :: SolutionTolerance !<The solution tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverNewtonSolutionToleranceSetObj",Err,ERROR,*999)
 
    CALL SOLVER_NEWTON_SOLUTION_TOLERANCE_SET(Solver%SOLVER,SolutionTolerance,Err,ERROR,*999)

    CALL EXITS("CMISSSolverNewtonSolutionToleranceSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonSolutionToleranceSetObj",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonSolutionToleranceSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverNewtonSolutionToleranceSetObj
      
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the delta0 for a Newton trust region solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonTrustRegionDelta0SetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,Delta0,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the Newton trust region solver to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the Newton trust region solver to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the delta0 for.
    REAL(DP), INTENT(IN) :: Delta0 !<The delta0 for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverNewtonTrustRegionDelta0SetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_NEWTON_TRUSTREGION_DELTA0_SET(SOLVER,Delta0,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonTrustRegionDelta0SetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonTrustRegionDelta0SetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonTrustRegionDelta0SetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverNewtonTrustRegionDelta0SetNumber0

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the delta0 for a Newton trust region solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonTrustRegionDelta0SetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,Delta0,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the Newton trust region solver to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the delta0 for.
    REAL(DP), INTENT(IN) :: Delta0 !<The delta0 for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverNewtonTrustRegionDelta0SetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_NEWTON_TRUSTREGION_DELTA0_SET(SOLVER,Delta0,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonTrustRegionDelta0SetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonTrustRegionDelta0SetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonTrustRegionDelta0SetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverNewtonTrustRegionDelta0SetNumber1

  !================================================================================================================================
  !  
 
  !>Sets/changes the delta0 for a Newton trust region solver identified by an object.
  SUBROUTINE CMISSSolverNewtonTrustRegionDelta0SetObj(Solver,Delta0,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The Newton trust region solver to set the delta0 for.
    REAL(DP), INTENT(IN) :: Delta0 !<The delta0 for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverNewtonTrustRegionDelta0SetObj",Err,ERROR,*999)
 
    CALL SOLVER_NEWTON_TRUSTREGION_DELTA0_SET(Solver%SOLVER,Delta0,Err,ERROR,*999)

    CALL EXITS("CMISSSolverNewtonTrustRegionDelta0SetObj")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonTrustRegionDelta0SetObj",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonTrustRegionDelta0SetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverNewtonTrustRegionDelta0SetObj
    
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the tolerance for a Newton trust region solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonTrustRegionToleranceSetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,Tolerance,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the Newton trust region solver to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the Newton trust region solver to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the tolerance for.
    REAL(DP), INTENT(IN) :: Tolerance !<The tolerance for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverNewtonTrustRegionToleranceSetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_NEWTON_TRUSTREGION_TOLERANCE_SET(SOLVER,Tolerance,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonTrustRegionToleranceSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonTrustRegionToleranceSetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonTrustRegionToleranceSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverNewtonTrustRegionToleranceSetNumber0

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the tolerance for a Newton trust region solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonTrustRegionToleranceSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,Tolerance,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the Newton trust region solver to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the tolerance for.
    REAL(DP), INTENT(IN) :: Tolerance !<The tolerance for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverNewtonTrustRegionToleranceSetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_NEWTON_TRUSTREGION_TOLERANCE_SET(SOLVER,Tolerance,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonTrustRegionToleranceSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonTrustRegionToleranceSetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonTrustRegionToleranceSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverNewtonTrustRegionToleranceSetNumber1

  !================================================================================================================================
  !  
 
  !>Sets/changes the tolerance for a Newton trust region solver identified by an object.
  SUBROUTINE CMISSSolverNewtonTrustRegionToleranceSetObj(Solver,Tolerance,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The Newton trust region solver to set the tolerance for.
    REAL(DP), INTENT(IN) :: Tolerance !<The tolerance for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverNewtonTrustRegionToleranceSetObj",Err,ERROR,*999)
 
    CALL SOLVER_NEWTON_TRUSTREGION_TOLERANCE_SET(Solver%SOLVER,Tolerance,Err,ERROR,*999)

    CALL EXITS("CMISSSolverNewtonTrustRegionToleranceSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonTrustRegionToleranceSetObj",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonTrustRegionToleranceSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverNewtonTrustRegionToleranceSetObj
    
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the type of a Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonTypeSetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,NewtonSolveType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: NewtonSolveType !<The type of the Newton solver to set. \see OPENCMISS_NewtonSolverTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverNewtonTypeSetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_NEWTON_TYPE_SET(SOLVER,NewtonSolveType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonTypeSetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverNewtonTypeSetNumber0

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the type of a Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonTypeSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,NewtonSolveType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: NewtonSolveType !<The type of the Newton solver to set. \see OPENCMISS_NewtonSolverTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverNewtonTypeSetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_NEWTON_TYPE_SET(SOLVER,NewtonSolveType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonTypeSetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverNewtonTypeSetNumber1

  !================================================================================================================================
  !  
 
  !>Sets/changes the type of a Newton solver identified by an object.
  SUBROUTINE CMISSSolverNewtonTypeSetObj(Solver,NewtonSolveType,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: NewtonSolveType !<The type of the Newton solver to set. \see OPENCMISS_NewtonSolverTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverNewtonTypeSetObj",Err,ERROR,*999)
 
    CALL SOLVER_NEWTON_TYPE_SET(Solver%SOLVER,NewtonSolveType,Err,ERROR,*999)

    CALL EXITS("CMISSSolverNewtonTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonTypeSetObj",Err,ERROR)
    CALL EXITS("CMISSSolverNewtonTypeSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverNewtonTypeSetObj
    
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the type of a nonlinear solver identified by an user number.
  SUBROUTINE CMISSSolverNonlinearTypeSetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,NonlinearSolveType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the nonlinear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the nonlinear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: NonlinearSolveType !<The type of the nonlinear solver to set. \see OPENCMISS_NonlinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverNonlinearTypeSetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_NONLINEAR_TYPE_SET(SOLVER,NonlinearSolveType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverNonlinearTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverNonlinearTypeSetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverNonlinearTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverNonlinearTypeSetNumber0

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the type of a nonlinear solver identified by an user number.
  SUBROUTINE CMISSSolverNonlinearTypeSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,NonlinearSolveType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the nonlinear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: NonlinearSolveType !<The type of the nonlinear solver to set. \see OPENCMISS_NonlinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverNonlinearTypeSetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_NONLINEAR_TYPE_SET(SOLVER,NonlinearSolveType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverNonlinearTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverNonlinearTypeSetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverNonlinearTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverNonlinearTypeSetNumber1

  !================================================================================================================================
  !  
 
  !>Sets/changes the type of a nonlinear solver identified by an object.
  SUBROUTINE CMISSSolverNonlinearTypeSetObj(Solver,NonlinearSolveType,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The nonlinear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: NonlinearSolveType !<The type of the nonlinear solver to set. \see OPENCMISS_NonlinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverNonlinearTypeSetObj",Err,ERROR,*999)
 
    CALL SOLVER_NONLINEAR_TYPE_SET(Solver%SOLVER,NonlinearSolveType,Err,ERROR,*999)

    CALL EXITS("CMISSSolverNonlinearTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverNonlinearTypeSetObj",Err,ERROR)
    CALL EXITS("CMISSSolverNonlinearTypeSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverNonlinearTypeSetObj
    
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the output type for a solver identified by an user number.
  SUBROUTINE CMISSSolverOutputTypeSetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,OutputType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to set the output type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the solver to set the output type for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the output type for.
    INTEGER(INTG), INTENT(IN) :: OutputType !<The type of solver output to set. \see OPENCMISS_SolverOutputTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverOutputTypeSetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_OUTPUT_TYPE_SET(SOLVER,OutputType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverOutputTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverOutputTypeSetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverOutputTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverOutputTypeSetNumber0

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the type of output for a solver identified by an user number.
  SUBROUTINE CMISSSolverOutputTypeSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,OutputType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to set the output type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the output type for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the output type for.
    INTEGER(INTG), INTENT(IN) :: OutputType !<The type of solver output to set. \see OPENCMISS_SolverOutputTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverOutputTypeSetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_OUTPUT_TYPE_SET(SOLVER,OutputType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverOutputTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverOutputTypeSetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverOutputTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverOutputTypeSetNumber1

  !================================================================================================================================
  !  
 
  !>Sets/changes the output type for a solver identified by an object.
  SUBROUTINE CMISSSolverOutputTypeSetObj(Solver,OutputType,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The solver to set the output type for.
    INTEGER(INTG), INTENT(IN) :: OutputType !<The type of solver output to set. \see OPENCMISS_SolverOutputTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverOutputTypeSetObj",Err,ERROR,*999)
 
    CALL SOLVER_OUTPUT_TYPE_SET(Solver%SOLVER,OutputType,Err,ERROR,*999)

    CALL EXITS("CMISSSolverOutputTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverOutputTypeSetObj",Err,ERROR)
    CALL EXITS("CMISSSolverOutputTypeSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverOutputTypeSetObj
    
  !  
  !================================================================================================================================
  !
  
  !>Returns the solver equations for a solver identified by an user number.
  SUBROUTINE CMISSSolverSolverEquationsGetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,SolverEquations,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the solver to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to get the solver equations for.
    TYPE(CMISSSolverEquationsType), INTENT(INOUT) :: SolverEquations !<On return, the solver equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverSolverEquationsGetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_SOLVER_EQUATIONS_GET(SOLVER,SolverEquations%SOLVER_EQUATIONS,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverSolverEquationsGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverSolverEquationsGetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverSolverEquationsGetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverSolverEquationsGetNumber0

  !  
  !================================================================================================================================
  !  

  !>Returns the solver equations for a solver identified by an user number.
  SUBROUTINE CMISSSolverSolverEquationsGetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,SolverEquations,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to get the solver equations for.
    TYPE(CMISSSolverEquationsType), INTENT(INOUT) :: SolverEquations !<On return, the solver equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverSolverEquationsGetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_SOLVER_EQUATIONS_GET(SOLVER,SolverEquations%SOLVER_EQUATIONS,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverSolverEquationsGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverSolverEquationsGetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverSolverEquationsGetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverSolverEquationsGetNumber1

  !================================================================================================================================
  !  
 
  !>Returns the solver equations for a solver identified by an object.
  SUBROUTINE CMISSSolverSolverEquationsGetObj(Solver,SolverEquations,Err)
  
    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: Solver !<The solver to get the solver equations for.
    TYPE(CMISSSolverEquationsType), INTENT(INOUT) :: SolverEquations !<On return, the solver equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverSolverEquationsGetObj",Err,ERROR,*999)
 
    CALL SOLVER_SOLVER_EQUATIONS_GET(Solver%SOLVER,SolverEquations%SOLVER_EQUATIONS,Err,ERROR,*999)

    CALL EXITS("CMISSSolverSolverEquationsGetObj")
    RETURN
999 CALL ERRORS("CMISSSolverSolverEquationsGetObj",Err,ERROR)
    CALL EXITS("CMISSSolverSolverEquationsGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverSolverEquationsGetObj
    
  !  
  !================================================================================================================================
  !
  
  !>Adds equations sets to solver equations identified by an user number.
  SUBROUTINE CMISSSolverEquationsEquationsSetAddNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex, &
    & RegionUserNumber,EquationsSetUserNumber,EquationsSetIndex,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem with the solver to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the solver to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region with the equations set to add.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to add.
    INTEGER(INTG), INTENT(OUT) :: EquationsSetIndex !<On return, the index of the added equations set in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverEquationsEquationsSetAddNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_SOLVER_EQUATIONS_GET(SOLVER,SOLVER_EQUATIONS,Err,ERROR,*999)
      CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
      IF(ASSOCIATED(REGION)) THEN
        CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
        IF(ASSOCIATED(EQUATIONS_SET)) THEN
          CALL SOLVER_EQUATIONS_EQUATIONS_SET_ADD(SOLVER_EQUATIONS,EQUATIONS_SET,EquationsSetIndex,Err,ERROR,*999)
        ELSE
          LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
            & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
          & " does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverEquationsEquationsSetAddNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverEquationsEquationsSetAddNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverEquationsEquationsSetAddNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverEquationsEquationsSetAddNumber0

  !  
  !================================================================================================================================
  !  

  !>Adds equations sets to solver equations identified by an user number.
  SUBROUTINE CMISSSolverEquationsEquationsSetAddNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex, &
    & RegionUserNumber,EquationsSetUserNumber,EquationsSetIndex,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region with the equations set to add.
    INTEGER(INTG), INTENT(IN) :: EquationsSetUserNumber !<The user number of the equations set to add.
    INTEGER(INTG), INTENT(OUT) :: EquationsSetIndex !<On return, the index of the added equations set in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverEquationsEquationsSetAddNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_SOLVER_EQUATIONS_GET(SOLVER,SOLVER_EQUATIONS,Err,ERROR,*999)
      CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
      IF(ASSOCIATED(REGION)) THEN
        CALL EQUATIONS_SET_USER_NUMBER_FIND(EquationsSetUserNumber,REGION,EQUATIONS_SET,Err,ERROR,*999)
        IF(ASSOCIATED(EQUATIONS_SET)) THEN
          CALL SOLVER_EQUATIONS_EQUATIONS_SET_ADD(SOLVER_EQUATIONS,EQUATIONS_SET,EquationsSetIndex,Err,ERROR,*999)
        ELSE
          LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(EquationsSetUserNumber,"*",Err,ERROR))// &
            & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
          & " does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverEquationsEquationsSetAddNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverEquationsEquationsSetAddNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverEquationsEquationsSetAddNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverEquationsEquationsSetAddNumber1

  !================================================================================================================================
  !  
 
  !>Adds equations sets to solver equations identified by an object.
  SUBROUTINE CMISSSolverEquationsEquationsSetAddObj(SolverEquations,EquationsSet,EquationsSetIndex,Err)
  
    !Argument variables
    TYPE(CMISSSolverEquationsType), INTENT(IN) :: SolverEquations !<The solver equations to add the equations set for.
    TYPE(CMISSEquationsSetType), INTENT(IN) :: EquationsSet !<The equations set to add.
    INTEGER(INTG), INTENT(OUT) :: EquationsSetIndex !<On return, the index of the added equations set in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverEquationsEquationsSetAddObj",Err,ERROR,*999)
 
    CALL SOLVER_EQUATIONS_EQUATIONS_SET_ADD(SolverEquations%SOLVER_EQUATIONS,EquationsSet%EQUATIONS_SET,EquationsSetIndex, &
      & Err,ERROR,*999)

    CALL EXITS("CMISSSolverEquationsEquationsSetAddObj")
    RETURN
999 CALL ERRORS("CMISSSolverEquationsEquationsSetAddObj",Err,ERROR)
    CALL EXITS("CMISSSolverEquationsEquationsSetAddObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverEquationsEquationsSetAddObj
    
  !  
  !================================================================================================================================
  !
  
  !>Sets/changes the sparsity type for solver equations identified by an user number.
  SUBROUTINE CMISSSolverEquationsSparsityTypeSetNumber0(ProblemUserNumber,ControlLoopIdentifier,SolverIndex,SparsityType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifier !<The control loop identifier with the solver to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: SparsityType !<The sparsity type to set. \see OPENCMISS_SolverEquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverEquationsSparsityTypeSetNumber0",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(SOLVER_EQUATIONS)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifier,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_SOLVER_EQUATIONS_GET(SOLVER,SOLVER_EQUATIONS,Err,ERROR,*999)
      CALL SOLVER_EQUATIONS_SPARSITY_TYPE_SET(SOLVER_EQUATIONS,SparsityType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverEquationsSparsityTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverEquationsSparsityTypeSetNumber0",Err,ERROR)
    CALL EXITS("CMISSSolverEquationsSparsityTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverEquationsSparsityTypeSetNumber0

  !  
  !================================================================================================================================
  !  

  !>Sets/changes the sparsity type for solver equations identified by an user number.
  SUBROUTINE CMISSSolverEquationsSparsityTypeSetNumber1(ProblemUserNumber,ControlLoopIdentifiers,SolverIndex,SparsityType,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ProblemUserNumber !<The user number of the problem number with the solver to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: ControlLoopIdentifiers(:) !<ControlLoopIdentifiers(i). The i'th control loop identifier to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: SolverIndex !<The solver index to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: SparsityType !<The sparsity type to set. \see OPENCMISS_SolverEquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSSolverEquationsSparsityTypeSetNumber1",Err,ERROR,*999)
 
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(SOLVER_EQUATIONS)
    CALL PROBLEM_USER_NUMBER_FIND(ProblemUserNumber,PROBLEM,Err,ERROR,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,ControlLoopIdentifiers,SolverIndex,SOLVER,Err,ERROR,*999)
      CALL SOLVER_SOLVER_EQUATIONS_GET(SOLVER,SOLVER_EQUATIONS,Err,ERROR,*999)
      CALL SOLVER_EQUATIONS_SPARSITY_TYPE_SET(SOLVER_EQUATIONS,SparsityType,Err,ERROR,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(ProblemUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSSolverEquationsSparsityTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverEquationsSparsityTypeSetNumber1",Err,ERROR)
    CALL EXITS("CMISSSolverEquationsSparsityTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSSolverEquationsSparsityTypeSetNumber1

  !================================================================================================================================
  !  
 
  !>Sets/changes the sparsity type for solver equations identified by an object.
  SUBROUTINE CMISSSolverEquationsSparsityTypeSetObj(SolverEquations,SparsityType,Err)
  
    !Argument variables
    TYPE(CMISSSolverEquationsType), INTENT(IN) :: SolverEquations !<The solver equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: SparsityType !<The sparsity type to set. \see OPENCMISS_SolverEquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSSolverEquationsSparsityTypeSetObj",Err,ERROR,*999)
 
    CALL SOLVER_EQUATIONS_SPARSITY_TYPE_SET(SolverEquations%SOLVER_EQUATIONS,SparsityType,Err,ERROR,*999)

    CALL EXITS("CMISSSolverEquationsSparsityTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverEquationsSparsityTypeSetObj",Err,ERROR)
    CALL EXITS("CMISSSolverEquationsSparsityTypeSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN

  END SUBROUTINE CMISSSolverEquationsSparsityTypeSetObj
    
  !  
  !================================================================================================================================
  !

END MODULE OPENCMISS
