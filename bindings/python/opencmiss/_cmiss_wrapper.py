"""Wrap the OpenCMISS python interface generated by SWIG to make
it more object oriented and "Pythonic"
"""

import opencmiss_swig
from _docstrings import docstrings as _docstrings
from _types import types as _types

class CMISSError(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)


class CMWrapper(object):
    """OpenCMISS python interface

    All OpenCMISS routines and constants can be accessed through this object
    without the "CMIS" prefix. Error return values are checked and exceptions
    are raised for non-zero return values.
    """

    def __init__(self):
        """Initialise OpenCMISS, setting the WorldCoordinateSystem
        and WorldRegion attributes
        """

        self.WorldCoordinateSystem = self.CoordinateSystemTypeInitialise()
        self.WorldRegion = self.RegionTypeInitialise()
        self.Initialise(self.WorldCoordinateSystem, self.WorldRegion)
        self.ErrorHandlingModeSet(self.ReturnErrorCode) #Don't output errors, we'll include trace in exception

        for type in _types:
            self.__setattr__(type,self._make_class(type))

    def __getattr__(self,attr_name):
        """Get an OpenCMISS constant or routine, removing the need to
        prefix it with a CMISS namespace as this is done already in Python.

        If the attribute is a function, then return a wrapped function
        that checks the return status for errors.
        """

        #Constants in Python should be in capitals with underscores, but
        #if we converted to camel-case this would screw up things like
        #CMISSSolverPETScLibrary, so just use camel-case
        try:
            attr = getattr(opencmiss_swig,'CMISS'+attr_name)
            if hasattr(attr,'__call__'):
                return_func = lambda *args: self._wrap_routine(attr, args)
                return_func.__name__ = attr_name
                try:
                    return_func.__doc__ = _docstrings['CMISS'+attr_name]
                except KeyError:
                    return_func.__doc__ = ''
                return return_func
            else:
                return attr
        except AttributeError:
            raise AttributeError("OpenCMISS has no constant or routine CMISS%s" % (attr_name))

    def _wrap_routine(self, routine, args=None):
        """Call a routine and check the return value, raise an
        exception if it is non-zero and return any other return values
        """

        if args is None:
            r = routine()
        else:
            #Replace wrapped cmiss types with the underlying type
            new_args = []
            for arg in args:
                if hasattr(arg,'cmiss_type'):
                    new_args.append(arg.cmiss_type)
                else:
                    new_args.append(arg)
            r = routine(*new_args)
        if isinstance(r,tuple):
            status = r[0]
            if len(r) == 1:
                return_val = None
            elif len(r) == 2:
                return_val = r[1]
            else:
                return_val = r[1:]
        else:
            status = r
            return_val = None
        if status != 0:
            #TODO: get error strings from OpenCMISS
            raise CMISSError, 'Non-zero return value'
        return return_val

    def _make_class(self,type_name):
        """Create a class to wrap a CMISS type
        """

        cm = self

        def init_func(self,*args):
            self.cmiss_type = getattr(cm,'%sTypeInitialise' % type_name)()
            self.type_name = type_name
            args += (self.cmiss_type,)
            getattr(cm,'%sCreateStart' % type_name)(*args)
        init_func.__doc__ = "Initialise a CMISS%sType, and start its creation." % type_name
        #TODO: Add list of parameters to docstring from doxygen comments on the create start routine

        docstring = "CMISS %s" % type_name
        #TODO: Get a list of method routines, maybe generate a _methods file so that initialising
        #all the types doesn't take forever

        kwattrs = {'__init__':init_func,'__doc__':docstring}
        return type(type_name, (object,), dict(**kwattrs))

