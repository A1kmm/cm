!> \file
!> $Id$
!> \author Chris Bradley
!> \brief This module handles all finite elasticity routines.
!>
!> \section LICENSE
!>
!> Version: MPL 1.1/GPL 2.0/LGPL 2.1
!>
!> The contents of this file are subject to the Mozilla Public License
!> Version 1.1 (the "License"); you may not use this file except in
!> compliance with the License. You may obtain a copy of the License at
!> http://www.mozilla.org/MPL/
!>
!> Software distributed under the License is distributed on an "AS IS"
!> basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
!> License for the specific language governing rights and limitations
!> under the License.
!>
!> The Original Code is openCMISS
!>
!> The Initial Developer of the Original Code is University of Auckland,
!> Auckland, New Zealand and University of Oxford, Oxford, United
!> Kingdom. Portions created by the University of Auckland and University
!> of Oxford are Copyright (C) 2007 by the University of Auckland and
!> the University of Oxford. All Rights Reserved.
!>
!> Contributor(s): Kumar Mithraratne
!>
!> Alternatively, the contents of this file may be used under the terms of
!> either the GNU General Public License Version 2 or later (the "GPL"), or
!> the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
!> in which case the provisions of the GPL or the LGPL are applicable instead
!> of those above. If you wish to allow use of your version of this file only
!> under the terms of either the GPL or the LGPL, and not to allow others to
!> use your version of this file under the terms of the MPL, indicate your
!> decision by deleting the provisions above and replace them with the notice
!> and other provisions required by the GPL or the LGPL. If you do not delete
!> the provisions above, a recipient may use your version of this file under
!> the terms of any one of the MPL, the GPL or the LGPL.
!>

!>This module handles all finite elasticity routines.
MODULE FINITE_ELASTICITY_ROUTINES

  USE BASE_ROUTINES
  USE BASIS_ROUTINES
  USE CONSTANTS
  USE CONTROL_LOOP_ROUTINES
  USE DISTRIBUTED_MATRIX_VECTOR
  USE DOMAIN_MAPPINGS
  USE EQUATIONS_MAPPING_ROUTINES
  USE EQUATIONS_MATRICES_ROUTINES
  USE EQUATIONS_SET_CONSTANTS
  USE FIELD_ROUTINES
  USE INPUT_OUTPUT
  USE ISO_VARYING_STRING
  USE KINDS
  USE MATHS  
  USE MATRIX_VECTOR
  USE PROBLEM_CONSTANTS
  USE SOLUTION_MAPPING_ROUTINES
  USE SOLUTIONS_ROUTINES
  USE SOLVER_ROUTINES
  USE STRINGS
  USE TIMER
  USE TYPES

  IMPLICIT NONE

  PRIVATE

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  PUBLIC FINITE_ELASTICITY_FINITE_ELEMENT_JACOBIAN_EVALUATE,FINITE_ELASTICITY_FINITE_ELEMENT_RESIDUAL_EVALUATE, &
    & FINITE_ELASTICITY_EQUATIONS_SET_SETUP,FINITE_ELASTICITY_EQUATIONS_SET_SUBTYPE_SET,FINITE_ELASTICITY_PROBLEM_SUBTYPE_SET, &
    & FINITE_ELASTICITY_PROBLEM_SETUP
  
CONTAINS

  !
  !================================================================================================================================
  !

  !>Evaluates the Jacobian for a finite elasticity finite element equations set.
  SUBROUTINE FINITE_ELASTICITY_FINITE_ELEMENT_JACOBIAN_EVALUATE(EQUATIONS_SET,ELEMENT_NUMBER,ERR,ERROR,*)

    !Argument variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET !<A pointer to the equations set to perform the finite element calculations on
    INTEGER(INTG), INTENT(IN) :: ELEMENT_NUMBER !<The element number to calculate
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: EQUATIONS_MAPPING
    TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: EQUATIONS_MATRICES
    TYPE(EQUATIONS_MATRICES_NONLINEAR_TYPE), POINTER :: NONLINEAR_MATRICES
    !TYPE(EQUATIONS_MATRICES_RHS_TYPE), POINTER :: RHS_VECTOR
    !TYPE(EQUATIONS_JACOBIAN_TYPE), POINTER :: EQUATIONS_JACOBIAN
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD 
    !TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(ELEMENT_VECTOR_TYPE) :: ELEMENT_VECTOR1,ELEMENT_VECTOR2,ELEMENT_VECTOR3
    TYPE(DISTRIBUTED_VECTOR_CMISS_TYPE) ::DISTRIBUTED_VECTOR_CMISS1
    INTEGER(INTG) :: component_idx,parameter_idx,element_dof_idx,m,n
    INTEGER(INTG) :: COMPONENT_NUMBER,DEPENDENT_NUMBER_OF_COMPONENTS
    INTEGER(INTG) :: DEPENDENT_COMPONENT_INTERPOLATION_TYPE,DEPENDENT_COMPONENT_NUMBER_OF_PARAMETERS, &
      & DEPENDENT_TOTAL_ELEMENT_PARAMETERS
    REAL(DP) :: DELTA
     
    CALL ENTERS("FINITE_ELASTICITY_FINITE_ELEMENT_JACOBIAN_EVALUATE",ERR,ERROR,*999)

    IF(ASSOCIATED(EQUATIONS_SET)) THEN
      EQUATIONS=>EQUATIONS_SET%EQUATIONS
      IF(ASSOCIATED(EQUATIONS)) THEN
        !CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
	CALL WRITE_STRING(GENERAL_OUTPUT_TYPE," *** Calculating Jacobian ***",ERR,ERROR,*999)
		
        DEPENDENT_FIELD=>EQUATIONS%INTERPOLATION%DEPENDENT_FIELD 
        DEPENDENT_NUMBER_OF_COMPONENTS=DEPENDENT_FIELD%VARIABLES(1)%NUMBER_OF_COMPONENTS	       
        EQUATIONS_MATRICES=>EQUATIONS%EQUATIONS_MATRICES
        NONLINEAR_MATRICES=>EQUATIONS_MATRICES%NONLINEAR_MATRICES
	
	ELEMENT_VECTOR3=NONLINEAR_MATRICES%ELEMENT_RESIDUAL		
        DISTRIBUTED_VECTOR_CMISS1=DEPENDENT_FIELD%PARAMETER_SETS%PARAMETER_SETS(1)%PTR%PARAMETERS%CMISS
	
	DELTA=0.0001_DP
	
	element_dof_idx=0
        DO component_idx=1,DEPENDENT_NUMBER_OF_COMPONENTS
          DEPENDENT_COMPONENT_INTERPOLATION_TYPE=DEPENDENT_FIELD%VARIABLES(1)%COMPONENTS(component_idx)%INTERPOLATION_TYPE
          IF (DEPENDENT_COMPONENT_INTERPOLATION_TYPE==FIELD_NODE_BASED_INTERPOLATION) THEN
	    DEPENDENT_COMPONENT_NUMBER_OF_PARAMETERS=DEPENDENT_FIELD%VARIABLES(1)%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP%NUMBER_OF_NODE_PARAMETERS
            DO parameter_idx=1,DEPENDENT_COMPONENT_NUMBER_OF_PARAMETERS
              element_dof_idx=element_dof_idx+1
	      DEPENDENT_FIELD%PARAMETER_SETS%PARAMETER_SETS(2)%PTR%PARAMETERS%CMISS%DATA_DP(element_dof_idx)= &
	        & DISTRIBUTED_VECTOR_CMISS1%DATA_DP(element_dof_idx)		
            ENDDO !parameter_idx
	  ELSEIF (DEPENDENT_COMPONENT_INTERPOLATION_TYPE==FIELD_ELEMENT_BASED_INTERPOLATION) THEN
            element_dof_idx=element_dof_idx+1	  	  
	    DEPENDENT_FIELD%PARAMETER_SETS%PARAMETER_SETS(2)%PTR%PARAMETERS%CMISS%DATA_DP(element_dof_idx)= &
	      & DISTRIBUTED_VECTOR_CMISS1%DATA_DP(element_dof_idx)	  
	  ENDIF
        ENDDO
	DEPENDENT_TOTAL_ELEMENT_PARAMETERS=element_dof_idx
	
	n=0
        DO component_idx=1,DEPENDENT_NUMBER_OF_COMPONENTS
          DEPENDENT_COMPONENT_INTERPOLATION_TYPE=DEPENDENT_FIELD%VARIABLES(1)%COMPONENTS(component_idx)%INTERPOLATION_TYPE
          IF (DEPENDENT_COMPONENT_INTERPOLATION_TYPE==FIELD_NODE_BASED_INTERPOLATION) THEN
	    DEPENDENT_COMPONENT_NUMBER_OF_PARAMETERS=DEPENDENT_FIELD%VARIABLES(1)%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP%NUMBER_OF_NODE_PARAMETERS
            DO parameter_idx=1,DEPENDENT_COMPONENT_NUMBER_OF_PARAMETERS
              n=n+1
	      
	      DEPENDENT_FIELD%PARAMETER_SETS%PARAMETER_SETS(2)%PTR%PARAMETERS%CMISS%DATA_DP(n)= &
	        & DISTRIBUTED_VECTOR_CMISS1%DATA_DP(n)+DELTA		
	      CALL FINITE_ELASTICITY_FINITE_ELEMENT_RESIDUAL_EVALUATE(EQUATIONS_SET,ELEMENT_NUMBER,ERR,ERROR,*999)
	      DEPENDENT_FIELD=>EQUATIONS%INTERPOLATION%DEPENDENT_FIELD        
              EQUATIONS_MATRICES=>EQUATIONS%EQUATIONS_MATRICES
              NONLINEAR_MATRICES=>EQUATIONS_MATRICES%NONLINEAR_MATRICES		
	      ELEMENT_VECTOR2=NONLINEAR_MATRICES%ELEMENT_RESIDUAL
	      DEPENDENT_FIELD%PARAMETER_SETS%PARAMETER_SETS(2)%PTR%PARAMETERS%CMISS%DATA_DP(n)= &
	        & DISTRIBUTED_VECTOR_CMISS1%DATA_DP(n)	
				
	      DEPENDENT_FIELD%PARAMETER_SETS%PARAMETER_SETS(2)%PTR%PARAMETERS%CMISS%DATA_DP(n)= &
	        & DISTRIBUTED_VECTOR_CMISS1%DATA_DP(n)-DELTA	        	      	      
	      CALL FINITE_ELASTICITY_FINITE_ELEMENT_RESIDUAL_EVALUATE(EQUATIONS_SET,ELEMENT_NUMBER,ERR,ERROR,*999)
	      DEPENDENT_FIELD=>EQUATIONS%INTERPOLATION%DEPENDENT_FIELD        
              EQUATIONS_MATRICES=>EQUATIONS%EQUATIONS_MATRICES
              NONLINEAR_MATRICES=>EQUATIONS_MATRICES%NONLINEAR_MATRICES		
	      ELEMENT_VECTOR1=NONLINEAR_MATRICES%ELEMENT_RESIDUAL	
	      DEPENDENT_FIELD%PARAMETER_SETS%PARAMETER_SETS(2)%PTR%PARAMETERS%CMISS%DATA_DP(n)= &
	        & DISTRIBUTED_VECTOR_CMISS1%DATA_DP(n)	
	      
	      DO m=1,DEPENDENT_TOTAL_ELEMENT_PARAMETERS
	        NONLINEAR_MATRICES%JACOBIAN%ELEMENT_JACOBIAN%MATRIX(m,n)= &
	      	  & (ELEMENT_VECTOR2%VECTOR(m)-ELEMENT_VECTOR1%VECTOR(m))/(2.0_DP*DELTA)
	      ENDDO	        	      	      
            ENDDO !parameter_idx

	  ELSEIF (DEPENDENT_COMPONENT_INTERPOLATION_TYPE==FIELD_ELEMENT_BASED_INTERPOLATION) THEN
            n=n+1	  
	  
	    DEPENDENT_FIELD%PARAMETER_SETS%PARAMETER_SETS(2)%PTR%PARAMETERS%CMISS%DATA_DP(n)= &
	      & DISTRIBUTED_VECTOR_CMISS1%DATA_DP(n)+DELTA			
	    CALL FINITE_ELASTICITY_FINITE_ELEMENT_RESIDUAL_EVALUATE(EQUATIONS_SET,ELEMENT_NUMBER,ERR,ERROR,*999)
	    DEPENDENT_FIELD=>EQUATIONS%INTERPOLATION%DEPENDENT_FIELD        
            EQUATIONS_MATRICES=>EQUATIONS%EQUATIONS_MATRICES
            NONLINEAR_MATRICES=>EQUATIONS_MATRICES%NONLINEAR_MATRICES		
	    ELEMENT_VECTOR2=NONLINEAR_MATRICES%ELEMENT_RESIDUAL
	    DEPENDENT_FIELD%PARAMETER_SETS%PARAMETER_SETS(2)%PTR%PARAMETERS%CMISS%DATA_DP(n)= &
	      & DISTRIBUTED_VECTOR_CMISS1%DATA_DP(n)	
		
	    DEPENDENT_FIELD%PARAMETER_SETS%PARAMETER_SETS(2)%PTR%PARAMETERS%CMISS%DATA_DP(n)= &
	      & DISTRIBUTED_VECTOR_CMISS1%DATA_DP(n)-DELTA	        	      	      		   
	    CALL FINITE_ELASTICITY_FINITE_ELEMENT_RESIDUAL_EVALUATE(EQUATIONS_SET,ELEMENT_NUMBER,ERR,ERROR,*999)
	    DEPENDENT_FIELD=>EQUATIONS%INTERPOLATION%DEPENDENT_FIELD        
            EQUATIONS_MATRICES=>EQUATIONS%EQUATIONS_MATRICES
            NONLINEAR_MATRICES=>EQUATIONS_MATRICES%NONLINEAR_MATRICES		
	    ELEMENT_VECTOR1=NONLINEAR_MATRICES%ELEMENT_RESIDUAL		        	      	      
	    DEPENDENT_FIELD%PARAMETER_SETS%PARAMETER_SETS(2)%PTR%PARAMETERS%CMISS%DATA_DP(n)= &
	      & DISTRIBUTED_VECTOR_CMISS1%DATA_DP(n)		      
	    	    
	    DO m=1,DEPENDENT_TOTAL_ELEMENT_PARAMETERS
	      NONLINEAR_MATRICES%JACOBIAN%ELEMENT_JACOBIAN%MATRIX(m,n)= &
                & (ELEMENT_VECTOR2%VECTOR(m)-ELEMENT_VECTOR1%VECTOR(m))/(2.0_DP*DELTA)
	     !WRITE(*,'(2(2x,i3),3(2x,f15.8))') element_dof_idx,m,ELEMENT_VECTOR2%VECTOR(m),ELEMENT_VECTOR1%VECTOR(m), &
	     !  & (ELEMENT_VECTOR2%VECTOR(m)-ELEMENT_VECTOR1%VECTOR(m))/(2.0_DP*DELTA) 
	    ENDDO	        	      	      
	  
	  ENDIF
        ENDDO
		
	NONLINEAR_MATRICES%ELEMENT_RESIDUAL=ELEMENT_VECTOR3	
	
      ELSE
        CALL FLAG_ERROR("Equations set equations is not associated.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Equations set is not associated.",ERR,ERROR,*999)
    ENDIF
       
    CALL EXITS("FINITE_ELASTICITY_FINITE_ELEMENT_JACOBIAN_EVALUATE")
    RETURN
999 CALL ERRORS("FINITE_ELASTICITY_FINITE_ELEMENT_JACOBIAN_EVALUATE",ERR,ERROR)
    CALL EXITS("FINITE_ELASTICITY_EQUATIONS_SET_FINITE_ELEMENT_JACOBIAN_EVALUATE")
    RETURN 1
  END SUBROUTINE FINITE_ELASTICITY_FINITE_ELEMENT_JACOBIAN_EVALUATE

  !
  !================================================================================================================================
  !

  !>Evaluates the residual and RHS vectors for a finite elasticity finite element equations set.
  SUBROUTINE FINITE_ELASTICITY_FINITE_ELEMENT_RESIDUAL_EVALUATE(EQUATIONS_SET,ELEMENT_NUMBER,ERR,ERROR,*)

    !Argument variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET !<A pointer to the equations set to perform the finite element calculations on
    INTEGER(INTG), INTENT(IN) :: ELEMENT_NUMBER !<The element number to calculate
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(BASIS_TYPE), POINTER :: DEPENDENT_BASIS,FIBRE_BASIS,GEOMETRIC_BASIS,MATERIALS_BASIS
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: EQUATIONS_MAPPING
    TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: EQUATIONS_MATRICES
    TYPE(EQUATIONS_MATRICES_NONLINEAR_TYPE), POINTER :: NONLINEAR_MATRICES
    !TYPE(EQUATIONS_MATRICES_RHS_TYPE), POINTER :: RHS_VECTOR
    !TYPE(EQUATIONS_JACOBIAN_TYPE), POINTER :: EQUATIONS_JACOBIAN
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD,FIBRE_FIELD,GEOMETRIC_FIELD,MATERIALS_FIELD
    !TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(QUADRATURE_SCHEME_TYPE), POINTER :: DEPENDENT_QUADRATURE_SCHEME
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: GEOMETRIC_INTERPOLATION_PARAMETERS, &
      & FIBRE_INTERPOLATION_PARAMETERS,MATERIALS_INTERPOLATION_PARAMETERS,DEPENDENT_INTERPOLATION_PARAMETERS
    TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: GEOMETRIC_INTERPOLATED_POINT,FIBRE_INTERPOLATED_POINT, &
      & MATERIALS_INTERPOLATED_POINT,DEPENDENT_INTERPOLATED_POINT
    !TYPE(VARYING_STRING) :: LOCAL_ERROR   
    INTEGER(INTG) :: component_idx,parameter_idx,gauss_idx,element_dof_idx
    INTEGER(INTG) :: component_idx1,component_idx2
    INTEGER(INTG) :: COMPONENT_NUMBER,DEPENDENT_NUMBER_OF_COMPONENTS,DEPENDENT_NUMBER_OF_ELEMENT_PARAMETERS
    INTEGER(INTG) :: DEPENDENT_COMPONENT_INTERPOLATION_TYPE,DEPENDENT_COMPONENT_NUMBER_OF_PARAMETERS
    INTEGER(INTG) :: DEPENDENT_NUMBER_OF_GAUSS_POINTS       
    REAL(DP) :: DZDNU(3,3),CAUCHY_TENSOR(3,3)
    REAL(DP) :: DFDZ(EQUATIONS_SET%EQUATIONS%INTERPOLATION%GEOMETRIC_FIELD%DECOMPOSITION%DOMAIN(1)% &
      & PTR%TOPOLOGY%ELEMENTS%ELEMENTS(ELEMENT_NUMBER)%BASIS%NUMBER_OF_ELEMENT_PARAMETERS,3)
    REAL(DP) :: GAUSS_WEIGHTS,Jznu,Jxxi
    
    	  
    CALL ENTERS("FINITE_ELASTICITY_FINITE_ELEMENT_RESIDUAL_EVALUATE",ERR,ERROR,*999)

    IF(ASSOCIATED(EQUATIONS_SET)) THEN
      EQUATIONS=>EQUATIONS_SET%EQUATIONS
      IF(ASSOCIATED(EQUATIONS)) THEN
	
        !CALL WRITE_STRING(GENERAL_OUTPUT_TYPE," *** Calculating Residulas ***",ERR,ERROR,*999)
  
        DEPENDENT_FIELD=>EQUATIONS%INTERPOLATION%DEPENDENT_FIELD
        FIBRE_FIELD=>EQUATIONS%INTERPOLATION%FIBRE_FIELD
	GEOMETRIC_FIELD=>EQUATIONS%INTERPOLATION%GEOMETRIC_FIELD
	MATERIALS_FIELD=>EQUATIONS%INTERPOLATION%MATERIALS_FIELD
        
	DEPENDENT_BASIS=>DEPENDENT_FIELD%DECOMPOSITION%DOMAIN(DEPENDENT_FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR% &
          & TOPOLOGY%ELEMENTS%ELEMENTS(ELEMENT_NUMBER)%BASIS       
        FIBRE_BASIS=>FIBRE_FIELD%DECOMPOSITION%DOMAIN(FIBRE_FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR% &
          & TOPOLOGY%ELEMENTS%ELEMENTS(ELEMENT_NUMBER)%BASIS
	GEOMETRIC_BASIS=>GEOMETRIC_FIELD%DECOMPOSITION%DOMAIN(GEOMETRIC_FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR% &
          & TOPOLOGY%ELEMENTS%ELEMENTS(ELEMENT_NUMBER)%BASIS
        MATERIALS_BASIS=>MATERIALS_FIELD%DECOMPOSITION%DOMAIN(MATERIALS_FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR% &
          & TOPOLOGY%ELEMENTS%ELEMENTS(ELEMENT_NUMBER)%BASIS

        EQUATIONS_MATRICES=>EQUATIONS%EQUATIONS_MATRICES
        NONLINEAR_MATRICES=>EQUATIONS_MATRICES%NONLINEAR_MATRICES
        EQUATIONS_MAPPING=>EQUATIONS%EQUATIONS_MAPPING
 
        DEPENDENT_QUADRATURE_SCHEME=>DEPENDENT_BASIS%QUADRATURE%QUADRATURE_SCHEME_MAP(BASIS_DEFAULT_QUADRATURE_SCHEME)%PTR
        DEPENDENT_NUMBER_OF_COMPONENTS=DEPENDENT_FIELD%VARIABLES(1)%NUMBER_OF_COMPONENTS
	DEPENDENT_NUMBER_OF_ELEMENT_PARAMETERS=DEPENDENT_BASIS%NUMBER_OF_ELEMENT_PARAMETERS
        DEPENDENT_NUMBER_OF_GAUSS_POINTS=DEPENDENT_QUADRATURE_SCHEME%NUMBER_OF_GAUSS

       !Update dependent field components(excluding hydrostatic pressure component) 	
	element_dof_idx=0
        DO component_idx=1,DEPENDENT_NUMBER_OF_COMPONENTS-1
	  DEPENDENT_COMPONENT_INTERPOLATION_TYPE=DEPENDENT_FIELD%VARIABLES(1)%COMPONENTS(component_idx)%INTERPOLATION_TYPE	  
	  IF (DEPENDENT_COMPONENT_INTERPOLATION_TYPE==FIELD_NODE_BASED_INTERPOLATION) THEN
	    DEPENDENT_COMPONENT_NUMBER_OF_PARAMETERS=DEPENDENT_FIELD%VARIABLES(1)%COMPONENTS(COMPONENT_IDX)%PARAM_TO_DOF_MAP%NUMBER_OF_NODE_PARAMETERS
            DO parameter_idx=1,DEPENDENT_COMPONENT_NUMBER_OF_PARAMETERS
              element_dof_idx=element_dof_idx+1
	      IF (NONLINEAR_MATRICES%UPDATE_RESIDUAL==.TRUE.) THEN !1st itteration - add displacement bcs to undeformed geomteric field
	        DEPENDENT_FIELD%PARAMETER_SETS%PARAMETER_SETS(1)%PTR%PARAMETERS%CMISS%DATA_DP(element_dof_idx)= &
	          & DEPENDENT_FIELD%PARAMETER_SETS%PARAMETER_SETS(2)%PTR%PARAMETERS%CMISS%DATA_DP(element_dof_idx)+ &
	          & GEOMETRIC_FIELD%PARAMETER_SETS%PARAMETER_SETS(1)%PTR%PARAMETERS%CMISS%DATA_DP(element_dof_idx)		
		NONLINEAR_MATRICES%ELEMENT_RESIDUAL%VECTOR(element_dof_idx)=0.0_DP 
	      ELSE ! subsequent iterations - copy parameters in dependent filed 2 to dpendent field 1
	        DEPENDENT_FIELD%PARAMETER_SETS%PARAMETER_SETS(1)%PTR%PARAMETERS%CMISS%DATA_DP(element_dof_idx)= &
		  & DEPENDENT_FIELD%PARAMETER_SETS%PARAMETER_SETS(2)%PTR%PARAMETERS%CMISS%DATA_DP(element_dof_idx)
		NONLINEAR_MATRICES%ELEMENT_RESIDUAL%VECTOR(element_dof_idx)=0.0_DP !Also set residual values to zero as this is reused for Jacobian calculations		  
	      ENDIF	  	      	      
            ENDDO !parameter_idx
	  ELSEIF (DEPENDENT_COMPONENT_INTERPOLATION_TYPE==FIELD_ELEMENT_BASED_INTERPOLATION) THEN
            element_dof_idx=element_dof_idx+1	 
	    !TODO - for element bassed interpolation		     
	    NONLINEAR_MATRICES%ELEMENT_RESIDUAL%VECTOR(element_dof_idx)=0.0_DP	      
	  ENDIF  
	ENDDO !component_idx	

        !Update hydrostatic presssure component, i.e. last component of the depedent field) 	
        DO component_idx=DEPENDENT_NUMBER_OF_COMPONENTS,DEPENDENT_NUMBER_OF_COMPONENTS	  
	  DEPENDENT_COMPONENT_INTERPOLATION_TYPE=DEPENDENT_FIELD%VARIABLES(1)%COMPONENTS(component_idx)%INTERPOLATION_TYPE	  
	  IF (DEPENDENT_COMPONENT_INTERPOLATION_TYPE==FIELD_NODE_BASED_INTERPOLATION) THEN
     	    DEPENDENT_COMPONENT_NUMBER_OF_PARAMETERS=DEPENDENT_FIELD%VARIABLES(1)%COMPONENTS(COMPONENT_IDX)%PARAM_TO_DOF_MAP%NUMBER_OF_NODE_PARAMETERS       
            DO parameter_idx=1,DEPENDENT_COMPONENT_NUMBER_OF_PARAMETERS
              element_dof_idx=element_dof_idx+1
	      NONLINEAR_MATRICES%ELEMENT_RESIDUAL%VECTOR(element_dof_idx)=0.0_DP
	      !TODO - for nodes based interpolation of hydrostatic pressure
            ENDDO
	  ELSEIF (DEPENDENT_COMPONENT_INTERPOLATION_TYPE==FIELD_ELEMENT_BASED_INTERPOLATION) THEN
            element_dof_idx=element_dof_idx+1
	    IF (NONLINEAR_MATRICES%UPDATE_RESIDUAL==.TRUE.) THEN !1st iteration - set initial guess
	      DEPENDENT_FIELD%PARAMETER_SETS%PARAMETER_SETS(1)%PTR%PARAMETERS%CMISS%DATA_DP(element_dof_idx)=-5.0_DP
	    ELSE ! subsequent iterations - copy parameters in dependent filed 2 to dpendent field 1
	      DEPENDENT_FIELD%PARAMETER_SETS%PARAMETER_SETS(1)%PTR%PARAMETERS%CMISS%DATA_DP(element_dof_idx)= &
		& DEPENDENT_FIELD%PARAMETER_SETS%PARAMETER_SETS(2)%PTR%PARAMETERS%CMISS%DATA_DP(element_dof_idx)	
	      NONLINEAR_MATRICES%ELEMENT_RESIDUAL%VECTOR(element_dof_idx)=0.0_DP !Also set residual values to zero as this is reused for Jacobian calculations		  			      
	    ENDIF	      	      	    	    
	  ENDIF  	  
	ENDDO !component_idx

	NONLINEAR_MATRICES%UPDATE_RESIDUAL=.FALSE.
	      	
	!Initialise tensors and matrices		
	DO component_idx1=1,3
	  DO component_idx2=1,3
	    DZDNU(component_idx1,component_idx2)=0.0_DP
	    CAUCHY_TENSOR(component_idx1,component_idx2)=0.0_DP
	    IF (component_idx1==component_idx2) DZDNU(component_idx1,component_idx2)=1.0_DP
	    IF (component_idx1==component_idx2) CAUCHY_TENSOR(component_idx1,component_idx2)=1.0_DP	    
	  ENDDO
	ENDDO
	DO parameter_idx=1,GEOMETRIC_BASIS%NUMBER_OF_ELEMENT_PARAMETERS
	  DO component_idx=1,3
	    DFDZ(parameter_idx,component_idx)=0.0_DP
	  ENDDO
        ENDDO

        GEOMETRIC_INTERPOLATION_PARAMETERS=>EQUATIONS%INTERPOLATION%GEOMETRIC_INTERP_PARAMETERS
        FIBRE_INTERPOLATION_PARAMETERS=>EQUATIONS%INTERPOLATION%FIBRE_INTERP_PARAMETERS
        MATERIALS_INTERPOLATION_PARAMETERS=>EQUATIONS%INTERPOLATION%MATERIALS_INTERP_PARAMETERS
        DEPENDENT_INTERPOLATION_PARAMETERS=>EQUATIONS%INTERPOLATION%DEPENDENT_INTERP_PARAMETERS	

        GEOMETRIC_INTERPOLATED_POINT=>EQUATIONS%INTERPOLATION%GEOMETRIC_INTERP_POINT
        FIBRE_INTERPOLATED_POINT=>EQUATIONS%INTERPOLATION%FIBRE_INTERP_POINT
        MATERIALS_INTERPOLATED_POINT=>EQUATIONS%INTERPOLATION%MATERIALS_INTERP_POINT	
        DEPENDENT_INTERPOLATED_POINT=>EQUATIONS%INTERPOLATION%DEPENDENT_INTERP_POINT
		
        CALL FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET(FIELD_VALUES_SET_TYPE,ELEMENT_NUMBER,GEOMETRIC_INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
        CALL FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET(FIELD_VALUES_SET_TYPE,ELEMENT_NUMBER,FIBRE_INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
        CALL FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET(FIELD_VALUES_SET_TYPE,ELEMENT_NUMBER,MATERIALS_INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
        CALL FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET(FIELD_VALUES_SET_TYPE,ELEMENT_NUMBER,DEPENDENT_INTERPOLATION_PARAMETERS,ERR,ERROR,*999)

        DO gauss_idx=1,DEPENDENT_NUMBER_OF_GAUSS_POINTS
          GAUSS_WEIGHTS=DEPENDENT_QUADRATURE_SCHEME%GAUSS_WEIGHTS(gauss_idx)
	
	  CALL FIELD_INTERPOLATE_XI(FIRST_PART_DERIV,DEPENDENT_QUADRATURE_SCHEME%GAUSS_POSITIONS(:,gauss_idx), &
            & DEPENDENT_INTERPOLATED_POINT,ERR,ERROR,*999)
	  CALL FIELD_INTERPOLATE_XI(NO_PART_DERIV,DEPENDENT_QUADRATURE_SCHEME%GAUSS_POSITIONS(:,gauss_idx), &
	    & DEPENDENT_INTERPOLATED_POINT,ERR,ERROR,*999)	        
	  CALL FIELD_INTERPOLATE_XI(FIRST_PART_DERIV,DEPENDENT_QUADRATURE_SCHEME%GAUSS_POSITIONS(:,gauss_idx), &
	    & GEOMETRIC_INTERPOLATED_POINT,ERR,ERROR,*999)
	  CALL FIELD_INTERPOLATE_XI(FIRST_PART_DERIV,DEPENDENT_QUADRATURE_SCHEME%GAUSS_POSITIONS(:,gauss_idx), &
	    & FIBRE_INTERPOLATED_POINT,ERR,ERROR,*999)
	  CALL FIELD_INTERPOLATE_XI(FIRST_PART_DERIV,DEPENDENT_QUADRATURE_SCHEME%GAUSS_POSITIONS(:,gauss_idx), &
	    & MATERIALS_INTERPOLATED_POINT,ERR,ERROR,*999)

          CALL FINITE_ELASTICITY_GAUSS_DEFORMATION_GRADEINT_TENSOR(DEPENDENT_INTERPOLATED_POINT,GEOMETRIC_INTERPOLATED_POINT, &
	    & FIBRE_INTERPOLATED_POINT,DZDNU,Jxxi,Jznu,ERR,ERROR,*999)    
                  
          CALL FINITE_ELASTICITY_GAUSS_CAUCHY_TENSOR(DEPENDENT_INTERPOLATED_POINT,MATERIALS_INTERPOLATED_POINT, &
	    & CAUCHY_TENSOR,DZDNU,ERR,ERROR,*999)
	
	  CALL FINITE_ELASTICITY_GAUSS_DFDZ(DEPENDENT_INTERPOLATED_POINT,DEPENDENT_NUMBER_OF_ELEMENT_PARAMETERS,ELEMENT_NUMBER, &
	    & gauss_idx,DFDZ,ERR,ERROR,*999)
	
	  element_dof_idx=0
          DO component_idx=1,DEPENDENT_NUMBER_OF_COMPONENTS	
	    IF (component_idx<DEPENDENT_NUMBER_OF_COMPONENTS) THEN ! geomteric components
	      DEPENDENT_COMPONENT_INTERPOLATION_TYPE=DEPENDENT_FIELD%VARIABLES(1)%COMPONENTS(component_idx)%INTERPOLATION_TYPE	
	      IF (DEPENDENT_COMPONENT_INTERPOLATION_TYPE==FIELD_NODE_BASED_INTERPOLATION) THEN
	        DEPENDENT_COMPONENT_NUMBER_OF_PARAMETERS=DEPENDENT_FIELD%VARIABLES(1)%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP%NUMBER_OF_NODE_PARAMETERS
		DO parameter_idx=1,DEPENDENT_COMPONENT_NUMBER_OF_PARAMETERS
	          element_dof_idx=element_dof_idx+1		    
                  !NONLINEAR_MATRICES%JACOBIAN%ELEMENT_RESIDUAL%VECTOR(element_dof_idx)= &
	          !  & NONLINEAR_MATRICES%JACOBIAN%ELEMENT_RESIDUAL%VECTOR(element_dof_idx)+ &
		  !  & GAUSS_WEIGHTS*Jxxi*Jznu*(CAUCHY_TENSOR(component_idx,1)*DFDZ(parameter_idx,1)+  &
		  !  & CAUCHY_TENSOR(component_idx,2)*DFDZ(parameter_idx,2)+ &
		  !  & CAUCHY_TENSOR(component_idx,3)*DFDZ(parameter_idx,3))		  		  		  
                  NONLINEAR_MATRICES%ELEMENT_RESIDUAL%VECTOR(element_dof_idx)= &
	            & NONLINEAR_MATRICES%ELEMENT_RESIDUAL%VECTOR(element_dof_idx)+ &
		    & GAUSS_WEIGHTS*Jxxi*Jznu*(CAUCHY_TENSOR(component_idx,1)*DFDZ(parameter_idx,1)+  &
		    & CAUCHY_TENSOR(component_idx,2)*DFDZ(parameter_idx,2)+ &
		    & CAUCHY_TENSOR(component_idx,3)*DFDZ(parameter_idx,3))		  		  		  
		ENDDO
	      ELSEIF (DEPENDENT_COMPONENT_INTERPOLATION_TYPE==FIELD_ELEMENT_BASED_INTERPOLATION) THEN
	        element_dof_idx=element_dof_idx+1
		!TODO:    	      
	      ENDIF
	    ELSEIF (component_idx==DEPENDENT_NUMBER_OF_COMPONENTS) THEN ! hydrostatic pressure component
	      DEPENDENT_COMPONENT_INTERPOLATION_TYPE=DEPENDENT_FIELD%VARIABLES(1)%COMPONENTS(component_idx)%INTERPOLATION_TYPE	
	      IF (DEPENDENT_COMPONENT_INTERPOLATION_TYPE==FIELD_NODE_BASED_INTERPOLATION) THEN
	        DEPENDENT_COMPONENT_NUMBER_OF_PARAMETERS=DEPENDENT_FIELD%VARIABLES(1)%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP%NUMBER_OF_NODE_PARAMETERS
		DO parameter_idx=1,DEPENDENT_COMPONENT_NUMBER_OF_PARAMETERS
	          element_dof_idx=element_dof_idx+1
		  !TODO: 	      
	        ENDDO
	      ELSEIF (DEPENDENT_COMPONENT_INTERPOLATION_TYPE==FIELD_ELEMENT_BASED_INTERPOLATION) THEN
	        element_dof_idx=element_dof_idx+1               
		!NONLINEAR_MATRICES%JACOBIAN%ELEMENT_RESIDUAL%VECTOR(element_dof_idx)= &
	        !  & NONLINEAR_MATRICES%JACOBIAN%ELEMENT_RESIDUAL%VECTOR(element_dof_idx)+GAUSS_WEIGHTS*Jxxi*(Jznu-1.0_DP)  
		NONLINEAR_MATRICES%ELEMENT_RESIDUAL%VECTOR(element_dof_idx)= &
	          & NONLINEAR_MATRICES%ELEMENT_RESIDUAL%VECTOR(element_dof_idx)+GAUSS_WEIGHTS*Jxxi*(Jznu-1.0_DP)    		  
	      ENDIF
		    
	    ENDIF  	  	  
	  ENDDO !component_idx
	  
	ENDDO !gauss_idx
	
	!DO element_dof_idx=1,25
	!  !WRITE(*,'(2x,i2,3x,f12.8)') element_dof_idx,NONLINEAR_MATRICES%JACOBIAN%ELEMENT_RESIDUAL%VECTOR(element_dof_idx)
	!  WRITE(*,'(2x,i2,3x,f12.8)') element_dof_idx,NONLINEAR_MATRICES%ELEMENT_RESIDUAL%VECTOR(element_dof_idx)	
        !ENDDO
	
      ELSE
        CALL FLAG_ERROR("Equations set equations is not associated.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Equations set is not associated.",ERR,ERROR,*999)
    ENDIF
       
    CALL EXITS("FINITE_ELASTICITY_FINITE_ELEMENT_RESIDUAL_EVALUATE")
    RETURN
999 CALL ERRORS("FINITE_ELASTICITY_FINITE_ELEMENT_RESIDUAL_EVALUATE",ERR,ERROR)
    CALL EXITS("FINITE_ELASTICITY_FINITE_ELEMENT_RESIDUAL_EVALUATE")
    RETURN 1
  END SUBROUTINE FINITE_ELASTICITY_FINITE_ELEMENT_RESIDUAL_EVALUATE

  !
  !================================================================================================================================
  !
  
  !>Evaluates the deformation gradient tensor at a given Gauss point
  SUBROUTINE FINITE_ELASTICITY_GAUSS_DEFORMATION_GRADEINT_TENSOR(DEPENDENT_INTERPOLATED_POINT,GEOMETRIC_INTERPOLATED_POINT, &
    & FIBRE_INTERPOLATED_POINT,DZDNU,Jxxi,Jznu,ERR,ERROR,*)    

    !Argument variables
    TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: DEPENDENT_INTERPOLATED_POINT,GEOMETRIC_INTERPOLATED_POINT,FIBRE_INTERPOLATED_POINT    
    !INTEGER(INTG) :: GAUSS_POINT_NUMBER     
    REAL(DP) :: DZDNU(:,:),Jxxi,Jznu    
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string   
    !Local Variables
    INTEGER(INTG) :: derivative_idx,component_idx,xi_idx 
    REAL(DP) :: DNUDX(3,3),DNUDXI(3,3),DXDNU(3,3),DXIDNU(3,3),DXDXI(3,3),DZDXI(3,3),Jnuxi
    !Temporary Variables    
    INTEGER(INTG) :: i,j    

    CALL ENTERS("FINITE_ELASTICITY_GAUSS_DEFORMATION_GRADEINT_TENSOR",ERR,ERROR,*999)
    	 
    DO component_idx=1,3 !GEOMETRIC_INTERPOLATED_POINT%INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
      DO xi_idx=1,3 !GEOMETRIC_INTERPOLATED_POINT%INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_XI
        derivative_idx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xi_idx)  !2,4,7      
        DXDXI(component_idx,xi_idx)=GEOMETRIC_INTERPOLATED_POINT%VALUES(component_idx,derivative_idx)  !dx/dxi
        DZDXI(component_idx,xi_idx)=DEPENDENT_INTERPOLATED_POINT%VALUES(component_idx,derivative_idx)  !dz/dxi
      ENDDO	  
    ENDDO 

    CALL FINITE_ELASTICITY_GAUSS_DXDNU(FIBRE_INTERPOLATED_POINT,DXDNU,DXDXI,ERR,ERROR,*999)

    CALL MATRIX_TRANSPOSE(DXDNU,DNUDX,ERR,ERROR,*999) !dx/dnu is orthogonal. Therefore transpose is inverse
          	  
    CALL MATRIX_PRODUCT(DNUDX,DXDXI,DNUDXI,ERR,ERROR,*999) ! dnu/dxi = dnu/dx * dx/dxi
    CALL INVERT(DNUDXI,DXIDNU,Jnuxi,ERR,ERROR,*999) ! dxi/dnu 
	  
    CALL MATRIX_PRODUCT(DZDXI,DXIDNU,DZDNU,ERR,ERROR,*999) ! dz/dnu = dz/dxi * dxi/dnu  (deformation gradient tensor, F)	
            
    Jxxi=DETERMINANT(DXDXI,ERR,ERROR)
    Jznu=DETERMINANT(DZDNU,ERR,ERROR)
             
    CALL EXITS("FINITE_ELASTICITY_GAUSS_DEFORMATION_GRADEINT_TENSOR")
    RETURN
999 CALL ERRORS("FINITE_ELASTICITY_GAUSS_DEFORMATION_GRADEINT_TENSOR",ERR,ERROR)
    CALL EXITS("FINITE_ELASTICITY_GAUSS_DEFORMATION_GRADEINT_TENSOR")
    RETURN 1
  END SUBROUTINE FINITE_ELASTICITY_GAUSS_DEFORMATION_GRADEINT_TENSOR

  !
  !================================================================================================================================
  !
  
  !>Evaluates dx/dnu(undeformed-material cs) tensor at a given Gauss point
  SUBROUTINE FINITE_ELASTICITY_GAUSS_DXDNU(INTERPOLATED_POINT,DXDNU,DXDXI,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: INTERPOLATED_POINT    
    REAL(DP) :: DXDNU(:,:),DXDXI(:,:)    
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: fibre_idx,i,j,nj_idx 
    INTEGER(INTG) :: vector(3) = (/1,2,3/)
    REAL(DP) :: A(3),ANGLE(3),B(3),C(3),DXDNU1(3,3),DXDNU2(3,3),DXDNU3(3,3),R(3,3), &
      & R1(3,3),R2(3,3),R3(3,3)

    CALL ENTERS("FINITE_ELASTICITY_GAUSS_DXDNU",ERR,ERROR,*999)
        
    !First calculate default dx/dnu
    DO nj_idx=1,3	
      A(nj_idx)=DXDXI(nj_idx,1) !default material_1 dir.
    ENDDO 
    CALL CROSS_PRODUCT(DXDXI(vector,1),DXDXI(vector,2),C,ERR,ERROR,*999) !default material_3 dir.    
    CALL CROSS_PRODUCT(C,A,B,ERR,ERROR,*999) ! default material_2 dir.      
    
    DO nj_idx=1,3	
      DXDNU(nj_idx,1)=A(nj_idx)/L2NORM(A) 
      DXDNU(nj_idx,2)=B(nj_idx)/L2NORM(B)      
      DXDNU(nj_idx,3)=C(nj_idx)/L2NORM(C)        
    ENDDO 
    
    !The normalised DXDNU contains the transformation(rotaion) from spatial CS -> material CS 
    DO i=1,3
      DO j=1,3
        R(i,j)=DXDNU(i,j) 
      ENDDO
    ENDDO
    
    !Now transform(rotate) the default material CS to align with spatial CS.
    !This does not have to be done. Since both CSs are ortonomral, v1-v2-v3 
    !end up having coordinates (1,0,0), (0,1,0) and (0,0,1)
    !Then rotate by angles specified (old CMISS - ipfibr file values)     
    DO fibre_idx=1,3,1     
      ANGLE(fibre_idx)=INTERPOLATED_POINT%VALUES(fibre_idx,1)
    ENDDO
     
    DO i=1,3
      DO j=1,3
        R1(i,j)=0.0_DP 
        R2(i,j)=0.0_DP 
        R3(i,j)=0.0_DP 
	IF (i==j) THEN
	  R1(i,j)=1.0_DP
	  R2(i,j)=1.0_DP	  
	  R3(i,j)=1.0_DP
	ENDIF  	  		
      ENDDO
    ENDDO
        
    R3(1,1)=cos(ANGLE(1))    !angles are in radians
    R3(1,2)=-sin(ANGLE(1))
    R3(2,1)=sin(ANGLE(1))
    R3(2,2)=cos(ANGLE(1))
    R2(1,1)=cos(ANGLE(2))
    R2(1,3)=sin(ANGLE(2))
    R2(3,1)=-sin(ANGLE(2))
    R2(3,3)=cos(ANGLE(2))
    R1(2,2)=cos(ANGLE(3))
    R1(2,3)=-sin(ANGLE(3))
    R1(3,2)=sin(ANGLE(3))
    R1(3,3)=cos(ANGLE(3))
    
    CALL MATRIX_PRODUCT(R3,DXDNU,DXDNU3,ERR,ERROR,*999)   !rotate about v3 => v1'-v2'-v3
    CALL MATRIX_PRODUCT(R2,DXDNU3,DXDNU2,ERR,ERROR,*999)  !rotate about v2' => v1''-v2'-v3'     
    CALL MATRIX_PRODUCT(R1,DXDNU2,DXDNU1,ERR,ERROR,*999)  !rotate about v1'' => v1''-v2''-v3''
    
    !Inverse-rotate v1''-v2''-v3''
    CALL MATRIX_PRODUCT(R,DXDNU1,DXDNU,ERR,ERROR,*999)  
            
    CALL EXITS("FINITE_ELASTICITY_GAUSS_DXDNU")
    RETURN
999 CALL ERRORS("FINITE_ELASTICITY_GAUSS_DXDNU",ERR,ERROR)
    CALL EXITS("FINITE_ELASTICITY_GAUSS_DXDNU")
    RETURN 1
  END SUBROUTINE FINITE_ELASTICITY_GAUSS_DXDNU

  !
  !================================================================================================================================
  !

  !>Evaluates the Cauchy stress tensor at a given Gauss point
  SUBROUTINE FINITE_ELASTICITY_GAUSS_CAUCHY_TENSOR(DEPENDENT_INTERPOLATED_POINT,MATERIALS_INTERPOLATED_POINT, &
    & CAUCHY_TENSOR,DZDNU,ERR,ERROR,*)

    !Argument variables    
    TYPE(FIELD_TYPE), POINTER :: FIELD    
    TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: DEPENDENT_INTERPOLATED_POINT,MATERIALS_INTERPOLATED_POINT
    REAL(DP), INTENT(OUT) :: CAUCHY_TENSOR(:,:)
    REAL(DP), INTENT(IN) ::  DZDNU(:,:)
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: i,j,PRESSURE_COMPONENT    
    REAL(DP) :: AZL(3,3),C(0:1,0:1),DZDNUT(3,3),PIOLA_TENSOR(3,3),TEMP(3,3),Jznu,P 
        
    CALL ENTERS("FINITE_ELASTICITY_GAUSS_CAUCHY_TENSOR",ERR,ERROR,*999)
	
    C(1,0)=MATERIALS_INTERPOLATED_POINT%VALUES(1,1)
    C(0,1)=MATERIALS_INTERPOLATED_POINT%VALUES(2,1)
    PRESSURE_COMPONENT=DEPENDENT_INTERPOLATED_POINT%INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
    P=DEPENDENT_INTERPOLATED_POINT%VALUES(PRESSURE_COMPONENT,1)
    
    CALL MATRIX_TRANSPOSE(DZDNU,DZDNUT,ERR,ERROR,*999)    
    CALL MATRIX_PRODUCT(DZDNUT,DZDNU,AZL,ERR,ERROR,*999) ! AZL = F'*F (deformed covariant or right cauchy defromation tensor, C)	    
        
    PIOLA_TENSOR(1,1)=2.0_DP*(C(1,0)+C(0,1)*(AZL(2,2)+AZL(3,3))+P*(AZL(2,2)*AZL(3,3)-AZL(2,3)*AZL(3,2)))
    PIOLA_TENSOR(1,2)=2.0_DP*(       C(0,1)*(-AZL(2,1))        +P*(AZL(2,3)*AZL(3,1)-AZL(2,1)*AZL(3,3)))
    PIOLA_TENSOR(1,3)=2.0_DP*(       C(0,1)*(-AZL(3,1))        +P*(AZL(2,1)*AZL(3,2)-AZL(2,2)*AZL(3,1)))            
    PIOLA_TENSOR(2,1)=PIOLA_TENSOR(1,2)
    PIOLA_TENSOR(2,2)=2.0_DP*(C(1,0)+C(0,1)*(AZL(3,3)+AZL(1,1))+P*(AZL(1,1)*AZL(3,3)-AZL(1,3)*AZL(3,1)))
    PIOLA_TENSOR(2,3)=2.0_DP*(       C(0,1)*(-AZL(3,2))        +P*(AZL(1,2)*AZL(3,1)-AZL(1,1)*AZL(3,2)))    
    PIOLA_TENSOR(3,1)=PIOLA_TENSOR(1,3)       
    PIOLA_TENSOR(3,2)=PIOLA_TENSOR(2,3) 
    PIOLA_TENSOR(3,3)=2.0_DP*(C(1,0)+C(0,1)*(AZL(1,1)+AZL(2,2))+P*(AZL(1,1)*AZL(2,2)-AZL(1,2)*AZL(2,1)))    

    Jznu=DETERMINANT(DZDNU,ERR,ERROR)

    CALL MATRIX_PRODUCT(DZDNU,PIOLA_TENSOR,TEMP,ERR,ERROR,*999)     
    CALL MATRIX_PRODUCT(TEMP,DZDNUT,CAUCHY_TENSOR,ERR,ERROR,*999)     

    DO i=1,3,1
      DO j=1,3,1
        CAUCHY_TENSOR(i,j)=CAUCHY_TENSOR(i,j)/Jznu
      ENDDO
    ENDDO
      
    CALL EXITS("FINITE_ELASTICITY_GAUSS_CAUCHY_TENSOR")
    RETURN
999 CALL ERRORS("FINITE_ELASTICITY_GAUSS_CAUCHY_TENSOR",ERR,ERROR)
    CALL EXITS("FINITE_ELASTICITY_GAUSS_CAUCHY_TENSOR")
    RETURN 1
  END SUBROUTINE FINITE_ELASTICITY_GAUSS_CAUCHY_TENSOR


  !
  !================================================================================================================================
  !

  !>Evaluates df/dz (derivative of interpolation function wrt deformed coord) matrix at a given Gauss point
  SUBROUTINE FINITE_ELASTICITY_GAUSS_DFDZ(INTERPOLATED_POINT,DEPENDENT_NUMBER_OF_ELEMENT_PARAMETERS,ELEMENT_NUMBER, &
    & GAUSS_POINT_NUMBER,DFDZ,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: INTERPOLATED_POINT       
    INTEGER(INTG), INTENT(IN) :: ELEMENT_NUMBER       
    INTEGER(INTG), INTENT(IN) :: GAUSS_POINT_NUMBER   
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    INTEGER(INTG) :: DEPENDENT_NUMBER_OF_ELEMENT_PARAMETERS
    REAL(DP) :: DFDZ(:,:)  
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string    
    !Local Variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(QUADRATURE_SCHEME_TYPE), POINTER :: QUADRATURE_SCHEME
    INTEGER(INTG) :: derivative_idx,component_idx,nk_idx,NKT,nn_idx,NNT,ns,NST,NXIT,xi_idx,parameter_idx 
    REAL(DP) :: DXIDZ(3,3),DZDXI(3,3)
    REAL(DP) :: Jzxi
    REAL(DP) :: DFDXI(DEPENDENT_NUMBER_OF_ELEMENT_PARAMETERS,3)
    !Temporary variables
    INTEGER(INTG) :: i,j    

    CALL ENTERS("FINITE_ELASTICITY_GAUSS_DFDZ",ERR,ERROR,*999)
    
    FIELD=>INTERPOLATED_POINT%INTERPOLATION_PARAMETERS%FIELD
    BASIS=>FIELD%DECOMPOSITION%DOMAIN(FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR%TOPOLOGY% &
      & ELEMENTS%ELEMENTS(ELEMENT_NUMBER)%BASIS  
    QUADRATURE_SCHEME=>BASIS%QUADRATURE%QUADRATURE_SCHEME_MAP(BASIS_DEFAULT_QUADRATURE_SCHEME)%PTR
    
    DO parameter_idx=1,DEPENDENT_NUMBER_OF_ELEMENT_PARAMETERS
      DO xi_idx=1,3
        derivative_idx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xi_idx)  !2,4,7   
        DFDXI(parameter_idx,xi_idx)=QUADRATURE_SCHEME%GAUSS_BASIS_FNS(parameter_idx,derivative_idx,GAUSS_POINT_NUMBER)
      ENDDO
    ENDDO

    DO component_idx=1,3 !FIELD%NUMBER_OF_COMPONENTS-1
      DO xi_idx=1,3 !INTERPOLATED_POINT%INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_XI
        derivative_idx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xi_idx)  !2,4,7      
        DZDXI(component_idx,xi_idx)=INTERPOLATED_POINT%VALUES(component_idx,derivative_idx)  !dz/dxi
      ENDDO	  
    ENDDO 
    
    CALL INVERT(DZDXI,DXIDZ,Jzxi,ERR,ERROR,*999) !dxi/dz 
    
    DO parameter_idx=1,DEPENDENT_NUMBER_OF_ELEMENT_PARAMETERS
      DO component_idx=1,3 !FIELD%NUMBER_OF_COMPONENTS-1
        DFDZ(parameter_idx,component_idx)=0.0_DP
	DO xi_idx=1,3
	  DFDZ(parameter_idx,component_idx)=DFDZ(parameter_idx,component_idx)+DFDXI(parameter_idx,xi_idx)*DXIDZ(xi_idx,component_idx)
	ENDDO  
      ENDDO    
    ENDDO

    CALL EXITS("FINITE_ELASTICITY_GAUSS_DFDZ")
    RETURN
999 CALL ERRORS("FINITE_ELASTICITY_GAUSS_DFDZ",ERR,ERROR)
    CALL EXITS("FINITE_ELASTICITY_GAUSS_DFDZ")
    RETURN 1
  END SUBROUTINE FINITE_ELASTICITY_GAUSS_DFDZ

  !
  !================================================================================================================================
  !

  !>Sets up the finite elasticity equation type of an elasticity equations set class.
  SUBROUTINE FINITE_ELASTICITY_EQUATIONS_SET_SETUP(EQUATIONS_SET,SETUP_TYPE,ACTION_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET !<A pointer to the equations set to setup a Laplace equation on.
    INTEGER(INTG), INTENT(IN) :: SETUP_TYPE !<The setup type
    INTEGER(INTG), INTENT(IN) :: ACTION_TYPE !<The action type
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,NEXT_NUMBER,NUMBER_OF_COMPONENTS
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: EQUATIONS_MAPPING
    TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: EQUATIONS_MATRICES
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("FINITE_ELASTICITY_EQUATIONS_SET_SETUP",ERR,ERROR,*999)

    IF(ASSOCIATED(EQUATIONS_SET)) THEN
      SELECT CASE(EQUATIONS_SET%SUBTYPE)
      CASE(EQUATIONS_SET_NO_SUBTYPE)
        SELECT CASE(SETUP_TYPE)
        CASE(EQUATIONS_SET_SETUP_INITIAL_TYPE)
          SELECT CASE(ACTION_TYPE)
          CASE(EQUATIONS_SET_SETUP_START_ACTION)
            EQUATIONS_SET%LINEARITY=EQUATIONS_SET_NONLINEAR
            EQUATIONS_SET%TIME_TYPE=EQUATIONS_SET_STATIC
            EQUATIONS_SET%SOLUTION_METHOD=EQUATIONS_SET_FEM_SOLUTION_METHOD
          CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
!!TODO: Check valid setup
          CASE DEFAULT
            LOCAL_ERROR="The action type of "//TRIM(NUMBER_TO_VSTRING(ACTION_TYPE,"*",ERR,ERROR))// &
              & " for a setup type of "//TRIM(NUMBER_TO_VSTRING(SETUP_TYPE,"*",ERR,ERROR))// &
              & " is invalid for a finite elasticity equation."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          END SELECT
        CASE(EQUATIONS_SET_SETUP_GEOMETRY_TYPE)
          !Do nothing???
        CASE(EQUATIONS_SET_SETUP_DEPENDENT_TYPE)
          SELECT CASE(ACTION_TYPE)
          CASE(EQUATIONS_SET_SETUP_START_ACTION)
!!TODO: maybe given negative user numbers to openCMISS generated fields???
            CALL FIELD_NEXT_NUMBER_FIND(EQUATIONS_SET%REGION,NEXT_NUMBER,ERR,ERROR,*999)
            CALL FIELD_CREATE_START(NEXT_NUMBER,EQUATIONS_SET%REGION,EQUATIONS_SET%DEPENDENT%DEPENDENT_FIELD,ERR,ERROR,*999)
            CALL FIELD_TYPE_SET(EQUATIONS_SET%DEPENDENT%DEPENDENT_FIELD,FIELD_GEOMETRIC_TYPE,ERR,ERROR,*999)
            CALL FIELD_DEPENDENT_TYPE_SET(EQUATIONS_SET%DEPENDENT%DEPENDENT_FIELD,FIELD_DEPENDENT_TYPE,ERR,ERROR,*999)
            CALL FIELD_MESH_DECOMPOSITION_SET(EQUATIONS_SET%DEPENDENT%DEPENDENT_FIELD,EQUATIONS_SET%GEOMETRY%GEOMETRIC_FIELD% &
              & DECOMPOSITION,ERR,ERROR,*999)
            CALL FIELD_NUMBER_OF_VARIABLES_SET(EQUATIONS_SET%DEPENDENT%DEPENDENT_FIELD,2,ERR,ERROR,*999)
            NUMBER_OF_COMPONENTS=EQUATIONS_SET%GEOMETRY%GEOMETRIC_FIELD%VARIABLES(FIELD_STANDARD_VARIABLE_TYPE)% &
              & NUMBER_OF_COMPONENTS
            CALL FIELD_NUMBER_OF_COMPONENTS_SET(EQUATIONS_SET%DEPENDENT%DEPENDENT_FIELD,NUMBER_OF_COMPONENTS,ERR,ERROR,*999)
            !Default to the geometric interpolation setup
            DO component_idx=1,NUMBER_OF_COMPONENTS
              CALL FIELD_COMPONENT_MESH_COMPONENT_SET(EQUATIONS_SET%DEPENDENT%DEPENDENT_FIELD,FIELD_STANDARD_VARIABLE_TYPE, &
                & component_idx,EQUATIONS_SET%GEOMETRY%GEOMETRIC_FIELD%VARIABLES(FIELD_STANDARD_VARIABLE_TYPE)%COMPONENTS( &
                & component_idx)%MESH_COMPONENT_NUMBER,ERR,ERROR,*999)
              CALL FIELD_COMPONENT_MESH_COMPONENT_SET(EQUATIONS_SET%DEPENDENT%DEPENDENT_FIELD,FIELD_NORMAL_VARIABLE_TYPE, &
                & component_idx,EQUATIONS_SET%GEOMETRY%GEOMETRIC_FIELD%VARIABLES(FIELD_STANDARD_VARIABLE_TYPE)%COMPONENTS( &
                & component_idx)%MESH_COMPONENT_NUMBER,ERR,ERROR,*999)
            ENDDO !component_idx
            SELECT CASE(EQUATIONS_SET%SOLUTION_METHOD)
            CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
              DO component_idx=1,NUMBER_OF_COMPONENTS
                CALL FIELD_COMPONENT_INTERPOLATION_SET(EQUATIONS_SET%DEPENDENT%DEPENDENT_FIELD,FIELD_STANDARD_VARIABLE_TYPE, &
                  & component_idx,FIELD_NODE_BASED_INTERPOLATION,ERR,ERROR,*999)
                CALL FIELD_COMPONENT_INTERPOLATION_SET(EQUATIONS_SET%DEPENDENT%DEPENDENT_FIELD,FIELD_NORMAL_VARIABLE_TYPE, &
                  & component_idx,FIELD_NODE_BASED_INTERPOLATION,ERR,ERROR,*999)
              ENDDO !component_idx
              CALL FIELD_SCALING_TYPE_SET(EQUATIONS_SET%DEPENDENT%DEPENDENT_FIELD,EQUATIONS_SET%GEOMETRY%GEOMETRIC_FIELD% &
                & SCALINGS%SCALING_TYPE,ERR,ERROR,*999)
            CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
              CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
            CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
              CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
            CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
              CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
            CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
              CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
            CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
              CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
            CASE DEFAULT
              LOCAL_ERROR="The solution method of "//TRIM(NUMBER_TO_VSTRING(EQUATIONS_SET%SOLUTION_METHOD,"*",ERR,ERROR))// &
                & " is invalid."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT
          CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
            CALL FIELD_CREATE_FINISH(EQUATIONS_SET%REGION,EQUATIONS_SET%DEPENDENT%DEPENDENT_FIELD,ERR,ERROR,*999)
          CASE DEFAULT
            LOCAL_ERROR="The action type of "//TRIM(NUMBER_TO_VSTRING(ACTION_TYPE,"*",ERR,ERROR))// &
              & " for a setup type of "//TRIM(NUMBER_TO_VSTRING(SETUP_TYPE,"*",ERR,ERROR))// &
              & " is invalid for a finite elasticity equation"
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          END SELECT
        CASE(EQUATIONS_SET_SETUP_MATERIALS_TYPE)
          SELECT CASE(ACTION_TYPE)
          CASE(EQUATIONS_SET_SETUP_START_ACTION)
            !Do nothing
          CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
            !Do nothing
            !? Maybe set finished flag????
          CASE DEFAULT
            LOCAL_ERROR="The action type of "//TRIM(NUMBER_TO_VSTRING(ACTION_TYPE,"*",ERR,ERROR))// &
              & " for a setup type of "//TRIM(NUMBER_TO_VSTRING(SETUP_TYPE,"*",ERR,ERROR))// &
              & " is invalid for a finite elasticity equation."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          END SELECT
        CASE(EQUATIONS_SET_SETUP_SOURCE_TYPE)
          SELECT CASE(ACTION_TYPE)
          CASE(EQUATIONS_SET_SETUP_START_ACTION)
            !Do nothing
          CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
            !Do nothing
            !? Maybe set finished flag????
          CASE DEFAULT
            LOCAL_ERROR="The action type of "//TRIM(NUMBER_TO_VSTRING(ACTION_TYPE,"*",ERR,ERROR))// &
              & " for a setup type of "//TRIM(NUMBER_TO_VSTRING(SETUP_TYPE,"*",ERR,ERROR))// &
              & " is invalid for a finite elasticity equation."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          END SELECT
        CASE(EQUATIONS_SET_SETUP_ANALYTIC_TYPE)
          SELECT CASE(ACTION_TYPE)
          CASE(EQUATIONS_SET_SETUP_START_ACTION)
            IF(EQUATIONS_SET%DEPENDENT%DEPENDENT_FINISHED) THEN
              !Do nothing
            ELSE
              CALL FLAG_ERROR("Equations set dependent field has not been finished.",ERR,ERROR,*999)
            ENDIF
          CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
            !Do nothing
            !? Maybe set finished flag????
          CASE DEFAULT
            LOCAL_ERROR="The action type of "//TRIM(NUMBER_TO_VSTRING(ACTION_TYPE,"*",ERR,ERROR))// &
              & " for a setup type of "//TRIM(NUMBER_TO_VSTRING(SETUP_TYPE,"*",ERR,ERROR))// &
              & " is invalid for a finite elasticity equation."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          END SELECT
        CASE(EQUATIONS_SET_SETUP_FIXED_CONDITIONS_TYPE)
          SELECT CASE(ACTION_TYPE)
          CASE(EQUATIONS_SET_SETUP_START_ACTION)
            IF(EQUATIONS_SET%DEPENDENT%DEPENDENT_FINISHED) THEN
              DEPENDENT_FIELD=>EQUATIONS_SET%DEPENDENT%DEPENDENT_FIELD
              IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
                CALL FIELD_PARAMETER_SET_CREATE(DEPENDENT_FIELD,FIELD_BOUNDARY_CONDITIONS_SET_TYPE,ERR,ERROR,*999)
              ELSE
                CALL FLAG_ERROR("Equations set dependent field is not associated.",ERR,ERROR,*999)
              ENDIF
            ELSE
              CALL FLAG_ERROR("Equations set dependent field has not been finished.",ERR,ERROR,*999)
            ENDIF
          CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
            DEPENDENT_FIELD=>EQUATIONS_SET%DEPENDENT%DEPENDENT_FIELD
            IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
              CALL FIELD_PARAMETER_SET_UPDATE_START(DEPENDENT_FIELD,FIELD_BOUNDARY_CONDITIONS_SET_TYPE,ERR,ERROR,*999)
              CALL FIELD_PARAMETER_SET_UPDATE_FINISH(DEPENDENT_FIELD,FIELD_BOUNDARY_CONDITIONS_SET_TYPE,ERR,ERROR,*999)
            ELSE
              CALL FLAG_ERROR("Equations set dependent field is not associated.",ERR,ERROR,*999)
            ENDIF
          CASE DEFAULT
            LOCAL_ERROR="The action type of "//TRIM(NUMBER_TO_VSTRING(ACTION_TYPE,"*",ERR,ERROR))// &
              & " for a setup type of "//TRIM(NUMBER_TO_VSTRING(SETUP_TYPE,"*",ERR,ERROR))// &
              & " is invalid for a finite elasticity equation."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          END SELECT
        CASE(EQUATIONS_SET_SETUP_EQUATIONS_TYPE)
          SELECT CASE(ACTION_TYPE)
          CASE(EQUATIONS_SET_SETUP_START_ACTION)
            IF(ASSOCIATED(EQUATIONS_SET%FIXED_CONDITIONS)) THEN
              IF(EQUATIONS_SET%FIXED_CONDITIONS%FIXED_CONDITIONS_FINISHED) THEN
                !Do nothing
                !?Initialise problem solution???
              ELSE
                CALL FLAG_ERROR("Equations set fixed conditions has not been finished.",ERR,ERROR,*999)
              ENDIF
            ELSE
              CALL FLAG_ERROR("Equations set fixed conditions is not associated.",ERR,ERROR,*999)
            ENDIF
          CASE(EQUATIONS_SET_SETUP_FINISH_ACTION)
            SELECT CASE(EQUATIONS_SET%SOLUTION_METHOD)
            CASE(EQUATIONS_SET_FEM_SOLUTION_METHOD)
              EQUATIONS=>EQUATIONS_SET%EQUATIONS
              IF(ASSOCIATED(EQUATIONS)) THEN
                !Create the equations mapping.
                CALL EQUATIONS_MAPPING_CREATE_START(EQUATIONS,EQUATIONS_MAPPING,ERR,ERROR,*999)
                CALL EQUATIONS_MAPPING_LINEAR_MATRICES_NUMBER_SET(EQUATIONS_MAPPING,0,ERR,ERROR,*999)
                CALL EQUATIONS_MAPPING_RHS_VARIABLE_TYPE_SET(EQUATIONS_MAPPING,FIELD_NORMAL_VARIABLE_TYPE,ERR,ERROR,*999)
                CALL EQUATIONS_MAPPING_CREATE_FINISH(EQUATIONS_MAPPING,ERR,ERROR,*999)
                !Create the equations matrices
                CALL EQUATIONS_MATRICES_CREATE_START(EQUATIONS,EQUATIONS_MATRICES,ERR,ERROR,*999)
                CALL EQUATIONS_MATRICES_CREATE_FINISH(EQUATIONS_MATRICES,ERR,ERROR,*999)
              ELSE
                CALL FLAG_ERROR("Equations is not associated.",ERR,ERROR,*999)
              ENDIF
            CASE(EQUATIONS_SET_BEM_SOLUTION_METHOD)
              CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
            CASE(EQUATIONS_SET_FD_SOLUTION_METHOD)
              CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
            CASE(EQUATIONS_SET_FV_SOLUTION_METHOD)
              CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
            CASE(EQUATIONS_SET_GFEM_SOLUTION_METHOD)
              CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
            CASE(EQUATIONS_SET_GFV_SOLUTION_METHOD)
              CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
            CASE DEFAULT
                LOCAL_ERROR="The solution method of "//TRIM(NUMBER_TO_VSTRING(EQUATIONS_SET%SOLUTION_METHOD,"*",ERR,ERROR))// &
                & " is invalid."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT
          CASE DEFAULT
            LOCAL_ERROR="The action type of "//TRIM(NUMBER_TO_VSTRING(ACTION_TYPE,"*",ERR,ERROR))// &
              & " for a setup type of "//TRIM(NUMBER_TO_VSTRING(SETUP_TYPE,"*",ERR,ERROR))// &
              & " is invalid for a finite elasticity equation."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          END SELECT
        CASE DEFAULT
          LOCAL_ERROR="The setup type of "//TRIM(NUMBER_TO_VSTRING(SETUP_TYPE,"*",ERR,ERROR))// &
            & " is invalid for a finite elasticity equation."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        END SELECT
      CASE DEFAULT
        LOCAL_ERROR="Equations set subtype "//TRIM(NUMBER_TO_VSTRING(EQUATIONS_SET%SUBTYPE,"*",ERR,ERROR))// &
          & " is not valid for a finite elasticity equation type of an elasticity equation set class."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      END SELECT
    ELSE
      CALL FLAG_ERROR("Equations set is not associated",ERR,ERROR,*999)
    ENDIF
       
    CALL EXITS("FINITE_ELASTICITY_EQUATIONS_SET_SETUP")
    RETURN
999 CALL ERRORS("FINITE_ELASTICITY_EQUATIONS_SET_SETUP",ERR,ERROR)
    CALL EXITS("FINITE_ELASTICITY_EQUATIONS_SET_SETUP")
    RETURN 1
  END SUBROUTINE FINITE_ELASTICITY_EQUATIONS_SET_SETUP

  !
  !================================================================================================================================
  !

  !>Sets/changes the equation subtype for a finite elasticity equation type of an elasticity equations set class.
  SUBROUTINE FINITE_ELASTICITY_EQUATIONS_SET_SUBTYPE_SET(EQUATIONS_SET,EQUATIONS_SET_SUBTYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET !<A pointer to the equations set to set the equation subtype for
    INTEGER(INTG), INTENT(IN) :: EQUATIONS_SET_SUBTYPE !<The equation subtype to set
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("FINITE_ELASTICITY_EQUATIONS_SET_SUBTYPE_SET",ERR,ERROR,*999)
    
    IF(ASSOCIATED(EQUATIONS_SET)) THEN
      SELECT CASE(EQUATIONS_SET_SUBTYPE)
      CASE(EQUATIONS_SET_NO_SUBTYPE)        
        EQUATIONS_SET%CLASS=EQUATIONS_SET_ELASTICITY_CLASS
        EQUATIONS_SET%TYPE=EQUATIONS_SET_FINITE_ELASTICITY_TYPE
        EQUATIONS_SET%SUBTYPE=EQUATIONS_SET_NO_SUBTYPE       
        CALL FINITE_ELASTICITY_EQUATIONS_SET_SETUP(EQUATIONS_SET,EQUATIONS_SET_SETUP_INITIAL_TYPE, &
          & EQUATIONS_SET_SETUP_START_ACTION,ERR,ERROR,*999)
      CASE DEFAULT
        LOCAL_ERROR="Equations set subtype "//TRIM(NUMBER_TO_VSTRING(EQUATIONS_SET_SUBTYPE,"*",ERR,ERROR))// &
          & " is not valid for a finite elasticity equation type of an elasticity equations set class."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      END SELECT
    ELSE
      CALL FLAG_ERROR("Equations set is not associated.",ERR,ERROR,*999)
    ENDIF
       
    CALL EXITS("FINITE_ELASTICITY_EQUATIONS_SET_SUBTYPE_SET")
    RETURN
999 CALL ERRORS("FINITE_ELASTICITY_EQUATIONS_SET_SUBTYPE_SET",ERR,ERROR)
    CALL EXITS("FINITE_ELASTICITY_EQUATIONS_SET_SUBTYPE_SET")
    RETURN 1
  END SUBROUTINE FINITE_ELASTICITY_EQUATIONS_SET_SUBTYPE_SET

  !
  !================================================================================================================================
  !
 
  !>Sets up the finite elasticity problem.
  SUBROUTINE FINITE_ELASTICITY_PROBLEM_SETUP(PROBLEM,SETUP_TYPE,ACTION_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM !<A pointer to the solutions set to setup a Laplace equation on.
    INTEGER(INTG), INTENT(IN) :: SETUP_TYPE !<The setup type
    INTEGER(INTG), INTENT(IN) :: ACTION_TYPE !<The action type
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP,CONTROL_LOOP_ROOT
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(PROBLEM_EQUATIONS_ADD_TYPE), POINTER :: EQUATIONS_TO_ADD
    TYPE(SOLUTION_TYPE), POINTER :: SOLUTION
    TYPE(SOLUTION_MAPPING_TYPE), POINTER :: SOLUTION_MAPPING
    TYPE(SOLUTIONS_TYPE), POINTER :: SOLUTIONS
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("FINITE_ELASTICITY_PROBLEM_SETUP",ERR,ERROR,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(SOLUTION)
    NULLIFY(SOLUTIONS)
    NULLIFY(SOLUTION_MAPPING)
    NULLIFY(SOLVER)
    IF(ASSOCIATED(PROBLEM)) THEN
      SELECT CASE(PROBLEM%SUBTYPE)
      CASE(PROBLEM_NO_SUBTYPE)
        SELECT CASE(SETUP_TYPE)
        CASE(PROBLEM_SETUP_INITIAL_TYPE)
          SELECT CASE(ACTION_TYPE)
          CASE(PROBLEM_SETUP_START_ACTION)
            !Do nothing????
          CASE(PROBLEM_SETUP_FINISH_ACTION)
            !Do nothing????
          CASE(PROBLEM_SETUP_DO_ACTION)
            CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
          CASE DEFAULT
            LOCAL_ERROR="The action type of "//TRIM(NUMBER_TO_VSTRING(ACTION_TYPE,"*",ERR,ERROR))// &
              & " for a setup type of "//TRIM(NUMBER_TO_VSTRING(SETUP_TYPE,"*",ERR,ERROR))// &
              & " is invalid for a finite elasticity problem."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          END SELECT
        CASE(PROBLEM_SETUP_CONTROL_TYPE)
          SELECT CASE(ACTION_TYPE)
          CASE(PROBLEM_SETUP_START_ACTION)
            !Set up a simple control loop
            CALL CONTROL_LOOP_CREATE_START(PROBLEM,CONTROL_LOOP,ERR,ERROR,*999)
          CASE(PROBLEM_SETUP_FINISH_ACTION)
            !Finish the control loops
            CONTROL_LOOP_ROOT=>PROBLEM%CONTROL_LOOP
            CALL CONTROL_LOOP_GET(CONTROL_LOOP_ROOT,CONTROL_LOOP_NODE,CONTROL_LOOP,ERR,ERROR,*999)
            CALL CONTROL_LOOP_CREATE_FINISH(CONTROL_LOOP,ERR,ERROR,*999)            
          CASE(PROBLEM_SETUP_DO_ACTION)
            CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
          CASE DEFAULT
            LOCAL_ERROR="The action type of "//TRIM(NUMBER_TO_VSTRING(ACTION_TYPE,"*",ERR,ERROR))// &
              & " for a setup type of "//TRIM(NUMBER_TO_VSTRING(SETUP_TYPE,"*",ERR,ERROR))// &
              & " is invalid for a finite elasticity problem."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          END SELECT
        CASE(PROBLEM_SETUP_SOLUTION_TYPE)
          SELECT CASE(ACTION_TYPE)
          CASE(PROBLEM_SETUP_START_ACTION)
            !Get the control loop
            CONTROL_LOOP_ROOT=>PROBLEM%CONTROL_LOOP
            CALL CONTROL_LOOP_GET(CONTROL_LOOP_ROOT,CONTROL_LOOP_NODE,CONTROL_LOOP,ERR,ERROR,*999)
            !Create the solutions on the control loop
            CALL SOLUTIONS_CREATE_START(CONTROL_LOOP,SOLUTIONS,ERR,ERROR,*999)
            CALL SOLUTIONS_NUMBER_SET(SOLUTIONS,1,ERR,ERROR,*999)
            CALL SOLUTIONS_LINEARITY_SET(SOLUTIONS,1,PROBLEM_SOLUTION_NONLINEAR,ERR,ERROR,*999)
            CALL SOLUTIONS_CREATE_FINISH(SOLUTIONS,ERR,ERROR,*999)
            !Create the solutions mapping 
            CALL SOLUTIONS_SOLUTION_GET(SOLUTIONS,1,SOLUTION,ERR,ERROR,*999)
            CALL SOLUTION_MAPPING_CREATE_START(SOLUTION,SOLUTION_MAPPING,ERR,ERROR,*999)
          CASE(PROBLEM_SETUP_FINISH_ACTION)
            !Get the control loop
            CONTROL_LOOP_ROOT=>PROBLEM%CONTROL_LOOP
            CALL CONTROL_LOOP_GET(CONTROL_LOOP_ROOT,CONTROL_LOOP_NODE,CONTROL_LOOP,ERR,ERROR,*999)
            !Get the solution mapping
            CALL CONTROL_LOOP_SOLUTIONS_GET(CONTROL_LOOP,SOLUTIONS,ERR,ERROR,*999)
            CALL SOLUTIONS_SOLUTION_GET(SOLUTIONS,1,SOLUTION,ERR,ERROR,*999)
            CALL SOLUTION_SOLUTION_MAPPING_GET(SOLUTION,SOLUTION_MAPPING,ERR,ERROR,*999)
            !Finish the solution mapping creation           
            CALL SOLUTION_MAPPING_CREATE_FINISH(SOLUTION_MAPPING,ERR,ERROR,*999)
          CASE(PROBLEM_SETUP_DO_ACTION)
            EQUATIONS_TO_ADD=>PROBLEM%EQUATIONS_TO_ADD
            IF(ASSOCIATED(EQUATIONS_TO_ADD)) THEN
              EQUATIONS_SET=>EQUATIONS_TO_ADD%EQUATIONS_SET_TO_ADD
              IF(ASSOCIATED(EQUATIONS_SET)) THEN
                !Check the equations set is from a finite elasticity equations set
                IF(EQUATIONS_SET%CLASS==EQUATIONS_SET_ELASTICITY_CLASS.AND. &
                  & EQUATIONS_SET%TYPE==EQUATIONS_SET_FINITE_ELASTICITY_TYPE.AND. &
                  & EQUATIONS_SET%SUBTYPE==EQUATIONS_SET_NO_SUBTYPE) THEN
                  !Get the control loop
                  CONTROL_LOOP_ROOT=>PROBLEM%CONTROL_LOOP
                  CALL CONTROL_LOOP_GET(CONTROL_LOOP_ROOT,EQUATIONS_TO_ADD%CONTROL_LOOP_IDENTIFIER,CONTROL_LOOP,ERR,ERROR,*999)
                  !Get the solution mapping
                  CALL CONTROL_LOOP_SOLUTIONS_GET(CONTROL_LOOP,SOLUTIONS,ERR,ERROR,*999)
                  CALL SOLUTIONS_SOLUTION_GET(SOLUTIONS,EQUATIONS_TO_ADD%SOLUTION_INDEX,SOLUTION,ERR,ERROR,*999)
                  CALL SOLUTION_SOLUTION_MAPPING_GET(SOLUTION,SOLUTION_MAPPING,ERR,ERROR,*999)
                  !Add in the equations set
                  CALL SOLUTION_MAPPING_EQUATIONS_SET_ADD(SOLUTION_MAPPING,EQUATIONS_TO_ADD%EQUATIONS_SET_TO_ADD, &
                    & EQUATIONS_TO_ADD%EQUATIONS_SET_ADDED_INDEX,ERR,ERROR,*999)
                  CALL SOLUTION_MAPPING_EQUATS_VARS_TO_SOLVER_MATRIX_SET(SOLUTION_MAPPING,1,EQUATIONS_TO_ADD% &
                    & EQUATIONS_SET_ADDED_INDEX,(/FIELD_STANDARD_VARIABLE_TYPE/),ERR,ERROR,*999)
                ELSE
                  CALL FLAG_ERROR("The equations set to add is not a finite elasticity equations set.",ERR,ERROR,*999)
                ENDIF
              ELSE
                CALL FLAG_ERROR("Equations set to add is not associated.",ERR,ERROR,*999)
              ENDIF
            ELSE
              CALL FLAG_ERROR("Problem equations to add is not associated.",ERR,ERROR,*999)
            ENDIF
          CASE DEFAULT
            LOCAL_ERROR="The action type of "//TRIM(NUMBER_TO_VSTRING(ACTION_TYPE,"*",ERR,ERROR))// &
              & " for a setup type of "//TRIM(NUMBER_TO_VSTRING(SETUP_TYPE,"*",ERR,ERROR))// &
              & " is invalid for a finite elasticity problem."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          END SELECT
        CASE(PROBLEM_SETUP_SOLVER_TYPE)
          !Get the control loop
          CONTROL_LOOP_ROOT=>PROBLEM%CONTROL_LOOP
          CALL CONTROL_LOOP_GET(CONTROL_LOOP_ROOT,CONTROL_LOOP_NODE,CONTROL_LOOP,ERR,ERROR,*999)
          !Get the solution
          CALL CONTROL_LOOP_SOLUTIONS_GET(CONTROL_LOOP,SOLUTIONS,ERR,ERROR,*999)
          CALL SOLUTIONS_SOLUTION_GET(SOLUTIONS,1,SOLUTION,ERR,ERROR,*999)
          SELECT CASE(ACTION_TYPE)
          CASE(PROBLEM_SETUP_START_ACTION)
            !Start the creation of a nonlinear solver
            CALL SOLVER_CREATE_START(SOLUTION,SOLVER_NONLINEAR_TYPE,SOLVER,ERR,ERROR,*999)
            CALL SOLVER_LIBRARY_SET(SOLVER,SOLVER_PETSC_LIBRARY,ERR,ERROR,*999)
            CALL SOLVER_SPARSITY_TYPE_SET(SOLVER,SOLVER_SPARSE_MATRICES,ERR,ERROR,*999)
          CASE(PROBLEM_SETUP_FINISH_ACTION)
            !Get the solver
            CALL SOLUTION_SOLVER_GET(SOLUTION,SOLVER,ERR,ERROR,*999)
            !Finish the solver creation
            CALL SOLVER_CREATE_FINISH(SOLVER,ERR,ERROR,*999)
          CASE(PROBLEM_SETUP_DO_ACTION)
            CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
          CASE DEFAULT
            LOCAL_ERROR="The action type of "//TRIM(NUMBER_TO_VSTRING(ACTION_TYPE,"*",ERR,ERROR))// &
              & " for a setup type of "//TRIM(NUMBER_TO_VSTRING(SETUP_TYPE,"*",ERR,ERROR))// &
              & " is invalid for a finite elasticity problem."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          END SELECT
        CASE DEFAULT
          LOCAL_ERROR="The setup type of "//TRIM(NUMBER_TO_VSTRING(SETUP_TYPE,"*",ERR,ERROR))// &
            & " is invalid for a finite elasticity problem."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        END SELECT
      CASE DEFAULT
        LOCAL_ERROR="Problem subtype "//TRIM(NUMBER_TO_VSTRING(PROBLEM%SUBTYPE,"*",ERR,ERROR))// &
          & " is not valid for a finite elasticity type of an elasticity problem class."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      END SELECT
    ELSE
      CALL FLAG_ERROR("Problem is not associated.",ERR,ERROR,*999)
    ENDIF
       
    CALL EXITS("FINITE_ELASTICITY_PROBLEM_SETUP")
    RETURN
999 CALL ERRORS("FINITE_ELASTICITY_PROBLEM_SETUP",ERR,ERROR)
    CALL EXITS("FINITE_ELASTICITY_PROBLEM_SETUP")
    RETURN 1
  END SUBROUTINE FINITE_ELASTICITY_PROBLEM_SETUP
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the problem subtype for a finite elasticity type .
  SUBROUTINE FINITE_ELASTICITY_PROBLEM_SUBTYPE_SET(PROBLEM,PROBLEM_SUBTYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM !<A pointer to the problem to set the problem subtype for
    INTEGER(INTG), INTENT(IN) :: PROBLEM_SUBTYPE !<The problem subtype to set
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("FINITE_ELASTICITY_PROBLEM_SUBTYPE_SET",ERR,ERROR,*999)
    
    IF(ASSOCIATED(PROBLEM)) THEN
      SELECT CASE(PROBLEM_SUBTYPE)
      CASE(PROBLEM_NO_SUBTYPE)        
        PROBLEM%CLASS=PROBLEM_ELASTICITY_CLASS
        PROBLEM%TYPE=PROBLEM_FINITE_ELASTICITY_TYPE
        PROBLEM%SUBTYPE=PROBLEM_NO_SUBTYPE      
        CALL FINITE_ELASTICITY_PROBLEM_SETUP(PROBLEM,PROBLEM_SETUP_INITIAL_TYPE,PROBLEM_SETUP_START_ACTION, &
          & ERR,ERROR,*999)
      CASE DEFAULT
        LOCAL_ERROR="Problem subtype "//TRIM(NUMBER_TO_VSTRING(PROBLEM_SUBTYPE,"*",ERR,ERROR))// &
          & " is not valid for a finite elasticity type of an elasticity problem class."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      END SELECT
    ELSE
      CALL FLAG_ERROR("Problem is not associated.",ERR,ERROR,*999)
    ENDIF
       
    CALL EXITS("FINITE_ELASTICITY_PROBLEM_SUBTYPE_SET")
    RETURN
999 CALL ERRORS("FINITE_ELASTICITY_PROBLEM_SUBTYPE_SET",ERR,ERROR)
    CALL EXITS("FINITE_ELASTICITY_PROBLEM_SUBTYPE_SET")
    RETURN 1
  END SUBROUTINE FINITE_ELASTICITY_PROBLEM_SUBTYPE_SET

  !
  !================================================================================================================================
  !
 
END MODULE FINITE_ELASTICITY_ROUTINES
