"""Wrap the OpenCMISS python interface generated by SWIG to make
it more object oriented and "Pythonic"
"""

import opencmiss_swig
from _docstrings import docstrings as _docstrings
from _types import types as _types

class CMISSError(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)


class CMISSWrapper(object):
    """OpenCMISS python interface

    All OpenCMISS routines and constants can be accessed through this object
    without the "CMIS" prefix. Error return values are checked and exceptions
    are raised for non-zero return values.
    """

    def __init__(self):
        """Initialise OpenCMISS, setting the WorldCoordinateSystem
        and WorldRegion attributes
        """

        self.WorldCoordinateSystem = self.CoordinateSystemTypeInitialise()
        self.WorldRegion = self.RegionTypeInitialise()
        self.Initialise(self.WorldCoordinateSystem, self.WorldRegion)
        self.ErrorHandlingModeSet(self.ReturnErrorCode) #Don't output errors, we'll include trace in exception

        for type in _types:
            self.__setattr__(type,self._make_class(type))

    def __getattr__(self,attr_name):
        """Get an OpenCMISS constant or routine, removing the need to
        prefix it with a CMISS namespace as this is done already in Python.

        If the attribute is a function, then return a wrapped function
        that checks the return status for errors.
        """

        #Constants in Python should be in capitals with underscores, but
        #if we converted to camel-case this would screw up things like
        #CMISSSolverPETScLibrary, so just use camel-case
        try:
            attr = getattr(opencmiss_swig,'CMISS'+attr_name)
            if hasattr(attr,'__call__'):
                return_func = lambda *args: _wrap_routine(attr, args)
                return_func.__name__ = attr_name
                try:
                    return_func.__doc__ = _docstrings['CMISS'+attr_name]
                except KeyError:
                    return_func.__doc__ = ''
                return return_func
            else:
                return attr
        except AttributeError:
            raise AttributeError("OpenCMISS has no constant or routine CMISS%s" % (attr_name))

    def _make_class(self,type_name):
        """Create a class to wrap a CMISS type
        """

        cm = self

        def init_func(self,*args):
            self.__dict__['type_name'] = type_name #Avoid recursive call to __getattr__
            self.cmiss_type = getattr(cm,'%sTypeInitialise' % type_name)()
            if len(args) > 0:
                #Only call create start if we get passed some arguments, otherwise initialise a null type
                try:
                    args += (self.cmiss_type,)
                    getattr(cm,'%sCreateStart' % type_name)(*args)
                except AttributeError:
                    #No create start routine
                    raise ValueError, "%s has no CreateStart routine so does not take any arguments." % self.type_name
        if hasattr(cm,'%sCreateStart' % type_name):
            init_func.__doc__ = "Initialise a CMISS%sType, and start its creation." % type_name
        else:
            init_func.__doc__ = "Initialise a CMISS%sType." % type_name
        #TODO: Add list of parameters to docstring from doxygen comments on the create start routine

        docstring = "CMISS %s" % type_name
        #TODO: Get a list of method routines, maybe generate a _methods file so that initialising
        #all the types doesn't take forever

        kwattrs = {'__doc__':docstring, '__init__':init_func}
        cmiss_class = type(type_name, (object,), dict(**kwattrs))

        def get_attribute(self,attr_name):
            try:
                attr = getattr(opencmiss_swig, 'CMISS'+self.type_name+attr_name)
                if hasattr(attr,'__call__'):
                    #Call method with first parameter as the cmiss type:
                    return_func = lambda *args: _wrap_routine(attr, args)
                    return_func.__name__ = attr_name
                    try:
                        #Todo: remove first parameter from docstring
                        return_func.__doc__ = _docstrings['CMISS'+self.type_name+attr_name]
                    except KeyError:
                        return_func.__doc__ = ''
                    #Return this function bound to the object, so that the first 'self'
                    #argument is added automatically as it appears as a method
                    return return_func.__get__(self,cmiss_class)
                else:
                    return attr
            except AttributeError:
                try:
                    attr = getattr(opencmiss_swig, 'CMISS'+self.type_name+attr_name[0].upper()+attr_name[1:]+'Get')
                    return _wrap_routine(attr, (self,))
                except AttributeError:
                    raise AttributeError("OpenCMISS has no constant or routine CMISS%s%s, and no routine CMISS%s%sGet" % \
                            (self.type_name, attr_name, self.type_name, attr_name))
        get_attribute.__doc__ = "Get a method or attribute of a CMISS%sType." % type_name

        def set_attribute(self,attr_name,value):
            try:
                set_routine = getattr(opencmiss_swig, 'CMISS'+self.type_name+attr_name[0].upper()+attr_name[1:]+'Set')
                _wrap_routine(set_routine, (self,value))
            except AttributeError:
                self.__dict__[attr_name] = value
        set_attribute.__doc__ = "Set an attribute of a CMISS%sType, calling the underlying CMISS%s..Set routine if it exists." % (type_name, type_name)

        cmiss_class.__getattr__ = get_attribute
        cmiss_class.__setattr__ = set_attribute
        return cmiss_class


def _wrap_routine(routine, args=None):
    """Call a routine and check the return value, raise an
    exception if it is non-zero and return any other return values
    """

    if args is None:
        r = routine()
    else:
        #Replace wrapped cmiss types with the underlying type
        new_args = []
        for arg in args:
            if hasattr(arg,'cmiss_type'):
                new_args.append(arg.cmiss_type)
            else:
                new_args.append(arg)
        r = routine(*new_args)
    if isinstance(r,tuple):
        status = r[0]
        if len(r) == 1:
            return_val = None
        elif len(r) == 2:
            return_val = r[1]
        else:
            return_val = r[1:]
    else:
        status = r
        return_val = None
    if status != 0:
        raise CMISSError, opencmiss_swig.CMISSExtractErrorMessage()[1]
    return return_val

