!> \file
!> \author Chris Bradley
!> \brief The top level OpenCMISS module.
!>
!> \mainpage OpenCMISS Documentation
!>
!> An open source interactive computer program for Continuum Mechanics, Image analysis, Signal processing and System
!> Identification. Target usage: Bioengineering application of finite element analysis, boundary element and collocation
!> techniques.
!>
!> \section LICENSE
!>
!> Version: MPL 1.1/GPL 2.0/LGPL 2.1
!>
!> The contents of this file are subject to the Mozilla Public License
!> Version 1.1 (the "License"); you may not use this file except in
!> compliance with the License. You may obtain a copy of the License at
!> http://www.mozilla.org/MPL/
!>
!> Software distributed under the License is distributed on an "AS IS"
!> basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
!> License for the specific language governing rights and limitations
!> under the License.
!>
!> The Original Code is OpenCMISS
!>
!> The Initial Developer of the Original Code is University of Auckland,
!> Auckland, New Zealand, the University of Oxford, Oxford, United
!> Kingdom and King's College, London, United Kingdom. Portions created
!> by the University of Auckland, the University of Oxford and King's
!> College, London are Copyright (C) 2007-2010 by the University of
!> Auckland, the University of Oxford and King's College, London.
!> All Rights Reserved.
!>
!> Contributor(s):
!>
!> Alternatively, the contents of this file may be used under the terms of
!> either the GNU General Public License Version 2 or later (the "GPL"), or
!> the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
!> in which case the provisions of the GPL or the LGPL are applicable instead
!> of those above. If you wish to allow use of your version of this file only
!> under the terms of either the GPL or the LGPL, and not to allow others to
!> use your version of this file under the terms of the MPL, indicate your
!> decision by deleting the provisions above and replace them with the notice
!> and other provisions required by the GPL or the LGPL. If you do not delete
!> the provisions above, a recipient may use your version of this file under
!> the terms of any one of the MPL, the GPL or the LGPL.
!>
!>
!> The top level OpenCMISS module. This module is the buffer module between the OpenCMISS library and user code.
MODULE OPENCMISS

  USE ANALYTIC_ANALYSIS_ROUTINES
  USE BASE_ROUTINES
  USE BASIS_ROUTINES
  USE BOUNDARY_CONDITIONS_ROUTINES
  USE CMISS
  USE CMISS_CELLML
  USE COMP_ENVIRONMENT
  USE CONSTANTS
  USE CONTROL_LOOP_ROUTINES
  USE COORDINATE_ROUTINES
  USE DATA_POINT_ROUTINES
  USE DATA_PROJECTION_ROUTINES
  USE EQUATIONS_ROUTINES
  USE EQUATIONS_SET_CONSTANTS
  USE EQUATIONS_SET_ROUTINES
  USE FIELD_ROUTINES
#ifdef USEFIELDML
  USE FIELDML_TYPES
  USE FIELDML_INPUT_ROUTINES
  USE FIELDML_OUTPUT_ROUTINES
  USE FIELDML_UTIL_ROUTINES
#endif
  USE FIELD_IO_ROUTINES
  USE FINITE_ELASTICITY_ROUTINES
  USE GENERATED_MESH_ROUTINES
  USE HAMILTON_JACOBI_EQUATIONS_ROUTINES
  USE HISTORY_ROUTINES
  USE INPUT_OUTPUT
  USE INTERFACE_ROUTINES
  USE INTERFACE_CONDITIONS_CONSTANTS
  USE INTERFACE_CONDITIONS_ROUTINES
  USE INTERFACE_EQUATIONS_ROUTINES
  USE ISO_C_BINDING
  USE ISO_VARYING_STRING
  USE KINDS
  USE MESH_ROUTINES
  USE NODE_ROUTINES
  USE PROBLEM_CONSTANTS
  USE PROBLEM_ROUTINES
  USE REGION_ROUTINES
  USE SOLVER_ROUTINES
  USE STRINGS
  USE TYPES

  IMPLICIT NONE

  PRIVATE

  !Module parameters

  !Module types

  !>Contains information about a basis function.
  TYPE CMISSBasisType
    PRIVATE
    TYPE(BASIS_TYPE), POINTER :: BASIS
  END TYPE CMISSBasisType

  !>Contains information on the boundary conditions for the equations set.
  TYPE CMISSBoundaryConditionsType
    PRIVATE
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
  END TYPE CMISSBoundaryConditionsType

  !>Contains information on a CellML environment.
  TYPE CMISSCellMLType
    PRIVATE
    TYPE(CELLML_TYPE), POINTER :: CELLML
  END TYPE CMISSCellMLType

  !>Contains information about the CellML equations for a solver.
  TYPE CMISSCellMLEquationsType
    PRIVATE
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: CELLML_EQUATIONS
  END TYPE CMISSCellMLEquationsType

  !>Contains information on a control loop.
  TYPE CMISSControlLoopType
    PRIVATE
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
  END TYPE CMISSControlLoopType

  !>Contains information on a coordinate system.
  TYPE CMISSCoordinateSystemType
    PRIVATE
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
  END TYPE CMISSCoordinateSystemType

  !>Contains information on the data points defined on a region.
  TYPE CMISSDataPointsType
    PRIVATE
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
  END TYPE CMISSDataPointsType

  !>Contains information about a data projection.
  TYPE CMISSDataProjectionType
    PRIVATE
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
  END TYPE CMISSDataProjectionType

  !>Contains information on the mesh decomposition.
  TYPE CMISSDecompositionType
    PRIVATE
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
  END TYPE CMISSDecompositionType

  !>Contains information about the equations in an equations set.
  TYPE CMISSEquationsType
    PRIVATE
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
  END TYPE CMISSEquationsType

  !>Contains information on an equations set defined on a region.
  TYPE CMISSEquationsSetType
    PRIVATE
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
  END TYPE CMISSEquationsSetType

  !>Contains information for a field defined on a region.
  TYPE CMISSFieldType
    PRIVATE
    TYPE(FIELD_TYPE), POINTER :: FIELD
  END TYPE CMISSFieldType

  !>Contains information for a fields defined on a region.
  TYPE CMISSFieldsType
    PRIVATE
    TYPE(FIELDS_TYPE), POINTER :: FIELDS
  END TYPE CMISSFieldsType

  !>Contains information on a generated mesh.
  TYPE CMISSGeneratedMeshType
    PRIVATE
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
  END TYPE CMISSGeneratedMeshType

  !>Contains information about a history file for a control loop.
  TYPE CMISSHistoryType
    PRIVATE
    TYPE(HISTORY_TYPE), POINTER :: HISTORY
  END TYPE CMISSHistoryType

  !>Contains information about an interface.
  TYPE CMISSInterfaceType
    PRIVATE
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
  END TYPE CMISSInterfaceType

  !>Contains information about an interface condition.
  TYPE CMISSInterfaceConditionType
    PRIVATE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
  END TYPE CMISSInterfaceConditionType

  !>Contains information about an interface condition.
  TYPE CMISSInterfaceEquationsType
    PRIVATE
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: INTERFACE_EQUATIONS
  END TYPE CMISSInterfaceEquationsType

   !>Contains information on an interfaces meshes connectivity.
  TYPE CMISSInterfaceMeshConnectivityType
    PRIVATE
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: MESH_CONNECTIVITY
  END TYPE CMISSInterfaceMeshConnectivityType

  !>Contains information on a mesh defined on a region.
  TYPE CMISSMeshType
    PRIVATE
    TYPE(MESH_TYPE), POINTER :: MESH
  END TYPE CMISSMeshType

  !>Contains information on a mesh elements defined in a mesh
  TYPE CMISSMeshElementsType
    PRIVATE
    TYPE(MESH_ELEMENTS_TYPE), POINTER :: MESH_ELEMENTS
  END TYPE CMISSMeshElementsType

  !>Contains information on an embedded mesh
  TYPE CMISSMeshEmbeddingType
    PRIVATE
    TYPE(MESH_EMBEDDING_TYPE), POINTER :: MESH_EMBEDDING
  END TYPE CMISSMeshEmbeddingType

  !>Contains information on the nodes defined on a region.
  TYPE CMISSNodesType
    PRIVATE
    TYPE(NODES_TYPE), POINTER :: NODES
  END TYPE CMISSNodesType

  !>Contains information for a problem.
  TYPE CMISSProblemType
    PRIVATE
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
  END TYPE CMISSProblemType

  !>Contains information for a particular quadrature scheme for a basis.
  TYPE CMISSQuadratureType
    PRIVATE
    TYPE(QUADRATURE_TYPE), POINTER :: QUADRATURE
  END TYPE CMISSQuadratureType

 !>Contains information for a region.
  TYPE CMISSRegionType
    PRIVATE
    TYPE(REGION_TYPE), POINTER :: REGION
  END TYPE CMISSRegionType

  !>Contains information about a solver.
  TYPE CMISSSolverType
    PRIVATE
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
  END TYPE CMISSSolverType

  !>Contains information about the solver equations for a solver.
  TYPE CMISSSolverEquationsType
    PRIVATE
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
  END TYPE CMISSSolverEquationsType

  !>Contains information on a computational work group
  TYPE CMISSComputationalWorkGroupType
    PRIVATE
    TYPE(COMPUTATIONAL_WORK_GROUP_TYPE), POINTER :: COMPUTATIONAL_WORK_GROUP
  END TYPE CMISSComputationalWorkGroupType

  !Module variables

  TYPE(VARYING_STRING) :: error

  !Interface CMISS_Finalise_
  !  MODULE PROCEDURE CMISSFinalise
  !END INTERFACE !CMISS_Finalise_

  INTERFACE CMISSInitialise
    MODULE PROCEDURE CMISSInitialiseNumber
    MODULE PROCEDURE CMISSInitialiseObj
  END INTERFACE !CMISSInitialise

  INTERFACE CMISSFieldsTypeCreate
    MODULE PROCEDURE CMISSFieldsTypeCreateInterface
    MODULE PROCEDURE CMISSFieldsTypeCreateRegion
  END INTERFACE !CMISSFieldsTypeCreate

  !PUBLIC CMISS_Finalise,CMISS_Initialise
  PUBLIC CMISSFinalise,CMISSInitialise

  PUBLIC CMISSBasisType,CMISSBasisTypesCopy,CMISSBasisTypeFinalise,CMISSBasisTypeInitialise

  PUBLIC CMISSBoundaryConditionsType,CMISSBoundaryConditionsTypeFinalise,CMISSBoundaryConditionsTypeInitialise

  PUBLIC CMISSCellMLType,CMISSCellMLTypeFinalise,CMISSCellMLTypeInitialise

  PUBLIC CMISSCellMLEquationsType,CMISSCellMLEquationsTypeFinalise,CMISSCellMLEquationsTypeInitialise

  PUBLIC CMISSComputationalWorkGroupType,CMISSComputationalWorkGroupTypeInitialise

  PUBLIC CMISSControlLoopType,CMISSControlLoopTypeFinalise,CMISSControlLoopTypeInitialise

  PUBLIC CMISSCoordinateSystemType,CMISSCoordinateSystemTypeFinalise,CMISSCoordinateSystemTypeInitialise

  PUBLIC CMISSDataPointsType,CMISSDataPointsTypeFinalise,CMISSDataPointsTypeInitialise

  PUBLIC CMISSDataProjectionType,CMISSDataProjectionTypeFinalise,CMISSDataProjectionTypeInitialise

  PUBLIC CMISSDecompositionType,CMISSDecompositionTypeFinalise,CMISSDecompositionTypeInitialise

  PUBLIC CMISSDecompositionCalculateFacesSet

  PUBLIC CMISSEquationsType,CMISSEquationsTypeFinalise,CMISSEquationsTypeInitialise

  PUBLIC CMISSEquationsSetType,CMISSEquationsSetTypeFinalise,CMISSEquationsSetTypeInitialise

  PUBLIC CMISSFieldType,CMISSFieldTypeFinalise,CMISSFieldTypeInitialise

  PUBLIC CMISSFieldsType,CMISSFieldsTypeCreate,CMISSFieldsTypeFinalise,CMISSFieldsTypeInitialise

  PUBLIC CMISSGeneratedMeshType,CMISSGeneratedMeshTypeFinalise,CMISSGeneratedMeshTypeInitialise

  PUBLIC CMISSHistoryType,CMISSHistoryTypeFinalise,CMISSHistoryTypeInitialise

  PUBLIC CMISSInterfaceType,CMISSInterfaceTypeFinalise,CMISSInterfaceTypeInitialise

  PUBLIC CMISSInterfaceConditionType,CMISSInterfaceConditionTypeFinalise,CMISSInterfaceConditionTypeInitialise

  PUBLIC CMISSInterfaceEquationsType,CMISSInterfaceEquationsTypeFinalise,CMISSInterfaceEquationsTypeInitialise

  PUBLIC CMISSInterfaceMeshConnectivityType,CMISSInterfaceMeshConnectivityTypeFinalise, &
     & CMISSInterfaceMeshConnectivityTypeInitialise

  PUBLIC CMISSMeshType,CMISSMeshTypeFinalise,CMISSMeshTypeInitialise

  PUBLIC CMISSMeshElementsType,CMISSMeshElementsTypeFinalise,CMISSMeshElementsTypeInitialise

  PUBLIC CMISSNodesType,CMISSNodesTypeFinalise,CMISSNodesTypeInitialise

  PUBLIC CMISSProblemType,CMISSProblemTypeFinalise,CMISSProblemTypeInitialise

  PUBLIC CMISSQuadratureType,CMISSQuadratureTypeFinalise,CMISSQuadratureTypeInitialise

  PUBLIC CMISSRegionType,CMISSRegionTypeFinalise,CMISSRegionTypeInitialise

  PUBLIC CMISSSolverType,CMISSSolverTypeFinalise,CMISSSolverTypeInitialise

  PUBLIC CMISSSolverEquationsType,CMISSSolverEquationsTypeFinalise,CMISSSolverEquationsTypeInitialise

!!==================================================================================================================================
!!
!! ANALYTIC_ANALYSIS_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Output the analytic error analysis for a field compared to the analytic values parameter set.
  INTERFACE CMISSAnalyticAnalysisOutput
    MODULE PROCEDURE CMISSAnalyticAnalysisOutputNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisOutputObj
  END INTERFACE !CMISSAnalyticAnalysisOutput

  !>Get the absolute error of the node.
  INTERFACE CMISSAnalyticAnalysisAbsoluteErrorGetNode
    MODULE PROCEDURE CMISSAnalyticAnalysisAbsoluteErrorGetNodeNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisAbsoluteErrorGetNodeObj
  END INTERFACE !CMISSAnalyticAnalysisAbsoluteErrorGetNode

  !>Get the percentage error of the node.
  INTERFACE CMISSAnalyticAnalysisPercentageErrorGetNode
    MODULE PROCEDURE CMISSAnalyticAnalysisPercentageErrorGetNodeNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisPercentageErrorGetNodeObj
  END INTERFACE !CMISSAnalyticAnalysisPercentageErrorGetNode

  !>Get the relative error of the node.
  INTERFACE CMISSAnalyticAnalysisRelativeErrorGetNode
    MODULE PROCEDURE CMISSAnalyticAnalysisRelativeErrorGetNodeNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisRelativeErrorGetNodeObj
  END INTERFACE !CMISSAnalyticAnalysisRelativeErrorGetNode

  !>Get the absolute error of the element.
  INTERFACE CMISSAnalyticAnalysisAbsoluteErrorGetElement
    MODULE PROCEDURE CMISSAnalyticAnalysisAbsoluteErrorGetElementNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisAbsoluteErrorGetElementObj
  END INTERFACE !CMISSAnalyticAnalysisAbsoluteErrorGetElement

  !>Get the percentage error of the element.
  INTERFACE CMISSAnalyticAnalysisPercentageErrorGetElement
    MODULE PROCEDURE CMISSAnalyticAnalysisPercentageErrorGetElementNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisPercentageErrorGetElementObj
  END INTERFACE !CMISSAnalyticAnalysisPercentageErrorGetElement

  !>Get the relative error of the element.
  INTERFACE CMISSAnalyticAnalysisRelativeErrorGetElement
    MODULE PROCEDURE CMISSAnalyticAnalysisRelativeErrorGetElementNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisRelativeErrorGetElementObj
  END INTERFACE !CMISSAnalyticAnalysisRelativeErrorGetElement

  !>Get the absolute error of the constant.
  INTERFACE CMISSAnalyticAnalysisAbsoluteErrorGetConstant
    MODULE PROCEDURE CMISSAnalyticAnalysisAbsoluteErrorGetConstantNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisAbsoluteErrorGetConstantObj
  END INTERFACE !CMISSAnalyticAnalysisAbsoluteErrorGetConstant

  !>Get the percentage error of the constant.
  INTERFACE CMISSAnalyticAnalysisPercentageErrorGetConstant
    MODULE PROCEDURE CMISSAnalyticAnalysisPercentageErrorGetConstantNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisPercentageErrorGetConstantObj
  END INTERFACE !CMISSAnalyticAnalysisPercentageErrorGetConstant

  !>Get the relative error of the constant.
  INTERFACE CMISSAnalyticAnalysisRelativeErrorGetConstant
    MODULE PROCEDURE CMISSAnalyticAnalysisRelativeErrorGetConstantNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisRelativeErrorGetConstantObj
  END INTERFACE !CMISSAnalyticAnalysisRelativeErrorGetConstant

  !>Get the rms error of nodes.
  INTERFACE CMISSAnalyticAnalysisRmsErrorGetNode
    MODULE PROCEDURE CMISSAnalyticAnalysisRmsErrorGetNodeNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisRmsErrorGetNodeObj
  END INTERFACE !CMISSAnalyticAnalysisRmsErrorGetNode

  !>Get the rms error of elements.
  INTERFACE CMISSAnalyticAnalysisRmsErrorGetElement
    MODULE PROCEDURE CMISSAnalyticAnalysisRmsErrorGetElementNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisRmsErrorGetElementObj
  END INTERFACE !CMISSAnalyticAnalysisRmsErrorGetElement

  !>Get integral of numerical values.
  INTERFACE CMISSAnalyticAnalysisIntegralNumericalValueGet
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralNumericalValueGetNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralNumericalValueGetObj
  END INTERFACE !CMISSAnalyticAnalysisIntegralNumericalValueGet

  !>Get integral of analytical values.
  INTERFACE CMISSAnalyticAnalysisIntegralAnalyticValueGet
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralAnalyticValueGetNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralAnalyticValueGetObj
  END INTERFACE !CMISSAnalyticAnalysisIntegralAnalyticValueGet

  !>Get integral of percentage errors.
  INTERFACE CMISSAnalyticAnalysisIntegralPercentageErrorGet
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralPercentageErrorGetNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralPercentageErrorGetObj
  END INTERFACE !CMISSAnalyticAnalysisIntegralPercentageErrorGet

  !>Get integral of absolute errors.
  INTERFACE CMISSAnalyticAnalysisIntegralAbsoluteErrorGet
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralAbsoluteErrorGetNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralAbsoluteErrorGetObj
  END INTERFACE !CMISSAnalyticAnalysisIntegralAbsoluteErrorGet

  !>Get integral of relative errors.
  INTERFACE CMISSAnalyticAnalysisIntegralRelativeErrorGet
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralRelativeErrorGetNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralRelativeErrorGetObj
  END INTERFACE !CMISSAnalyticAnalysisIntegralRelativeErrorGet

  !>Get integral of nid numerical errors.
  INTERFACE CMISSAnalyticAnalysisIntegralNidNumericalValueGet
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralNidNumericalValueGetNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralNidNumericalValueGetObj
  END INTERFACE !CMISSAnalyticAnalysisIntegralNidNumericalValueGet

  !>Get integral of nid errors.
  INTERFACE CMISSAnalyticAnalysisIntegralNidErrorGet
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralNidErrorGetNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralNidErrorGetObj
  END INTERFACE !CMISSAnalyticAnalysisIntegralNidErrorGet

  PUBLIC CMISSAnalyticAnalysisOutput

  PUBLIC CMISSAnalyticAnalysisAbsoluteErrorGetNode,CMISSAnalyticAnalysisPercentageErrorGetNode, &
    & CMISSAnalyticAnalysisRelativeErrorGetNode

  PUBLIC CMISSAnalyticAnalysisAbsoluteErrorGetElement,CMISSAnalyticAnalysisPercentageErrorGetElement, &
    & CMISSAnalyticAnalysisRelativeErrorGetElement

  PUBLIC CMISSAnalyticAnalysisAbsoluteErrorGetConstant,CMISSAnalyticAnalysisPercentageErrorGetConstant, &
    & CMISSAnalyticAnalysisRelativeErrorGetConstant

  PUBLIC CMISSAnalyticAnalysisRmsErrorGetNode,CMISSAnalyticAnalysisRmsErrorGetElement

  PUBLIC CMISSAnalyticAnalysisIntegralNumericalValueGet,CMISSAnalyticAnalysisIntegralAnalyticValueGet, &
    & CMISSAnalyticAnalysisIntegralPercentageErrorGet,CMISSAnalyticAnalysisIntegralAbsoluteErrorGet, &
    & CMISSAnalyticAnalysisIntegralRelativeErrorGet,CMISSAnalyticAnalysisIntegralNidNumericalValueGet, &
    & CMISSAnalyticAnalysisIntegralNidErrorGet

!!==================================================================================================================================
!!
!! BASE_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_DiagnosticAndTimingConstants OPENCMISS::DiagnosticAndTiming::Constants
  !> \brief Diagnostic and Timing constants.
  !>@{
  !> \addtogroup OPENCMISS_DiagnosticTypes OPENCMISS::DiagnosticAndTiming::DiagnosticTypes
  !> \brief Diganostic constants.
  !> \see OPENCMISS::DiagnosticTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_ALL_DIAG_TYPE = ALL_DIAG_TYPE !<Type for setting diagnostic output in all routines \see OPENCMISS_DiagnosticTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_IN_DIAG_TYPE = IN_DIAG_TYPE !<Type for setting diagnostic output in one routine \see OPENCMISS_DiagnosticTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FROM_DIAG_TYPE = FROM_DIAG_TYPE !<Type for setting diagnostic output in one routine downwards \see OPENCMISS_DiagnosticTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_TimingTypes OPENCMISS::DiagnosticAndTiming::TimingTypes
  !> \brief Timing constants.
  !> \see OPENCMISS::TimingTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_ALL_TIMING_TYPE = ALL_TIMING_TYPE !<Type for setting timing output in all routines \see OPENCMISS_TimingTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_IN_TIMING_TYPE = IN_TIMING_TYPE !<Type for setting timing output in one routine \see OPENCMISS_TimingTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FROM_TIMING_TYPE = FROM_TIMING_TYPE !<Type for setting timing output from one routine downwards \see OPENCMISS_TimingTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  PUBLIC CMISS_ALL_DIAG_TYPE,CMISS_IN_DIAG_TYPE,CMISS_FROM_DIAG_TYPE

  PUBLIC CMISS_ALL_TIMING_TYPE,CMISS_IN_TIMING_TYPE,CMISS_FROM_TIMING_TYPE

  PUBLIC CMISSDiagnosticsSetOff,CMISSDiagnosticsSetOn

  PUBLIC CMISSOutputSetOff,CMISSOutputSetOn

  PUBLIC CMISSTimingSetOff,CMISSTimingSetOn,CMISSTimingSummaryOutput

!!==================================================================================================================================
!!
!! BASIS_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_BasisConstants OPENCMISS::Basis::Constants
  !> \brief Basis function constants.
  !>@{
  !> \addtogroup OPENCMISS_BasisTypes OPENCMISS::Basis::BasisTypes
  !> \brief Basis definition type parameters.
  !> \see OPENCMISS::BasisConstants,OPENCMISS
  !>@{ symbol 'nodenumber' at (1) has no IMPLICIT type.
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_LAGRANGE_HERMITE_TP_TYPE = BASIS_LAGRANGE_HERMITE_TP_TYPE !<Lagrange-Hermite tensor product basis type \see OPENCMISS_BasisTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_SIMPLEX_TYPE = BASIS_SIMPLEX_TYPE !<Simplex basis type \see OPENCMISS_BasisTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_SERENDIPITY_TYPE = BASIS_SERENDIPITY_TYPE !<Serendipity basis type \see OPENCMISS_BasisTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_AUXILLIARY_TYPE = BASIS_AUXILLIARY_TYPE !<Auxillary basis type \see OPENCMISS_BasisTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_B_SPLINE_TP_TYPE = BASIS_B_SPLINE_TP_TYPE !<B-spline basis type \see OPENCMISS_BasisTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_FOURIER_LAGRANGE_HERMITE_TP_TYPE = BASIS_FOURIER_LAGRANGE_HERMITE_TP_TYPE !<Fourier-Lagrange tensor product basis type \see OPENCMISS_BasisTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_EXTENDED_LAGRANGE_TP_TYPE = BASIS_EXTENDED_LAGRANGE_TP_TYPE !< Extendend Lagrange tensor product basis type \see OPENCMISS_BasisTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_BasisInterpolationSpecifications OPENCMISS::Basis::InterpolationSpecifications
  !> \brief Interpolation specification parameters
  !> \see OPENCMISS::BasisConstants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_LINEAR_LAGRANGE_INTERPOLATION = BASIS_LINEAR_LAGRANGE_INTERPOLATION !<Linear Lagrange interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_QUADRATIC_LAGRANGE_INTERPOLATION = BASIS_QUADRATIC_LAGRANGE_INTERPOLATION !<Quadratic Lagrange interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_CUBIC_LAGRANGE_INTERPOLATION = BASIS_CUBIC_LAGRANGE_INTERPOLATION !<Cubic Lagrange interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_CUBIC_HERMITE_INTERPOLATION = BASIS_CUBIC_HERMITE_INTERPOLATION !<Cubic Hermite interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_QUADRATIC1_HERMITE_INTERPOLATION = BASIS_QUADRATIC1_HERMITE_INTERPOLATION !<Quadratic Hermite (no derivative at xi=0) interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_QUADRATIC2_HERMITE_INTERPOLATION = BASIS_QUADRATIC2_HERMITE_INTERPOLATION !<Quadratic Hermite (no derivative at xi=1) interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_LINEAR_SIMPLEX_INTERPOLATION = BASIS_LINEAR_SIMPLEX_INTERPOLATION !<Linear Simplex interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_QUADRATIC_SIMPLEX_INTERPOLATION = BASIS_QUADRATIC_SIMPLEX_INTERPOLATION !<Quadratic Simplex interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_CUBIC_SIMPLEX_INTERPOLATION = BASIS_CUBIC_SIMPLEX_INTERPOLATION !<Cubic Simplex interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_BasisQuadratureSchemes OPENCMISS::Basis::QuadratureSchemes
  !> \brief Quadrature scheme parameters
  !> \see OPENCMISS::BasisConstants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_DEFAULT_QUADRATURE_SCHEME = BASIS_DEFAULT_QUADRATURE_SCHEME !<Identifier for the default quadrature scheme \see OPENCMISS_BasisQuadratureSchemes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_LOW_QUADRATURE_SCHEME = BASIS_LOW_QUADRATURE_SCHEME !<Identifier for a low order quadrature scheme \see OPENCMISS_BasisQuadratureSchemes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_MID_QUADRATURE_SCHEME = BASIS_MID_QUADRATURE_SCHEME !<Identifier for a mid order quadrature scheme \see OPENCMISS_BasisQuadratureSchemes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_HIGH_QUADRATURE_SCHEME = BASIS_HIGH_QUADRATURE_SCHEME !<Identifier for a high order quadrature scheme \see OPENCMISS_BasisQuadratureSchemes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_BasisQuadratureTypes OPENCMISS::Basis::QuadratureTypes
  !> \brief Basis quadrature type parameters.
  !> \see OPENCMISS::BasisConstants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_GAUSS_LEGENDRE_QUADRATURE = BASIS_GAUSS_LEGENDRE_QUADRATURE !<Gauss-Legendre quadrature \see OPENCMISS_BasisQuadratureTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_GAUSS_LAGUERRE_QUADRATURE = BASIS_GAUSS_LAGUERRE_QUADRATURE !<Gauss-Laguerre quadrature \see OPENCMISS_BasisQuadratureTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_GUASS_HERMITE_QUADRATURE = BASIS_GUASS_HERMITE_QUADRATURE !<Gauss-Hermite quadrature \see OPENCMISS_BasisQuadratureTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_ADAPTIVE_GAUSS_LEGENDRE_QUADRATURE = BASIS_ADAPTIVE_GAUSS_LEGENDRE_QUADRATURE !<Adaptive Gauss-Legendre quadrature \see OPENCMISS_BasisQuadratureTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_GAUSS_SIMPLEX_QUADRATURE = BASIS_GAUSS_SIMPLEX_QUADRATURE !<Gauss-Legendre for Simplex elements quadrature \see OPENCMISS_BasisQuadratureTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_BasisXiCollapse OPENCMISS::Basis::XiCollapse
  !> \brief Basis Xi collapse parameters.
  !> \see OPENCMISS::Basis,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_XI_COLLAPSED = BASIS_XI_COLLAPSED !<The Xi direction is collapsed \see OPENCMISS_BasisXiCollapse,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_COLLAPSED_AT_XI0 = BASIS_COLLAPSED_AT_XI0 !<The Xi direction at the xi=0 end of this Xi direction is collapsed \see OPENCMISS_BasisXiCollapse,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_COLLAPSED_AT_XI1 = BASIS_COLLAPSED_AT_XI1 !<The Xi direction at the xi=1 end of this Xi direction is collapsed \see OPENCMISS_BasisXiCollapse,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_NOT_COLLAPSED = BASIS_NOT_COLLAPSED !<The Xi direction is not collapsed \see OPENCMISS_BasisXiCollapse,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Returns the collapsed Xi flags for a basis.
  INTERFACE CMISSBasisCollapsedXiGet
    MODULE PROCEDURE CMISSBasisCollapsedXiGetNumber
    MODULE PROCEDURE CMISSBasisCollapsedXiGetObj
  END INTERFACE !CMISSBasisCollapsedXiGet

  !>Sets/changes the collapsed Xi flags for a basis.
  INTERFACE CMISSBasisCollapsedXiSet
    MODULE PROCEDURE CMISSBasisCollapsedXiSetNumber
    MODULE PROCEDURE CMISSBasisCollapsedXiSetObj
  END INTERFACE !CMISSBasisCollapsedXiSet

  !>Finishes the creation of a new basis. \see OPENCMISS::CMISSBasisCreateStart
  INTERFACE CMISSBasisCreateFinish
    MODULE PROCEDURE CMISSBasisCreateFinishNumber
    MODULE PROCEDURE CMISSBasisCreateFinishObj
  END INTERFACE !CMISSBasisCreateFinish

  !>Starts the creation of a new basis. \see OPENCMISS::CMISSBasisCreateFinish
  INTERFACE CMISSBasisCreateStart
    MODULE PROCEDURE CMISSBasisCreateStartNumber
    MODULE PROCEDURE CMISSBasisCreateStartObj
  END INTERFACE !CMISSBasisCreateStart

  !>Destroys a basis.
  INTERFACE CMISSBasisDestroy
    MODULE PROCEDURE CMISSBasisDestroyNumber
    MODULE PROCEDURE CMISSBasisDestroyObj
  END INTERFACE !CMISSBasisDestroy

  !>Get the interpolation type in each Xi directions for a basis.
  INTERFACE CMISSBasisInterpolationXiGet
    MODULE PROCEDURE CMISSBasisInterpolationXiGetNumber
    MODULE PROCEDURE CMISSBasisInterpolationXiGetObj
  END INTERFACE !CMISSBasisInterpolationXiGet

  !>Sets/changes the interpolation type in each Xi directions for a basis.
  INTERFACE CMISSBasisInterpolationXiSet
    MODULE PROCEDURE CMISSBasisInterpolationXiSetNumber
    MODULE PROCEDURE CMISSBasisInterpolationXiSetObj
  END INTERFACE !CMISSBasisInterpolationXiSet

  !>Returns the number of local nodes in a basis.
  INTERFACE CMISSBasisNumberOfLocalNodesGet
    MODULE PROCEDURE CMISSBasisNumberOfLocalNodesGetNumber
    MODULE PROCEDURE CMISSBasisNumberOfLocalNodesGetObj
  END INTERFACE !CMISSBasisNumberOfLocalNodesGet

  !>Returns the number of Xi directions in a basis.
  INTERFACE CMISSBasisNumberOfXiGet
    MODULE PROCEDURE CMISSBasisNumberOfXiGetNumber
    MODULE PROCEDURE CMISSBasisNumberOfXiGetObj
  END INTERFACE !CMISSBasisNumberOfXiGet

  !>Sets/changes the number of Xi directions in a basis.
  INTERFACE CMISSBasisNumberOfXiSet
    MODULE PROCEDURE CMISSBasisNumberOfXiSetNumber
    MODULE PROCEDURE CMISSBasisNumberOfXiSetObj
  END INTERFACE !CMISSBasisNumberOfXiSet

  !>Returns the number of Gauss points in each Xi direction on a basis quadrature.
  INTERFACE CMISSBasisQuadratureNumberOfGaussXiGet
    MODULE PROCEDURE CMISSBasisQuadratureNumberOfGaussXiGetNumber
    MODULE PROCEDURE CMISSBasisQuadratureNumberOfGaussXiGetObj
  END INTERFACE !CMISSBasisQuadratureNumberOfGaussXiGet

  !>Sets/changes the number of Gauss points in each Xi direction on a basis quadrature.
  INTERFACE CMISSBasisQuadratureNumberOfGaussXiSet
    MODULE PROCEDURE CMISSBasisQuadratureNumberOfGaussXiSetNumber
    MODULE PROCEDURE CMISSBasisQuadratureNumberOfGaussXiSetObj
  END INTERFACE !CMISSBasisQuadratureNumberOfGaussXiSet

  !>Returns the order of quadrature for a basis quadrature.
  INTERFACE CMISSBasisQuadratureOrderGet
    MODULE PROCEDURE CMISSBasisQuadratureOrderGetNumber
    MODULE PROCEDURE CMISSBasisQuadratureOrderGetObj
  END INTERFACE !CMISSBasisQuadratureOrderGet

  !>Sets/changes the order of quadrature for a basis quadrature.
  INTERFACE CMISSBasisQuadratureOrderSet
    MODULE PROCEDURE CMISSBasisQuadratureOrderSetNumber
    MODULE PROCEDURE CMISSBasisQuadratureOrderSetObj
  END INTERFACE !CMISSBasisQuadratureOrderSet

  !>Returns the quadrature type for a basis quadrature.
  INTERFACE CMISSBasisQuadratureTypeGet
    MODULE PROCEDURE CMISSBasisQuadratureTypeGetNumber
    MODULE PROCEDURE CMISSBasisQuadratureTypeGetObj
  END INTERFACE !CMISSBasisQuadratureTypeGet

  !>Sets/changes the quadrature type for a basis quadrature.
  INTERFACE CMISSBasisQuadratureTypeSet
    MODULE PROCEDURE CMISSBasisQuadratureTypeSetNumber
    MODULE PROCEDURE CMISSBasisQuadratureTypeSetObj
  END INTERFACE !CMISSBasisQuadratureTypeSet

  !>Sets/changes the local face gauss evaluatoin flag for a basis quadrature.
  INTERFACE CMISSBasisQuadratureLocalFaceGaussEvaluateSet
    MODULE PROCEDURE CMISSBasisQuadratureLocalFaceGaussEvaluateSetNumber
    MODULE PROCEDURE CMISSBasisQuadratureLocalFaceGaussEvaluateSetObj
  END INTERFACE !CMISSBasisQuadratureLocalFaceGaussEvaluateSet

  !>Returns the type of a basis.
  INTERFACE CMISSBasisTypeGet
    MODULE PROCEDURE CMISSBasisTypeGetNumber
    MODULE PROCEDURE CMISSBasisTypeGetObj
  END INTERFACE !CMISSBasisTypeGet

  !>Sets/changes the type of a basis.
  INTERFACE CMISSBasisTypeSet
    MODULE PROCEDURE CMISSBasisTypeSetNumber
    MODULE PROCEDURE CMISSBasisTypeSetObj
  END INTERFACE !CMISSBasisTypeSet

  PUBLIC CMISS_BASIS_LAGRANGE_HERMITE_TP_TYPE,CMISS_BASIS_SIMPLEX_TYPE,CMISS_BASIS_SERENDIPITY_TYPE,CMISS_BASIS_AUXILLIARY_TYPE, &
    & CMISS_BASIS_B_SPLINE_TP_TYPE,CMISS_BASIS_FOURIER_LAGRANGE_HERMITE_TP_TYPE,CMISS_BASIS_EXTENDED_LAGRANGE_TP_TYPE

  PUBLIC CMISS_BASIS_LINEAR_LAGRANGE_INTERPOLATION,CMISS_BASIS_QUADRATIC_LAGRANGE_INTERPOLATION, &
    & CMISS_BASIS_CUBIC_LAGRANGE_INTERPOLATION, &
    & CMISS_BASIS_CUBIC_HERMITE_INTERPOLATION,CMISS_BASIS_QUADRATIC1_HERMITE_INTERPOLATION, &
    & CMISS_BASIS_QUADRATIC2_HERMITE_INTERPOLATION, &
    & CMISS_BASIS_LINEAR_SIMPLEX_INTERPOLATION,CMISS_BASIS_QUADRATIC_SIMPLEX_INTERPOLATION,CMISS_BASIS_CUBIC_SIMPLEX_INTERPOLATION

  PUBLIC CMISS_BASIS_DEFAULT_QUADRATURE_SCHEME,CMISS_BASIS_LOW_QUADRATURE_SCHEME,CMISS_BASIS_MID_QUADRATURE_SCHEME, &
    & CMISS_BASIS_HIGH_QUADRATURE_SCHEME

  PUBLIC CMISS_BASIS_GAUSS_LEGENDRE_QUADRATURE,CMISS_BASIS_GAUSS_LAGUERRE_QUADRATURE,CMISS_BASIS_GUASS_HERMITE_QUADRATURE, &
    & CMISS_BASIS_ADAPTIVE_GAUSS_LEGENDRE_QUADRATURE,CMISS_BASIS_GAUSS_SIMPLEX_QUADRATURE

  PUBLIC CMISS_BASIS_XI_COLLAPSED,CMISS_BASIS_COLLAPSED_AT_XI0,CMISS_BASIS_COLLAPSED_AT_XI1,CMISS_BASIS_NOT_COLLAPSED

  PUBLIC CMISSBasisCollapsedXiGet,CMISSBasisCollapsedXiSet

  PUBLIC CMISSBasisCreateFinish,CMISSBasisCreateStart,CMISSBasisDestroy

  PUBLIC CMISSBasisInterpolationXiGet,CMISSBasisInterpolationXiSet

  PUBLIC CMISSBasisNumberOfLocalNodesGet

  PUBLIC CMISSBasisNumberOfXiGet,CMISSBasisNumberOfXiSet

  PUBLIC CMISSBasisQuadratureNumberOfGaussXiGet,CMISSBasisQuadratureNumberOfGaussXiSet

  PUBLIC CMISSBasisQuadratureOrderGet,CMISSBasisQuadratureOrderSet

  PUBLIC CMISSBasisQuadratureTypeGet,CMISSBasisQuadratureTypeSet, CMISSBasisQuadratureLocalFaceGaussEvaluateSet

  PUBLIC CMISSBasisTypeGet,CMISSBasisTypeSet

!!==================================================================================================================================
!!
!! BOUNDARY_CONDITIONS_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters


  !> \addtogroup OPENCMISS_BoundaryConditionsConstants OPENCMISS::BoundaryConditions::Constants
  !> \brief Boundary conditions constants.
  !>@{
  !> \addtogroup OPENCMISS_BoundaryConditionsTypes OPENCMISS::BoundaryConditions::Types
  !> \brief Boundary conditions type parameters.
  !> \see OPENCMISS::BoundaryConditions,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_FREE = BOUNDARY_CONDITION_FREE !<The dof is free. \see OPENCMISS_BoundaryConditionsTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_FIXED = BOUNDARY_CONDITION_FIXED !<The dof is fixed as a boundary condition. \see OPENCMISS_BoundaryConditionsTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_MIXED = BOUNDARY_CONDITION_MIXED !<The dof is set as a mixed boundary condition. \see OPENCMISS_BoundaryConditionsTypes,OPENCMISS

  !Temporary boundary flags (to be removed when general boundary object becomes available!)
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_FIXED_WALL = BOUNDARY_CONDITION_FIXED_WALL
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_FIXED_INLET = BOUNDARY_CONDITION_FIXED_INLET
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_FIXED_OUTLET = BOUNDARY_CONDITION_FIXED_OUTLET
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_MOVED_WALL = BOUNDARY_CONDITION_MOVED_WALL
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_MOVED_WALL_INCREMENTED = BOUNDARY_CONDITION_MOVED_WALL_INCREMENTED
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_FREE_WALL = BOUNDARY_CONDITION_FREE_WALL

  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_NEUMANN_POINT = BOUNDARY_CONDITION_NEUMANN_POINT
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_NEUMANN_INTEGRATED = BOUNDARY_CONDITION_NEUMANN_INTEGRATED
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_NEUMANN_FREE = BOUNDARY_CONDITION_NEUMANN_FREE
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_DIRICHLET = BOUNDARY_CONDITION_DIRICHLET
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_CAUCHY = BOUNDARY_CONDITION_CAUCHY
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_ROBIN = BOUNDARY_CONDITION_ROBIN

  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_FIXED_INCREMENTED = BOUNDARY_CONDITION_FIXED_INCREMENTED
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_PRESSURE = BOUNDARY_CONDITION_PRESSURE
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_PRESSURE_INCREMENTED = BOUNDARY_CONDITION_PRESSURE_INCREMENTED

  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_CORRECTION_MASS_INCREASE = BOUNDARY_CONDITION_CORRECTION_MASS_INCREASE
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_IMPERMEABLE_WALL = BOUNDARY_CONDITION_IMPERMEABLE_WALL
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Destroys boundary conditions.
  INTERFACE CMISSBoundaryConditionsDestroy
    MODULE PROCEDURE CMISSBoundaryConditionsDestroyNumber0
    MODULE PROCEDURE CMISSBoundaryConditionsDestroyNumber1
    MODULE PROCEDURE CMISSBoundaryConditionsDestroyObj
  END INTERFACE !CMISSBoundaryConditionsDestroy

  !>Adds to the value of the specified constant and sets this as a boundary condition on the specified constant.
  INTERFACE CMISSBoundaryConditionsAddConstant
    MODULE PROCEDURE CMISSBoundaryConditionsAddConstantNumber
    MODULE PROCEDURE CMISSBoundaryConditionsAddConstantObj
  END INTERFACE !CMISSBoundaryConditionsAddConstant

  !>Sets the value of the specified constant as a boundary condition on the specified constant.
  INTERFACE CMISSBoundaryConditionsSetConstant
    MODULE PROCEDURE CMISSBoundaryConditionsSetConstantNumber
    MODULE PROCEDURE CMISSBoundaryConditionsSetConstantObj
  END INTERFACE !CMISSBoundaryConditionsSetConstant

  !>Adds to the value of the element constant and sets this as a boundary condition on the specified element.
  INTERFACE CMISSBoundaryConditionsAddElement
    MODULE PROCEDURE CMISSBoundaryConditionsAddElementNumber
    MODULE PROCEDURE CMISSBoundaryConditionsAddElementObj
  END INTERFACE !CMISSBoundaryConditionsAddElement

  !>Sets the value of the specified element as a boundary condition on the specified element.
  INTERFACE CMISSBoundaryConditionsSetElement
    MODULE PROCEDURE CMISSBoundaryConditionsSetElementNumber
    MODULE PROCEDURE CMISSBoundaryConditionsSetElementObj
  END INTERFACE !CMISSBoundaryConditionsSetElement

  !>Adds to the value of the node constant and sets this as a boundary condition on the specified node.
  INTERFACE CMISSBoundaryConditionsAddNode
    MODULE PROCEDURE CMISSBoundaryConditionsAddNodeNumber
    MODULE PROCEDURE CMISSBoundaryConditionsAddNodeObj
  END INTERFACE !CMISSBoundaryConditionsAddNode

  !>Sets the value of the specified node as a boundary condition on the specified node.
  INTERFACE CMISSBoundaryConditionsSetNode
    MODULE PROCEDURE CMISSBoundaryConditionsSetNodeNumber0
    MODULE PROCEDURE CMISSBoundaryConditionsSetNodeNumber1
    MODULE PROCEDURE CMISSBoundaryConditionsSetNodeObj
  END INTERFACE !CMISSBoundaryConditionsSetNode

 !>Add DOF and value to boundary condition object.
 INTERFACE CMISSBoundaryConditionsAddDOFToBoundary
   MODULE PROCEDURE CMISSBoundaryConditionsAddDOFToBoundaryNumber
   MODULE PROCEDURE CMISSBoundaryConditionsAddDOFToBoundaryObj
 END INTERFACE !CMISSBoundaryConditionsAddDOFToBoundary

  PUBLIC CMISS_BOUNDARY_CONDITION_FREE,CMISS_BOUNDARY_CONDITION_FIXED,CMISS_BOUNDARY_CONDITION_MIXED
  !Temporary boundary flags (to be removed when general boundary object becomes available!)
  PUBLIC CMISS_BOUNDARY_CONDITION_FIXED_WALL,CMISS_BOUNDARY_CONDITION_FIXED_INLET,CMISS_BOUNDARY_CONDITION_MOVED_WALL, &
    & CMISS_BOUNDARY_CONDITION_FREE_WALL,CMISS_BOUNDARY_CONDITION_FIXED_OUTLET,CMISS_BOUNDARY_CONDITION_MOVED_WALL_INCREMENTED, &
    & CMISS_BOUNDARY_CONDITION_CORRECTION_MASS_INCREASE,CMISS_BOUNDARY_CONDITION_IMPERMEABLE_WALL

  PUBLIC CMISS_BOUNDARY_CONDITION_NEUMANN_POINT,CMISS_BOUNDARY_CONDITION_NEUMANN_INTEGRATED,CMISS_BOUNDARY_CONDITION_DIRICHLET
  PUBLIC CMISS_BOUNDARY_CONDITION_CAUCHY,CMISS_BOUNDARY_CONDITION_ROBIN,CMISS_BOUNDARY_CONDITION_FIXED_INCREMENTED
  PUBLIC CMISS_BOUNDARY_CONDITION_PRESSURE,CMISS_BOUNDARY_CONDITION_PRESSURE_INCREMENTED,CMISS_BOUNDARY_CONDITION_NEUMANN_FREE

  PUBLIC CMISSBoundaryConditionsDestroy

  PUBLIC CMISSBoundaryConditionsAddConstant,CMISSBoundaryConditionsSetConstant

  PUBLIC CMISSBoundaryConditionsAddElement,CMISSBoundaryConditionsSetElement

  PUBLIC CMISSBoundaryConditionsAddNode,CMISSBoundaryConditionsSetNode

  PUBLIC CMISSBoundaryConditionsAddDOFToBoundary

!!==================================================================================================================================
!!
!! CMISS
!!
!!==================================================================================================================================

  !Module parameters
  !> \addtogroup OPENCMISS_CMISSConstants OPENCMISS::CMISS::Constants
  !> \brief CMISS constants.
  !>@{
  !> \addtogroup OPENCMISS_CMISSErrorHandlingModes OPENCMISS::CMISS::ErrorHandlingModes
  !> \brief CMISS error handling mode parameters
  !> \see OPENCMISS::CMISS,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_CMISS_RETURN_ERROR_CODE = CMISS_RETURN_ERROR_CODE !<Just return the error code \see OPENCMISS_CMISSErrorHandlingModes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_CMISS_OUTPUT_ERROR = CMISS_OUTPUT_ERROR !<Output the error traceback and return the error code \see OPENCMISS_CMISSErrorHandlingModes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_CMISS_TRAP_ERROR = CMISS_TRAP_ERROR!<Trap the error by outputing the error traceback and stopping the program \see OPENCMISS_CMISSErrorHandlingModes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Extracts the OpenCMISS error message.
  INTERFACE CMISSExtractErrorMessage
    MODULE PROCEDURE CMISSExtractErrorMessageC
    MODULE PROCEDURE CMISSExtractErrorMessageVS
  END INTERFACE !CMISSExtractErrorMessage

  !>Gets the random seeds for OpenCMISS.
  INTERFACE CMISSRandomSeedsGet
    MODULE PROCEDURE CMISSRandomSeedsGet0
    MODULE PROCEDURE CMISSRandomSeedsGet1
  END INTERFACE !CMISSRandomSeedsGet

  !>Sets the random seeds for OpenCMISS.
  INTERFACE CMISSRandomSeedsSet
    MODULE PROCEDURE CMISSRandomSeedsSet0
    MODULE PROCEDURE CMISSRandomSeedsSet1
  END INTERFACE !CMISSRandomSeedsSet

  PUBLIC CMISS_CMISS_RETURN_ERROR_CODE,CMISS_CMISS_OUTPUT_ERROR,CMISS_CMISS_TRAP_ERROR

  PUBLIC CMISSErrorHandlingModeGet,CMISSErrorHandlingModeSet

  PUBLIC CMISSExtractErrorMessage

  PUBLIC CMISSRandomSeedsGet,CMISSRandomSeedsSizeGet,CMISSRandomSeedsSet

!!==================================================================================================================================
!!
!! CMISS_CELLML
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_CellMLConstants OPENCMISS::CellML::Constants
  !> \brief CellML constants.
  !>@{
  !> \addtogroup OPENCMISS_CellMLFieldTypes OPENCMISS::CellML::FieldTypes
  !> \brief CellML field type parameters.
  !> \see OPENCMISS::CellML,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_CELLML_MODELS_FIELD = CELLML_MODELS_FIELD !<CellML models field type \see OPENCMISS_CellMLFieldTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_CELLML_STATE_FIELD = CELLML_STATE_FIELD !<CellML state field type \see OPENCMISS_CellMLFieldTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_CELLML_INTERMEDIATE_FIELD = CELLML_INTERMEDIATE_FIELD !<CellML intermediate field type \see OPENCMISS_CellMLFieldTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_CELLML_PARAMETERS_FIELD = CELLML_PARAMETERS_FIELD !<CellML parameters field type \see OPENCMISS_CellMLFieldTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Set a CellML model variable as being known (the value will be set from an OpenCMISS field)
  INTERFACE CMISSCellMLVariableSetAsKnown
    MODULE PROCEDURE CMISSCellMLVariableSetAsKnownNumberC
    MODULE PROCEDURE CMISSCellMLVariableSetAsKnownObjC
    MODULE PROCEDURE CMISSCellMLVariableSetAsKnownNumberVS
    MODULE PROCEDURE CMISSCellMLVariableSetAsKnownObjVS
  END INTERFACE !CMISSCellMLVariableSetAsKnown

  !>Set a CellML model variable as being wanted (the value will be extracted from the model to an OpenCMISS field)
  INTERFACE CMISSCellMLVariableSetAsWanted
    MODULE PROCEDURE CMISSCellMLVariableSetAsWantedNumberC
    MODULE PROCEDURE CMISSCellMLVariableSetAsWantedObjC
    MODULE PROCEDURE CMISSCellMLVariableSetAsWantedNumberVS
    MODULE PROCEDURE CMISSCellMLVariableSetAsWantedObjVS
  END INTERFACE !CMISSCellMLVariableSetAsWanted

  !>Map a CellML model variable to a field variable component in this CellML environment.
  INTERFACE CMISSCellMLCreateCellMLToFieldMap
    MODULE PROCEDURE CMISSCellMLCreateCellMLToFieldMapNumberC
    MODULE PROCEDURE CMISSCellMLCreateCellMLToFieldMapObjC
    MODULE PROCEDURE CMISSCellMLCreateCellMLToFieldMapNumberVS
    MODULE PROCEDURE CMISSCellMLCreateCellMLToFieldMapObjVS
  END INTERFACE !CMISSCellMLCreateCellMLToFieldMap

  !>Map a field variable component to a CellML model variable in this CellML environment.
  INTERFACE CMISSCellMLCreateFieldToCellMLMap
    MODULE PROCEDURE CMISSCellMLCreateFieldToCellMLMapNumberC
    MODULE PROCEDURE CMISSCellMLCreateFieldToCellMLMapObjC
    MODULE PROCEDURE CMISSCellMLCreateFieldToCellMLMapNumberVS
    MODULE PROCEDURE CMISSCellMLCreateFieldToCellMLMapObjVS
  END INTERFACE !CMISSCellMLCreateFieldToCellMLMap

  !>Finishes the creation of a CellML environment. \see OPENCMISS::CMISSCellMLCreateStart
  INTERFACE CMISSCellMLCreateFinish
    MODULE PROCEDURE CMISSCellMLCreateFinishNumber
    MODULE PROCEDURE CMISSCellMLCreateFinishObj
  END INTERFACE !CMISSCellMLCreateFinish

  !>Starts the creation of a CellML environment. \see OPENCMISS::CMISSCellMLCreateFinish
  INTERFACE CMISSCellMLCreateStart
    MODULE PROCEDURE CMISSCellMLCreateStartNumber
    MODULE PROCEDURE CMISSCellMLCreateStartObj
  END INTERFACE !CMISSCellMLCreateStart

  !>Destroys a CellML environment.
  INTERFACE CMISSCellMLDestroy
    MODULE PROCEDURE CMISSCellMLDestroyNumber
    MODULE PROCEDURE CMISSCellMLDestroyObj
  END INTERFACE !CMISSCellMLDestroy

  !>Finishes the creation of field maps for a CellML environment. \see OPENCMISS::CMISSCellMLFieldMapsCreateStart
  INTERFACE CMISSCellMLFieldMapsCreateFinish
    MODULE PROCEDURE CMISSCellMLFieldMapsCreateFinishNumber
    MODULE PROCEDURE CMISSCellMLFieldMapsCreateFinishObj
  END INTERFACE !CMISSCellMLFieldMapsCreateFinish

  !>Starts the creation of field maps for a CellML environment. \see OPENCMISS::CMISSCellMLFieldMapsCreateFinish
  INTERFACE CMISSCellMLFieldMapsCreateStart
    MODULE PROCEDURE CMISSCellMLFieldMapsCreateStartNumber
    MODULE PROCEDURE CMISSCellMLFieldMapsCreateStartObj
  END INTERFACE !CMISSCellMLFieldMapsCreateStart

  !>Imports the specified CellML model into a CellML models environment.
  INTERFACE CMISSCellMLModelImport
    MODULE PROCEDURE CMISSCellMLModelImportNumberC
    MODULE PROCEDURE CMISSCellMLModelImportObjC
    MODULE PROCEDURE CMISSCellMLModelImportNumberVS
    MODULE PROCEDURE CMISSCellMLModelImportObjVS
  END INTERFACE !CMISSCellMLModelImport

  !>Finishes the creation of CellML models field. \see OPENCMISS::CMISSCellMLModelsFieldCreateStart
  INTERFACE CMISSCellMLModelsFieldCreateFinish
    MODULE PROCEDURE CMISSCellMLModelsFieldCreateFinishNumber
    MODULE PROCEDURE CMISSCellMLModelsFieldCreateFinishObj
  END INTERFACE !CMISSCellMLModelsFieldCreateFinish

  !>Starts the creation of CellML models field. \see OPENCMISS::CMISSCellMLModelsFieldCreateFinish
  INTERFACE CMISSCellMLModelsFieldCreateStart
    MODULE PROCEDURE CMISSCellMLModelsFieldCreateStartNumber
    MODULE PROCEDURE CMISSCellMLModelsFieldCreateStartObj
  END INTERFACE !CMISSCellMLModelsFieldCreateStart

  !>Returns the CellML models field for a CellML environment.
  INTERFACE CMISSCellMLModelsFieldGet
    MODULE PROCEDURE CMISSCellMLModelsFieldGetNumber
    MODULE PROCEDURE CMISSCellMLModelsFieldGetObj
  END INTERFACE !CMISSCellMLModelsFieldGet

  !>Finishes the creation of CellML state field. \see OPENCMISS::CMISSCellMLStateFieldCreateStart
  INTERFACE CMISSCellMLStateFieldCreateFinish
    MODULE PROCEDURE CMISSCellMLStateFieldCreateFinishNumber
    MODULE PROCEDURE CMISSCellMLStateFieldCreateFinishObj
  END INTERFACE !CMISSCellMLStateFieldCreateFinish

  !>Starts the creation of CellML state field. \see OPENCMISS::CMISSCellMLStateFieldCreateFinish
  INTERFACE CMISSCellMLStateFieldCreateStart
    MODULE PROCEDURE CMISSCellMLStateFieldCreateStartNumber
    MODULE PROCEDURE CMISSCellMLStateFieldCreateStartObj
  END INTERFACE !CMISSCellMLStateFieldCreateStart

  !>Returns the CellML state field for a CellML environment.
  INTERFACE CMISSCellMLStateFieldGet
    MODULE PROCEDURE CMISSCellMLStateFieldGetNumber
    MODULE PROCEDURE CMISSCellMLStateFieldGetObj
  END INTERFACE !CMISSCellMLStateFieldGet

  !>Returns the component for a given CellML field that corresponds to the specified CellML variable ID.
  INTERFACE CMISSCellMLFieldComponentGet
    MODULE PROCEDURE CMISSCellMLFieldComponentGetNumberC
    MODULE PROCEDURE CMISSCellMLFieldComponentGetObjC
    MODULE PROCEDURE CMISSCellMLFieldComponentGetNumberVS
    MODULE PROCEDURE CMISSCellMLFieldComponentGetObjVS
  END INTERFACE !CMISSCellMLFieldComponentGet

  !>Finishes the creation of CellML intermediate field. \see OPENCMISS::CMISSCellMLIntermediateFieldCreateStart
  INTERFACE CMISSCellMLIntermediateFieldCreateFinish
    MODULE PROCEDURE CMISSCellMLIntermediateFieldCreateFinishNumber
    MODULE PROCEDURE CMISSCellMLIntermediateFieldCreateFinishObj
  END INTERFACE !CMISSCellMLIntermediateFieldCreateFinish

  !>Starts the creation of CellML intermediate field. \see OPENCMISS::CMISSCellMLIntermediateFieldCreateFinish
  INTERFACE CMISSCellMLIntermediateFieldCreateStart
    MODULE PROCEDURE CMISSCellMLIntermediateFieldCreateStartNumber
    MODULE PROCEDURE CMISSCellMLIntermediateFieldCreateStartObj
  END INTERFACE !CMISSCellMLIntermediateFieldCreateStart

  !>Returns the CellML intermediate field for a CellML environment.
  INTERFACE CMISSCellMLIntermediateFieldGet
    MODULE PROCEDURE CMISSCellMLIntermediateFieldGetNumber
    MODULE PROCEDURE CMISSCellMLIntermediateFieldGetObj
  END INTERFACE !CMISSCellMLIntermediateFieldGet

  !>Finishes the creation of CellML parameters field. \see OPENCMISS::CMISSCellMLParametersFieldCreateStart
  INTERFACE CMISSCellMLParametersFieldCreateFinish
    MODULE PROCEDURE CMISSCellMLParametersFieldCreateFinishNumber
    MODULE PROCEDURE CMISSCellMLParametersFieldCreateFinishObj
  END INTERFACE !CMISSCellMLParametersFieldCreateFinish

  !>Starts the creation of CellML parameters field. \see OPENCMISS::CMISSCellMLParametersFieldCreateFinish
  INTERFACE CMISSCellMLParametersFieldCreateStart
    MODULE PROCEDURE CMISSCellMLParametersFieldCreateStartNumber
    MODULE PROCEDURE CMISSCellMLParametersFieldCreateStartObj
  END INTERFACE !CMISSCellMLParametersFieldCreateStart

  !>Returns the CellML parameters field for a CellML environment.
  INTERFACE CMISSCellMLParametersFieldGet
    MODULE PROCEDURE CMISSCellMLParametersFieldGetNumber
    MODULE PROCEDURE CMISSCellMLParametersFieldGetObj
  END INTERFACE !CMISSCellMLParametersFieldGet

  !>Validate and instantiate the specified CellML environment.
  INTERFACE CMISSCellMLGenerate
    MODULE PROCEDURE CMISSCellMLGenerateNumber
    MODULE PROCEDURE CMISSCellMLGenerateObj
  END INTERFACE !CMISSCellMLGenerate

  PUBLIC CMISS_CELLML_MODELS_FIELD,CMISS_CELLML_STATE_FIELD,CMISS_CELLML_INTERMEDIATE_FIELD,CMISS_CELLML_PARAMETERS_FIELD

  PUBLIC CMISSCellMLVariableSetAsKnown,CMISSCellMLVariableSetAsWanted

  PUBLIC CMISSCellMLCreateCellMLToFieldMap,CMISSCellMLCreateFieldToCellMLMap

  PUBLIC CMISSCellMLCreateFinish,CMISSCellMLCreateStart

  PUBLIC CMISSCellMLDestroy

  PUBLIC CMISSCellMLFieldMapsCreateStart,CMISSCellMLFieldMapsCreateFinish

  PUBLIC CMISSCellMLModelImport

  PUBLIC CMISSCellMLModelsFieldCreateFinish,CMISSCellMLModelsFieldCreateStart,CMISSCellMLModelsFieldGet

  PUBLIC CMISSCellMLStateFieldCreateFinish,CMISSCellMLStateFieldCreateStart,CMISSCellMLStateFieldGet

  PUBLIC CMISSCellMLFieldComponentGet

  PUBLIC CMISSCellMLIntermediateFieldCreateFinish,CMISSCellMLIntermediateFieldCreateStart

  PUBLIC CMISSCellMLIntermediateFieldGet

  PUBLIC CMISSCellMLParametersFieldCreateFinish,CMISSCellMLParametersFieldCreateStart,CMISSCellMLParametersFieldGet

  PUBLIC CMISSCellMLGenerate

!!==================================================================================================================================
!!
!! COMP_ENVIRONMENT
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  PUBLIC CMISSComputationalNodeNumberGet

  PUBLIC CMISSComputationalNumberOfNodesGet

  PUBLIC CMISSComputationalWorkGroupCreateStart

  PUBLIC CMISSComputationalWorkGroupCreateFinish

  PUBLIC CMISSComputationalWorkGroupSubgroupAdd

  PUBLIC CMISSDecompositionWorldWorkGroupSet
!!==================================================================================================================================
!!
!! CONSTANTS
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_Constants OPENCMISS::Constants
  !> \brief Control loops constants.
  !>@{
  !> \addtogroup OPENCMISS_GlobalDerivativeConstants OPENCMISS::Constants::GlobalDerivativeConstants
  !> \brief Global derivative constant identifiers
  !> \see OPENCMISS_CONSTANTS,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_NO_GLOBAL_DERIV = NO_GLOBAL_DERIV !<No global derivative i.e., u \see OPENCMISS_GlobalDerivativeConstants,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GLOBAL_DERIV_S1 = GLOBAL_DERIV_S1 !<First global derivative in the s1 direction i.e., du/ds1 \see OPENCMISS_GlobalDerivativeConstants,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GLOBAL_DERIV_S2 = GLOBAL_DERIV_S2 !<First global derivative in the s2 direction i.e., du/ds2 \see OPENCMISS_GlobalDerivativeConstants,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GLOBAL_DERIV_S1_S2 = GLOBAL_DERIV_S1_S2 !<Global Cross derivative in the s1 and s2 direction i.e., d^2u/ds1ds2 \see OPENCMISS_GlobalDerivativeConstants,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GLOBAL_DERIV_S3 = GLOBAL_DERIV_S3 !<First global derivative in the s3 direction i.e., du/ds3 \see OPENCMISS_GlobalDerivativeConstants,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GLOBAL_DERIV_S1_S3 = GLOBAL_DERIV_S1_S3 !<Global Cross derivative in the s1 and s3 direction i.e., d^2u/ds1ds3 \see OPENCMISS_GlobalDerivativeConstants,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GLOBAL_DERIV_S2_S3 = GLOBAL_DERIV_S2_S3 !<Global Cross derivative in the s2 and s3 direction i.e., d^2u/ds2ds3 \see OPENCMISS_GlobalDerivativeConstants,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GLOBAL_DERIV_S1_S2_S3 = GLOBAL_DERIV_S1_S2_S3 !<Cross derivative in the s1, s2 and s3 direction i.e., d^3u/ds1ds2ds3 \see OPENCMISS_GlobalDerivativeConstants,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  PUBLIC CMISS_NO_GLOBAL_DERIV,CMISS_GLOBAL_DERIV_S1,CMISS_GLOBAL_DERIV_S2,CMISS_GLOBAL_DERIV_S1_S2, &
    & CMISS_GLOBAL_DERIV_S3,CMISS_GLOBAL_DERIV_S1_S3,CMISS_GLOBAL_DERIV_S2_S3,CMISS_GLOBAL_DERIV_S1_S2_S3

!!==================================================================================================================================
!!
!! CONTROL_LOOP_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_ControlLoopConstants OPENCMISS::ControlLoop::Constants
  !> \brief Control loops constants.
  !>@{
  !> \addtogroup OPENCMISS_ControlLoopIdentifiers OPENCMISS::ControlLoop::Identifiers
  !> \brief The control loop identification parameters.
  !> \see OPENCMISS::ControlLoop,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_CONTROL_LOOP_NODE = CONTROL_LOOP_NODE !<The identifier for a each "leaf" node in a control loop. \see OPENCMISS_ControlLoopIdentifiers,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_ControlLoopOutputTypes OPENCMISS::ControlLoop::OutputTypes
  !> \brief The control loop output types.
  !> \see OPENCMISS::ControlLoop,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_CONTROL_LOOP_NO_OUTPUT = CONTROL_LOOP_NO_OUTPUT !<No output from the control loop. \see OPENCMISS_ControlLoopOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_CONTROL_LOOP_PROGRESS_OUTPUT = CONTROL_LOOP_PROGRESS_OUTPUT !<Progress output from the control loop. \see OPENCMISS_ControlLoopOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_CONTROL_LOOP_TIMING_OUTPUT = CONTROL_LOOP_TIMING_OUTPUT !<Timing output from the control loop. \see OPENCMISS_ControlLoopOutputTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Returns the current time parameters for a time control loop.
  INTERFACE CMISSControlLoopCurrentTimesGet
    MODULE PROCEDURE CMISSControlLoopCurrentTimesGetNumber0
    MODULE PROCEDURE CMISSControlLoopCurrentTimesGetNumber1
    MODULE PROCEDURE CMISSControlLoopCurrentTimesGetObj
  END INTERFACE !CMISSControlLoopCurrentTimesGet

  !>Destroy a control loop.
  INTERFACE CMISSControlLoopDestroy
    MODULE PROCEDURE CMISSControlLoopDestroyNumber0
    MODULE PROCEDURE CMISSControlLoopDestroyNumber1
    MODULE PROCEDURE CMISSControlLoopDestroyObj
  END INTERFACE !CMISSControlLoopDestroy

  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root.
  INTERFACE CMISSControlLoopGet
    MODULE PROCEDURE CMISSControlLoopGetNumber00
    MODULE PROCEDURE CMISSControlLoopGetNumber10
    MODULE PROCEDURE CMISSControlLoopGetNumber01
    MODULE PROCEDURE CMISSControlLoopGetNumber11
    MODULE PROCEDURE CMISSControlLoopGetObj0
    MODULE PROCEDURE CMISSControlLoopGetObj1
  END INTERFACE !CMISSControlLoopGet

  !>Sets/changes the iteration parameters for a fixed control loop. \todo need a get metod
  INTERFACE CMISSControlLoopIterationsSet
    MODULE PROCEDURE CMISSControlLoopIterationsSetNumber0
    MODULE PROCEDURE CMISSControlLoopIterationsSetNumber1
    MODULE PROCEDURE CMISSControlLoopIterationsSetObj
  END INTERFACE !CMISSControlLoopIterationsSet

  !>Returns the label of a control loop.
  INTERFACE CMISSControlLoopLabelGet
    MODULE PROCEDURE CMISSControlLoopLabelGetCNumber0
    MODULE PROCEDURE CMISSControlLoopLabelGetCNumber1
    MODULE PROCEDURE CMISSControlLoopLabelGetCObj
    MODULE PROCEDURE CMISSControlLoopLabelGetVSNumber0
    MODULE PROCEDURE CMISSControlLoopLabelGetVSNumber1
    MODULE PROCEDURE CMISSControlLoopLabelGetVSObj
  END INTERFACE !CMISSControlLoopLabelGet

  !>Sets/changes the label of a control loop.
  INTERFACE CMISSControlLoopLabelSet
    MODULE PROCEDURE CMISSControlLoopLabelSetCNumber0
    MODULE PROCEDURE CMISSControlLoopLabelSetCNumber1
    MODULE PROCEDURE CMISSControlLoopLabelSetCObj
    MODULE PROCEDURE CMISSControlLoopLabelSetVSNumber0
    MODULE PROCEDURE CMISSControlLoopLabelSetVSNumber1
    MODULE PROCEDURE CMISSControlLoopLabelSetVSObj
  END INTERFACE !CMISSControlLoopLabelSet

  !>Sets/changes the maximum iterations for a while control loop. \todo need a get method
  INTERFACE CMISSControlLoopMaximumIterationsSet
    MODULE PROCEDURE CMISSControlLoopMaximumIterationsSetNumber0
    MODULE PROCEDURE CMISSControlLoopMaximumIterationsSetNumber1
    MODULE PROCEDURE CMISSControlLoopMaximumIterationsSetObj
  END INTERFACE !CMISSControlLoopMaximumIterationsSet

  !>Returns the number of sub loops for a control loop.
  INTERFACE CMISSControlLoopNumberOfSubLoopsGet
    MODULE PROCEDURE CMISSControlLoopNumberOfSubLoopsGetNumber0
    MODULE PROCEDURE CMISSControlLoopNumberOfSubLoopsGetNumber1
    MODULE PROCEDURE CMISSControlLoopNumberOfSubLoopsGetObj
  END INTERFACE !CMISSControlLoopNumberOfSubLoopsGet

  !>Sets/changes the number of sub loops for a control loop. \todo is this really a public method???
  INTERFACE CMISSControlLoopNumberOfSubLoopsSet
    MODULE PROCEDURE CMISSControlLoopNumberOfSubLoopsSetNumber0
    MODULE PROCEDURE CMISSControlLoopNumberOfSubLoopsSetNumber1
    MODULE PROCEDURE CMISSControlLoopNumberOfSubLoopsSetObj
  END INTERFACE !CMISSControlLoopNumberOfSubLoopsGet

  !>Sets/changes the output parameters for a time control loop.
  INTERFACE CMISSControlLoopTimeOutputSet
    MODULE PROCEDURE CMISSControlLoopTimeOutputSetNumber0
    MODULE PROCEDURE CMISSControlLoopTimeOutputSetNumber1
    MODULE PROCEDURE CMISSControlLoopTimeOutputSetObj
  END INTERFACE !CMISSControlLoopTimeOutputSet

  !>Returns the output type for a control loop.
  INTERFACE CMISSControlLoopOutputTypeGet
    MODULE PROCEDURE CMISSControlLoopOutputTypeGetNumber0
    MODULE PROCEDURE CMISSControlLoopOutputTypeGetNumber1
    MODULE PROCEDURE CMISSControlLoopOutputTypeGetObj
  END INTERFACE !CMISSControlLoopOutputTypeGet

  !>Sets/changes the output type for a control loop.
  INTERFACE CMISSControlLoopOutputTypeSet
    MODULE PROCEDURE CMISSControlLoopOutputTypeSetNumber0
    MODULE PROCEDURE CMISSControlLoopOutputTypeSetNumber1
    MODULE PROCEDURE CMISSControlLoopOutputTypeSetObj
  END INTERFACE !CMISSControlLoopOutputTypeSet

  !>Sets/changes the input parameters for a time control loop.
  INTERFACE CMISSControlLoopTimeInputSet
    MODULE PROCEDURE CMISSControlLoopTimeInputSetNumber0
    MODULE PROCEDURE CMISSControlLoopTimeInputSetNumber1
    MODULE PROCEDURE CMISSControlLoopTimeInputSetObj
  END INTERFACE !CMISSControlLoopTimeInputSet

  !>Returns the time parameters for a time control loop.
  INTERFACE CMISSControlLoopTimesGet
    MODULE PROCEDURE CMISSControlLoopTimesGetNumber0
    MODULE PROCEDURE CMISSControlLoopTimesGetNumber1
    MODULE PROCEDURE CMISSControlLoopTimesGetObj
  END INTERFACE !CMISSControlLoopTimesGet

  !>Sets/Changes the time parameters for a time control loop.
  INTERFACE CMISSControlLoopTimesSet
    MODULE PROCEDURE CMISSControlLoopTimesSetNumber0
    MODULE PROCEDURE CMISSControlLoopTimesSetNumber1
    MODULE PROCEDURE CMISSControlLoopTimesSetObj
  END INTERFACE !CMISSControlLoopTimesSet

  !>Sets/Changes the loop type for a control loop. \todo Is this really a public       method? \todo need a get method
  INTERFACE CMISSControlLoopTypeSet
    MODULE PROCEDURE CMISSControlLoopTypeSetNumber0
    MODULE PROCEDURE CMISSControlLoopTypeSetNumber1
    MODULE PROCEDURE CMISSControlLoopTypeSetObj
  END INTERFACE !CMISSControlLoopTypeSet

  PUBLIC CMISS_CONTROL_LOOP_NODE

  PUBLIC CMISS_CONTROL_LOOP_NO_OUTPUT,CMISS_CONTROL_LOOP_PROGRESS_OUTPUT,CMISS_CONTROL_LOOP_TIMING_OUTPUT

  PUBLIC CMISSControlLoopCurrentTimesGet

  PUBLIC CMISSControlLoopDestroy

  PUBLIC CMISSControlLoopGet

  PUBLIC CMISSControlLoopIterationsSet

  PUBLIC CMISSControlLoopLabelGet,CMISSControlLoopLabelSet

  PUBLIC CMISSControlLoopMaximumIterationsSet

  PUBLIC CMISSControlLoopNumberOfSubLoopsGet,CMISSControlLoopNumberOfSubLoopsSet

  PUBLIC CMISSControlLoopOutputTypeGet,CMISSControlLoopOutputTypeSet

  PUBLIC CMISSControlLoopTimeOutputSet,CMISSControlLoopTimeInputSet

  PUBLIC CMISSControlLoopTimesGet,CMISSControlLoopTimesSet

  PUBLIC CMISSControlLoopTypeSet


!!==================================================================================================================================
!!
!! COORDINATE_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_CoordinateConstants OPENCMISS::Coordinate::Constants
  !> \brief Coordinate constants.
  !>@{
  !> \addtogroup OPENCMISS_CoordinateSystemTypes OPENCMISS::Coordinate::SystemTypes
  !> \brief Coordinate system type parameters.
  !> \see OPENCMISS::Coordinate,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_COORDINATE_RECTANGULAR_CARTESIAN_TYPE = COORDINATE_RECTANGULAR_CARTESIAN_TYPE !<Rectangular Cartesian coordinate system type \see OPENCMISS_CoordinateSystemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_COORDINATE_CYLINDRICAL_POLAR_TYPE = COORDINATE_CYLINDRICAL_POLAR_TYPE !<Cylindrical polar coordinate system type \see OPENCMISS_CoordinateSystemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_COORDINATE_SPHERICAL_POLAR_TYPE = COORDINATE_SPHERICAL_POLAR_TYPE !<Spherical polar coordinate system type \see OPENCMISS_CoordinateSystemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_COORDINATE_PROLATE_SPHEROIDAL_TYPE = COORDINATE_PROLATE_SPHEROIDAL_TYPE !<Prolate spheroidal coordinate system type \see OPENCMISS_CoordinateSystemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_COORDINATE_OBLATE_SPHEROIDAL_TYPE = COORDINATE_OBLATE_SPHEROIDAL_TYPE !<Oblate spheroidal coordinate system type \see OPENCMISS_CoordinateSystemTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_CoordinateRadialInterpolations OPENCMISS::Coordinate::RadialInterpolations
  !> \brief The type of radial interpolation for polar coordinate systems
  !> \see OPENCMISS::Coordinate,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_COORDINATE_NO_RADIAL_INTERPOLATION_TYPE = COORDINATE_NO_RADIAL_INTERPOLATION_TYPE !<No radial interpolation \see OPENCMISS_CoordinateRadialInterpolations,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_COORDINATE_RADIAL_INTERPOLATION_TYPE = COORDINATE_RADIAL_INTERPOLATION_TYPE !<r radial interpolation \see OPENCMISS_CoordinateRadialInterpolations,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_COORDINATE_RADIAL_SQUARED_INTERPOLATION_TYPE = COORDINATE_RADIAL_SQUARED_INTERPOLATION_TYPE !<r^2 radial interpolation \see OPENCMISS_CoordinateRadialInterpolations,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_COORDINATE_RADIAL_CUBED_INTERPOLATION_TYPE = COORDINATE_RADIAL_CUBED_INTERPOLATION_TYPE !<r^3 radial interpolation \see OPENCMISS_CoordinateRadialInterpolations,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Finishes the creation of a coordinate system. \see OPENCMISS::CMISSCoordinateSystemCreateStart
  INTERFACE CMISSCoordinateSystemCreateFinish
    MODULE PROCEDURE CMISSCoordinateSystemCreateFinishNumber
    MODULE PROCEDURE CMISSCoordinateSystemCreateFinishObj
  END INTERFACE !CMISSCoordinateSystemCreateFinish

  !>Starts the creation of a coordinate system. \see OPENCMISS::CMISSCoordinateSystemCreateFinish
  INTERFACE CMISSCoordinateSystemCreateStart
    MODULE PROCEDURE CMISSCoordinateSystemCreateStartNumber
    MODULE PROCEDURE CMISSCoordinateSystemCreateStartObj
  END INTERFACE !CMISSCoordinateSystemCreateStart

  !>Destorys a coordinate system.
  INTERFACE CMISSCoordinateSystemDestroy
    MODULE PROCEDURE CMISSCoordinateSystemDestroyNumber
    MODULE PROCEDURE CMISSCoordinateSystemDestroyObj
  END INTERFACE !CMISSCoordinateSystemDestroy

  !>Returns the coordinate system dimension. \todo user number method \todo fix pointers
  INTERFACE CMISSCoordinateSystemDimensionGet
    MODULE PROCEDURE CMISSCoordinateSystemDimensionGetNumber
    MODULE PROCEDURE CMISSCoordinateSystemDimensionGetObj
  END INTERFACE !CMISSCoordinateSystemDimensionGet

  !>Sets/changes the coordinate system dimension. \todo fix pointers
  INTERFACE CMISSCoordinateSystemDimensionSet
    MODULE PROCEDURE CMISSCoordinateSystemDimensionSetNumber
    MODULE PROCEDURE CMISSCoordinateSystemDimensionSetObj
  END INTERFACE !CMISSCoordinateSystemDimensionSet

  !>Returns the coordinate system focus. \todo user number method \todo fix pointers
  INTERFACE CMISSCoordinateSystemFocusGet
    MODULE PROCEDURE CMISSCoordinateSystemFocusGetNumber
    MODULE PROCEDURE CMISSCoordinateSystemFocusGetObj
  END INTERFACE !CMISSCoordinateSystemFocusGet

  !>Sets/changes the coordinate system focus. \todo user number method \todo fix pointers
  INTERFACE CMISSCoordinateSystemFocusSet
    MODULE PROCEDURE CMISSCoordinateSystemFocusSetNumber
    MODULE PROCEDURE CMISSCoordinateSystemFocusSetObj
  END INTERFACE !CMISSCoordinateSystemFocusSet

  !>Returns the coordinate system radial interpolation type. \todo user number method \todo fix pointers
  INTERFACE CMISSCoordinateSystemRadialInterpolationGet
    MODULE PROCEDURE CMISSCoordinateSystemRadialInterpolationGetNumber
    MODULE PROCEDURE CMISSCoordinateSystemRadialInterpolationGetObj
  END INTERFACE !CMISSCoordinateSystemRadialInterpolationGet

  !>Sets/changes the coordinate system radial interpolation type. \todo user number method \todo fix pointers
  INTERFACE CMISSCoordinateSystemRadialInterpolationSet
    MODULE PROCEDURE CMISSCoordinateSystemRadialInterpolationSetNumber
    MODULE PROCEDURE CMISSCoordinateSystemRadialInterpolationSetObj
  END INTERFACE !CMISSCoordinateSystemRadialInterpolationSet

  !>Returns the coordinate system type. \todo user number method \todo fix pointers
  INTERFACE CMISSCoordinateSystemTypeGet
    MODULE PROCEDURE CMISSCoordinateSystemTypeGetNumber
    MODULE PROCEDURE CMISSCoordinateSystemTypeGetObj
  END INTERFACE !CMISSCoordinateSystemTypeGet

  !>Sets/changes the coordinate system type. \todo user number method \todo fix pointers
  INTERFACE CMISSCoordinateSystemTypeSet
    MODULE PROCEDURE CMISSCoordinateSystemTypeSetNumber
    MODULE PROCEDURE CMISSCoordinateSystemTypeSetObj
  END INTERFACE !CMISSCoordinateSystemTypeSet

  !>Returns the coordinate system orign.
  INTERFACE CMISSCoordinateSystemOriginGet
    MODULE PROCEDURE CMISSCoordinateSystemOriginGetNumber
    MODULE PROCEDURE CMISSCoordinateSystemOriginGetObj
  END INTERFACE !CMISSCoordinateSystemOriginGet

  !>Sets/changes the coordinate system orign.
  INTERFACE CMISSCoordinateSystemOriginSet
    MODULE PROCEDURE CMISSCoordinateSystemOriginSetNumber
    MODULE PROCEDURE CMISSCoordinateSystemOriginSetObj
  END INTERFACE !CMISSCoordinateSystemOriginSet

  !>Returns the coordinate system orientation.
  INTERFACE CMISSCoordinateSystemOrientationGet
    MODULE PROCEDURE CMISSCoordinateSystemOrientationGetNumber
    MODULE PROCEDURE CMISSCoordinateSystemOrientationGetObj
  END INTERFACE !CMISSCoordinateSystemOrientationGet

  !>Sets/changes the coordinate system orientation.
  INTERFACE CMISSCoordinateSystemOrientationSet
    MODULE PROCEDURE CMISSCoordinateSystemOrientationSetNumber
    MODULE PROCEDURE CMISSCoordinateSystemOrientationSetObj
  END INTERFACE !CMISSCoordinateSystemOrientationSet

  PUBLIC CMISS_COORDINATE_RECTANGULAR_CARTESIAN_TYPE,CMISS_COORDINATE_CYLINDRICAL_POLAR_TYPE, &
    & CMISS_COORDINATE_SPHERICAL_POLAR_TYPE, &
    & CMISS_COORDINATE_PROLATE_SPHEROIDAL_TYPE,CMISS_COORDINATE_OBLATE_SPHEROIDAL_TYPE

  PUBLIC CMISS_COORDINATE_NO_RADIAL_INTERPOLATION_TYPE,CMISS_COORDINATE_RADIAL_INTERPOLATION_TYPE, &
    & CMISS_COORDINATE_RADIAL_SQUARED_INTERPOLATION_TYPE,CMISS_COORDINATE_RADIAL_CUBED_INTERPOLATION_TYPE

  PUBLIC CMISSCoordinateSystemCreateFinish,CMISSCoordinateSystemCreateStart

  PUBLIC CMISSCoordinateSystemDestroy

  PUBLIC CMISSCoordinateSystemDimensionGet,CMISSCoordinateSystemDimensionSet

  PUBLIC CMISSCoordinateSystemFocusGet,CMISSCoordinateSystemFocusSet

  PUBLIC CMISSCoordinateSystemRadialInterpolationGet,CMISSCoordinateSystemRadialInterpolationSet

  PUBLIC CMISSCoordinateSystemTypeGet,CMISSCoordinateSystemTypeSet

  PUBLIC CMISSCoordinateSystemOriginGet,CMISSCoordinateSystemOriginSet

  PUBLIC CMISSCoordinateSystemOrientationGet,CMISSCoordinateSystemOrientationSet

!!==================================================================================================================================
!!
!! DATA_POINT_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Finishes the process of creating data points in a region. \see OPENCMISS::CMISSDataPointsCreateStart
  INTERFACE CMISSDataPointsCreateFinish
    MODULE PROCEDURE CMISSDataPointsCreateFinishNumber
    MODULE PROCEDURE CMISSDataPointsCreateFinishObj
  END INTERFACE !CMISSDataPointsCreateFinish

  !>Starts the process of creating data points in a region. \see OPENCMISS::CMISSDataPointsCreateFinish
  INTERFACE CMISSDataPointsCreateStart
    MODULE PROCEDURE CMISSDataPointsCreateStartNumber
    MODULE PROCEDURE CMISSDataPointsCreateStartObj
    MODULE PROCEDURE CMISSDataPointsCreateStartInterfaceObj
  END INTERFACE !CMISSDataPointsCreateFinish

  !>Destroys data points.
  INTERFACE CMISSDataPointsDestroy
    MODULE PROCEDURE CMISSDataPointsDestroyNumber
    MODULE PROCEDURE CMISSDataPointsDestroyObj
  END INTERFACE !CMISSDataPointsDestroy

  !>Returns the number of data points
  INTERFACE CMISSDataPointsNumberOfDataPointsGet
    MODULE PROCEDURE CMISSDataPointsNumberOfDataPointsGetNumber
    MODULE PROCEDURE CMISSDataPointsNumberOfDataPointsGetObj
  END INTERFACE !CMISSDataPointsNumberOfDataPointsGet

  !>Returns the label for a data point identified by a given global number. \todo should this be a user number?
  INTERFACE CMISSDataPointsLabelGet
    MODULE PROCEDURE CMISSDataPointsLabelGetCNumber
    MODULE PROCEDURE CMISSDataPointsLabelGetCObj
    MODULE PROCEDURE CMISSDataPointsLabelGetVSNumber
    MODULE PROCEDURE CMISSDataPointsLabelGetVSObj
  END INTERFACE !CMISSDataPointsLabelGet

  !>Sets/changes the label for a data point identified by a given global number. \todo should this be a user number?
  INTERFACE CMISSDataPointsLabelSet
    MODULE PROCEDURE CMISSDataPointsLabelSetCNumber
    MODULE PROCEDURE CMISSDataPointsLabelSetCObj
    MODULE PROCEDURE CMISSDataPointsLabelSetVSNumber
    MODULE PROCEDURE CMISSDataPointsLabelSetVSObj
  END INTERFACE !CMISSDataPointsLabelSet

  !>Returns the projection distance for a data point identified by a given global number.
  INTERFACE CMISSDataPointsProjectionDistanceGet
    MODULE PROCEDURE CMISSDataPointsProjectionDistanceGetNumber
    MODULE PROCEDURE CMISSDataPointsProjectionDistanceGetObj
  END INTERFACE !CMISSDataPointsProjectionDistanceGet

  !>Returns the projection element number for a data point identified by a given global number.
  INTERFACE CMISSDataPointsProjectionElementNumberGet
    MODULE PROCEDURE CMISSDataPointsProjectionElementNumberGetNumber
    MODULE PROCEDURE CMISSDataPointsProjectionElementNumberGetObj
  END INTERFACE !CMISSDataPointsProjectionElementNumberGet

  !>Returns the projection element face number for a data point identified by a given global number.
  INTERFACE CMISSDataPointsProjectionElementFaceNumberGet
    MODULE PROCEDURE CMISSDataPointsProjectionElementFaceNumberGetNumber
    MODULE PROCEDURE CMISSDataPointsProjectionElementFaceNumberGetObj
  END INTERFACE !CMISSDataPointsProjectionElementFaceNumberGet

  !>Returns the projection element line number for a data point identified by a given global number.
  INTERFACE CMISSDataPointsProjectionElementLineNumberGet
    MODULE PROCEDURE CMISSDataPointsProjectionElementLineNumberGetNumber
    MODULE PROCEDURE CMISSDataPointsProjectionElementLineNumberGetObj
  END INTERFACE !CMISSDataPointsProjectionElementLineNumberGet

  !>Returns the projection exit tag for a data point identified by a given global number.
  INTERFACE CMISSDataPointsProjectionExitTagGet
    MODULE PROCEDURE CMISSDataPointsProjectionExitTagGetNumber
    MODULE PROCEDURE CMISSDataPointsProjectionExitTagGetObj
  END INTERFACE !CMISSDataPointsProjectionExitTagGet

  !>Returns the projection xi for a data point identified by a given global number.
  INTERFACE CMISSDataPointsProjectionXiGet
    MODULE PROCEDURE CMISSDataPointsProjectionXiGetNumber
    MODULE PROCEDURE CMISSDataPointsProjectionXiGetObj
  END INTERFACE !CMISSDataPointsProjectionXiGet


  !>Returns the user number for a data point identified by a given global number.
  INTERFACE CMISSDataPointsUserNumberGet
    MODULE PROCEDURE CMISSDataPointsUserNumberGetNumber
    MODULE PROCEDURE CMISSDataPointsUserNumberGetObj
  END INTERFACE !CMISSDataPointsUserNumberGet

  !>Sets/changes the user number for a data point identified by a given global number.
  INTERFACE CMISSDataPointsUserNumberSet
    MODULE PROCEDURE CMISSDataPointsUserNumberSetNumber
    MODULE PROCEDURE CMISSDataPointsUserNumberSetObj
  END INTERFACE !CMISSDataPointsUserNumberSet

  !>Returns the values for a data point identified by a given global number. \todo should this be a user number?
  INTERFACE CMISSDataPointsValuesGet
    MODULE PROCEDURE CMISSDataPointsValuesGetNumber
    MODULE PROCEDURE CMISSDataPointsValuesGetObj
  END INTERFACE !CMISSDataPointsValuesGet

  !>Sets/changes the values for a data point identified by a given global number. \todo should this be a user number?
  INTERFACE CMISSDataPointsValuesSet
    MODULE PROCEDURE CMISSDataPointsValuesSetNumber
    MODULE PROCEDURE CMISSDataPointsValuesSetObj
  END INTERFACE !CMISSDataPointsValuesSet

  !>Returns the weights for a data point identified by a given global number. \todo should this be a user number?
  INTERFACE CMISSDataPointsWeightsGet
    MODULE PROCEDURE CMISSDataPointsWeightsGetNumber
    MODULE PROCEDURE CMISSDataPointsWeightsGetObj
  END INTERFACE !CMISSDataPointsWeightsGet

  !>Sets/changes the weights for a data point identified by a given global number. \todo should this be a user number?
  INTERFACE CMISSDataPointsWeightsSet
    MODULE PROCEDURE CMISSDataPointsWeightsSetNumber
    MODULE PROCEDURE CMISSDataPointsWeightsSetObj
  END INTERFACE !CMISSDataPointsWeightsSet

  PUBLIC CMISSDataPointsCreateFinish,CMISSDataPointsCreateStart

  PUBLIC CMISSDataPointsDestroy

  PUBLIC CMISSDataPointsNumberOfDataPointsGet

  PUBLIC CMISSDataPointsLabelGet,CMISSDataPointsLabelSet

  PUBLIC CMISSDataPointsProjectionDistanceGet,CMISSDataPointsProjectionElementNumberGet

  PUBLIC CMISSDataPointsProjectionElementFaceNumberGet,CMISSDataPointsProjectionElementLineNumberGet

  PUBLIC CMISSDataPointsProjectionExitTagGet,CMISSDataPointsProjectionXiGet

  PUBLIC CMISSDataPointsUserNumberGet,CMISSDataPointsUserNumberSet

  PUBLIC CMISSDataPointsValuesGet,CMISSDataPointsValuesSet

  PUBLIC CMISSDataPointsWeightsGet,CMISSDataPointsWeightsSet

!!==================================================================================================================================
!!
!! DATA_PROJECTION_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_DataProjectionConstants OPENCMISS::DataProjection::Constants
  !> \brief DataProjection  constants.
  !>@{
  !> \addtogroup OPENCMISS_DataProjectionProjectionTypes OPENCMISS::DataProjection::ProjectionTypes
  !> \brief Equations projection types
  !> \see OPENCMISS::DataProjection,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_DATA_PROJECTION_BOUNDARY_LINES_PROJECTION_TYPE = DATA_PROJECTION_BOUNDARY_LINES_PROJECTION_TYPE!<The boundary line projection type for data projection, only projects to boundary lines of the mesh. \see OPENCMISS_DataProjectionProjectionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_DATA_PROJECTION_BOUNDARY_FACES_PROJECTION_TYPE = DATA_PROJECTION_BOUNDARY_FACES_PROJECTION_TYPE !<The boundary face projection type for data projection, only projects to boundary faces of the mesh. \see OPENCMISS_DataProjectionProjectionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_DATA_PROJECTION_ALL_ELEMENTS_PROJECTION_TYPE = DATA_PROJECTION_ALL_ELEMENTS_PROJECTION_TYPE !<The element projection type for data projection, projects to all elements in mesh. \see OPENCMISS_DataProjectionProjectionTypes,OPENCMISS

  !Module types

  !Module variables

  !Interfaces

  !>Returns the absolute tolerance for a data projection.
  INTERFACE CMISSDataProjectionAbsoluteToleranceGet
    MODULE PROCEDURE CMISSDataProjectionAbsoluteToleranceGetNumber
    MODULE PROCEDURE CMISSDataProjectionAbsoluteToleranceGetObj
  END INTERFACE !CMISSDataProjectionWeightsGet

  !>Sets/changes the absolute tolerance for a data projection.
  INTERFACE CMISSDataProjectionAbsoluteToleranceSet
    MODULE PROCEDURE CMISSDataProjectionAbsoluteToleranceSetNumber
    MODULE PROCEDURE CMISSDataProjectionAbsoluteToleranceSetObj
  END INTERFACE !CMISSDataProjectionWeightsSet

  !>Finishes the creation of a new data projection. \see OPENCMISS::CMISSDataProjectionCreateStart
  INTERFACE CMISSDataProjectionCreateFinish
    MODULE PROCEDURE CMISSDataProjectionCreateFinishNumber
    MODULE PROCEDURE CMISSDataProjectionCreateFinishObj
  END INTERFACE !CMISSDataProjectionCreateFinish

  !>Starts the creation of a new data projection. \see OPENCMISS::CMISSDataProjectionCreateFinish
  INTERFACE CMISSDataProjectionCreateStart
    MODULE PROCEDURE CMISSDataProjectionCreateStartNumber
    MODULE PROCEDURE CMISSDataProjectionCreateStartObj
  END INTERFACE !CMISSDataProjectionCreateStart

  !>Destroy a data projection.
  INTERFACE CMISSDataProjectionDestroy
    MODULE PROCEDURE CMISSDataProjectionDestroyNumber
    MODULE PROCEDURE CMISSDataProjectionDestroyObj
  END INTERFACE !CMISSDataProjectionDestroy

  !>Starts the evluation of data projection.
  INTERFACE CMISSDataProjectionEvaluate
    MODULE PROCEDURE CMISSDataProjectionEvaluateNumber
    MODULE PROCEDURE CMISSDataProjectionEvaluateObj
  END INTERFACE !CMISSDataProjectionEvaluate

  !>Returns the maximum iteration update for a data projection.
  INTERFACE CMISSDataProjectionMaximumIterationUpdateGet
    MODULE PROCEDURE CMISSDataProjectionMaximumIterationUpdateGetNumber
    MODULE PROCEDURE CMISSDataProjectionMaximumIterationUpdateGetObj
  END INTERFACE !CMISSDataProjectionMaximumIterationUpdateGet

  !>Sets/changes the maximum iteration update for a data projection.
  INTERFACE CMISSDataProjectionMaximumIterationUpdateSet
    MODULE PROCEDURE CMISSDataProjectionMaximumIterationUpdateSetNumber
    MODULE PROCEDURE CMISSDataProjectionMaximumIterationUpdateSetObj
  END INTERFACE !CMISSDataProjectionMaximumIterationUpdateSet

  !>Returns the maximum number of iterations for a data projection.
  INTERFACE CMISSDataProjectionMaximumNumberOfIterationsGet
    MODULE PROCEDURE CMISSDataProjectionMaximumNumberOfIterationsGetNumber
    MODULE PROCEDURE CMISSDataProjectionMaximumNumberOfIterationsGetObj
  END INTERFACE !CMISSDataProjectionMaximumNumberOfIterationsGet

  !>Sets/changes the maximum number of iterations for a data projection.
  INTERFACE CMISSDataProjectionMaximumNumberOfIterationsSet
    MODULE PROCEDURE CMISSDataProjectionMaximumNumberOfIterationsSetNumber
    MODULE PROCEDURE CMISSDataProjectionMaximumNumberOfIterationsSetObj
  END INTERFACE !CMISSDataProjectionMaximumNumberOfIterationsSet

  !>Returns the number of closest elements for a data projection.
  INTERFACE CMISSDataProjectionNumberOfClosestElementsGet
    MODULE PROCEDURE CMISSDataProjectionNumberOfClosestElementsGetNumber
    MODULE PROCEDURE CMISSDataProjectionNumberOfClosestElementsGetObj
  END INTERFACE !CMISSDataProjectionNumberOfClosestElementsGet

  !>Sets/changes the number of closest elements for a data projection.
  INTERFACE CMISSDataProjectionNumberOfClosestElementsSet
    MODULE PROCEDURE CMISSDataProjectionNumberOfClosestElementsSetNumber
    MODULE PROCEDURE CMISSDataProjectionNumberOfClosestElementsSetObj
  END INTERFACE !CMISSDataProjectionNumberOfClosestElementsSet

  !>Returns the projection type for a data projection.
  INTERFACE CMISSDataProjectionProjectionTypeGet
    MODULE PROCEDURE CMISSDataProjectionProjectionTypeGetNumber
    MODULE PROCEDURE CMISSDataProjectionProjectionTypeGetObj
  END INTERFACE !CMISSDataProjectionProjectionTypeGet

  !>Sets/changes the projection type for a data projection.
  INTERFACE CMISSDataProjectionProjectionTypeSet
    MODULE PROCEDURE CMISSDataProjectionProjectionTypeSetNumber
    MODULE PROCEDURE CMISSDataProjectionProjectionTypeSetObj
  END INTERFACE !CMISSDataProjectionProjectionTypeSet

  !>Returns the relative tolerance for a data projection.
  INTERFACE CMISSDataProjectionRelativeToleranceGet
    MODULE PROCEDURE CMISSDataProjectionRelativeToleranceGetNumber
    MODULE PROCEDURE CMISSDataProjectionRelativeToleranceGetObj
  END INTERFACE !CMISSDataProjectionRelativeToleranceGet

  !>Sets/changes the relative tolerance for a data projection.
  INTERFACE CMISSDataProjectionRelativeToleranceSet
    MODULE PROCEDURE CMISSDataProjectionRelativeToleranceSetNumber
    MODULE PROCEDURE CMISSDataProjectionRelativeToleranceSetObj
  END INTERFACE !CMISSDataProjectionRelativeToleranceSet

  !>Returns the starting xi for a data projection.
  INTERFACE CMISSDataProjectionStartingXiGet
    MODULE PROCEDURE CMISSDataProjectionStartingXiGetNumber
    MODULE PROCEDURE CMISSDataProjectionStartingXiGetObj
  END INTERFACE !CMISSDataProjectionStartingXiGet

  !>Sets/changes the starting xi for a data projection.
  INTERFACE CMISSDataProjectionStartingXiSet
    MODULE PROCEDURE CMISSDataProjectionStartingXiSetNumber
    MODULE PROCEDURE CMISSDataProjectionStartingXiSetObj
  END INTERFACE !CMISSDataProjectionStartingXiSet

  PUBLIC CMISS_DATA_PROJECTION_BOUNDARY_LINES_PROJECTION_TYPE,CMISS_DATA_PROJECTION_BOUNDARY_FACES_PROJECTION_TYPE

  PUBLIC CMISS_DATA_PROJECTION_ALL_ELEMENTS_PROJECTION_TYPE

  PUBLIC CMISSDataProjectionAbsoluteToleranceGet,CMISSDataProjectionAbsoluteToleranceSet

  PUBLIC CMISSDataProjectionCreateFinish,CMISSDataProjectionCreateStart

  PUBLIC CMISSDataProjectionDestroy

  PUBLIC CMISSDataProjectionEvaluate

  PUBLIC CMISSDataProjectionMaximumIterationUpdateGet,CMISSDataProjectionMaximumIterationUpdateSet

  PUBLIC CMISSDataProjectionMaximumNumberOfIterationsGet,CMISSDataProjectionMaximumNumberOfIterationsSet

  PUBLIC CMISSDataProjectionNumberOfClosestElementsGet,CMISSDataProjectionNumberOfClosestElementsSet

  PUBLIC CMISSDataProjectionProjectionTypeGet,CMISSDataProjectionProjectionTypeSet

  PUBLIC CMISSDataProjectionRelativeToleranceGet,CMISSDataProjectionRelativeToleranceSet

  PUBLIC CMISSDataProjectionStartingXiGet,CMISSDataProjectionStartingXiSet

!!==================================================================================================================================
!!
!! EQUATIONS_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_EquationsConstants OPENCMISS::Equations::Constants
  !> \brief Equations  constants.
  !>@{
  !> \addtogroup OPENCMISS_EquationsOutputTypes OPENCMISS::Equations::OutputTypes
  !> \brief Equations output types
  !> \see OPENCMISS::Equations,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_NO_OUTPUT = EQUATIONS_NO_OUTPUT!<No output from the equations \see OPENCMISS_EquationsOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_TIMING_OUTPUT = EQUATIONS_TIMING_OUTPUT !<Timing information output. \see OPENCMISS_EquationsOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_MATRIX_OUTPUT = EQUATIONS_MATRIX_OUTPUT !<All below and equation matrices output. \see OPENCMISS_EquationsOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_ELEMENT_MATRIX_OUTPUT = EQUATIONS_ELEMENT_MATRIX_OUTPUT !<All below and element matrices output. \see OPENCMISS_EquationsOutputTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_EquationsSparsityTypes OPENCMISS::Equations::SparsityTypes
  !> \brief Equations sparsity types
  !> \see OPENCMISS::Equations,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SPARSE_MATRICES = EQUATIONS_SPARSE_MATRICES !<Use sparse matrices for the equations. \see OPENCMISS_EquationsSparsityTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_FULL_MATRICES = EQUATIONS_FULL_MATRICES !<Use fully populated matrices for the equations. \see OPENCMISS_EquationsSparsityTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_EquationsLumpingTypes OPENCMISS::Equations::LumpingTypes
  !> \brief Equations lumping types
  !> \see OPENCMISS::Equations,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_UNLUMPED_MATRICES = EQUATIONS_UNLUMPED_MATRICES !<The equations matrices are not lumped. \see OPENCMISS_EquationsLumpingTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_LUMPED_MATRICES = EQUATIONS_LUMPED_MATRICES !<The equations matrices are "mass" lumped. \see OPENCMISS_EquationsLumpingTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_EquationsLinearityTypes OPENCMISS::Equations::LinearityTypes
  !> \brief The equations linearity types
  !> \see OPENCMISS::Equations,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_LINEAR = EQUATIONS_LINEAR !<The equations are linear. \see OPENCMISS_EquationsLinearityTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_NONLINEAR = EQUATIONS_NONLINEAR !<The equations are non-linear. \see \see OPENCMISS_EquationsLinearityTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_NONLINEAR_BCS = EQUATIONS_NONLINEAR_BCS !<The equations have non-linear boundary conditions. \see \see OPENCMISS_EquationsLinearityTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_EquationsTimeDepedenceTypes OPENCMISS::Equations::TimeDepedenceTypes
  !> \brief The equations time dependence types
  !> \see OPENCMISS::Equations,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_STATIC = EQUATIONS_STATIC !<The equations are static and have no time dependence. \see OPENCMISS_EquationsTimeDepedenceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_QUASISTATIC = EQUATIONS_QUASISTATIC !<The equations are quasi-static. \see OPENCMISS_EquationsTimeDepedenceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_FIRST_ORDER_DYNAMIC = EQUATIONS_FIRST_ORDER_DYNAMIC !<The equations are first order dynamic. \see OPENCMISS_EquationsTimeDepedenceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SECOND_ORDER_DYNAMIC = EQUATIONS_SECOND_ORDER_DYNAMIC !<The equations are a second order dynamic. \see OPENCMISS_EquationsTimeDepedenceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_TIME_STEPPING = EQUATIONS_TIME_STEPPING !<The equations are for time stepping. \see OPENCMISS_EquationsTimeDepedenceTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Destroys equations for an equations set.
  INTERFACE CMISSEquationsDestroy
    MODULE PROCEDURE CMISSEquationsDestroyNumber
    MODULE PROCEDURE CMISSEquationsDestroyObj
  END INTERFACE !CMISSEquationsDestroy

  !>Gets the linearity type for equations.
  INTERFACE CMISSEquationsLinearityTypeGet
    MODULE PROCEDURE CMISSEquationsLinearityTypeGetNumber
    MODULE PROCEDURE CMISSEquationsLinearityTypeGetObj
  END INTERFACE !CMISSEquationsLinearityTypeGet

  !>Gets the lumping type for equations.
  INTERFACE CMISSEquationsLumpingTypeGet
    MODULE PROCEDURE CMISSEquationsLumpingTypeGetNumber
    MODULE PROCEDURE CMISSEquationsLumpingTypeGetObj
  END INTERFACE !CMISSEquationsLumpingTypeGet

  !>Sets/changes the lumping type for equations.
  INTERFACE CMISSEquationsLumpingTypeSet
    MODULE PROCEDURE CMISSEquationsLumpingTypeSetNumber
    MODULE PROCEDURE CMISSEquationsLumpingTypeSetObj
  END INTERFACE !CMISSEquationsLumpingTypeSet

  !>Gets the output type for equations.
  INTERFACE CMISSEquationsOutputTypeGet
    MODULE PROCEDURE CMISSEquationsOutputTypeGetNumber
    MODULE PROCEDURE CMISSEquationsOutputTypeGetObj
  END INTERFACE !CMISSEquationsOutputTypeGet

  !>Sets/changes the output type for equations.
  INTERFACE CMISSEquationsOutputTypeSet
    MODULE PROCEDURE CMISSEquationsOutputTypeSetNumber
    MODULE PROCEDURE CMISSEquationsOutputTypeSetObj
  END INTERFACE !CMISSEquationsOutputTypeSet

 !>Gets the sparsity type for equations.
  INTERFACE CMISSEquationsSparsityTypeGet
    MODULE PROCEDURE CMISSEquationsSparsityTypeGetNumber
    MODULE PROCEDURE CMISSEquationsSparsityTypeGetObj
  END INTERFACE !CMISSEquationsSparsityTypeGet

  !>Sets/changes the sparsity type for equations.
  INTERFACE CMISSEquationsSparsityTypeSet
    MODULE PROCEDURE CMISSEquationsSparsityTypeSetNumber
    MODULE PROCEDURE CMISSEquationsSparsityTypeSetObj
  END INTERFACE !CMISSEquationsSparsityTypeSet

  !>Gets the time dependence type for equations.
  INTERFACE CMISSEquationsTimeDependenceTypeGet
    MODULE PROCEDURE CMISSEquationsTimeDependenceTypeGetNumber
    MODULE PROCEDURE CMISSEquationsTimeDependenceTypeGetObj
  END INTERFACE !CMISSEquationsTimeDependenceTypeGet

 PUBLIC CMISS_EQUATIONS_NO_OUTPUT,CMISS_EQUATIONS_TIMING_OUTPUT,CMISS_EQUATIONS_MATRIX_OUTPUT,CMISS_EQUATIONS_ELEMENT_MATRIX_OUTPUT

  PUBLIC CMISS_EQUATIONS_SPARSE_MATRICES,CMISS_EQUATIONS_FULL_MATRICES

  PUBLIC CMISS_EQUATIONS_UNLUMPED_MATRICES,CMISS_EQUATIONS_LUMPED_MATRICES

  PUBLIC CMISS_EQUATIONS_LINEAR,CMISS_EQUATIONS_NONLINEAR,CMISS_EQUATIONS_NONLINEAR_BCS

  PUBLIC CMISS_EQUATIONS_STATIC,CMISS_EQUATIONS_QUASISTATIC,CMISS_EQUATIONS_FIRST_ORDER_DYNAMIC, &
    & CMISS_EQUATIONS_SECOND_ORDER_DYNAMIC, &
    & CMISS_EQUATIONS_TIME_STEPPING

  PUBLIC CMISSEquationsDestroy

  PUBLIC CMISSEquationsLinearityTypeGet

  PUBLIC CMISSEquationsLumpingTypeGet,CMISSEquationsLumpingTypeSet

  PUBLIC CMISSEquationsOutputTypeGet,CMISSEquationsOutputTypeSet

  PUBLIC CMISSEquationsSparsityTypeGet,CMISSEquationsSparsityTypeSet

  PUBLIC CMISSEquationsTimeDependenceTypeGet

!!==================================================================================================================================
!!
!! EQUATIONS_SET_CONSTANTS
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_EquationsSetConstants OPENCMISS::EquationsSet::Constants
  !> \brief Equations set constants.
  !>@{
  !> \addtogroup OPENCMISS_EquationsSetClasses OPENCMISS::EquationsSet::Classes
  !> \brief Equations set classes.
  !> \see OPENCMISS::EquationsSet,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NO_CLASS = EQUATIONS_SET_NO_CLASS !<No equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ELASTICITY_CLASS = EQUATIONS_SET_ELASTICITY_CLASS !<Elasticity equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_FLUID_MECHANICS_CLASS = EQUATIONS_SET_FLUID_MECHANICS_CLASS !<Fluid Mechanics equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ELECTROMAGNETICS_CLASS = EQUATIONS_SET_ELECTROMAGNETICS_CLASS !<Electromagnetics equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_CLASSICAL_FIELD_CLASS = EQUATIONS_SET_CLASSICAL_FIELD_CLASS !<Classical Field equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_BIOELECTRICS_CLASS = EQUATIONS_SET_BIOELECTRICS_CLASS !<Bioelectrics equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MODAL_CLASS = EQUATIONS_SET_MODAL_CLASS !<Modal equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_FITTING_CLASS = EQUATIONS_SET_FITTING_CLASS !<Fitting equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_OPTIMISATION_CLASS = EQUATIONS_SET_OPTIMISATION_CLASS !<Optimisation equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MULTI_PHYSICS_CLASS = EQUATIONS_SET_MULTI_PHYSICS_CLASS !<Multi Physics equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_EquationsSetTypes OPENCMISS::EquationsSet::Types
  !> \brief Equations set Types.
  !> \see OPENCMISS::EquationsSet,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NO_TYPE = EQUATIONS_SET_NO_TYPE !<No equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_ELASTICITY_TYPE = EQUATIONS_SET_LINEAR_ELASTICITY_TYPE !<Linear elasticity equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_FINITE_ELASTICITY_TYPE = EQUATIONS_SET_FINITE_ELASTICITY_TYPE !<Finite elasticity equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STOKES_EQUATION_TYPE = EQUATIONS_SET_STOKES_EQUATION_TYPE !<Stokes equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TYPE = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TYPE !<Navier-Stokes equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DARCY_EQUATION_TYPE = EQUATIONS_SET_DARCY_EQUATION_TYPE !<Darcy equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DARCY_PRESSURE_EQUATION_TYPE = EQUATIONS_SET_DARCY_PRESSURE_EQUATION_TYPE !<Darcy pressure equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_POISEUILLE_EQUATION_TYPE = EQUATIONS_SET_POISEUILLE_EQUATION_TYPE !<Poiseuille equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_BURGERS_EQUATION_TYPE = EQUATIONS_SET_BURGERS_EQUATION_TYPE !<Burgers equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ELECTROSTATIC_TYPE = EQUATIONS_SET_ELECTROSTATIC_TYPE !<Electrostatic equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MAGNETOSTATIC_TYPE = EQUATIONS_SET_MAGNETOSTATIC_TYPE !<Magnetostatic equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MAXWELLS_EQUATIONS_TYPE = EQUATIONS_SET_MAXWELLS_EQUATIONS_TYPE !<Maxwells equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LAPLACE_EQUATION_TYPE = EQUATIONS_SET_LAPLACE_EQUATION_TYPE !<Laplace equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_POISSON_EQUATION_TYPE = EQUATIONS_SET_POISSON_EQUATION_TYPE !<Poisson equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_HELMHOLTZ_EQUATION_TYPE = EQUATIONS_SET_HELMHOLTZ_EQUATION_TYPE !<Helmholtz equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_WAVE_EQUATION_TYPE = EQUATIONS_SET_WAVE_EQUATION_TYPE !<Wave equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DIFFUSION_EQUATION_TYPE = EQUATIONS_SET_DIFFUSION_EQUATION_TYPE !<Diffusion equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ADVECTION_DIFFUSION_EQUATION_TYPE = &
    & EQUATIONS_SET_ADVECTION_DIFFUSION_EQUATION_TYPE !<Advection-Diffusion equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_REACTION_DIFFUSION_EQUATION_TYPE = EQUATIONS_SET_REACTION_DIFFUSION_EQUATION_TYPE !<Reaction-Diffusion equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_BIHARMONIC_EQUATION_TYPE = EQUATIONS_SET_BIHARMONIC_EQUATION_TYPE !<Biharmonic equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MONODOMAIN_EQUATION_TYPE = EQUATIONS_SET_MONODOMAIN_EQUATION_TYPE !<Monodomain equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_BIDOMAIN_EQUATION_TYPE = EQUATIONS_SET_BIDOMAIN_EQUATION_TYPE !<Bidomain equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_ELASTIC_MODAL_TYPE = EQUATIONS_SET_LINEAR_ELASTIC_MODAL_TYPE !<Linear elasticity modal equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DATA_FITTING_EQUATION_TYPE = EQUATIONS_SET_DATA_FITTING_EQUATION_TYPE !<Galerkin projection equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_FINITE_ELASTICITY_DARCY_TYPE = EQUATIONS_SET_FINITE_ELASTICITY_DARCY_TYPE !<Finite Elasticity Darcy equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_FINITE_ELASTICITY_STOKES_TYPE = EQUATIONS_SET_FINITE_ELASTICITY_STOKES_TYPE !<Finite Elasticity Stokes equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_FINITE_ELASTICITY_NAVIER_STOKES_TYPE = &
    & EQUATIONS_SET_FINITE_ELASTICITY_NAVIER_STOKES_TYPE !<Finite Elasticity Navier Stokes equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DIFFUSION_DIFFUSION_TYPE = EQUATIONS_SET_DIFFUSION_DIFFUSION_TYPE !<Diffusion Diffusion equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DIFFUSION_ADVECTION_DIFFUSION_TYPE = &
    & EQUATIONS_SET_DIFFUSION_ADVECTION_DIFFUSION_TYPE !<Diffusion Advection Diffusion equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MONODOMAIN_STRANG_SPLITTING_EQUATION_TYPE = &
    & EQUATIONS_SET_MONODOMAIN_STRANG_SPLITTING_EQUATION_TYPE !<Monodomain equation equations Strang Splitting set type \see OPENCMISS_EquationsSetTypes,OPENCMISS

  !>@}
  !> \addtogroup OPENCMISS_EquationsSetSubtypes OPENCMISS::EquationsSet::Subtypes
  !> \brief Equations set subtypes.
  !> \see OPENCMISS::EquationsSet,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NO_SUBTYPE = EQUATIONS_SET_NO_SUBTYPE !<No equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_THREE_DIMENSIONAL_SUBTYPE = EQUATIONS_SET_THREE_DIMENSIONAL_SUBTYPE !<Three dimensional linear elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRESS_SUBTYPE = &
    & EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRESS_SUBTYPE !<Plane stress linear elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRAIN_SUBTYPE = &
    & EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRAIN_SUBTYPE !<Plane strain linear elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ONE_DIMENSIONAL_SUBTYPE = EQUATIONS_SET_ONE_DIMENSIONAL_SUBTYPE !<One dimensional linear elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_PLATE_SUBTYPE = EQUATIONS_SET_PLATE_SUBTYPE !<Plate linear elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_SHELL_SUBTYPE = EQUATIONS_SET_SHELL_SUBTYPE !<Shell linear elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE = EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE !< Mooney-Rivlin constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ACTIVECONTRACTION_SUBTYPE =&
    & EQUATIONS_SET_ACTIVECONTRACTION_SUBTYPE !< Active contraction/costa-based law with quasistatic time loop for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ISOTROPIC_EXPONENTIAL_SUBTYPE = EQUATIONS_SET_ISOTROPIC_EXPONENTIAL_SUBTYPE !< Isotropic exponential constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_EXPONENTIAL_SUBTYPE = &
    & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_EXPONENTIAL_SUBTYPE !< Transverse isotropic exponential constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ORTHOTROPIC_MATERIAL_COSTA_SUBTYPE = &
    & EQUATIONS_SET_ORTHOTROPIC_MATERIAL_COSTA_SUBTYPE !< Orthotropic Costa constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_COMPRESSIBLE_FINITE_ELASTICITY_SUBTYPE= &
    & EQUATIONS_SET_COMPRESSIBLE_FINITE_ELASTICITY_SUBTYPE !<Compressible version for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_GUCCIONE_SUBTYPE = &
    & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_GUCCIONE_SUBTYPE !< Transverse isotropic Guccione constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_INCOMPRESS_FINITE_ELASTICITY_DARCY_SUBTYPE= &
    & EQUATIONS_SET_INCOMPRESSIBLE_FINITE_ELASTICITY_DARCY_SUBTYPE !<Incompressible version for finite elasticity coupled with Darcy equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE= &
    & EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE !<INRIA Model for finite elasticity coupled with Darcy equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ELASTICITY_MULTI_COMP_DARCY_INRIA_SUBTYPE= &
    & EQUATIONS_SET_ELASTICITY_MULTI_COMPARTMENT_DARCY_INRIA_SUBTYPE !<Multi Compartment Darcy INRIA Model coupled with finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_INCOMPRESS_ELASTICITY_DRIVEN_DARCY_SUBTYPE= &
    & EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE !< Incompressible finite elasticity with Darcy flow driven by solid hydrostatic pressure \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_MR_SUBTYPE= &
    & EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_MR_SUBTYPE !< Incompressible finite elasticity with Darcy flow driven by solid hydrostatic pressure, formulated in terms of modified invariants. \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_INCOMPRESS_ELAST_MULTI_COMP_DARCY_SUBTYPE= &
    & EQUATIONS_SET_INCOMPRESSIBLE_ELAST_MULTI_COMP_DARCY_SUBTYPE
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MEMBRANE_SUBTYPE = EQUATIONS_SET_MEMBRANE_SUBTYPE !<Compressible version for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ORTHOTROPIC_HOLZAPFEL_OGDEN_SUBTYPE = &
    & EQUATIONS_SET_ORTHOTROPIC_MATERIAL_HOLZAPFEL_OGDEN_SUBTYPE !< Orthotropic Holzapfel-Ogden constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ELASTICITY_FLUID_PRES_STATIC_INRIA_SUBTYPE = &
    & EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_STATIC_INRIA_SUBTYPE !< Static finite elasticity coupled with fluid pressure set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ELASTICITY_FLUID_PRES_HOLMES_MOW_SUBTYPE= &
    & EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_HOLMES_MOW_SUBTYPE !<Holmes and Mow's poroelastic constitutive relation subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STATIC_STOKES_SUBTYPE = EQUATIONS_SET_STATIC_STOKES_SUBTYPE !<Static Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LAPLACE_STOKES_SUBTYPE = EQUATIONS_SET_LAPLACE_STOKES_SUBTYPE !<Laplace type Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_TRANSIENT_STOKES_SUBTYPE = EQUATIONS_SET_TRANSIENT_STOKES_SUBTYPE !<Transient Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ALE_STOKES_SUBTYPE = EQUATIONS_SET_ALE_STOKES_SUBTYPE !<ALE Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_PGM_STOKES_SUBTYPE = EQUATIONS_SET_PGM_STOKES_SUBTYPE !<PGM Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_OPTIMISED_STOKES_SUBTYPE = EQUATIONS_SET_OPTIMISED_STOKES_SUBTYPE !<Optimised Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STATIC_NAVIER_STOKES_SUBTYPE = EQUATIONS_SET_STATIC_NAVIER_STOKES_SUBTYPE !<Static Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LAPLACE_NAVIER_STOKES_SUBTYPE = EQUATIONS_SET_LAPLACE_NAVIER_STOKES_SUBTYPE !<Laplace type Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_TRANSIENT_NAVIER_STOKES_SUBTYPE = EQUATIONS_SET_TRANSIENT_NAVIER_STOKES_SUBTYPE !<Transient Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_1DTRANSIENT_NAVIER_STOKES_SUBTYPE = &
    & EQUATIONS_SET_1DTRANSIENT_NAVIER_STOKES_SUBTYPE !<1DTransient Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ALE_NAVIER_STOKES_SUBTYPE = EQUATIONS_SET_ALE_NAVIER_STOKES_SUBTYPE !<ALE Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_PGM_NAVIER_STOKES_SUBTYPE = EQUATIONS_SET_PGM_NAVIER_STOKES_SUBTYPE !<PGM Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_OPTIMISED_NAVIER_STOKES_SUBTYPE = EQUATIONS_SET_OPTIMISED_NAVIER_STOKES_SUBTYPE !<Optimised Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STANDARD_DARCY_SUBTYPE = EQUATIONS_SET_STANDARD_DARCY_SUBTYPE !<Standard Darcy equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_QUASISTATIC_DARCY_SUBTYPE = EQUATIONS_SET_QUASISTATIC_DARCY_SUBTYPE !<Quasistatic Darcy equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ALE_DARCY_SUBTYPE = EQUATIONS_SET_ALE_DARCY_SUBTYPE !<ALE Darcy equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_TRANSIENT_DARCY_SUBTYPE = EQUATIONS_SET_TRANSIENT_DARCY_SUBTYPE !<Transient Darcy equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_TRANSIENT_ALE_DARCY_SUBTYPE = EQUATIONS_SET_TRANSIENT_ALE_DARCY_SUBTYPE !<Transient ALE Darcy equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MULTI_COMPARTMENT_DARCY_SUBTYPE = EQUATIONS_SET_MULTI_COMPARTMENT_DARCY_SUBTYPE !<Multi Compartment Darcy equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_BURGERS_SUBTYPE = EQUATIONS_SET_BURGERS_SUBTYPE !<Burgers equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_GENERALISED_BURGERS_SUBTYPE = EQUATIONS_SET_GENERALISED_BURGERS_SUBTYPE !<Generalised Burgers equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STATIC_BURGERS_SUBTYPE = EQUATIONS_SET_STATIC_BURGERS_SUBTYPE !<Static Burgers equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_INVISCID_BURGERS_SUBTYPE = EQUATIONS_SET_INVISCID_BURGERS_SUBTYPE !<Inviscid Burgers equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STANDARD_LAPLACE_SUBTYPE = EQUATIONS_SET_STANDARD_LAPLACE_SUBTYPE !<Standard Laplace equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_GENERALISED_LAPLACE_SUBTYPE = EQUATIONS_SET_GENERALISED_LAPLACE_SUBTYPE !<Generalised Laplace equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MOVING_MESH_LAPLACE_SUBTYPE = EQUATIONS_SET_MOVING_MESH_LAPLACE_SUBTYPE !<Moving mesh Laplace equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STATIC_POISEUILLE_SUBTYPE = EQUATIONS_SET_STATIC_POISEUILLE_SUBTYPE !<Static Poiseuille equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DYNAMIC_POISEUILLE_SUBTYPE = EQUATIONS_SET_DYNAMIC_POISEUILLE_SUBTYPE !<Dynamic Poiseuille equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_PRESSURE_POISSON_SUBTYPE = EQUATIONS_SET_LINEAR_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NONLINEAR_PRESSURE_POISSON_SUBTYPE = &
    & EQUATIONS_SET_NONLINEAR_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ALE_PRESSURE_POISSON_SUBTYPE = EQUATIONS_SET_ALE_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_FITTED_PRESSURE_POISSON_SUBTYPE = EQUATIONS_SET_FITTED_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_CONSTANT_SOURCE_POISSON_SUBTYPE = EQUATIONS_SET_CONSTANT_SOURCE_POISSON_SUBTYPE !<Constant source Poisson equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_SOURCE_POISSON_SUBTYPE = EQUATIONS_SET_LINEAR_SOURCE_POISSON_SUBTYPE !<Linear source Poisson equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_QUADRATIC_SOURCE_POISSON_SUBTYPE = EQUATIONS_SET_QUADRATIC_SOURCE_POISSON_SUBTYPE !<Quadratic source Poisson equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_EXPONENTIAL_SOURCE_POISSON_SUBTYPE = &
    & EQUATIONS_SET_EXPONENTIAL_SOURCE_POISSON_SUBTYPE !<Exponential source Poisson equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STANDARD_HELMHOLTZ_SUBTYPE = EQUATIONS_SET_STANDARD_HELMHOLTZ_SUBTYPE !<No source Helmholtz equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_GENERALISED_HELMHOLTZ_SUBTYPE = EQUATIONS_SET_GENERALISED_HELMHOLTZ_SUBTYPE !<No source Helmholtz equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NO_SOURCE_DIFFUSION_SUBTYPE = EQUATIONS_SET_NO_SOURCE_DIFFUSION_SUBTYPE !<No source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_CONSTANT_SOURCE_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_CONSTANT_SOURCE_DIFFUSION_SUBTYPE !<Constant source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_SOURCE_DIFFUSION_SUBTYPE = EQUATIONS_SET_LINEAR_SOURCE_DIFFUSION_SUBTYPE !<Linear source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_QUADRATIC_SOURCE_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_QUADRATIC_SOURCE_DIFFUSION_SUBTYPE !<Quadratic source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_EXPONENTIAL_SOURCE_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_EXPONENTIAL_SOURCE_DIFFUSION_SUBTYPE !<Exponential source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NO_SOURCE_ALE_DIFFUSION_SUBTYPE = EQUATIONS_SET_NO_SOURCE_ALE_DIFFUSION_SUBTYPE !<No source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_CONSTANT_SOURCE_ALE_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_CONSTANT_SOURCE_ALE_DIFFUSION_SUBTYPE !<Constant source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE !<Linear source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_QUADRATIC_SOURCE_ALE_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_QUADRATIC_SOURCE_ALE_DIFFUSION_SUBTYPE !<Quadratic source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_EXPONENTIAL_SOURCE_ALE_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_EXPONENTIAL_SOURCE_ALE_DIFFUSION_SUBTYPE !<Exponential source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MULTI_COMP_TRANSPORT_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_MULTI_COMP_TRANSPORT_DIFFUSION_SUBTYPE !<Multi-compartment transport diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NO_SOURCE_ADVECTION_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_NO_SOURCE_ADVECTION_DIFFUSION_SUBTYPE !<No source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_CONSTANT_SOURCE_ADVECTION_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_CONSTANT_SOURCE_ADVECTION_DIFFUSION_SUBTYPE !<Constant source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_SOURCE_ADVECTION_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_ADVECTION_DIFFUSION_SUBTYPE !<Linear source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_QUADRATIC_SOURCE_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_QUADRATIC_SOURCE_ADVECTION_DIFFUSION_SUBTYPE !<Quadratic source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_EXPONENTIAL_SOURCE_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_EXPONENTIAL_SOURCE_ADVECTION_DIFFUSION_SUBTYPE !<Exponential source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_CONSTITUTIVE_LAW_IN_CELLML_EVALUATE_SUBTYPE = &
    & EQUATIONS_SET_CONSTITUTIVE_LAW_IN_CELLML_EVALUATE_SUBTYPE !<In CellML evaluated incompressible material law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NO_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_NO_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE !<No source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_CONSTANT_SOURCE_ALE_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_CONSTANT_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE !<Constant source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_SOURCE_ALE_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE !<Linear source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_QUADRATIC_SOURCE_ALE_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_QUADRATIC_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE !<Quadratic source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_EXP_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_EXP_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE !<Exponential source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NO_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_NO_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE !<No source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_CONSTANT_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_CONSTANT_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE !<Constant source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE !<Linear source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NO_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_NO_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE !<No source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_CONSTANT_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_CONSTANT_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE !<Constant source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE !<Linear source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_QUAD_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_QUAD_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE !<Quadratic source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_EXP_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_EXP_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE !<Exponential source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NO_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_NO_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE !<No source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_CONSTANT_SOURCE_ALE_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_CONSTANT_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE !<Constant source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_SOURCE_ALE_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE !<Linear source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_QUAD_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_QUAD_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE !<Quadratic source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_EXP_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_EXP_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE !<Exponential source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NO_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_NO_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE !<No source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_CONST_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_CONSTANT_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE !<Constant source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LIN_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE !<Linear source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_COUPLED_SOURCE_DIFFUSION_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_COUPLED_SOURCE_DIFFUSION_ADVEC_DIFFUSION_SUBTYPE !<Coupled source diffusion & advection-diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MULTI_COMP_TRANSPORT_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_MULTI_COMP_TRANSPORT_ADVEC_DIFF_SUBTYPE !<Multi-component transport advection-diffusion equations set \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MULT_COMP_TRANSPORT_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_MULTI_COMP_TRANSPORT_ADVEC_DIFF_SUPG_SUBTYPE !<Multi-component transport advection-diffusion equations set using SUPG scheme \see OPENCMISS_EquationsSetSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_CELLML_REAC_SPLIT_REAC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_CELLML_REAC_SPLIT_REAC_DIFF_SUBTYPE !CellML Reaction Diffusion with order splitting \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_CELLML_REAC_NO_SPLIT_REAC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_CELLML_REAC_NO_SPLIT_REAC_DIFF_SUBTYPE !CellML Reaction Diffusion without order splitting \see OPENCMISS_EquationsSetSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_CONSTANT_REAC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_CONSTANT_REAC_DIFF_SUBTYPE !Standard Reaction Diffusion without order splitting, and constant source \see OPENCMISS_EquationsSetSubtypes,OPENCMISS


  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MONODOMAIN_BUENOOROVIO_SUBTYPE= EQUATIONS_SET_MONODOMAIN_BUENOOROVIO_SUBTYPE !<First monodomain equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MONODOMAIN_TENTUSSCHER06_SUBTYPE= EQUATIONS_SET_MONODOMAIN_TENTUSSCHER06_SUBTYPE !<First monodomain equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_FIRST_BIDOMAIN_SUBTYPE = EQUATIONS_SET_FIRST_BIDOMAIN_SUBTYPE !<First bidomain equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_SECOND_BIDOMAIN_SUBTYPE = EQUATIONS_SET_SECOND_BIDOMAIN_SUBTYPE !<Second bidomain equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STANDARD_DATA_FITTING_SUBTYPE = &
    & EQUATIONS_SET_STANDARD_DATA_FITTING_SUBTYPE !<Standard Galerkin Projection equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_GENERALISED_DATA_FITTING_SUBTYPE = &
    & EQUATIONS_SET_GENERALISED_DATA_FITTING_SUBTYPE !<Generalised Galerkin Projection equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MAT_PROPERTIES_DATA_FITTING_SUBTYPE = &
    & EQUATIONS_SET_MAT_PROPERTIES_DATA_FITTING_SUBTYPE !<Material Properties Galerkin Projection equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MAT_PROP_INRIA_MODEL_DATA_FITTING_SUBTYPE = &
    & EQUATIONS_SET_MAT_PROPERTIES_INRIA_MODEL_DATA_FITTING_SUBTYPE !<Material Properties INRIA Model Galerkin Projection equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_VECTOR_DATA_FITTING_SUBTYPE = &
    & EQUATIONS_SET_VECTOR_DATA_FITTING_SUBTYPE !<Standard Galerkin Projection equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DIVFREE_VECTOR_DATA_FITTING_SUBTYPE = &
    & EQUATIONS_SET_DIVFREE_VECTOR_DATA_FITTING_SUBTYPE !<Standard Galerkin Projection equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_VECTOR_DATA_PRE_FITTING_SUBTYPE = &
    & EQUATIONS_SET_VECTOR_DATA_PRE_FITTING_SUBTYPE !<Standard Galerkin Projection equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DIVFREE_VECTOR_DATA_PRE_FITTING_SUBTYPE = &
    & EQUATIONS_SET_DIVFREE_VECTOR_DATA_PRE_FITTING_SUBTYPE !<Standard Galerkin Projection equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS



  INTEGER(INTG), PARAMETER :: CMISSEquationsSetStandardElasticityDarcySubtype = EQUATIONS_SET_STANDARD_ELASTICITY_DARCY_SUBTYPE !<Standard Elasticity Darcy equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_COUPLED_SOURCE_DIFFUSION_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_COUPLED_SOURCE_DIFFUSION_DIFFUSION_SUBTYPE !<Coupled source diffusion-diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STANDARD_MONODOMAIN_ELASTICITY_SUBTYPE =  &
    & EQUATIONS_SET_STANDARD_MONODOMAIN_ELASTICITY_SUBTYPE !<Standard Monodomain Elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS

  !>@}
  !> \addtogroup OPENCMISS_EquationsSetSolutionMethods OPENCMISS::EquationsSet::SolutionMethods
  !> \brief The solution method parameters
  !> \see OPENCMISS::EquationsSet,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_FEM_SOLUTION_METHOD = EQUATIONS_SET_FEM_SOLUTION_METHOD !<Finite Element Method solution method. \see OPENCMISS_EquationsSetSolutionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_BEM_SOLUTION_METHOD = EQUATIONS_SET_BEM_SOLUTION_METHOD !<Boundary Element Method solution method. \see OPENCMISS_EquationsSetSolutionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_FD_SOLUTION_METHOD = EQUATIONS_SET_FD_SOLUTION_METHOD !<Finite Difference solution method. \see OPENCMISS_EquationsSetSolutionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_FV_SOLUTION_METHOD = EQUATIONS_SET_FV_SOLUTION_METHOD !<Finite Volume solution method. \see OPENCMISS_EquationsSetSolutionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_GFEM_SOLUTION_METHOD = EQUATIONS_SET_GFEM_SOLUTION_METHOD !<Grid-based Finite Element Method solution method. \see OPENCMISS_EquationsSetSolutionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_GFD_SOLUTION_METHOD = EQUATIONS_SET_GFD_SOLUTION_METHOD !<Grid-based Finite Difference solution method. \see OPENCMISS_EquationsSetSolutionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_GFV_SOLUTION_METHOD = EQUATIONS_SET_GFV_SOLUTION_METHOD !<Grid-based Finite Volume solution method. \see OPENCMISS_EquationsSetSolutionMethods,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_EquationsSetAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes
  !> \brief The analytic function types.
  !> \see OPENCMISS::EquationsSet,OPENCMISS
  !>@{
  !> \addtogroup OPENCMISS_EquationsSetLaplaceAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::Laplace
  !> \brief The analytic function types for a Laplace equation
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LAPLACE_EQUATION_TWO_DIM_1 = EQUATIONS_SET_LAPLACE_EQUATION_TWO_DIM_1 !<u=x**2+2*x*y-y**2 \see OPENCMISS_EquationsSetLaplaceAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LAPLACE_EQUATION_TWO_DIM_2 = EQUATIONS_SET_LAPLACE_EQUATION_TWO_DIM_2 !<u=cos(x)cosh(y) \see OPENCMISS_EquationsSetLaplaceAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LAPLACE_EQUATION_THREE_DIM_1 = EQUATIONS_SET_LAPLACE_EQUATION_THREE_DIM_1 !<u=x**2-2*y**2+z**2 \see OPENCMISS_EquationsSetLaplaceAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LAPLACE_EQUATION_THREE_DIM_2 = EQUATIONS_SET_LAPLACE_EQUATION_THREE_DIM_2 !<u=cos(x)*cosh(y)*z \see OPENCMISS_EquationsSetLaplaceAnalyticFunctionTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_EquationsSetHelmholtzAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::Helmholtz
  !> \brief The analytic function types for a Helmholtz equation
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_HELMHOLTZ_EQUATION_TWO_DIM_1 = EQUATIONS_SET_HELMHOLTZ_EQUATION_TWO_DIM_1 !<u=cos(sqrt(2)*k*x)*sin(sqrt(2)*k*y) \see OPENCMISS_EquationsSetHelmholtzAnalyticFunctionTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_PoiseuilleAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::Poiseuille
  !> \brief The analytic function types for a Poiseuille equation.
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_POISEUILLE_EQUATION_TWO_DIM_1 = EQUATIONS_SET_POISEUILLE_EQUATION_TWO_DIM_1 !<u=ln(4/(x+y+1^2)) \see OPENCMISS_EquationsSetPoiseuilleAnalyticFunctionTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_PoissonAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::Poisson
  !> \brief The analytic function types for a Poisson equation.
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_POISSON_EQUATION_TWO_DIM_1 = EQUATIONS_SET_POISSON_EQUATION_TWO_DIM_1 !<u=ln(4/(x+y+1^2)) \see OPENCMISS_EquationsSetPoissonAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_POISSON_EQUATION_TWO_DIM_2 = EQUATIONS_SET_POISSON_EQUATION_TWO_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetPoissonAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_POISSON_EQUATION_TWO_DIM_3 = EQUATIONS_SET_POISSON_EQUATION_TWO_DIM_3 !<u=tbd \see OPENCMISS_EquationsSetPoissonAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_POISSON_EQUATION_THREE_DIM_1 = EQUATIONS_SET_POISSON_EQUATION_THREE_DIM_1 !<u=ln(6/(x+y+z+1^2)) \see OPENCMISS_EquationsSetPoissonAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_POISSON_EQUATION_THREE_DIM_2 = EQUATIONS_SET_POISSON_EQUATION_THREE_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetPoissonAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_POISSON_EQUATION_THREE_DIM_3 = EQUATIONS_SET_POISSON_EQUATION_THREE_DIM_3 !<u=tbd \see OPENCMISS_EquationsSetPoissonAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_PRESSURE_POISSON_THREE_DIM_1 = EQUATIONS_SET_PRESSURE_POISSON_THREE_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetPoissonAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_PRESSURE_POISSON_THREE_DIM_2 = EQUATIONS_SET_PRESSURE_POISSON_THREE_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetPoissonAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_TEST_CASE_NEUMANN = TEST_CASE_NEUMANN !<Test case setup for testing of Neumann boundary conditions
  INTEGER(INTG), PARAMETER :: CMISS_TEST_CASE_NEUMANN_WITHOUT_SOURCE = TEST_CASE_NEUMANN_WITHOUT_SOURCE !<Test case setup for testing of Neumann boundary conditions
  INTEGER(INTG), PARAMETER :: CMISS_TEST_CASE_DIRICHLET = TEST_CASE_DIRICHLET !<Test case setup for testing of Neumann boundary conditions
  INTEGER(INTG), PARAMETER :: CMISS_TEST_CASE_MIXED_NEUMANN_DIRICHLET_1 = TEST_CASE_MIXED_NEUMANN_DIRICHLET_1 !<Test case setup for testing of Neumann boundary conditions
  INTEGER(INTG), PARAMETER :: CMISS_TEST_CASE_MIXED_NEUMANN_DIRICHLET_2 = TEST_CASE_MIXED_NEUMANN_DIRICHLET_2 !<Test case setup for testing of Neumann boundary conditions
  INTEGER(INTG), PARAMETER :: CMISS_TEST_CASE_MIXED_NEUMANN_DIRICHLET_3 = TEST_CASE_MIXED_NEUMANN_DIRICHLET_3 !<Test case setup for testing of Neumann boundary conditions
  INTEGER(INTG), PARAMETER :: CMISS_TEST_CASE_MIXED_NEUMANN_DIRICHLET_4 = TEST_CASE_MIXED_NEUMANN_DIRICHLET_4 !<Test case setup for testing of Neumann boundary conditions
  INTEGER(INTG), PARAMETER :: CMISSTestCaseMixedNeumannDirichlet_5 = TEST_CASE_MIXED_NEUMANN_DIRICHLET_5 !<Test case setup for testing of Neumann boundary conditions
  INTEGER(INTG), PARAMETER :: CMISS_TEST_CASE_MIXED_NEUMANN_DIRICHLET_6 = TEST_CASE_MIXED_NEUMANN_DIRICHLET_6 !<Test case setup for testing of Neumann boundary conditions
  INTEGER(INTG), PARAMETER :: CMISS_TEST_CASE_MIXED_NEUMANN_DIRICHLET_7 = TEST_CASE_MIXED_NEUMANN_DIRICHLET_7 !<Test case setup for testing of Neumann boundary conditions
  INTEGER(INTG), PARAMETER :: CMISS_TEST_CASE_NEUMANN_CUBIC = TEST_CASE_NEUMANN_CUBIC !<Test case setup for testing of Neumann boundary conditions
  !>@}
  !> \addtogroup OPENCMISS_DiffusionAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::Diffusion
  !> \brief The analytic function types for a diffusion equation.
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DIFFUSION_EQUATION_ONE_DIM_1 = EQUATIONS_SET_DIFFUSION_EQUATION_ONE_DIM_1
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DIFFUSION_EQUATION_TWO_DIM_1 = EQUATIONS_SET_DIFFUSION_EQUATION_TWO_DIM_1 !<u=exp(-kt)*sin(sqrt(k)*(x*cos(phi)+y*sin(phi))) \see OPENCMISS_EquationsSetDiffusionAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DIFFUSION_EQUATION_THREE_DIM_1 = EQUATIONS_SET_DIFFUSION_EQUATION_THREE_DIM_1 !<
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_SOURCE_DIFFUSION_THREE_DIM_1 = &
    & EQUATIONS_SET_LINEAR_SOURCE_DIFFUSION_EQUATION_THREE_DIM_1
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_QUADRATIC_SOURCE_DIFFUSION_ONE_DIM_1 = &
    & EQUATIONS_SET_QUADRATIC_SOURCE_DIFFUSION_EQUATION_ONE_DIM_1
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_EXPONENTIAL_SOURCE_DIFFUSION_ONE_DIM_1 = &
    & EQUATIONS_SET_EXPONENTIAL_SOURCE_DIFFUSION_EQUATION_ONE_DIM_1

  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MULTI_COMP_DIFFUSION_TWO_COMP_TWO_DIM = &
    & EQUATIONS_SET_MULTI_COMP_DIFFUSION_TWO_COMP_TWO_DIM !<Prescribed solution, using a source term to correct for error - 2D with 2 compartments
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MULTI_COMP_DIFFUSION_TWO_COMP_THREE_DIM = &
    & EQUATIONS_SET_MULTI_COMP_DIFFUSION_TWO_COMP_THREE_DIM !<Prescribed solution, using a source term to correct for error - 3D with 2 compartments
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MULTI_COMP_DIFFUSION_THREE_COMP_THREE_DIM = &
    & EQUATIONS_SET_MULTI_COMP_DIFFUSION_THREE_COMP_THREE_DIM !<Prescribed solution, using a source term to correct for error - 3D with 3 compartments
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MULTI_COMP_DIFFUSION_FOUR_COMP_THREE_DIM = &
    & EQUATIONS_SET_MULTI_COMP_DIFFUSION_FOUR_COMP_THREE_DIM !<Prescribed solution, using a source term to correct for error - 3D with 3 compartments
  !>@}
  !> \addtogroup OPENCMISS_AdvectionDiffusionAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::AdvectionDiffusion
  !> \brief The analytic function types for an advection-diffusion equation.
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ADVECTION_DIFFUSION_EQUATION_TWO_DIM_1 = &
    & EQUATIONS_SET_ADVECTION_DIFFUSION_EQUATION_TWO_DIM_1 !<u=exp(-kt)*sin(sqrt(k)*(x*cos(phi)+y*sin(phi))) \see OPENCMISS_EquationsSetDiffusionAnalyticFunctionTypes,OPENCMISS
  !> \addtogroup OPENCMISS_StokesAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::Stokes
  !> \brief The analytic function types for a Stokes equation.
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_1 = EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_2 = EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_3 = EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_3 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_4 = EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_4 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_5 = EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_5 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_1 = EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_2 = EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_3 = EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_3 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_4 = EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_4 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_5 = EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_5 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_NavierStokesAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::NavierStokes
  !> \brief The analytic function types for a Navier-Stokes equation.
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_1 = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_2 = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_3 = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_3 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_4 = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_4 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_5 = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_5 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_1 = &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_2 = &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_3 = &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_3 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_4 = &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_4 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_5 = &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_5 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_DarcyAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::Darcy
  !> \brief The analytic function types for a Darcy equation.
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_1 = EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetDarcyAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_2 = EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetDarcyAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_3 = EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_3 !<u=tbd \see OPENCMISS_EquationsSetDarcyAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_1 = EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetDarcyAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_2 = EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetDarcyAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_3 = EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_3 !<u=tbd \see OPENCMISS_EquationsSetDarcyAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_INCOMP_ELAST_DARCY_ANALYTIC_DARCY = &
    & EQUATIONS_SET_INCOMP_ELAST_DARCY_ANALYTIC_DARCY !<this is a solution where the finite elasticity solve is skipped to allow easy analytic testing of the mass increase & velocity solve step of incompressible poromechanical model
  !>@}
  !> \addtogroup OPENCMISS_BurgersAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::Burgers
  !> \brief The analytic function types for a Burgers equation.
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_BURGERS_EQUATION_ONE_DIM_1 = EQUATIONS_SET_BURGERS_EQUATION_ONE_DIM_1
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_GENERALISED_BURGERS_EQUATION_ONE_DIM_1 = &
    & EQUATIONS_SET_GENERALISED_BURGERS_EQUATION_ONE_DIM_1
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_GENERALISED_BURGERS_EQUATION_ONE_DIM_2 = &
    & EQUATIONS_SET_GENERALISED_BURGERS_EQUATION_ONE_DIM_2
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STATIC_BURGERS_EQUATION_ONE_DIM_1 = &
    & EQUATIONS_SET_STATIC_BURGERS_EQUATION_ONE_DIM_1
  !>@}

  !> \addtogroup OPENCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::LinearElasticity
  !> \brief The analytic function types for a LinearElasticity equation
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_ELASTICITY_ONE_DIM_1 = EQUATIONS_SET_LINEAR_ELASTICITY_ONE_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_1 = EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_2 = EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_1 = EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_2 = EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_EquationsSetFiniteElasticityAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::FiniteElasticity
  !> \brief The analytic function types for a FiniteElasticity equation
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_FINITE_ELASTICITY_CYLINDER = EQUATIONS_SET_FINITE_ELASTICITY_CYLINDER !<u=tbd \see OPENCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OPENCMISS
  !>@}
  !>@}
  !>@}

  !> \addtogroup OPENCMISS_AnalyticParamIndices OPENCMISS::FiniteElasticity::AnalyticParamIndices
  !> \brief Indices for EQUATIONS_SET_ANALYTIC_TYPE%ANALYTIC_USER_PARAMS
  !> \see OPENCMISS::FiniteElasticity::AnalyticParamIndices,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_PIN_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_PIN_IDX !<Inner pressure parameter index \see OPENCMISS_AnalyticParamIndices,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_POUT_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_POUT_IDX !<Outer pressure parameter index \see OPENCMISS_AnalyticParamIndices,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_LAMBDA_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_LAMBDA_IDX !<Lambda parameter index \see OPENCMISS_AnalyticParamIndices,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_TSI_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_TSI_IDX !<Tsi parameter index \see OPENCMISS_AnalyticParamIndices,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_RIN_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_RIN_IDX !<Inner radius parameter index \see OPENCMISS_AnalyticParamIndices,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_ROUT_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_ROUT_IDX !<Outer radius parameter index \see OPENCMISS_AnalyticParamIndices,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C1_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C1_IDX !<c1 parameter index \see OPENCMISS_AnalyticParamIndices,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C2_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C2_IDX !<c2 parameter index \see OPENCMISS_AnalyticParamIndices,OPENCMISS
  !>@}

  !Module types

  !Module variables

  !Interfaces

  PUBLIC CMISS_EQUATIONS_SET_NO_CLASS,CMISS_EQUATIONS_SET_ELASTICITY_CLASS,CMISS_EQUATIONS_SET_FLUID_MECHANICS_CLASS, &
    & CMISS_EQUATIONS_SET_ELECTROMAGNETICS_CLASS,CMISS_EQUATIONS_SET_CLASSICAL_FIELD_CLASS,CMISS_EQUATIONS_SET_BIOELECTRICS_CLASS, &
    & CMISS_EQUATIONS_SET_MODAL_CLASS,CMISS_EQUATIONS_SET_FITTING_CLASS,CMISS_EQUATIONS_SET_OPTIMISATION_CLASS, &
    & CMISS_EQUATIONS_SET_MULTI_PHYSICS_CLASS

  PUBLIC CMISS_EQUATIONS_SET_NO_TYPE,CMISS_EQUATIONS_SET_LINEAR_ELASTICITY_TYPE,CMISS_EQUATIONS_SET_FINITE_ELASTICITY_TYPE, &
    & CMISS_EQUATIONS_SET_STOKES_EQUATION_TYPE,CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TYPE, &
    & CMISS_EQUATIONS_SET_DARCY_EQUATION_TYPE, &
    & CMISS_EQUATIONS_SET_DARCY_PRESSURE_EQUATION_TYPE,CMISS_EQUATIONS_SET_BURGERS_EQUATION_TYPE, &
    & CMISS_EQUATIONS_SET_STATIC_POISEUILLE_SUBTYPE, &
    & CMISS_EQUATIONS_SET_DYNAMIC_POISEUILLE_SUBTYPE, &
    & CMISS_EQUATIONS_SET_ELECTROSTATIC_TYPE,CMISS_EQUATIONS_SET_MAGNETOSTATIC_TYPE,CMISS_EQUATIONS_SET_MAXWELLS_EQUATIONS_TYPE, &
    & CMISS_EQUATIONS_SET_LAPLACE_EQUATION_TYPE,CMISS_EQUATIONS_SET_POISEUILLE_EQUATION_TYPE, &
    & CMISS_EQUATIONS_SET_POISSON_EQUATION_TYPE, &
    & CMISS_EQUATIONS_SET_HELMHOLTZ_EQUATION_TYPE,CMISS_EQUATIONS_SET_WAVE_EQUATION_TYPE, &
    & CMISS_EQUATIONS_SET_DIFFUSION_EQUATION_TYPE, &
    & CMISS_EQUATIONS_SET_ADVECTION_DIFFUSION_EQUATION_TYPE,CMISS_EQUATIONS_SET_REACTION_DIFFUSION_EQUATION_TYPE, &
    & CMISS_EQUATIONS_SET_BIHARMONIC_EQUATION_TYPE,CMISS_EQUATIONS_SET_MONODOMAIN_EQUATION_TYPE, &
    & CMISS_EQUATIONS_SET_BIDOMAIN_EQUATION_TYPE, &
    & CMISS_EQUATIONS_SET_LINEAR_ELASTIC_MODAL_TYPE,CMISS_EQUATIONS_SET_DATA_FITTING_EQUATION_TYPE, &
    & CMISS_EQUATIONS_SET_MONODOMAIN_STRANG_SPLITTING_EQUATION_TYPE

  PUBLIC CMISS_EQUATIONS_SET_FINITE_ELASTICITY_DARCY_TYPE, &
    & CMISS_EQUATIONS_SET_FINITE_ELASTICITY_STOKES_TYPE, CMISS_EQUATIONS_SET_FINITE_ELASTICITY_NAVIER_STOKES_TYPE, &
    & CMISS_EQUATIONS_SET_DIFFUSION_DIFFUSION_TYPE, CMISS_EQUATIONS_SET_DIFFUSION_ADVECTION_DIFFUSION_TYPE

  PUBLIC CMISS_EQUATIONS_SET_NO_SUBTYPE,CMISS_EQUATIONS_SET_THREE_DIMENSIONAL_SUBTYPE, &
    & CMISS_EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRESS_SUBTYPE, &
    & CMISS_EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRAIN_SUBTYPE,CMISS_EQUATIONS_SET_ONE_DIMENSIONAL_SUBTYPE, &
    & CMISS_EQUATIONS_SET_PLATE_SUBTYPE, &
    & CMISS_EQUATIONS_SET_SHELL_SUBTYPE, &
    & CMISS_EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE,CMISS_EQUATIONS_SET_ISOTROPIC_EXPONENTIAL_SUBTYPE, &
    & CMISS_EQUATIONS_SET_ACTIVECONTRACTION_SUBTYPE,&
    & CMISS_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_EXPONENTIAL_SUBTYPE, CMISS_EQUATIONS_SET_ORTHOTROPIC_MATERIAL_COSTA_SUBTYPE, &
    & CMISS_EQUATIONS_SET_COMPRESSIBLE_FINITE_ELASTICITY_SUBTYPE,CMISS_EQUATIONS_SET_INCOMPRESS_FINITE_ELASTICITY_DARCY_SUBTYPE, &
    & CMISS_EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE,CMISS_EQUATIONS_SET_ELASTICITY_MULTI_COMP_DARCY_INRIA_SUBTYPE, &
    & CMISS_EQUATIONS_SET_INCOMPRESS_ELASTICITY_DRIVEN_DARCY_SUBTYPE, &
    & CMISS_EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_MR_SUBTYPE, &
    & CMISS_EQUATIONS_SET_INCOMPRESS_ELAST_MULTI_COMP_DARCY_SUBTYPE,CMISS_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_GUCCIONE_SUBTYPE, &
    & CMISS_EQUATIONS_SET_MEMBRANE_SUBTYPE, CMISS_EQUATIONS_SET_ORTHOTROPIC_HOLZAPFEL_OGDEN_SUBTYPE, &
    & CMISS_EQUATIONS_SET_ELASTICITY_FLUID_PRES_STATIC_INRIA_SUBTYPE, &
    & CMISS_EQUATIONS_SET_ELASTICITY_FLUID_PRES_HOLMES_MOW_SUBTYPE,&
    & CMISS_EQUATIONS_SET_STATIC_STOKES_SUBTYPE, CMISS_EQUATIONS_SET_LAPLACE_STOKES_SUBTYPE, &
    & CMISS_EQUATIONS_SET_TRANSIENT_STOKES_SUBTYPE,CMISS_EQUATIONS_SET_ALE_STOKES_SUBTYPE, &
    & CMISS_EQUATIONS_SET_ALE_NAVIER_STOKES_SUBTYPE, &
    & CMISS_EQUATIONS_SET_OPTIMISED_STOKES_SUBTYPE,CMISS_EQUATIONS_SET_STATIC_NAVIER_STOKES_SUBTYPE, &
    & CMISS_EQUATIONS_SET_LAPLACE_NAVIER_STOKES_SUBTYPE,CMISS_EQUATIONS_SET_TRANSIENT_NAVIER_STOKES_SUBTYPE, &
    & CMISS_EQUATIONS_SET_1DTRANSIENT_NAVIER_STOKES_SUBTYPE, &
    & CMISS_EQUATIONS_SET_OPTIMISED_NAVIER_STOKES_SUBTYPE,CMISS_EQUATIONS_SET_STANDARD_DARCY_SUBTYPE, &
    & CMISS_EQUATIONS_SET_QUASISTATIC_DARCY_SUBTYPE,CMISS_EQUATIONS_SET_ALE_DARCY_SUBTYPE, &
    & CMISS_EQUATIONS_SET_TRANSIENT_DARCY_SUBTYPE, &
    & CMISS_EQUATIONS_SET_TRANSIENT_ALE_DARCY_SUBTYPE,CMISS_EQUATIONS_SET_MULTI_COMPARTMENT_DARCY_SUBTYPE, &
    & CMISS_EQUATIONS_SET_STANDARD_LAPLACE_SUBTYPE,CMISS_EQUATIONS_SET_MOVING_MESH_LAPLACE_SUBTYPE, &
    & CMISS_EQUATIONS_SET_GENERALISED_LAPLACE_SUBTYPE,CMISS_EQUATIONS_SET_CONSTANT_SOURCE_POISSON_SUBTYPE, &
    & CMISS_EQUATIONS_SET_LINEAR_PRESSURE_POISSON_SUBTYPE, CMISS_EQUATIONS_SET_NONLINEAR_PRESSURE_POISSON_SUBTYPE, &
    & CMISS_EQUATIONS_SET_ALE_PRESSURE_POISSON_SUBTYPE, CMISS_EQUATIONS_SET_FITTED_PRESSURE_POISSON_SUBTYPE,&
    & CMISS_EQUATIONS_SET_LINEAR_SOURCE_POISSON_SUBTYPE,CMISS_EQUATIONS_SET_QUADRATIC_SOURCE_POISSON_SUBTYPE, &
    & CMISS_EQUATIONS_SET_EXPONENTIAL_SOURCE_POISSON_SUBTYPE,CMISS_EQUATIONS_SET_STANDARD_HELMHOLTZ_SUBTYPE, &
    & CMISS_EQUATIONS_SET_GENERALISED_HELMHOLTZ_SUBTYPE, &
    & CMISS_EQUATIONS_SET_NO_SOURCE_DIFFUSION_SUBTYPE,CMISS_EQUATIONS_SET_CONSTANT_SOURCE_DIFFUSION_SUBTYPE, &
    & CMISS_EQUATIONS_SET_LINEAR_SOURCE_DIFFUSION_SUBTYPE,CMISS_EQUATIONS_SET_QUADRATIC_SOURCE_DIFFUSION_SUBTYPE, &
    & CMISS_EQUATIONS_SET_EXPONENTIAL_SOURCE_DIFFUSION_SUBTYPE,CMISS_EQUATIONS_SET_MULTI_COMP_TRANSPORT_DIFFUSION_SUBTYPE, &
    & CMISS_EQUATIONS_SET_NO_SOURCE_ALE_DIFFUSION_SUBTYPE,CMISS_EQUATIONS_SET_CONSTANT_SOURCE_ALE_DIFFUSION_SUBTYPE, &
    & CMISS_EQUATIONS_SET_LINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE,CMISS_EQUATIONS_SET_QUADRATIC_SOURCE_ALE_DIFFUSION_SUBTYPE, &
    & CMISS_EQUATIONS_SET_EXPONENTIAL_SOURCE_ALE_DIFFUSION_SUBTYPE, &
    & CMISS_EQUATIONS_SET_NO_SOURCE_ADVECTION_DIFFUSION_SUBTYPE, &
    & CMISS_EQUATIONS_SET_CONSTANT_SOURCE_ADVECTION_DIFFUSION_SUBTYPE, &
    & CMISS_EQUATIONS_SET_LINEAR_SOURCE_ADVECTION_DIFFUSION_SUBTYPE, &
    & CMISS_EQUATIONS_SET_QUADRATIC_SOURCE_ADVEC_DIFF_SUBTYPE,CMISS_EQUATIONS_SET_EXPONENTIAL_SOURCE_ADVEC_DIFF_SUBTYPE, &
    & CMISS_EQUATIONS_SET_NO_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE, &
    & CMISS_EQUATIONS_SET_CONSTANT_SOURCE_ALE_ADVEC_DIFF_SUBTYPE,CMISS_EQUATIONS_SET_LINEAR_SOURCE_ALE_ADVEC_DIFF_SUBTYPE, &
    & CMISS_EQUATIONS_SET_QUADRATIC_SOURCE_ALE_ADVEC_DIFF_SUBTYPE,CMISS_EQUATIONS_SET_EXP_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE, &
    & CMISS_EQUATIONS_SET_NO_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE, CMISS_EQUATIONS_SET_CONSTANT_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE, &
    & CMISS_EQUATIONS_SET_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE, &
    & CMISS_EQUATIONS_SET_NO_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE, CMISS_EQUATIONS_SET_CONSTANT_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE, &
    & CMISS_EQUATIONS_SET_LINEAR_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE, CMISS_EQUATIONS_SET_QUAD_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE, &
    & CMISS_EQUATIONS_SET_EXP_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE, &
    & CMISS_EQUATIONS_SET_NO_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE, &
    & CMISS_EQUATIONS_SET_CONSTANT_SOURCE_ALE_ADVEC_DIFF_SUPG_SUBTYPE, &
    & CMISS_EQUATIONS_SET_LINEAR_SOURCE_ALE_ADVEC_DIFF_SUPG_SUBTYPE, &
    & CMISS_EQUATIONS_SET_QUAD_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE, &
    & CMISS_EQUATIONS_SET_EXP_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE, &
    & CMISS_EQUATIONS_SET_NO_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE, &
    & CMISS_EQUATIONS_SET_CONST_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE, &
    & CMISS_EQUATIONS_SET_LIN_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE, &
    & CMISS_EQUATIONS_SET_MULTI_COMP_TRANSPORT_ADVEC_DIFF_SUBTYPE,CMISS_EQUATIONS_SET_MULT_COMP_TRANSPORT_ADVEC_DIFF_SUPG_SUBTYPE, &
    & CMISS_EQUATIONS_SET_PGM_STOKES_SUBTYPE, &
    & CMISS_EQUATIONS_SET_FIRST_BIDOMAIN_SUBTYPE,CMISS_EQUATIONS_SET_SECOND_BIDOMAIN_SUBTYPE, &
    & CMISS_EQUATIONS_SET_MONODOMAIN_BUENOOROVIO_SUBTYPE,&
    & CMISS_EQUATIONS_SET_MONODOMAIN_TENTUSSCHER06_SUBTYPE  ,&
    & CMISS_EQUATIONS_SET_STANDARD_DATA_FITTING_SUBTYPE,CMISS_EQUATIONS_SET_GENERALISED_DATA_FITTING_SUBTYPE, &
    & CMISS_EQUATIONS_SET_VECTOR_DATA_FITTING_SUBTYPE,CMISS_EQUATIONS_SET_DIVFREE_VECTOR_DATA_FITTING_SUBTYPE, &
    & CMISS_EQUATIONS_SET_VECTOR_DATA_PRE_FITTING_SUBTYPE,CMISS_EQUATIONS_SET_DIVFREE_VECTOR_DATA_PRE_FITTING_SUBTYPE, &
    & CMISS_EQUATIONS_SET_MAT_PROPERTIES_DATA_FITTING_SUBTYPE,CMISS_EQUATIONS_SET_MAT_PROP_INRIA_MODEL_DATA_FITTING_SUBTYPE, &
    & CMISS_EQUATIONS_SET_PGM_NAVIER_STOKES_SUBTYPE, &
    & CMISS_EQUATIONS_SET_CONSTITUTIVE_LAW_IN_CELLML_EVALUATE_SUBTYPE, &
    & CMISS_EQUATIONS_SET_COUPLED_SOURCE_DIFFUSION_DIFFUSION_SUBTYPE, &
    & CMISS_EQUATIONS_SET_COUPLED_SOURCE_DIFFUSION_ADVEC_DIFF_SUBTYPE, &
    & CMISS_EQUATIONS_SET_BURGERS_SUBTYPE,CMISS_EQUATIONS_SET_GENERALISED_BURGERS_SUBTYPE, &
    & CMISS_EQUATIONS_SET_STATIC_BURGERS_SUBTYPE, &
    & CMISS_EQUATIONS_SET_INVISCID_BURGERS_SUBTYPE,CMISS_EQUATIONS_SET_STANDARD_MONODOMAIN_ELASTICITY_SUBTYPE


  PUBLIC CMISS_EQUATIONS_SET_CELLML_REAC_SPLIT_REAC_DIFF_SUBTYPE, CMISS_EQUATIONS_SET_CELLML_REAC_NO_SPLIT_REAC_DIFF_SUBTYPE, &
    & CMISS_EQUATIONS_SET_CONSTANT_REAC_DIFF_SUBTYPE

  PUBLIC CMISS_EQUATIONS_SET_FEM_SOLUTION_METHOD,CMISS_EQUATIONS_SET_BEM_SOLUTION_METHOD,CMISS_EQUATIONS_SET_FD_SOLUTION_METHOD, &
    & CMISS_EQUATIONS_SET_FV_SOLUTION_METHOD,CMISS_EQUATIONS_SET_GFEM_SOLUTION_METHOD,CMISS_EQUATIONS_SET_GFD_SOLUTION_METHOD, &
    & CMISS_EQUATIONS_SET_GFV_SOLUTION_METHOD

  PUBLIC CMISS_EQUATIONS_SET_LAPLACE_EQUATION_TWO_DIM_1,CMISS_EQUATIONS_SET_LAPLACE_EQUATION_TWO_DIM_2, &
    & CMISS_EQUATIONS_SET_LAPLACE_EQUATION_THREE_DIM_1,CMISS_EQUATIONS_SET_LAPLACE_EQUATION_THREE_DIM_2

  PUBLIC CMISS_EQUATIONS_SET_HELMHOLTZ_EQUATION_TWO_DIM_1

  PUBLIC CMISS_EQUATIONS_SET_LINEAR_ELASTICITY_ONE_DIM_1,CMISS_EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_1, &
    & CMISS_EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_2,CMISS_EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_1, &
    & CMISS_EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_2

  PUBLIC CMISS_EQUATIONS_SET_DIFFUSION_EQUATION_ONE_DIM_1,CMISS_EQUATIONS_SET_DIFFUSION_EQUATION_TWO_DIM_1, &
    & CMISS_EQUATIONS_SET_DIFFUSION_EQUATION_THREE_DIM_1, &
    & CMISS_EQUATIONS_SET_LINEAR_SOURCE_DIFFUSION_THREE_DIM_1,CMISS_EQUATIONS_SET_QUADRATIC_SOURCE_DIFFUSION_ONE_DIM_1, &
    & CMISS_EQUATIONS_SET_EXPONENTIAL_SOURCE_DIFFUSION_ONE_DIM_1,CMISS_EQUATIONS_SET_MULTI_COMP_DIFFUSION_TWO_COMP_TWO_DIM, &
    & CMISS_EQUATIONS_SET_MULTI_COMP_DIFFUSION_TWO_COMP_THREE_DIM,CMISS_EQUATIONS_SET_MULTI_COMP_DIFFUSION_THREE_COMP_THREE_DIM, &
    & CMISS_EQUATIONS_SET_MULTI_COMP_DIFFUSION_FOUR_COMP_THREE_DIM


  PUBLIC CMISS_EQUATIONS_SET_ADVECTION_DIFFUSION_EQUATION_TWO_DIM_1

  PUBLIC CMISS_EQUATIONS_SET_POISEUILLE_EQUATION_TWO_DIM_1

  PUBLIC CMISS_EQUATIONS_SET_BURGERS_EQUATION_ONE_DIM_1,CMISS_EQUATIONS_SET_GENERALISED_BURGERS_EQUATION_ONE_DIM_1, &
    & CMISS_EQUATIONS_SET_GENERALISED_BURGERS_EQUATION_ONE_DIM_2, &
    & CMISS_EQUATIONS_SET_STATIC_BURGERS_EQUATION_ONE_DIM_1

  PUBLIC CMISS_EQUATIONS_SET_POISSON_EQUATION_TWO_DIM_1,CMISS_EQUATIONS_SET_POISSON_EQUATION_TWO_DIM_2, &
    & CMISS_EQUATIONS_SET_POISSON_EQUATION_TWO_DIM_3
  PUBLIC CMISS_EQUATIONS_SET_POISSON_EQUATION_THREE_DIM_1,CMISS_EQUATIONS_SET_POISSON_EQUATION_THREE_DIM_2, &
    & CMISS_EQUATIONS_SET_POISSON_EQUATION_THREE_DIM_3
  PUBLIC CMISS_TEST_CASE_NEUMANN,CMISS_TEST_CASE_DIRICHLET,CMISS_TEST_CASE_NEUMANN_WITHOUT_SOURCE
  PUBLIC CMISS_TEST_CASE_MIXED_NEUMANN_DIRICHLET_1,CMISS_TEST_CASE_MIXED_NEUMANN_DIRICHLET_2, &
    & CMISS_TEST_CASE_MIXED_NEUMANN_DIRICHLET_3
  PUBLIC CMISS_TEST_CASE_MIXED_NEUMANN_DIRICHLET_4,CMISS_TEST_CASE_MIXED_NEUMANN_DIRICHLET_6, &
    & CMISS_TEST_CASE_MIXED_NEUMANN_DIRICHLET_7
  PUBLIC CMISS_TEST_CASE_NEUMANN_CUBIC,CMISS_EQUATIONS_SET_PRESSURE_POISSON_THREE_DIM_1, &
    & CMISS_EQUATIONS_SET_PRESSURE_POISSON_THREE_DIM_2

  PUBLIC CMISS_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_1,CMISS_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_2, &
    & CMISS_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_3
  PUBLIC CMISS_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_4,CMISS_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_5
  PUBLIC CMISS_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_1,CMISS_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_2, &
    & CMISS_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_3
  PUBLIC CMISS_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_4,CMISS_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_5

  PUBLIC CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_1,CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_2, &
    & CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_3
  PUBLIC CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_4,CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_5
  PUBLIC CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_1,CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_2, &
    & CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_3
  PUBLIC CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_4,CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_5

  PUBLIC CMISS_EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_1,CMISS_EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_2, &
    & CMISS_EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_3
  PUBLIC CMISS_EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_1,CMISS_EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_2, &
    & CMISS_EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_3
  PUBLIC CMISS_EQUATIONS_SET_INCOMP_ELAST_DARCY_ANALYTIC_DARCY

  PUBLIC CMISS_EQUATIONS_SET_FINITE_ELASTICITY_CYLINDER
  PUBLIC CMISS_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_PIN_IDX,CMISS_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_POUT_IDX
  PUBLIC CMISS_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_LAMBDA_IDX,CMISS_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_TSI_IDX
  PUBLIC CMISS_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_RIN_IDX,CMISS_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_ROUT_IDX
  PUBLIC CMISS_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C1_IDX,CMISS_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C2_IDX

!!==================================================================================================================================
!!
!! EQUATIONS_SET_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Finish the creation of a analytic solution for an equations set. \see OPENCMISS::CMISSEquationsSetAnalyticCreateStart
  INTERFACE CMISSEquationsSetAnalyticCreateFinish
    MODULE PROCEDURE CMISSEquationsSetAnalyticCreateFinishNumber
    MODULE PROCEDURE CMISSEquationsSetAnalyticCreateFinishObj
  END INTERFACE !CMISSEquationsSetAnalyticCreateFinish

  !>Start the creation of a analytic solution for an equations set. \see OPENCMISS::CMISSEquationsSetAnalyticCreateFinish
  INTERFACE CMISSEquationsSetAnalyticCreateStart
    MODULE PROCEDURE CMISSEquationsSetAnalyticCreateStartNumber
    MODULE PROCEDURE CMISSEquationsSetAnalyticCreateStartObj
  END INTERFACE !CMISSEquationsSetAnalyticCreateStart

  !>Destroy the analytic solution for an equations set.
  INTERFACE CMISSEquationsSetAnalyticDestroy
    MODULE PROCEDURE CMISSEquationsSetAnalyticDestroyNumber
    MODULE PROCEDURE CMISSEquationsSetAnalyticDestroyObj
  END INTERFACE !CMISSEquationsSetAnalyticDestroy

  !>Evaluates the current analytic solution for an equations set.
  INTERFACE CMISSEquationsSetAnalyticEvaluate
    MODULE PROCEDURE CMISSEquationsSetAnalyticEvaluateNumber
    MODULE PROCEDURE CMISSEquationsSetAnalyticEvaluateObj
  END INTERFACE !CMISSEquationsSetAnalyticEvaluate

  !>Returns the analytic time for an equations set.
  INTERFACE CMISSEquationsSetAnalyticTimeGet
    MODULE PROCEDURE CMISSEquationsSetAnalyticTimeGetNumber
    MODULE PROCEDURE CMISSEquationsSetAnalyticTimeGetObj
  END INTERFACE !CMISSEquationsSetAnalyticTimeGet

  !>Sets/changes the analytic time for an equations set.
  INTERFACE CMISSEquationsSetAnalyticTimeSet
    MODULE PROCEDURE CMISSEquationsSetAnalyticTimeSetNumber
    MODULE PROCEDURE CMISSEquationsSetAnalyticTimeSetObj
  END INTERFACE !CMISSEquationsSetAnalyticTimeSet

  !>Finish the creation of an equations set. \see OPENCMISS::CMISSEquationsSetCreateStart
  INTERFACE CMISSEquationsSetCreateFinish
    MODULE PROCEDURE CMISSEquationsSetCreateFinishNumber
    MODULE PROCEDURE CMISSEquationsSetCreateFinishObj
  END INTERFACE !CMISSEquationsSetCreateFinish

  !>Start the creation of an equations set on a region. \see OPENCMISS::CMISSEquationsSetCreateFinish
  INTERFACE CMISSEquationsSetCreateStart
    MODULE PROCEDURE CMISSEquationsSetCreateStartNumber
    MODULE PROCEDURE CMISSEquationsSetCreateStartObj
  END INTERFACE !CMISSEquationsSetCreateStart

  !>Destroy an equations set.
  INTERFACE CMISSEquationsSetDestroy
    MODULE PROCEDURE CMISSEquationsSetDestroyNumber
    MODULE PROCEDURE CMISSEquationsSetDestroyObj
  END INTERFACE !CMISSEquationsSetDestroy

  !>Finish the creation of dependent variables for an equations set. \see OPENCMISS::CMISSEquationsSetDependentCreateStart
  INTERFACE CMISSEquationsSetDependentCreateFinish
    MODULE PROCEDURE CMISSEquationsSetDependentCreateFinishNumber
    MODULE PROCEDURE CMISSEquationsSetDependentCreateFinishObj
  END INTERFACE !CMISSEquationsSetDependentCreateFinish

  !>Start the creation of dependent variables for an equations set. \see OPENCMISS::CMISSEquationsSetDependentCreateFinish
  INTERFACE CMISSEquationsSetDependentCreateStart
    MODULE PROCEDURE CMISSEquationsSetDependentCreateStartNumber
    MODULE PROCEDURE CMISSEquationsSetDependentCreateStartObj
  END INTERFACE !CMISSEquationsSetDependentCreateStart

  !>Destroy the dependent variables for an equations set.
  INTERFACE CMISSEquationsSetDependentDestroy
    MODULE PROCEDURE CMISSEquationsSetDependentDestroyNumber
    MODULE PROCEDURE CMISSEquationsSetDependentDestroyObj
  END INTERFACE !CMISSEquationsSetDependentDestroy

  !>Finish the creation of equations for an equations set. \see OPENCMISS::CMISSEquationsSetEquationsCreateStart
  INTERFACE CMISSEquationsSetEquationsCreateFinish
    MODULE PROCEDURE CMISSEquationsSetEquationsCreateFinishNumber
    MODULE PROCEDURE CMISSEquationsSetEquationsCreateFinishObj
  END INTERFACE !CMISSEquationsSetEquationsCreateFinish

  !>Start the creation of equations for an equations set. \see OPENCMISS::CMISSEquationsSetEquationsCreateFinish
  INTERFACE CMISSEquationsSetEquationsCreateStart
    MODULE PROCEDURE CMISSEquationsSetEquationsCreateStartNumber
    MODULE PROCEDURE CMISSEquationsSetEquationsCreateStartObj
  END INTERFACE !CMISSEquationsSetEquationsCreateStart

  !>Destroy the equations for an equations set.
  INTERFACE CMISSEquationsSetEquationsDestroy
    MODULE PROCEDURE CMISSEquationsSetEquationsDestroyNumber
    MODULE PROCEDURE CMISSEquationsSetEquationsDestroyObj
  END INTERFACE !CMISSEquationsSetEquationsDestroy

  !>Finish the creation of independent fields for an equations set. \see OPENCMISS::CMISSEquationsSetIndependentCreateStart
  INTERFACE CMISSEquationsSetIndependentCreateFinish
    MODULE PROCEDURE CMISSEquationsSetIndependentCreateFinishNumber
    MODULE PROCEDURE CMISSEquationsSetIndependentCreateFinishObj
  END INTERFACE !CMISSEquationsSetIndependentCreateFinish

  !>Start the creation of independent fields for an equations set. \see OPENCMISS::CMISSEquationsSetMaterialsCreateFinish
  INTERFACE CMISSEquationsSetIndependentCreateStart
    MODULE PROCEDURE CMISSEquationsSetIndependentCreateStartNumber
    MODULE PROCEDURE CMISSEquationsSetIndependentCreateStartObj
  END INTERFACE !CMISSEquationsSetIndependentCreateStart

  !>Destroy the independent fields for an equations set.
  INTERFACE CMISSEquationsSetIndependentDestroy
    MODULE PROCEDURE CMISSEquationsSetIndependentDestroyNumber
    MODULE PROCEDURE CMISSEquationsSetIndependentDestroyObj
  END INTERFACE !CMISSEquationsSetIndependentDestroy

  !>Finish the creation of materials for an equations set. \see OPENCMISS::CMISSEquationsSetMaterialsCreateStart
  INTERFACE CMISSEquationsSetMaterialsCreateFinish
    MODULE PROCEDURE CMISSEquationsSetMaterialsCreateFinishNumber
    MODULE PROCEDURE CMISSEquationsSetMaterialsCreateFinishObj
  END INTERFACE !CMISSEquationsSetMaterialsCreateFinish

  !>Start the creation of materials for an equations set. \see OPENCMISS::CMISSEquationsSetMaterialsCreateFinish
  INTERFACE CMISSEquationsSetMaterialsCreateStart
    MODULE PROCEDURE CMISSEquationsSetMaterialsCreateStartNumber
    MODULE PROCEDURE CMISSEquationsSetMaterialsCreateStartObj
  END INTERFACE !CMISSEquationsSetMaterialsCreateStart

  !>Destroy the materials for an equations set.
  INTERFACE CMISSEquationsSetMaterialsDestroy
    MODULE PROCEDURE CMISSEquationsSetMaterialsDestroyNumber
    MODULE PROCEDURE CMISSEquationsSetMaterialsDestroyObj
  END INTERFACE !CMISSEquationsSetMaterialsDestroy

  !>Returns the solution method for an equations set.
  INTERFACE CMISSEquationsSetSolutionMethodGet
    MODULE PROCEDURE CMISSEquationsSetSolutionMethodGetNumber
    MODULE PROCEDURE CMISSEquationsSetSolutionMethodGetObj
  END INTERFACE !CMISSEquationsSetSolutionMethodGet

  !>Sets/changes the solution method for an equations set.
  INTERFACE CMISSEquationsSetSolutionMethodSet
    MODULE PROCEDURE CMISSEquationsSetSolutionMethodSetNumber
    MODULE PROCEDURE CMISSEquationsSetSolutionMethodSetObj
  END INTERFACE !CMISSEquationsSetSolutionMethodSet

  !>Finish the creation of a source for an equations set. \see OPENCMISS::CMISSEquationsSetSourceCreateStart
  INTERFACE CMISSEquationsSetSourceCreateFinish
    MODULE PROCEDURE CMISSEquationsSetSourceCreateFinishNumber
    MODULE PROCEDURE CMISSEquationsSetSourceCreateFinishObj
  END INTERFACE !CMISSEquationsSetSourceCreateFinish

  !>Start the creation of a source for an equations set. \see OPENCMISS::CMISSEquationsSetSourceCreateFinish
  INTERFACE CMISSEquationsSetSourceCreateStart
    MODULE PROCEDURE CMISSEquationsSetSourceCreateStartNumber
    MODULE PROCEDURE CMISSEquationsSetSourceCreateStartObj
  END INTERFACE !CMISSEquationsSetSourceCreateStart

  !>Destroy the source for an equations set.
  INTERFACE CMISSEquationsSetSourceDestroy
    MODULE PROCEDURE CMISSEquationsSetSourceDestroyNumber
    MODULE PROCEDURE CMISSEquationsSetSourceDestroyObj
  END INTERFACE !CMISSEquationsSetSourceDestroy

  !>Returns the equations set specification i.e., equations set class, type and subtype for an equations set.
  INTERFACE CMISSEquationsSetSpecificationGet
    MODULE PROCEDURE CMISSEquationsSetSpecificationGetNumber
    MODULE PROCEDURE CMISSEquationsSetSpecificationGetObj
  END INTERFACE !CMISSEquationsSetSpecificationGet

   !>Sets/changes the equations set specification i.e., equations set class, type and subtype for an equations set.
  INTERFACE CMISSEquationsSetSpecificationSet
    MODULE PROCEDURE CMISSEquationsSetSpecificationSetNumber
    MODULE PROCEDURE CMISSEquationsSetSpecificationSetObj
  END INTERFACE !CMISSEquationsSetSpecificationSet

  !>Gets the equations set analytic user parameter
  INTERFACE CMISSEquationsSetAnalyticUserParamGet
    MODULE PROCEDURE CMISSEquationsSetAnalyticUserParamGetNumber
    MODULE PROCEDURE CMISSEquationsSetAnalyticUserParamGetObj
  END INTERFACE

  !>Sets/changes the equations set analytic user parameter
  INTERFACE CMISSEquationsSetAnalyticUserParamSet
    MODULE PROCEDURE CMISSEquationsSetAnalyticUserParamSetNumber
    MODULE PROCEDURE CMISSEquationsSetAnalyticUserParamSetObj
  END INTERFACE

  PUBLIC CMISSEquationsSetAnalyticCreateFinish,CMISSEquationsSetAnalyticCreateStart

  PUBLIC CMISSEquationsSetAnalyticDestroy

  PUBLIC CMISSEquationsSetAnalyticEvaluate

  PUBLIC CMISSEquationsSetAnalyticTimeGet,CMISSEquationsSetAnalyticTimeSet

  PUBLIC CMISSEquationsSetCreateFinish,CMISSEquationsSetCreateStart

  PUBLIC CMISSEquationsSetDestroy

  PUBLIC CMISSEquationsSetDependentCreateFinish,CMISSEquationsSetDependentCreateStart

  PUBLIC CMISSEquationsSetDependentDestroy

  PUBLIC CMISSEquationsSetEquationsCreateFinish,CMISSEquationsSetEquationsCreateStart

  PUBLIC CMISSEquationsSetEquationsDestroy

  PUBLIC CMISSEquationsSetIndependentCreateFinish,CMISSEquationsSetIndependentCreateStart

  PUBLIC CMISSEquationsSetIndependentDestroy

  PUBLIC CMISSEquationsSetMaterialsCreateFinish,CMISSEquationsSetMaterialsCreateStart

  PUBLIC CMISSEquationsSetMaterialsDestroy

  PUBLIC CMISSEquationsSetSolutionMethodGet,CMISSEquationsSetSolutionMethodSet

  PUBLIC CMISSEquationsSetSourceCreateFinish,CMISSEquationsSetSourceCreateStart

  PUBLIC CMISSEquationsSetSourceDestroy

  PUBLIC CMISSEquationsSetSpecificationGet,CMISSEquationsSetSpecificationSet

  PUBLIC CMISSEquationsSetAnalyticUserParamSet,CMISSEquationsSetAnalyticUserParamGet


!!==================================================================================================================================
!!
!! FIELD_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_FieldConstants OPENCMISS::Field::Constants
  !> \brief Field constants.
  !>@{
  !> \addtogroup OPENCMISS_FieldDependentTypes OPENCMISS::Field::DependentTypes
  !> \brief Depedent field parameter types.
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_INDEPENDENT_TYPE = FIELD_INDEPENDENT_TYPE !<Independent field type \see OPENCMISS_FieldDependentTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DEPENDENT_TYPE = FIELD_DEPENDENT_TYPE !<Dependent field type \see OPENCMISS_FieldDependentTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_FieldDimensionTypes OPENCMISS::Field::DimensionTypes
  !> \brief Field dimension parameter types.
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_SCALAR_DIMENSION_TYPE = FIELD_SCALAR_DIMENSION_TYPE !<Scalar field \see OPENCMISS_FieldDimensionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_VECTOR_DIMENSION_TYPE = FIELD_VECTOR_DIMENSION_TYPE !<Vector field \see OPENCMISS_FieldDimensionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_TENSOR_DIMENSION_TYPE = FIELD_TENSOR_DIMENSION_TYPE !<Tensor field \see OPENCMISS_FieldDimensionTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_FieldTypes OPENCMISS::Field::Types
  !> \brief Field type parameters.
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_GEOMETRIC_TYPE = FIELD_GEOMETRIC_TYPE !<Geometric field \see OPENCMISS_FieldTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_FIBRE_TYPE = FIELD_FIBRE_TYPE !<Fibre field \see OPENCMISS_FieldTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_GENERAL_TYPE = FIELD_GENERAL_TYPE !<General field \see OPENCMISS_FieldTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_MATERIAL_TYPE = FIELD_MATERIAL_TYPE !<Material field \see OPENCMISS_FieldTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_FieldInterpolationTypes OPENCMISS::Field::InterpolationTypes
  !> \brief Field interpolation parameters.
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_CONSTANT_INTERPOLATION = FIELD_CONSTANT_INTERPOLATION !<Constant interpolation. One parameter for the field \see OPENCMISS_FieldInterpolationTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_ELEMENT_BASED_INTERPOLATION = FIELD_ELEMENT_BASED_INTERPOLATION !<Element based interpolation. Parameters are different in each element \see OPENCMISS_FieldInterpolationTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_NODE_BASED_INTERPOLATION = FIELD_NODE_BASED_INTERPOLATION !<Node based interpolation. Parameters are nodal based and a basis function is used \see OPENCMISS_FieldInterpolationTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_GRID_POINT_BASED_INTERPOLATION = FIELD_GRID_POINT_BASED_INTERPOLATION !<Grid point based interpolation. Parameters are different at each grid point \see OPENCMISS_FieldInterpolationTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_GAUSS_POINT_BASED_INTERPOLATION = FIELD_GAUSS_POINT_BASED_INTERPOLATION !<Gauss point based interpolation. Parameters are different at each Gauss point \see OPENCMISS_FieldInterpolationTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_FieldVariableTypes OPENCMISS::Field::VariableTypes
  !> \brief Field variable type parameters.
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_NUMBER_OF_VARIABLE_SUBTYPES = FIELD_NUMBER_OF_VARIABLE_SUBTYPES !<The number of subtypes of a variable - i.e., u, du/dn, du/dt, d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_U_VARIABLE_TYPE = FIELD_U_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELUDELN_VARIABLE_TYPE = FIELD_DELUDELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELUDELT_VARIABLE_TYPE = FIELD_DELUDELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DEL2UDELT2_VARIABLE_TYPE = FIELD_DEL2UDELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_V_VARIABLE_TYPE = FIELD_V_VARIABLE_TYPE !<Second standard variable type i.e., v \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELVDELN_VARIABLE_TYPE = FIELD_DELVDELN_VARIABLE_TYPE !<Second normal derivative variable type i.e., dv/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELVDELT_VARIABLE_TYPE = FIELD_DELVDELT_VARIABLE_TYPE !<Second first time derivative variable type i.e., dv/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DEL2VDELT2_VARIABLE_TYPE = FIELD_DEL2VDELT2_VARIABLE_TYPE !<Second second time derivative variable type i.e., d^2v/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_U1_VARIABLE_TYPE = FIELD_U1_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU1DELN_VARIABLE_TYPE = FIELD_DELU1DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU1DELT_VARIABLE_TYPE = FIELD_DELU1DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DEL2U1DELT2_VARIABLE_TYPE = FIELD_DEL2U1DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_U2_VARIABLE_TYPE = FIELD_U2_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU2DELN_VARIABLE_TYPE = FIELD_DELU2DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU2DELT_VARIABLE_TYPE = FIELD_DELU2DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DEL2U2DELT2_VARIABLE_TYPE = FIELD_DEL2U2DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_U3_VARIABLE_TYPE = FIELD_U3_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU3DELN_VARIABLE_TYPE = FIELD_DELU3DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU3DELT_VARIABLE_TYPE = FIELD_DELU3DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DEL2U3DELT2_VARIABLE_TYPE = FIELD_DEL2U3DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_U4_VARIABLE_TYPE = FIELD_U4_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU4DELN_VARIABLE_TYPE = FIELD_DELU4DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU4DELT_VARIABLE_TYPE = FIELD_DELU4DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DEL2U4DELT2_VARIABLE_TYPE = FIELD_DEL2U4DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_U5_VARIABLE_TYPE = FIELD_U5_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU5DELN_VARIABLE_TYPE = FIELD_DELU5DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU5DELT_VARIABLE_TYPE = FIELD_DELU5DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DEL2U5DELT2_VARIABLE_TYPE = FIELD_DEL2U5DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_U6_VARIABLE_TYPE = FIELD_U6_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU6DELN_VARIABLE_TYPE = FIELD_DELU6DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU6DELT_VARIABLE_TYPE = FIELD_DELU6DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DEL2U6DELT2_VARIABLE_TYPE = FIELD_DEL2U6DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_U7_VARIABLE_TYPE = FIELD_U7_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU7DELN_VARIABLE_TYPE = FIELD_DELU7DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU7DELT_VARIABLE_TYPE = FIELD_DELU7DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DEL2U7DELT2_VARIABLE_TYPE = FIELD_DEL2U7DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_U8_VARIABLE_TYPE = FIELD_U8_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU8DELN_VARIABLE_TYPE = FIELD_DELU8DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU8DELT_VARIABLE_TYPE = FIELD_DELU8DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DEL2U8DELT2_VARIABLE_TYPE = FIELD_DEL2U8DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_U9_VARIABLE_TYPE = FIELD_U9_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU9DELN_VARIABLE_TYPE = FIELD_DELU9DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU9DELT_VARIABLE_TYPE = FIELD_DELU9DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DEL2U9DELT2_VARIABLE_TYPE = FIELD_DEL2U9DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_U10_VARIABLE_TYPE = FIELD_U10_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU10DELN_VARIABLE_TYPE = FIELD_DELU10DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU10DELT_VARIABLE_TYPE = FIELD_DELU10DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DEL2U10DELT2_VARIABLE_TYPE = FIELD_DEL2U10DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_FieldDataTypes OPENCMISS::Field::DataTypes
  !> \brief Field data types
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_INTG_TYPE = FIELD_INTG_TYPE !<Integer field data type \see OPENCMISS_FieldDataTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_SP_TYPE = FIELD_SP_TYPE !<Single precision real field data type \see OPENCMISS_FieldDataTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DP_TYPE = FIELD_DP_TYPE !<Double precision real field data type \see OPENCMISS_FieldDataTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_L_TYPE = FIELD_L_TYPE !<Logical field data type \see OPENCMISS_FieldDataTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_FieldDOFOrderTypes OPENCMISS::Field::DOFOrderTypes
  !> \brief Field DOF order types
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_SEPARATED_COMPONENT_DOF_ORDER = FIELD_SEPARATED_COMPONENT_DOF_ORDER !<Field variable component dofs are not contiguous \see OPENCMISS_FieldDOFOrderTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER = FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER !<Field variable component dofs are contiguous \see OPENCMISS_FieldDOFOrderTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_FieldParameterSetTypes OPENCMISS::Field::ParameterSetTypes
  !> \brief Field parameter set type parameters
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_VALUES_SET_TYPE = FIELD_VALUES_SET_TYPE !<The parameter set corresponding to the field values (at time T+DT for dynamic problems) \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSBoundaryConditionsSetType = FIELD_BOUNDARY_CONDITIONS_SET_TYPE !<The parameter set corresponding to the field boundary condition values \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_INITIAL_VALUES_SET_TYPE = FIELD_INITIAL_VALUES_SET_TYPE !<The parameter set corresponding to the field initial values \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_INCREMENTAL_VALUES_SET_TYPE = FIELD_INCREMENTAL_VALUES_SET_TYPE !<The parameter set corresponding to the field incremental values \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_ANALYTIC_VALUES_SET_TYPE = FIELD_ANALYTIC_VALUES_SET_TYPE !<The parameter set corresponding to the analytic field values \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_PREVIOUS_VALUES_SET_TYPE = FIELD_PREVIOUS_VALUES_SET_TYPE !<The parameter set corresponding to the previous field values (at time T) \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_MEAN_PREDICTED_DISPLACEMENT_SET_TYPE = FIELD_MEAN_PREDICTED_DISPLACEMENT_SET_TYPE !<The parameter set corresponding to the mean predicited avalues (at time T+DT) \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_VELOCITY_VALUES_SET_TYPE = FIELD_VELOCITY_VALUES_SET_TYPE !<The parameter set corresponding to the velocity values (at time T+DT) \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_INITIAL_VELOCITY_SET_TYPE = FIELD_INITIAL_VELOCITY_SET_TYPE !<The parameter set corresponding to the initial velocity values for dynamic problems. This is also the previous velocity values \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_PREVIOUS_VELOCITY_SET_TYPE = FIELD_PREVIOUS_VELOCITY_SET_TYPE !<The parameter set corresponding to the previous velocity values (at time T). This is also the initial velocity values for dynamic problems. \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_MEAN_PREDICTED_VELOCITY_SET_TYPE = FIELD_MEAN_PREDICTED_VELOCITY_SET_TYPE !<The parameter set corresponding to the mean predicited velocity values (at time T+DT) \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_ACCELERATION_VALUES_SET_TYPE = FIELD_ACCELERATION_VALUES_SET_TYPE !<The parameter set corresponding to the acceleration values (at time T+DT) \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_INITIAL_ACCELERATION_SET_TYPE = FIELD_INITIAL_ACCELERATION_SET_TYPE !<The parameter set corresponding to the initial acceleration values for dynamic problems. This is also the previous accelearation values \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_PREVIOUS_ACCELERATION_SET_TYPE = FIELD_PREVIOUS_ACCELERATION_SET_TYPE !<The parameter set corresponding to the previous acceleration values (at time T).This is also the initial acceleration values for dynamic problems. \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_MEAN_PREDICTED_ACCELERATION_SET_TYPE = FIELD_MEAN_PREDICTED_ACCELERATION_SET_TYPE !<The parameter set corresponding to the mean predicited acceleration values (at time T+DT) \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_PRESSURE_VALUES_SET_TYPE = FIELD_PRESSURE_VALUES_SET_TYPE !<The parameter set corresponding to the surface pressure values. \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_PREVIOUS_PRESSURE_SET_TYPE = FIELD_PREVIOUS_PRESSURE_SET_TYPE !<The parameter set corresponding to the previous surface pressure values (at time T). \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_IMPERMEABLE_FLAG_VALUES_SET_TYPE = FIELD_IMPERMEABLE_FLAG_VALUES_SET_TYPE !<The parameter set corresponding to the impermeable flag values. \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_FieldScalingTypes OPENCMISS::Field::ScalingTypes
  !> \brief Field scaling type parameters
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_NO_SCALING = FIELD_NO_SCALING !<The field is not scaled \see OPENCMISS_FieldScalingTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_UNIT_SCALING = FIELD_UNIT_SCALING !<The field has unit scaling \see OPENCMISS_FieldScalingTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_ARC_LENGTH_SCALING = FIELD_ARC_LENGTH_SCALING !<The field has arc length scaling \see OPENCMISS_FieldScalingTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_ARITHMETIC_MEAN_SCALING = FIELD_ARITHMETIC_MEAN_SCALING !<The field has arithmetic mean of the arc length scaling \see OPENCMISS_FieldScalingTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_GEOMETRIC_MEAN_SCALING = FIELD_GEOMETRIC_MEAN_SCALING !<The field has geometric mean of the arc length scaling \see OPENCMISS_FieldScalingTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_HARMONIC_MEAN_SCALING = FIELD_HARMONIC_MEAN_SCALING !<The field has geometric mean of the arc length scaling \see OPENCMISS_FieldScalingTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Returns the interpolation type for a field variable component.
  INTERFACE CMISSFieldComponentInterpolationGet
    MODULE PROCEDURE CMISSFieldComponentInterpolationGetNumber
    MODULE PROCEDURE CMISSFieldComponentInterpolationGetObj
  END INTERFACE !CMISSFieldComponentInterpolationGet

  !>Sets/changes the interpolation type for a field variable component.
  INTERFACE CMISSFieldComponentInterpolationSet
    MODULE PROCEDURE CMISSFieldComponentInterpolationSetNumber
    MODULE PROCEDURE CMISSFieldComponentInterpolationSetObj
  END INTERFACE !CMISSFieldComponentInterpolationSet

  !>Returns the label for a field variable component.
  INTERFACE CMISSFieldComponentLabelGet
    MODULE PROCEDURE CMISSFieldComponentLabelGetCNumber
    MODULE PROCEDURE CMISSFieldComponentLabelGetCObj
    MODULE PROCEDURE CMISSFieldComponentLabelGetVSNumber
    MODULE PROCEDURE CMISSFieldComponentLabelGetVSObj
  END INTERFACE !CMISSFieldComponentLabelGet

  !>Sets/changes the label for a field variable component.
  INTERFACE CMISSFieldComponentLabelSet
    MODULE PROCEDURE CMISSFieldComponentLabelSetCNumber
    MODULE PROCEDURE CMISSFieldComponentLabelSetCObj
    MODULE PROCEDURE CMISSFieldComponentLabelSetVSNumber
    MODULE PROCEDURE CMISSFieldComponentLabelSetVSObj
  END INTERFACE !CMISSFieldComponentLabelSet

  !>Returns the mesh component number for a field variable component.
  INTERFACE CMISSFieldComponentMeshComponentGet
    MODULE PROCEDURE CMISSFieldComponentMeshComponentGetNumber
    MODULE PROCEDURE CMISSFieldComponentMeshComponentGetObj
  END INTERFACE !CMISSFieldComponentMeshComponentGet

  !>Sets/changes the mesh component number for a field variable component.
  INTERFACE CMISSFieldComponentMeshComponentSet
    MODULE PROCEDURE CMISSFieldComponentMeshComponentSetNumber
    MODULE PROCEDURE CMISSFieldComponentMeshComponentSetObj
  END INTERFACE !CMISSFieldComponentMeshComponentSet

  !>Initialises the values of a parameter set of a field variable component to a constant value.
  INTERFACE CMISSFieldComponentValuesInitialise
    MODULE PROCEDURE CMISSFieldComponentValuesInitialiseIntgNumber
    MODULE PROCEDURE CMISSFieldComponentValuesInitialiseIntgObj
    MODULE PROCEDURE CMISSFieldComponentValuesInitialiseSPNumber
    MODULE PROCEDURE CMISSFieldComponentValuesInitialiseSPObj
    MODULE PROCEDURE CMISSFieldComponentValuesInitialiseDPNumber
    MODULE PROCEDURE CMISSFieldComponentValuesInitialiseDPObj
    MODULE PROCEDURE CMISSFieldComponentValuesInitialiseLNumber
    MODULE PROCEDURE CMISSFieldComponentValuesInitialiseLObj
  END INTERFACE !CMISSFieldComponentValuesInitialise

  !>Returns the data type for a field variable.
  INTERFACE CMISSFieldDataTypeGet
    MODULE PROCEDURE CMISSFieldDataTypeGetNumber
    MODULE PROCEDURE CMISSFieldDataTypeGetObj
  END INTERFACE !CMISSFieldDataTypeGet

  !>Sets/changes the data type for a field variable.
  INTERFACE CMISSFieldDataTypeSet
    MODULE PROCEDURE CMISSFieldDataTypeSetNumber
    MODULE PROCEDURE CMISSFieldDataTypeSetObj
  END INTERFACE !CMISSFieldDataTypeSet

  !>Returns the DOF order type for a field variable.
  INTERFACE CMISSFieldDOFOrderTypeGet
    MODULE PROCEDURE CMISSFieldDOFOrderTypeGetNumber
    MODULE PROCEDURE CMISSFieldDOFOrderTypeGetObj
  END INTERFACE !CMISSFieldDOFOrderTypeGet

  !>Sets/changes the DOF order type for a field variable. Note: for contiguous coponent DOF ordering all the components of the field variable must have the same interpolation type.
  INTERFACE CMISSFieldDOFOrderTypeSet
    MODULE PROCEDURE CMISSFieldDOFOrderTypeSetNumber
    MODULE PROCEDURE CMISSFieldDOFOrderTypeSetObj
  END INTERFACE !CMISSFieldDOFOrderTypeSet

  !>Finishes the creation of a field. \see OPENCMISS::CMISSFieldCreateStart
  INTERFACE CMISSFieldCreateFinish
    MODULE PROCEDURE CMISSFieldCreateFinishNumber
    MODULE PROCEDURE CMISSFieldCreateFinishObj
  END INTERFACE !CMISSFieldCreateFinish

  !>Starts the creation of a field. \see OPENCMISS::CMISSFieldCreateFinish
  INTERFACE CMISSFieldCreateStart
    MODULE PROCEDURE CMISSFieldCreateStartNumber
    MODULE PROCEDURE CMISSFieldCreateStartInterfaceObj
    MODULE PROCEDURE CMISSFieldCreateStartRegionObj
  END INTERFACE !CMISSFieldCreateStart

  !>Returns the dependent type for a field.
  INTERFACE CMISSFieldDependentTypeGet
    MODULE PROCEDURE CMISSFieldDependentTypeGetNumber
    MODULE PROCEDURE CMISSFieldDependentTypeGetObj
  END INTERFACE !CMISSFieldDependentTypeGet

  !>Sets/changes the dependent type for a field.
  INTERFACE CMISSFieldDependentTypeSet
    MODULE PROCEDURE CMISSFieldDependentTypeSetNumber
    MODULE PROCEDURE CMISSFieldDependentTypeSetObj
  END INTERFACE !CMISSFieldDependentTypeSet

  !>Destroys a field.
  INTERFACE CMISSFieldDestroy
    MODULE PROCEDURE CMISSFieldDestroyNumber
    MODULE PROCEDURE CMISSFieldDestroyObj
  END INTERFACE !CMISSFieldDestroy

  !>Returns the field dimension for a field variable.
  INTERFACE CMISSFieldDimensionGet
    MODULE PROCEDURE CMISSFieldDimensionGetNumber
    MODULE PROCEDURE CMISSFieldDimensionGetObj
  END INTERFACE !CMISSFieldDimensionGet

  !>Sets/changes the field dimension for a field variable.
  INTERFACE CMISSFieldDimensionSet
    MODULE PROCEDURE CMISSFieldDimensionSetNumber
    MODULE PROCEDURE CMISSFieldDimensionSetObj
  END INTERFACE !CMISSFieldDimensionSet

  !>Returns the geometric field for a field.
  INTERFACE CMISSFieldGeometricFieldGet
    MODULE PROCEDURE CMISSFieldGeometricFieldGetNumber
    MODULE PROCEDURE CMISSFieldGeometricFieldGetObj
  END INTERFACE !CMISSFieldGeometricFieldGet

  !>Sets/changes the geometric field for a field.
  INTERFACE CMISSFieldGeometricFieldSet
    MODULE PROCEDURE CMISSFieldGeometricFieldSetNumber
    MODULE PROCEDURE CMISSFieldGeometricFieldSetObj
  END INTERFACE !CMISSFieldGeometricFieldSet

 !>Returns the label for a field.
  INTERFACE CMISSFieldLabelGet
    MODULE PROCEDURE CMISSFieldLabelGetCNumber
    MODULE PROCEDURE CMISSFieldLabelGetCObj
    MODULE PROCEDURE CMISSFieldLabelGetVSNumber
    MODULE PROCEDURE CMISSFieldLabelGetVSObj
  END INTERFACE !CMISSFieldLabelGet

  !>Sets/changes the label for a field.
  INTERFACE CMISSFieldLabelSet
    MODULE PROCEDURE CMISSFieldLabelSetCNumber
    MODULE PROCEDURE CMISSFieldLabelSetCObj
    MODULE PROCEDURE CMISSFieldLabelSetVSNumber
    MODULE PROCEDURE CMISSFieldLabelSetVSObj
  END INTERFACE !CMISSFieldLabelSet

  INTERFACE CMISSFieldPositionNormalTangentCalculateNode
    MODULE PROCEDURE CMISSFieldPositionNormalTangentCalculateNodeNumber
    MODULE PROCEDURE CMISSFieldPositionNormalTangentCalculateNodeObj
  END INTERFACE

  !>Returns the mesh decomposition for a field.
  INTERFACE CMISSFieldMeshDecompositionGet
    MODULE PROCEDURE CMISSFieldMeshDecompositionGetNumber
    MODULE PROCEDURE CMISSFieldMeshDecompositionGetObj
  END INTERFACE !CMISSFieldMeshDecompositionGet

  !>Sets/changes the mesh decomposition for a field. \todo remove when fields take decomposition argument on creation???
  INTERFACE CMISSFieldMeshDecompositionSet
    MODULE PROCEDURE CMISSFieldMeshDecompositionSetNumber
    MODULE PROCEDURE CMISSFieldMeshDecompositionSetObj
  END INTERFACE !CMISSFieldMeshDecompositionSet

  !>Returns the number of field components for a field variable.
  INTERFACE CMISSFieldNumberOfComponentsGet
    MODULE PROCEDURE CMISSFieldNumberOfComponentsGetNumber
    MODULE PROCEDURE CMISSFieldNumberOfComponentsGetObj
  END INTERFACE !CMISSFieldNumberOfComponentsGet

  !>Sets/changes the number of field components for a field variable.
  INTERFACE CMISSFieldNumberOfComponentsSet
    MODULE PROCEDURE CMISSFieldNumberOfComponentsSetNumber
    MODULE PROCEDURE CMISSFieldNumberOfComponentsSetObj
  END INTERFACE !CMISSFieldNumberOfComponentsSet

  !>Returns the number of field variables for a field.
  INTERFACE CMISSFieldNumberOfVariablesGet
    MODULE PROCEDURE CMISSFieldNumberOfVariablesGetNumber
    MODULE PROCEDURE CMISSFieldNumberOfVariablesGetObj
  END INTERFACE !CMISSFieldNumberOfVariablesGet

  !>Sets/changes the number of field variables for a field.
  INTERFACE CMISSFieldNumberOfVariablesSet
    MODULE PROCEDURE CMISSFieldNumberOfVariablesSetNumber
    MODULE PROCEDURE CMISSFieldNumberOfVariablesSetObj
  END INTERFACE !CMISSFieldNumberOfVariablesSet

  !>Adds the given value to the given parameter set for the constant of the field variable component.
  INTERFACE CMISSFieldParameterSetAddConstant
    MODULE PROCEDURE CMISSFieldParameterSetAddConstantIntgNumber
    MODULE PROCEDURE CMISSFieldParameterSetAddConstantIntgObj
    MODULE PROCEDURE CMISSFieldParameterSetAddConstantSPNumber
    MODULE PROCEDURE CMISSFieldParameterSetAddConstantSPObj
    MODULE PROCEDURE CMISSFieldParameterSetAddConstantDPNumber
    MODULE PROCEDURE CMISSFieldParameterSetAddConstantDPObj
    MODULE PROCEDURE CMISSFieldParameterSetAddConstantLNumber
    MODULE PROCEDURE CMISSFieldParameterSetAddConstantLObj
  END INTERFACE !CMISSFieldParameterSetAddConstant

  !>Adds the given value to the given parameter set for a particular user element of the field variable component.
  INTERFACE CMISSFieldParameterSetAddElement
    MODULE PROCEDURE CMISSFieldParameterSetAddElementIntgNumber
    MODULE PROCEDURE CMISSFieldParameterSetAddElementIntgObj
    MODULE PROCEDURE CMISSFieldParameterSetAddElementSPNumber
    MODULE PROCEDURE CMISSFieldParameterSetAddElementSPObj
    MODULE PROCEDURE CMISSFieldParameterSetAddElementDPNumber
    MODULE PROCEDURE CMISSFieldParameterSetAddElementDPObj
    MODULE PROCEDURE CMISSFieldParameterSetAddElementLNumber
    MODULE PROCEDURE CMISSFieldParameterSetAddElementLObj
  END INTERFACE !CMISSFieldParameterSetAddElement

  !>Adds the given value to the given parameter set for a particular user node of the field variable component.
  INTERFACE CMISSFieldParameterSetAddNode
    MODULE PROCEDURE CMISSFieldParameterSetAddNodeIntgNumber
    MODULE PROCEDURE CMISSFieldParameterSetAddNodeIntgObj
    MODULE PROCEDURE CMISSFieldParameterSetAddNodeSPNumber
    MODULE PROCEDURE CMISSFieldParameterSetAddNodeSPObj
    MODULE PROCEDURE CMISSFieldParameterSetAddNodeDPNumber
    MODULE PROCEDURE CMISSFieldParameterSetAddNodeDPObj
    MODULE PROCEDURE CMISSFieldParameterSetAddNodeLNumber
    MODULE PROCEDURE CMISSFieldParameterSetAddNodeLObj
  END INTERFACE !CMISSFieldParameterSetAddNode

  !>Creates a new parameter set of type set type for a field variable.
  INTERFACE CMISSFieldParameterSetCreate
    MODULE PROCEDURE CMISSFieldParameterSetCreateNumber
    MODULE PROCEDURE CMISSFieldParameterSetCreateObj
  END INTERFACE !CMISSFieldParameterSetCreate

  !>Destroy a parameter set of type set type for a field variable.
  INTERFACE CMISSFieldParameterSetDestroy
    MODULE PROCEDURE CMISSFieldParameterSetDestroyNumber
    MODULE PROCEDURE CMISSFieldParameterSetDestroyObj
  END INTERFACE !CMISSFieldParameterSetCreate

  !>Returns a pointer to the specified field parameter set local data array. The pointer must be restored with a call to OPENCMISS::CMISSFieldParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  INTERFACE CMISSFieldParameterSetDataGet
    MODULE PROCEDURE CMISSFieldParameterSetDataGetIntgNumber
    MODULE PROCEDURE CMISSFieldParameterSetDataGetIntgObj
    MODULE PROCEDURE CMISSFieldParameterSetDataGetSPNumber
    MODULE PROCEDURE CMISSFieldParameterSetDataGetSPObj
    MODULE PROCEDURE CMISSFieldParameterSetDataGetDPNumber
    MODULE PROCEDURE CMISSFieldParameterSetDataGetDPObj
    MODULE PROCEDURE CMISSFieldParameterSetDataGetLNumber
    MODULE PROCEDURE CMISSFieldParameterSetDataGetLObj
  END INTERFACE !CMISSFieldParameterSetDataGet

  !>Restores the specified field variable parameter set local array that was obtained with an OPENCMISS::CMISSFieldParameterSetDataGet call.
  INTERFACE CMISSFieldParameterSetDataRestore
    MODULE PROCEDURE CMISSFieldParameterSetDataRestoreIntgNumber
    MODULE PROCEDURE CMISSFieldParameterSetDataRestoreIntgObj
    MODULE PROCEDURE CMISSFieldParameterSetDataRestoreSPNumber
    MODULE PROCEDURE CMISSFieldParameterSetDataRestoreSPObj
    MODULE PROCEDURE CMISSFieldParameterSetDataRestoreDPNumber
    MODULE PROCEDURE CMISSFieldParameterSetDataRestoreDPObj
    MODULE PROCEDURE CMISSFieldParameterSetDataRestoreLNumber
    MODULE PROCEDURE CMISSFieldParameterSetDataRestoreLObj
  END INTERFACE !CMISSFieldParameterSetDataRestore

  !>Returns from the given parameter set a value for the specified constant of a field variable component.
  INTERFACE CMISSFieldParameterSetGetConstant
    MODULE PROCEDURE CMISSFieldParameterSetGetConstantIntgNumber
    MODULE PROCEDURE CMISSFieldParameterSetGetConstantIntgObj
    MODULE PROCEDURE CMISSFieldParameterSetGetConstantSPNumber
    MODULE PROCEDURE CMISSFieldParameterSetGetConstantSPObj
    MODULE PROCEDURE CMISSFieldParameterSetGetConstantDPNumber
    MODULE PROCEDURE CMISSFieldParameterSetGetConstantDPObj
    MODULE PROCEDURE CMISSFieldParameterSetGetConstantLNumber
    MODULE PROCEDURE CMISSFieldParameterSetGetConstantLObj
  END INTERFACE !CMISSFieldParameterSetGetConstant

  !>Returns from the given parameter set a value for the specified element of a field variable component.
  INTERFACE CMISSFieldParameterSetGetElement
    MODULE PROCEDURE CMISSFieldParameterSetGetElementIntgNumber
    MODULE PROCEDURE CMISSFieldParameterSetGetElementIntgObj
    MODULE PROCEDURE CMISSFieldParameterSetGetElementSPNumber
    MODULE PROCEDURE CMISSFieldParameterSetGetElementSPObj
    MODULE PROCEDURE CMISSFieldParameterSetGetElementDPNumber
    MODULE PROCEDURE CMISSFieldParameterSetGetElementDPObj
    MODULE PROCEDURE CMISSFieldParameterSetGetElementLNumber
    MODULE PROCEDURE CMISSFieldParameterSetGetElementLObj
  END INTERFACE !CMISSFieldParameterSetGetElement

  !>Returns from the given parameter set a value for the specified node and derivative of a field variable component.
  INTERFACE CMISSFieldParameterSetGetNode
    MODULE PROCEDURE CMISSFieldParameterSetGetNodeIntgNumber
    MODULE PROCEDURE CMISSFieldParameterSetGetNodeIntgObj
    MODULE PROCEDURE CMISSFieldParameterSetGetNodeSPNumber
    MODULE PROCEDURE CMISSFieldParameterSetGetNodeSPObj
    MODULE PROCEDURE CMISSFieldParameterSetGetNodeDPNumber
    MODULE PROCEDURE CMISSFieldParameterSetGetNodeDPObj
    MODULE PROCEDURE CMISSFieldParameterSetGetNodeLNumber
    MODULE PROCEDURE CMISSFieldParameterSetGetNodeLObj
  END INTERFACE !CMISSFieldParameterSetGetNode

  !>Returns from the given parameter set a value for the specified element and Gauss point of a field variable component.
  INTERFACE CMISSFieldParameterSetGetGaussPoint ! TODO: other versions
    MODULE PROCEDURE CMISSFieldParameterSetGetGaussPointDPObj
  END INTERFACE !CMISSFieldParameterSetGetGaussPoint

  !>Updates the given parameter set with the given value for the constant of a field variable component.
  INTERFACE CMISSFieldParameterSetUpdateConstant
    MODULE PROCEDURE CMISSFieldParameterSetUpdateConstantIntgNumber
    MODULE PROCEDURE CMISSFieldParameterSetUpdateConstantIntgObj
    MODULE PROCEDURE CMISSFieldParameterSetUpdateConstantSPNumber
    MODULE PROCEDURE CMISSFieldParameterSetUpdateConstantSPObj
    MODULE PROCEDURE CMISSFieldParameterSetUpdateConstantDPNumber
    MODULE PROCEDURE CMISSFieldParameterSetUpdateConstantDPObj
    MODULE PROCEDURE CMISSFieldParameterSetUpdateConstantLNumber
    MODULE PROCEDURE CMISSFieldParameterSetUpdateConstantLObj
  END INTERFACE !CMISSFieldParameterSetUpdateConstant

  !>Updates the given parameter set with the given value for a particular user element of a field variable component.
  INTERFACE CMISSFieldParameterSetUpdateElement
    MODULE PROCEDURE CMISSFieldParameterSetUpdateElementIntgNumber
    MODULE PROCEDURE CMISSFieldParameterSetUpdateElementIntgObj
    MODULE PROCEDURE CMISSFieldParameterSetUpdateElementSPNumber
    MODULE PROCEDURE CMISSFieldParameterSetUpdateElementSPObj
    MODULE PROCEDURE CMISSFieldParameterSetUpdateElementDPNumber
    MODULE PROCEDURE CMISSFieldParameterSetUpdateElementDPObj
    MODULE PROCEDURE CMISSFieldParameterSetUpdateElementLNumber
    MODULE PROCEDURE CMISSFieldParameterSetUpdateElementLObj
  END INTERFACE !CMISSFieldParameterSetUpdateElement

  !>Finishes the parameter set update for a field variable. \see OPENCMISS::CMISSFieldParameterSetUpdateStart
  INTERFACE CMISSFieldParameterSetUpdateFinish
    MODULE PROCEDURE CMISSFieldParameterSetUpdateFinishNumber
    MODULE PROCEDURE CMISSFieldParameterSetUpdateFinishObj
  END INTERFACE !CMISSFieldParameterSetUpdateFinish

  !>Updates the given parameter set with the given value for a particular user node of a field variable component.
  INTERFACE CMISSFieldParameterSetUpdateNode
    MODULE PROCEDURE CMISSFieldParameterSetUpdateNodeIntgNumber
    MODULE PROCEDURE CMISSFieldParameterSetUpdateNodeIntgObj
    MODULE PROCEDURE CMISSFieldParameterSetUpdateNodeSPNumber
    MODULE PROCEDURE CMISSFieldParameterSetUpdateNodeSPObj
    MODULE PROCEDURE CMISSFieldParameterSetUpdateNodeDPNumber
    MODULE PROCEDURE CMISSFieldParameterSetUpdateNodeDPObj
    MODULE PROCEDURE CMISSFieldParameterSetUpdateNodeLNumber
    MODULE PROCEDURE CMISSFieldParameterSetUpdateNodeLObj
  END INTERFACE !CMISSFieldParameterSetUpdateNode

  !>Updates the given parameter set with the given value for a particular gauss point of a field variable component.
  INTERFACE CMISSFieldParameterSetUpdateGaussPoint
    MODULE PROCEDURE CMISSFieldParameterSetUpdateGaussPointDPObj
  END INTERFACE !CMISSFieldParameterSetUpdateNode


  !>Starts the parameter set update for a field variable. \see OPENCMISS::CMISSFieldParameterSetUpdateFinish
  INTERFACE CMISSFieldParameterSetUpdateStart
    MODULE PROCEDURE CMISSFieldParameterSetUpdateStartNumber
    MODULE PROCEDURE CMISSFieldParameterSetUpdateStartObj
  END INTERFACE !CMISSFieldParameterSetUpdateStart

  !>Copy the parameters from the parameter set of a component of a field variable to the paramters of a parameter set of
  !>a component of another field variable.
  INTERFACE CMISSFieldParametersToFieldParametersComponentCopy
    MODULE PROCEDURE CMISSFieldParametersToFieldParametersComponentCopyNumber
    MODULE PROCEDURE CMISSFieldParametersToFieldParametersComponentCopyObj
  END INTERFACE !CMISSFieldParametersToFieldParametersComponentCopy

  !>Returns the scaling type for a field.
  INTERFACE CMISSFieldScalingTypeGet
    MODULE PROCEDURE CMISSFieldScalingTypeGetNumber
    MODULE PROCEDURE CMISSFieldScalingTypeGetObj
  END INTERFACE !CMISSFieldScalingTypeGet

  !>Sets/changes the scaling type for a field.
  INTERFACE CMISSFieldScalingTypeSet
    MODULE PROCEDURE CMISSFieldScalingTypeSetNumber
    MODULE PROCEDURE CMISSFieldScalingTypeSetObj
  END INTERFACE !CMISSFieldScalingTypeSet

  !>Returns the type for a field.
  INTERFACE CMISSFieldTypeGet
    MODULE PROCEDURE CMISSFieldTypeGetNumber
    MODULE PROCEDURE CMISSFieldTypeGetObj
  END INTERFACE !CMISSFieldTypeGet

  !>Sets/changes the type for a field.
  INTERFACE CMISSFieldTypeSet
    MODULE PROCEDURE CMISSFieldTypeSetNumber
    MODULE PROCEDURE CMISSFieldTypeSetObj
  END INTERFACE !CMISSFieldTypeSet

  !>Returns the label for a field variable.
  INTERFACE CMISSFieldVariableLabelGet
    MODULE PROCEDURE CMISSFieldVariableLabelGetCNumber
    MODULE PROCEDURE CMISSFieldVariableLabelGetCObj
    MODULE PROCEDURE CMISSFieldVariableLabelGetVSNumber
    MODULE PROCEDURE CMISSFieldVariableLabelGetVSObj
  END INTERFACE !CMISSFieldVariableLabelGet

  !>Sets/changes the label for a field variable.
  INTERFACE CMISSFieldVariableLabelSet
    MODULE PROCEDURE CMISSFieldVariableLabelSetCNumber
    MODULE PROCEDURE CMISSFieldVariableLabelSetCObj
    MODULE PROCEDURE CMISSFieldVariableLabelSetVSNumber
    MODULE PROCEDURE CMISSFieldVariableLabelSetVSObj
  END INTERFACE !CMISSFieldVariableLabelSet

  !>Returns the field variable types for a field.
  INTERFACE CMISSFieldVariableTypesGet
    MODULE PROCEDURE CMISSFieldVariableTypesGetNumber
    MODULE PROCEDURE CMISSFieldVariableTypesGetObj
  END INTERFACE !CMISSFieldVariableTypesGet

  !>Sets/changes the field variable types for a field.
  INTERFACE CMISSFieldVariableTypesSet
    MODULE PROCEDURE CMISSFieldVariableTypesSetNumber
    MODULE PROCEDURE CMISSFieldVariableTypesSetObj
  END INTERFACE !CMISSFieldVariableTypesSet


  PUBLIC CMISS_FIELD_DEPENDENT_TYPE,CMISS_FIELD_INDEPENDENT_TYPE

  PUBLIC CMISS_FIELD_SCALAR_DIMENSION_TYPE,CMISS_FIELD_VECTOR_DIMENSION_TYPE,CMISS_FIELD_TENSOR_DIMENSION_TYPE

  PUBLIC CMISS_FIELD_GEOMETRIC_TYPE,CMISS_FIELD_FIBRE_TYPE,CMISS_FIELD_GENERAL_TYPE,CMISS_FIELD_MATERIAL_TYPE

  PUBLIC CMISS_FIELD_CONSTANT_INTERPOLATION,CMISS_FIELD_ELEMENT_BASED_INTERPOLATION,CMISS_FIELD_NODE_BASED_INTERPOLATION, &
    & CMISS_FIELD_GRID_POINT_BASED_INTERPOLATION,CMISS_FIELD_GAUSS_POINT_BASED_INTERPOLATION

  PUBLIC CMISS_FIELD_NUMBER_OF_VARIABLE_SUBTYPES

  PUBLIC CMISS_FIELD_U_VARIABLE_TYPE,CMISS_FIELD_DELUDELN_VARIABLE_TYPE,CMISS_FIELD_DELUDELT_VARIABLE_TYPE, &
    & CMISS_FIELD_DEL2UDELT2_VARIABLE_TYPE, &
    & CMISS_FIELD_V_VARIABLE_TYPE,CMISS_FIELD_DELVDELN_VARIABLE_TYPE,CMISS_FIELD_DELVDELT_VARIABLE_TYPE, &
    & CMISS_FIELD_DEL2VDELT2_VARIABLE_TYPE, &
    & CMISS_FIELD_U1_VARIABLE_TYPE,CMISS_FIELD_DELU1DELN_VARIABLE_TYPE,CMISS_FIELD_DELU1DELT_VARIABLE_TYPE, &
    & CMISS_FIELD_DEL2U1DELT2_VARIABLE_TYPE, &
    & CMISS_FIELD_U2_VARIABLE_TYPE,CMISS_FIELD_DELU2DELN_VARIABLE_TYPE,CMISS_FIELD_DELU2DELT_VARIABLE_TYPE, &
    & CMISS_FIELD_DEL2U2DELT2_VARIABLE_TYPE, &
    & CMISS_FIELD_U3_VARIABLE_TYPE,CMISS_FIELD_DELU3DELN_VARIABLE_TYPE,CMISS_FIELD_DELU3DELT_VARIABLE_TYPE, &
    & CMISS_FIELD_DEL2U3DELT2_VARIABLE_TYPE, &
    & CMISS_FIELD_U4_VARIABLE_TYPE,CMISS_FIELD_DELU4DELN_VARIABLE_TYPE,CMISS_FIELD_DELU4DELT_VARIABLE_TYPE, &
    & CMISS_FIELD_DEL2U4DELT2_VARIABLE_TYPE, &
    & CMISS_FIELD_U5_VARIABLE_TYPE,CMISS_FIELD_DELU5DELN_VARIABLE_TYPE,CMISS_FIELD_DELU5DELT_VARIABLE_TYPE, &
    & CMISS_FIELD_DEL2U5DELT2_VARIABLE_TYPE, &
    & CMISS_FIELD_U6_VARIABLE_TYPE,CMISS_FIELD_DELU6DELN_VARIABLE_TYPE,CMISS_FIELD_DELU6DELT_VARIABLE_TYPE, &
    & CMISS_FIELD_DEL2U6DELT2_VARIABLE_TYPE, &
    & CMISS_FIELD_U7_VARIABLE_TYPE,CMISS_FIELD_DELU7DELN_VARIABLE_TYPE,CMISS_FIELD_DELU7DELT_VARIABLE_TYPE, &
    & CMISS_FIELD_DEL2U7DELT2_VARIABLE_TYPE, &
    & CMISS_FIELD_U8_VARIABLE_TYPE,CMISS_FIELD_DELU8DELN_VARIABLE_TYPE,CMISS_FIELD_DELU8DELT_VARIABLE_TYPE, &
    & CMISS_FIELD_DEL2U8DELT2_VARIABLE_TYPE, &
    & CMISS_FIELD_U9_VARIABLE_TYPE,CMISS_FIELD_DELU9DELN_VARIABLE_TYPE,CMISS_FIELD_DELU9DELT_VARIABLE_TYPE, &
    & CMISS_FIELD_DEL2U9DELT2_VARIABLE_TYPE, &
    & CMISS_FIELD_U10_VARIABLE_TYPE,CMISS_FIELD_DELU10DELN_VARIABLE_TYPE,CMISS_FIELD_DELU10DELT_VARIABLE_TYPE, &
    & CMISS_FIELD_DEL2U10DELT2_VARIABLE_TYPE

  PUBLIC CMISS_FIELD_INTG_TYPE,CMISS_FIELD_SP_TYPE,CMISS_FIELD_DP_TYPE,CMISS_FIELD_L_TYPE

  PUBLIC CMISS_FIELD_SEPARATED_COMPONENT_DOF_ORDER,CMISS_FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER

  PUBLIC CMISS_FIELD_VALUES_SET_TYPE,CMISS_FIELD_INITIAL_VALUES_SET_TYPE,CMISS_FIELD_INCREMENTAL_VALUES_SET_TYPE, &
    & CMISS_FIELD_ANALYTIC_VALUES_SET_TYPE, &
    & CMISS_FIELD_PREVIOUS_VALUES_SET_TYPE,CMISS_FIELD_MEAN_PREDICTED_DISPLACEMENT_SET_TYPE,CMISS_FIELD_VELOCITY_VALUES_SET_TYPE, &
    & CMISS_FIELD_INITIAL_VELOCITY_SET_TYPE,CMISS_FIELD_PREVIOUS_VELOCITY_SET_TYPE,CMISS_FIELD_MEAN_PREDICTED_VELOCITY_SET_TYPE, &
    & CMISS_FIELD_ACCELERATION_VALUES_SET_TYPE,CMISS_FIELD_INITIAL_ACCELERATION_SET_TYPE, &
    & CMISS_FIELD_PREVIOUS_ACCELERATION_SET_TYPE, &
    & CMISS_FIELD_MEAN_PREDICTED_ACCELERATION_SET_TYPE, CMISS_FIELD_PRESSURE_VALUES_SET_TYPE, &
    & CMISS_FIELD_PREVIOUS_PRESSURE_SET_TYPE, &
    & CMISS_FIELD_IMPERMEABLE_FLAG_VALUES_SET_TYPE

  PUBLIC CMISS_FIELD_NO_SCALING,CMISS_FIELD_UNIT_SCALING,CMISS_FIELD_ARC_LENGTH_SCALING,CMISS_FIELD_ARITHMETIC_MEAN_SCALING, &
    & CMISS_FIELD_GEOMETRIC_MEAN_SCALING,CMISS_FIELD_HARMONIC_MEAN_SCALING

  PUBLIC CMISSFieldComponentInterpolationGet,CMISSFieldComponentInterpolationSet

  PUBLIC CMISSFieldComponentLabelGet,CMISSFieldComponentLabelSet

  PUBLIC CMISSFieldComponentMeshComponentGet,CMISSFieldComponentMeshComponentSet

  PUBLIC CMISSFieldComponentValuesInitialise

  PUBLIC CMISSFieldDataTypeGet,CMISSFieldDataTypeSet

  PUBLIC CMISSFieldDOFOrderTypeGet,CMISSFieldDOFOrderTypeSet

  PUBLIC CMISSFieldCreateFinish,CMISSFieldCreateStart

  PUBLIC CMISSFieldDependentTypeGet,CMISSFieldDependentTypeSet

  PUBLIC CMISSFieldDestroy

  PUBLIC CMISSFieldDimensionGet,CMISSFieldDimensionSet

  PUBLIC CMISSFieldGeometricFieldGet,CMISSFieldGeometricFieldSet

  PUBLIC CMISSFieldLabelGet,CMISSFieldLabelSet

  PUBLIC CMISSFieldMeshDecompositionGet,CMISSFieldMeshDecompositionSet

  PUBLIC CMISSFieldPositionNormalTangentCalculateNode

  PUBLIC CMISSFieldNumberOfComponentsGet,CMISSFieldNumberOfComponentsSet

  PUBLIC CMISSFieldNumberOfVariablesGet,CMISSFieldNumberOfVariablesSet

  PUBLIC CMISSFieldParameterSetAddConstant,CMISSFieldParameterSetAddElement,CMISSFieldParameterSetAddNode

  PUBLIC CMISSFieldParameterSetCreate

  PUBLIC CMISSFieldParameterSetDestroy

  PUBLIC CMISSFieldParameterSetDataGet,CMISSFieldParameterSetDataRestore

  PUBLIC CMISSFieldParameterSetGetConstant,CMISSFieldParameterSetGetElement,CMISSFieldParameterSetGetNode

  PUBLIC CMISSFieldParameterSetUpdateConstant,CMISSFieldParameterSetUpdateElement,CMISSFieldParameterSetUpdateNode
  PUBLIC CMISSFieldParameterSetUpdateGaussPoint, CMISSFieldParameterSetGetGaussPoint

  PUBLIC CMISSFieldParameterSetUpdateFinish,CMISSFieldParameterSetUpdateStart

  PUBLIC CMISSFieldParametersToFieldParametersComponentCopy

  PUBLIC CMISSFieldScalingTypeGet,CMISSFieldScalingTypeSet

  PUBLIC CMISSFieldTypeGet,CMISSFieldTypeSet

  PUBLIC CMISSFieldVariableLabelGet,CMISSFieldVariableLabelSet

  PUBLIC CMISSFieldVariableTypesGet,CMISSFieldVariableTypesSet

!!==================================================================================================================================
!!
!! FIELD_IO_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  INTERFACE CMISSFieldIOElementsExport
    MODULE PROCEDURE CMISSFieldIOElementsExportCCObj
    MODULE PROCEDURE CMISSFieldIOElementsExportVSCObj
    MODULE PROCEDURE CMISSFieldIOElementsExportCVSObj
    MODULE PROCEDURE CMISSFieldIOElementsExportVSVSObj
  END INTERFACE !CMISSFieldIOElementsExport

  INTERFACE CMISSFieldIONodesExport
    MODULE PROCEDURE CMISSFieldIONodesExportCCObj
    MODULE PROCEDURE CMISSFieldIONodesExportVSCObj
    MODULE PROCEDURE CMISSFieldIONodesExportCVSObj
    MODULE PROCEDURE CMISSFieldIONodesExportVSVSObj
  END INTERFACE !CMISSFieldIONodesExport

  PUBLIC CMISSFieldIOElementsExport,CMISSFieldIONodesExport

!!==================================================================================================================================
!!
!! GENERATED_MESH_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_GeneratedMeshConstants OPENCMISS::GeneratedMesh::Constants
  !> \brief Generated mesh constants.
  !>@{
  !> \addtogroup OPENCMISS_GeneratedMeshTypes OPENCMISS::GeneratedMesh::Types
  !> \brief Generated mesh types.
  !> \see OPENCMISS::GeneratedMesh,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_REGULAR_MESH_TYPE = GENERATED_MESH_REGULAR_MESH_TYPE !<A regular generated mesh. \see OPENCMISS_GeneratedMeshTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_POLAR_MESH_TYPE = GENERATED_MESH_POLAR_MESH_TYPE !<A polar generated mesh. \see OPENCMISS_GeneratedMeshTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_FRACTAL_TREE_MESH_TYPE = GENERATED_MESH_FRACTAL_TREE_MESH_TYPE !<A fractal tree generated mesh. \see OPENCMISS_GeneratedMeshTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_CYLINDER_MESH_TYPE = GENERATED_MESH_CYLINDER_MESH_TYPE !<A cylinder generated mesh. \see OPENCMISS_GeneratedMeshTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_ELLIPSOID_MESH_TYPE = GENERATED_MESH_ELLIPSOID_MESH_TYPE !<An ellipsoid generated mesh. \see OPENCMISS_GeneratedMeshTypes,OPENCMISS
  !>@}
  !>@}

  !> \addtogroup OPENCMISS_GeneratedMeshConstants OPENCMISS::GeneratedMesh::Constants
  !> \brief Generated mesh constants.
  !>@{
  !> \addtogroup OPENCMISS_GeneratedMeshSurfaceTypes OPENCMISS::GeneratedMesh::SurfaceTypes
  !> \brief Generated mesh surface types.
  !> \see OPENCMISS::GeneratedMesh,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_CYLINDER_INNER_SURFACE = GENERATED_MESH_CYLINDER_INNER_SURFACE !<Cylinder inner surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_CYLINDER_OUTER_SURFACE = GENERATED_MESH_CYLINDER_OUTER_SURFACE !<Cylinder outer surface. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_CYLINDER_TOP_SURFACE = GENERATED_MESH_CYLINDER_TOP_SURFACE !<Cylinder top surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_CYLINDER_BOTTOM_SURFACE = GENERATED_MESH_CYLINDER_BOTTOM_SURFACE !<Cylinder bottom surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_ELLIPSOID_INNER_SURFACE = GENERATED_MESH_ELLIPSOID_INNER_SURFACE !<Ellipsoid inner surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_ELLIPSOID_OUTER_SURFACE = GENERATED_MESH_ELLIPSOID_OUTER_SURFACE !<Ellipsoid outer surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_ELLIPSOID_TOP_SURFACE = GENERATED_MESH_ELLIPSOID_TOP_SURFACE !<Ellipsoid top surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_REGULAR_LEFT_SURFACE = GENERATED_MESH_REGULAR_LEFT_SURFACE !<Regular left surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_REGULAR_RIGHT_SURFACE = GENERATED_MESH_REGULAR_RIGHT_SURFACE !<Regular right surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_REGULAR_TOP_SURFACE = GENERATED_MESH_REGULAR_TOP_SURFACE !<Regular top surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_REGULAR_BOTTOM_SURFACE = GENERATED_MESH_REGULAR_BOTTOM_SURFACE !<Regular bottom surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_REGULAR_FRONT_SURFACE = GENERATED_MESH_REGULAR_FRONT_SURFACE !<Regular front surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_REGULAR_BACK_SURFACE = GENERATED_MESH_REGULAR_BACK_SURFACE !<Regular back surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Returns the basis for a generated mesh.
  INTERFACE CMISSGeneratedMeshBasisGet
    MODULE PROCEDURE CMISSGeneratedMeshBasisGetNumber
    MODULE PROCEDURE CMISSGeneratedMeshBasisGetObj
  END INTERFACE !CMISSGeneratedMeshBasisGet

  !>Sets/changes the basis for a generated mesh.
  INTERFACE CMISSGeneratedMeshBasisSet
    MODULE PROCEDURE CMISSGeneratedMeshBasisSetNumber0
    MODULE PROCEDURE CMISSGeneratedMeshBasisSetNumber1
    MODULE PROCEDURE CMISSGeneratedMeshBasisSetObj0
    MODULE PROCEDURE CMISSGeneratedMeshBasisSetObj1
  END INTERFACE !CMISSGeneratedMeshBasisSet

  !>Sets/changes the base vectors for a generated mesh.
  INTERFACE CMISSGeneratedMeshBaseVectorsSet
    MODULE PROCEDURE CMISSGeneratedMeshBaseVectorsSetNumber
    MODULE PROCEDURE CMISSGeneratedMeshBaseVectorsSetObj
  END INTERFACE !CMISSGeneratedMeshBaseVectorsSet

  !>Finishes the creation of a generated mesh. \see OPENCMISS::CMISSGeneratedMeshCreateStart
  INTERFACE CMISSGeneratedMeshCreateFinish
    MODULE PROCEDURE CMISSGeneratedMeshCreateFinishNumber
    MODULE PROCEDURE CMISSGeneratedMeshCreateFinishObj
  END INTERFACE !CMISSGeneratedMeshCreateFinish

  !>Starts the creation of a generated mesh. \see OPENCMISS::CMISSGeneratedMeshCreateFinish
  INTERFACE CMISSGeneratedMeshCreateStart
    MODULE PROCEDURE CMISSGeneratedMeshCreateStartNumber
    MODULE PROCEDURE CMISSGeneratedMeshCreateStartInterfaceObj
    MODULE PROCEDURE CMISSGeneratedMeshCreateStartRegionObj
  END INTERFACE !CMISSGeneratedMeshCreateStart

  !>Destroys a generated mesh.
  INTERFACE CMISSGeneratedMeshDestroy
    MODULE PROCEDURE CMISSGeneratedMeshDestroyNumber
    MODULE PROCEDURE CMISSGeneratedMeshDestroyObj
  END INTERFACE !CMISSGeneratedMeshDestroy

  !>Returns the extent of a generated mesh.
  INTERFACE CMISSGeneratedMeshExtentGet
    MODULE PROCEDURE CMISSGeneratedMeshExtentGetNumber
    MODULE PROCEDURE CMISSGeneratedMeshExtentGetObj
  END INTERFACE !CMISSGeneratedMeshExtentGet

  !>Sets/changes the extent of a generated mesh.
  INTERFACE CMISSGeneratedMeshExtentSet
    MODULE PROCEDURE CMISSGeneratedMeshExtentSetNumber
    MODULE PROCEDURE CMISSGeneratedMeshExtentSetObj
  END INTERFACE !CMISSGeneratedMeshExtentSet

  !>Returns the number of elements in a generated mesh.
  INTERFACE CMISSGeneratedMeshNumberOfElementsGet
    MODULE PROCEDURE CMISSGeneratedMeshNumberOfElementsGetNumber
    MODULE PROCEDURE CMISSGeneratedMeshNumberOfElementsGetObj
  END INTERFACE !CMISSGeneratedMeshNumberOfElementsGet

  !>Sets/changes the number of elements in a generated mesh.
  INTERFACE CMISSGeneratedMeshNumberOfElementsSet
    MODULE PROCEDURE CMISSGeneratedMeshNumberOfElementsSetNumber
    MODULE PROCEDURE CMISSGeneratedMeshNumberOfElementsSetObj
  END INTERFACE !CMISSGeneratedMeshNumberOfElementsSet

  !>Returns the origin of a generated mesh.
  INTERFACE CMISSGeneratedMeshOriginGet
    MODULE PROCEDURE CMISSGeneratedMeshOriginGetNumber
    MODULE PROCEDURE CMISSGeneratedMeshOriginGetObj
  END INTERFACE !CMISSGeneratedMeshOriginGet

  !>Sets/changes the origin of a generated mesh.
  INTERFACE CMISSGeneratedMeshOriginSet
    MODULE PROCEDURE CMISSGeneratedMeshOriginSetNumber
    MODULE PROCEDURE CMISSGeneratedMeshOriginSetObj
  END INTERFACE !CMISSGeneratedMeshOriginSet

  !>Returns the type of a generated mesh.
  INTERFACE CMISSGeneratedMeshTypeGet
    MODULE PROCEDURE CMISSGeneratedMeshTypeGetNumber
    MODULE PROCEDURE CMISSGeneratedMeshTypeGetObj
  END INTERFACE !CMISSGeneratedMeshTypeGet

  !>Sets/changes the type of a generated mesh.
  INTERFACE CMISSGeneratedMeshTypeSet
    MODULE PROCEDURE CMISSGeneratedMeshTypeSetNumber
    MODULE PROCEDURE CMISSGeneratedMeshTypeSetObj
  END INTERFACE !CMISSGeneratedMeshTypeSet

  !>Calculates and sets the geometric field parameters for a generated mesh
  INTERFACE CMISSGeneratedMeshGeometricParametersCalculate
    MODULE PROCEDURE CMISSGeneratedMeshGeometricParametersCalculateNumber
    MODULE PROCEDURE CMISSGeneratedMeshGeometricParametersCalculateObj
  END INTERFACE !CMISSGeneratedMeshGeometricParametersCalculate

  !>Returns a list of nodes belonging to a surface of given type
  INTERFACE CMISSGeneratedMeshSurfaceGet
    MODULE PROCEDURE CMISSGeneratedMeshSurfaceGetNumber0
    MODULE PROCEDURE CMISSGeneratedMeshSurfaceGetNumber1
    MODULE PROCEDURE CMISSGeneratedMeshSurfaceGetObj0
    MODULE PROCEDURE CMISSGeneratedMeshSurfaceGetObj1
  END INTERFACE


  !>Creates an embedding of one mesh in another
  INTERFACE CMISSMeshEmbeddingCreate
    MODULE PROCEDURE CMISSMeshEmbeddingCreateNumber
    MODULE PROCEDURE CMISSMeshEmbeddingCreateObj
  END INTERFACE

  !>Sets the embedded nodes for one parent element
  INTERFACE CMISSMeshEmbeddingSetChildNodePosition
    MODULE PROCEDURE CMISSMeshEmbeddingSetChildNodePositionObj
  END INTERFACE


  !>Pushes data from the parent field to the child field
  INTERFACE CMISSMeshEmbeddingPushData
    MODULE PROCEDURE CMISSMeshEmbeddingPushDataObj
  END INTERFACE

  INTERFACE CMISSMeshEmbeddingSetGaussPointData
   MODULE PROCEDURE CMISSMeshEmbeddingSetGaussPointDataObj
  END INTERFACE

  INTERFACE CMISSMeshEmbeddingPullGaussPointData
   MODULE PROCEDURE CMISSMeshEmbeddingPullGaussPointDataObj
  END INTERFACE

   INTERFACE CMISSFieldParameterSetGetGaussPointCoord
    MODULE PROCEDURE CMISSFieldParameterSetGetGaussPointCoordObj
   END INTERFACE

  PUBLIC CMISSMeshEmbeddingCreate, CMISSMeshEmbeddingSetChildNodePosition, CMISSMeshEmbeddingType

  PUBLIC CMISSMeshEmbeddingTypeInitialise, CMISSMeshEmbeddingSetGaussPointData

  PUBLIC CMISSMeshEmbeddingPushData, CMISSMeshEmbeddingPullGaussPointData

  PUBLIC CMISSFieldParameterSetGetGaussPointCoord

  PUBLIC CMISS_GENERATED_MESH_REGULAR_MESH_TYPE,CMISS_GENERATED_MESH_POLAR_MESH_TYPE,CMISS_GENERATED_MESH_FRACTAL_TREE_MESH_TYPE

  PUBLIC CMISS_GENERATED_MESH_CYLINDER_MESH_TYPE, CMISS_GENERATED_MESH_ELLIPSOID_MESH_TYPE

  PUBLIC CMISS_GENERATED_MESH_CYLINDER_INNER_SURFACE,CMISS_GENERATED_MESH_CYLINDER_OUTER_SURFACE

  PUBLIC CMISS_GENERATED_MESH_CYLINDER_TOP_SURFACE, CMISS_GENERATED_MESH_CYLINDER_BOTTOM_SURFACE

  PUBLIC CMISS_GENERATED_MESH_ELLIPSOID_INNER_SURFACE, CMISS_GENERATED_MESH_ELLIPSOID_OUTER_SURFACE

  PUBLIC CMISS_GENERATED_MESH_ELLIPSOID_TOP_SURFACE

  PUBLIC CMISS_GENERATED_MESH_REGULAR_LEFT_SURFACE, CMISS_GENERATED_MESH_REGULAR_RIGHT_SURFACE, &
    & CMISS_GENERATED_MESH_REGULAR_TOP_SURFACE

  PUBLIC CMISS_GENERATED_MESH_REGULAR_BOTTOM_SURFACE, CMISS_GENERATED_MESH_REGULAR_FRONT_SURFACE, &
    & CMISS_GENERATED_MESH_REGULAR_BACK_SURFACE

  PUBLIC CMISSGeneratedMeshBasisGet,CMISSGeneratedMeshBasisSet

  PUBLIC CMISSGeneratedMeshBaseVectorsSet

  PUBLIC CMISSGeneratedMeshCreateFinish,CMISSGeneratedMeshCreateStart

  PUBLIC CMISSGeneratedMeshDestroy

  PUBLIC CMISSGeneratedMeshExtentGet,CMISSGeneratedMeshExtentSet

  PUBLIC CMISSGeneratedMeshNumberOfElementsGet,CMISSGeneratedMeshNumberOfElementsSet

  PUBLIC CMISSGeneratedMeshOriginGet,CMISSGeneratedMeshOriginSet

  PUBLIC CMISSGeneratedMeshTypeGet,CMISSGeneratedMeshTypeSet

  PUBLIC CMISSGeneratedMeshGeometricParametersCalculate

  PUBLIC CMISSGeneratedMeshSurfaceGet


!!==================================================================================================================================
!!
!! INTERFACE_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Adds a mesh to an interface.
  INTERFACE CMISSInterfaceMeshAdd
    MODULE PROCEDURE CMISSInterfaceMeshAddNumber
    MODULE PROCEDURE CMISSInterfaceMeshAddObj
  END INTERFACE !CMISSInterfaceMeshAdd

  !>Finishes the creation of an interface. \see OPENCMISS::CMISSInterfaceCreateStart
  INTERFACE CMISSInterfaceCreateFinish
    MODULE PROCEDURE CMISSInterfaceCreateFinishNumber
    MODULE PROCEDURE CMISSInterfaceCreateFinishObj
  END INTERFACE !CMISSInterfaceCreateStart

  !>Starts the creation of an interface. \see OPENCMISS::CMISSInterfaceCreateFinish
  INTERFACE CMISSInterfaceCreateStart
    MODULE PROCEDURE CMISSInterfaceCreateStartNumber
    MODULE PROCEDURE CMISSInterfaceCreateStartObj
  END INTERFACE !CMISSInterfaceCreateStart

  !>Destroys an interface.
  INTERFACE CMISSInterfaceDestroy
    MODULE PROCEDURE CMISSInterfaceDestroyNumber
    MODULE PROCEDURE CMISSInterfaceDestroyObj
  END INTERFACE !CMISSInterfaceDestroy

  !>Returns the label of an interface.
  INTERFACE CMISSInterfaceLabelGet
    MODULE PROCEDURE CMISSInterfaceLabelGetCNumber
    MODULE PROCEDURE CMISSInterfaceLabelGetCObj
    MODULE PROCEDURE CMISSInterfaceLabelGetVSNumber
    MODULE PROCEDURE CMISSInterfaceLabelGetVSObj
  END INTERFACE !CMISSInterfaceLabelGet

  !>Sets/changes the label of an interface.
  INTERFACE CMISSInterfaceLabelSet
    MODULE PROCEDURE CMISSInterfaceLabelSetCNumber
    MODULE PROCEDURE CMISSInterfaceLabelSetCObj
    MODULE PROCEDURE CMISSInterfaceLabelSetVSNumber
    MODULE PROCEDURE CMISSInterfaceLabelSetVSObj
  END INTERFACE !CMISSInterfaceLabelSet

  !>Finishes the creation of an interface meshes connectivity. \see OPENCMISS::CMISSInterfaceMeshConnectivityCreateStart
  INTERFACE CMISSInterfaceMeshConnectivityCreateFinish
    MODULE PROCEDURE CMISSInterfaceMeshConnectivityCreateFinishNumber
    MODULE PROCEDURE CMISSInterfaceMeshConnectivityCreateFinishObj
  END INTERFACE !CMISSInterfaceMeshConnectivityCreateFinish

  !>Starts the creation of an interface meshes connectivity.
  INTERFACE CMISSInterfaceMeshConnectivityCreateStart
    MODULE PROCEDURE CMISSInterfaceMeshConnectivityCreateStartNumber
    MODULE PROCEDURE CMISSInterfaceMeshConnectivityCreateStartObj
  END INTERFACE !CMISSInterfaceMeshConnectivityCreateStart

  !>Sets the element xi values for the mesh connectivity between an element in the interface mesh and an element in a region mesh
  INTERFACE CMISSInterfaceMeshConnectivityElementXiSet
    MODULE PROCEDURE CMISSInterfaceMeshConnectivityElementXiSetNumber
    MODULE PROCEDURE CMISSInterfaceMeshConnectivityElementXiSetObj
  END INTERFACE !CMISSInterfaceMeshConnectivityElementXiSet <<>>

  !>Sets the number of elements coupled through a given interface mesh element
  INTERFACE CMISSInterfaceMeshConnectivityElementNumberSet
    MODULE PROCEDURE CMISSInterfaceMeshConnectivityElementNumberSetNumber
    MODULE PROCEDURE CMISSInterfaceMeshConnectivityElementNumberSetObj
  END INTERFACE !CMISSInterfaceMeshConnectivityElementNumberSet

  !>Sets the number of elements coupled through a given interface mesh element
  INTERFACE CMISSInterfaceMeshConnectivitySetBasis
    MODULE PROCEDURE CMISSInterfaceMeshConnectivitySetBasisNumber
    MODULE PROCEDURE CMISSInterfaceMeshConnectivitySetBasisObj
  END INTERFACE !CMISSInterfaceMeshConnectivitySetBasis

  !>Destroys an interface meshes connectivity.
  INTERFACE CMISSInterfaceMeshConnectivityDestroy
    MODULE PROCEDURE CMISSInterfaceMeshConnectivityDestroyNumber
    MODULE PROCEDURE CMISSInterfaceMeshConnectivityDestroyObj
  END INTERFACE !CMISSInterfaceMeshConnectivityDestroy

  PUBLIC CMISSInterfaceMeshAdd

  PUBLIC CMISSInterfaceCreateFinish,CMISSInterfaceCreateStart

  PUBLIC CMISSInterfaceDestroy

  PUBLIC CMISSInterfaceLabelGet,CMISSInterfaceLabelSet

  PUBLIC CMISSInterfaceMeshConnectivityCreateFinish,CMISSInterfaceMeshConnectivityCreateStart

  PUBLIC CMISSInterfaceMeshConnectivityDestroy, CMISSInterfaceMeshConnectivitySetBasis

  PUBLIC CMISSInterfaceMeshConnectivityElementNumberSet, CMISSInterfaceMeshConnectivityElementXiSet

!!==================================================================================================================================
!!
!! INTERFACE_CONDITION_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_InterfaceConditionConstants OPENCMISS::InterfaceConditions::Constants
  !> \brief Interface conditions constants.
  !>@{
  !> \addtogroup OPENCMISS_InterfaceConditionMethods OPENCMISS::InterfaceConditions::Methods
  !> \brief Interface condition methods.
  !> \see OPENCMISS::InterfaceConditions,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_INTERFACE_CONDITION_LAGRANGE_MULTIPLIERS_METHOD = &
    & INTERFACE_CONDITION_LAGRANGE_MULTIPLIERS_METHOD !<Lagrange multipliers interface condition method. \see OPENCMISS_InterfaceConditionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_INTERFACE_CONDITION_AUGMENTED_LAGRANGE_METHOD = INTERFACE_CONDITION_AUGMENTED_LAGRANGE_METHOD !<Augmented Lagrange multiplers interface condition method. \see OPENCMISS_InterfaceConditionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_INTERFACE_CONDITION_PENALTY_METHOD = INTERFACE_CONDITION_PENALTY_METHOD !<Penalty interface condition method. \see OPENCMISS_InterfaceConditionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_INTERFACE_CONDITION_POINT_TO_POINT_METHOD = INTERFACE_CONDITION_POINT_TO_POINT_METHOD !<Point to point interface condition method. \see OPENCMISS_InterfaceConditionMethods,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_InterfaceConditionOperators OPENCMISS::InterfaceConditions::Operators
  !> \brief Interface condition operator types.
  !> \see OPENCMISS::InterfaceConditions,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_INTERFACE_CONDITION_FIELD_CONTINUITY_OPERATOR = INTERFACE_CONDITION_FIELD_CONTINUITY_OPERATOR !<Continuous field operator, i.e., lambda.(u_1-u_2). \see OPENCMISS_InterfaceConditionOperators,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_INTERFACE_CONDITION_FIELD_NORMAL_CONTINUITY_OPERATOR = &
    & INTERFACE_CONDITION_FIELD_NORMAL_CONTINUITY_OPERATOR !<Continuous field normal operator, i.e., lambda(u_1.n_1-u_2.n_2). \see OPENCMISS_InterfaceConditionOperators,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_INTERFACE_CONDITION_SOLID_FLUID_OPERATOR = INTERFACE_CONDITION_SOLID_FLUID_OPERATOR !<Solid fluid operator, i.e., lambda.(v_f-du_s/dt). \see OPENCMISS_InterfaceConditionOperators,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_INTERFACE_CONDITION_SOLID_FLUID_NORMAL_OPERATOR = &
    & INTERFACE_CONDITION_SOLID_FLUID_NORMAL_OPERATOR !<Solid fluid normal operator, i.e., lambda(v_f.n_f-du_s/dt.n_s). \see OPENCMISS_InterfaceConditionOperators,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Finishes the creation of an interface condition. \see OPENCMISS::CMISSInterfaceConditionCreateStart
  INTERFACE CMISSInterfaceConditionCreateFinish
    MODULE PROCEDURE CMISSInterfaceConditionCreateFinishNumber
    MODULE PROCEDURE CMISSInterfaceConditionCreateFinishObj
  END INTERFACE !CMISSInterfaceConditionCreateFinish

  !>Starts the creation of an interface condition. \see OPENCMISS::CMISSInterfaceConditionCreateFinish
  INTERFACE CMISSInterfaceConditionCreateStart
    MODULE PROCEDURE CMISSInterfaceConditionCreateStartNumber
    MODULE PROCEDURE CMISSInterfaceConditionCreateStartObj
  END INTERFACE !CMISSInterfaceConditionCreateStart

  !>Adds in a dependent variable to an interface condition.
  INTERFACE CMISSInterfaceConditionDependentVariableAdd
    MODULE PROCEDURE CMISSInterfaceConditionDependentVariableAddNumber
    MODULE PROCEDURE CMISSInterfaceConditionDependentVariableAddObj
  END INTERFACE !CMISSInterfaceConditionDependentVariableAdd

  !>Destroys an interface condition.
  INTERFACE CMISSInterfaceConditionDestroy
    MODULE PROCEDURE CMISSInterfaceConditionDestroyNumber
    MODULE PROCEDURE CMISSInterfaceConditionDestroyObj
  END INTERFACE !CMISSInterfaceConditionDestroy

  !>Finishes the creation of equations for an interface condition. \see OPENCMISS::CMISSInterfaceConditionEquationsCreateStart
  INTERFACE CMISSInterfaceConditionEquationsCreateFinish
    MODULE PROCEDURE CMISSInterfaceConditionEquationsCreateFinishNumber
    MODULE PROCEDURE CMISSInterfaceConditionEquationsCreateFinishObj
  END INTERFACE !CMISSInterfaceConditionEquationsCreateStart

  !>Starts the creation of equations for an interface condition. \see OPENCMISS::CMISSInterfaceConditionEquationsCreateFinish
  INTERFACE CMISSInterfaceConditionEquationsCreateStart
    MODULE PROCEDURE CMISSInterfaceConditionEquationsCreateStartNumber
    MODULE PROCEDURE CMISSInterfaceConditionEquationsCreateStartObj
  END INTERFACE !CMISSInterfaceConditionEquationsCreateStart

  !>Destroys the interface equations for an interface condition.
  INTERFACE CMISSInterfaceConditionEquationsDestroy
    MODULE PROCEDURE CMISSInterfaceConditionEquationsDestroyNumber
    MODULE PROCEDURE CMISSInterfaceConditionEquationsDestroyObj
  END INTERFACE !CMISSInterfaceConditionEquationsDestroy

  !>Finishes the creation of a Lagrange multipliers field for an interface condition. \see OPENCMISS::CMISSInterfaceConditionLagrangeFieldCreateStart
  INTERFACE CMISSInterfaceConditionLagrangeFieldCreateFinish
    MODULE PROCEDURE CMISSInterfaceConditionLagrangeFieldCreateFinishNumber
    MODULE PROCEDURE CMISSInterfaceConditionLagrangeFieldCreateFinishObj
  END INTERFACE !CMISSInterfaceConditionLagrangeFieldCreateFinish

  !>Starts the creation of a Lagrange multipliers field for an interface condition. \see OPENCMISS::CMISSInterfaceConditionLagrangeFieldCreateFinish
  INTERFACE CMISSInterfaceConditionLagrangeFieldCreateStart
    MODULE PROCEDURE CMISSInterfaceConditionLagrangeFieldCreateStartNumber
    MODULE PROCEDURE CMISSInterfaceConditionLagrangeFieldCreateStartObj
  END INTERFACE !CMISSInterfaceConditionLagrangeFieldCreateStart

  !>Returns the method for an interface condition.
  INTERFACE CMISSInterfaceConditionMethodGet
    MODULE PROCEDURE CMISSInterfaceConditionMethodGetNumber
    MODULE PROCEDURE CMISSInterfaceConditionMethodGetObj
  END INTERFACE !CMISSInterfaceConditionMethodGet

  !>Sets/changes the method for an interface condition.
  INTERFACE CMISSInterfaceConditionMethodSet
    MODULE PROCEDURE CMISSInterfaceConditionMethodSetNumber
    MODULE PROCEDURE CMISSInterfaceConditionMethodSetObj
  END INTERFACE !CMISSInterfaceConditionMethodSet

  !>Returns the operator for an interface condition.
  INTERFACE CMISSInterfaceConditionOperatorGet
    MODULE PROCEDURE CMISSInterfaceConditionOperatorGetNumber
    MODULE PROCEDURE CMISSInterfaceConditionOperatorGetObj
  END INTERFACE !CMISSInterfaceConditionOperatorGet

  !>Sets/changes the operator for an interface condition.
  INTERFACE CMISSInterfaceConditionOperatorSet
    MODULE PROCEDURE CMISSInterfaceConditionOperatorSetNumber
    MODULE PROCEDURE CMISSInterfaceConditionOperatorSetObj
  END INTERFACE !CMISSInterfaceConditionOperatorSet

  !>Returns the sparsity for interface equations.
  INTERFACE CMISSInterfaceEquationsSparsityGet
    MODULE PROCEDURE CMISSInterfaceEquationsSparsityGetNumber
    MODULE PROCEDURE CMISSInterfaceEquationsSparsityGetObj
  END INTERFACE !CMISSInterfaceEquationsSparsityGet

  !>Sets/changes the sparsity for interface equations.
  INTERFACE CMISSInterfaceEquationsSparsitySet
    MODULE PROCEDURE CMISSInterfaceEquationsSparsitySetNumber
    MODULE PROCEDURE CMISSInterfaceEquationsSparsitySetObj
  END INTERFACE !CMISSInterfaceEquationsSparsitySet

  !>Returns the output type for interface equations.
  INTERFACE CMISSInterfaceEquationsOutputTypeGet
    MODULE PROCEDURE CMISSInterfaceEquationsOutputTypeGetNumber
    MODULE PROCEDURE CMISSInterfaceEquationsOutputTypeGetObj
  END INTERFACE !CMISSInterfaceEquationsOutputTypeGet

  !>Sets/changes the output type for interface equations.
  INTERFACE CMISSInterfaceEquationsOutputTypeSet
    MODULE PROCEDURE CMISSInterfaceEquationsOutputTypeSetNumber
    MODULE PROCEDURE CMISSInterfaceEquationsOutputTypeSetObj
  END INTERFACE !CMISSInterfaceEquationsOutputTypeSet

  PUBLIC CMISS_INTERFACE_CONDITION_LAGRANGE_MULTIPLIERS_METHOD,CMISS_INTERFACE_CONDITION_AUGMENTED_LAGRANGE_METHOD, &
    & CMISS_INTERFACE_CONDITION_PENALTY_METHOD,CMISS_INTERFACE_CONDITION_POINT_TO_POINT_METHOD

  PUBLIC CMISS_INTERFACE_CONDITION_FIELD_CONTINUITY_OPERATOR,CMISS_INTERFACE_CONDITION_FIELD_NORMAL_CONTINUITY_OPERATOR, &
    & CMISS_INTERFACE_CONDITION_SOLID_FLUID_OPERATOR,CMISS_INTERFACE_CONDITION_SOLID_FLUID_NORMAL_OPERATOR

  PUBLIC CMISSInterfaceConditionCreateFinish,CMISSInterfaceConditionCreateStart

  PUBLIC CMISSInterfaceConditionDependentVariableAdd

  PUBLIC CMISSInterfaceConditionDestroy

  PUBLIC CMISSInterfaceConditionEquationsCreateFinish,CMISSInterfaceConditionEquationsCreateStart

  PUBLIC CMISSInterfaceConditionEquationsDestroy

  PUBLIC CMISSInterfaceConditionLagrangeFieldCreateFinish,CMISSInterfaceConditionLagrangeFieldCreateStart

  PUBLIC CMISSInterfaceConditionMethodGet,CMISSInterfaceConditionMethodSet

  PUBLIC CMISSInterfaceConditionOperatorGet,CMISSInterfaceConditionOperatorSet

  PUBLIC CMISSInterfaceEquationsSparsityGet,CMISSInterfaceEquationsSparsitySet

  PUBLIC CMISSInterfaceEquationsOutputTypeGet,CMISSInterfaceEquationsOutputTypeSet

!!==================================================================================================================================
!!
!! KINDS
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_KindConstants OPENCMISS::Kinds::Constants
  !> \brief Kind constants.
  !>@{
  !> \addtogroup OPENCMISS_IntegerKinds OPENCMISS::Kinds::Integers
  !> \brief Kind parameters for integer data types.
  !> \see OPENCMISS::Kinds,OPENCMISS
  !>@{
  INTEGER, PARAMETER :: CMISSIntg = INTG !<Standard integer kind. \see OPENCMISS_IntegerKinds,OPENCMISS
  INTEGER, PARAMETER :: CMISSSIntg = SINTG !<Short integer kind. \see OPENCMISS_IntegerKinds,OPENCMISS
  INTEGER, PARAMETER :: CMISSLIntg = LINTG !<Long integer kind. \see OPENCMISS_IntegerKinds,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_RealKinds OPENCMISS::Kinds::Reals
  !> \brief Kind parameters for real data types.
  !> \see OPENCMISS::Kinds,OPENCMISS
  !>@{
  INTEGER, PARAMETER :: CMISSSP = SP !<Single precision real kind. \see OPENCMISS_RealKinds,OPENCMISS
  INTEGER, PARAMETER :: CMISSDP = DP !<Double precision real kind. \see OPENCMISS_RealKinds,OPENCMISS
  INTEGER, PARAMETER :: CMISSQP = QP !<Quadruple precision real kind. \see OPENCMISS_RealKinds,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_ComplexKinds OPENCMISS::Kinds::Complex
  !> \brief Kind parameters for complex data types
  !> \see OPENCMISS::Kinds,OPENCMISS
  !>@{
  INTEGER, PARAMETER :: CMISSSPC = SPC !<Single precision complex kind. \see OPENCMISS_ComplexKinds,OPENCMISS
  INTEGER, PARAMETER :: CMISSDPC = DPC !<Double precision complex kind. \see OPENCMISS_ComplexKinds,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  PUBLIC CMISSIntg,CMISSSIntg,CMISSLIntg

  PUBLIC CMISSSP,CMISSDP,CMISSQP

  PUBLIC CMISSSPC,CMISSDPC

!!==================================================================================================================================
!!
!! MESH_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_MeshConstants OPENCMISS::Mesh::Constants
  !> \brief Mesh constants.
  !>@{
  !> \addtogroup OPENCMISS_DecompositionTypes OPENCMISS::Mesh::DecompositionTypes
  !> \brief The Decomposition types parameters
  !> \see OPENCMISS::Mesh,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_DECOMPOSITION_ALL_TYPE = DECOMPOSITION_ALL_TYPE !<The decomposition contains all elements. \see OPENCMISS_DecompositionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_DECOMPOSITION_CALCULATED_TYPE = DECOMPOSITION_CALCULATED_TYPE !<The element decomposition is calculated by graph partitioning. \see OPENCMISS_DecompositionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_DECOMPOSITION_USER_DEFINED_TYPE = DECOMPOSITION_USER_DEFINED_TYPE !<The user will set the element decomposition. \see OPENCMISS_DecompositionTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Finishes the creation of a domain decomposition. \see OPENCMISS::CMISSDecompositionCreateStart
  INTERFACE CMISSDecompositionCreateFinish
    MODULE PROCEDURE CMISSDecompositionCreateFinishNumber
    MODULE PROCEDURE CMISSDecompositionCreateFinishObj
  END INTERFACE !CMISSDecompositionCreateFinish

  !>Start the creation of a domain decomposition for a given mesh. \see OPENCMISS::CMISSDecompositionCreateStart
  INTERFACE CMISSDecompositionCreateStart
    MODULE PROCEDURE CMISSDecompositionCreateStartNumber
    MODULE PROCEDURE CMISSDecompositionCreateStartObj
  END INTERFACE !CMISSDecompositionCreateStart

  !>Destroys a domain decomposition.
  INTERFACE CMISSDecompositionDestroy
    MODULE PROCEDURE CMISSDecompositionDestroyNumber
    MODULE PROCEDURE CMISSDecompositionDestroyObj
  END INTERFACE !CMISSDecompositionDestroy

  !>Calculates the element domains for the decomposition of a mesh.
  INTERFACE CMISSDecompositionElementDomainCalculate
    MODULE PROCEDURE CMISSDecompositionElementDomainCalculateNumber
    MODULE PROCEDURE CMISSDecompositionElementDomainCalculateObj
  END INTERFACE !CMISSDecompositionElementDomainCalculate

  !>Returns the domain for a given element in a decomposition of a mesh.
  INTERFACE CMISSDecompositionElementDomainGet
    MODULE PROCEDURE CMISSDecompositionElementDomainGetNumber
    MODULE PROCEDURE CMISSDecompositionElementDomainGetObj
  END INTERFACE !CMISSDecompositionElementDomainGet

  !>Sets/changes the domain for a given element in a decomposition of a mesh.
  INTERFACE CMISSDecompositionElementDomainSet
    MODULE PROCEDURE CMISSDecompositionElementDomainSetNumber
    MODULE PROCEDURE CMISSDecompositionElementDomainSetObj
  END INTERFACE !CMISSDecompositionElementDomainSet

  !>Returns the mesh component number used for the decomposition of a mesh.
  INTERFACE CMISSDecompositionMeshComponentGet
    MODULE PROCEDURE CMISSDecompositionMeshComponentGetNumber
    MODULE PROCEDURE CMISSDecompositionMeshComponentGetObj
  END INTERFACE !CMISSDecompositionMeshComponentGet

  !>Sets/changes the mesh component number used for the decomposition of a mesh.
  INTERFACE CMISSDecompositionMeshComponentSet
    MODULE PROCEDURE CMISSDecompositionMeshComponentSetNumber
    MODULE PROCEDURE CMISSDecompositionMeshComponentSetObj
  END INTERFACE !CMISSDecompositionMeshComponentSet

  !>Returns the number of domains used for the decomposition of a mesh.
  INTERFACE CMISSDecompositionNumberOfDomainsGet
    MODULE PROCEDURE CMISSDecompositionNumberOfDomainsGetNumber
    MODULE PROCEDURE CMISSDecompositionNumberOfDomainsGetObj
  END INTERFACE !CMISSDecompositionNumberOfDomainsGet

  !>Sets/changes the number of domains used for the decomposition of a mesh.
  INTERFACE CMISSDecompositionNumberOfDomainsSet
    MODULE PROCEDURE CMISSDecompositionNumberOfDomainsSetNumber
    MODULE PROCEDURE CMISSDecompositionNumberOfDomainsSetObj
  END INTERFACE !CMISSDecompositionNumberOfDomainsSet

  !>Returns the type of decomposition.
  INTERFACE CMISSDecompositionTypeGet
    MODULE PROCEDURE CMISSDecompositionTypeGetNumber
    MODULE PROCEDURE CMISSDecompositionTypeGetObj
  END INTERFACE !CMISSDecompositionTypeGet

  !>Sets/changes the type of decomposition.
  INTERFACE CMISSDecompositionTypeSet
    MODULE PROCEDURE CMISSDecompositionTypeSetNumber
    MODULE PROCEDURE CMISSDecompositionTypeSetObj
  END INTERFACE !CMISSDecompositionTypeSet

  !>Sets/changes whether lines should be calculated for the decomposition.
  INTERFACE CMISSDecompositionCalculateLinesSet
    MODULE PROCEDURE CMISSDecompositionCalculateLinesSetNumber
    MODULE PROCEDURE CMISSDecompositionCalculateLinesSetObj
  END INTERFACE !CMISSDecompositionCalculateLinesSet

  !>Sets/changes whether faces should be calculated for the decomposition.
  INTERFACE CMISSDecompositionCalculateFacesSet
    MODULE PROCEDURE CMISSDecompositionCalculateFacesSetNumber
    MODULE PROCEDURE CMISSDecompositionCalculateFacesSetObj
  END INTERFACE !CMISSDecompositionCalculateFacesSet

  !>Finishes the creation of a mesh. \see OPENCMISS::CMISSMeshCreateStart
  INTERFACE CMISSMeshCreateFinish
    MODULE PROCEDURE CMISSMeshCreateFinishNumber
    MODULE PROCEDURE CMISSMeshCreateFinishObj
  END INTERFACE !CMISSMeshCreateFinish

  !>Starts the creation of a mesh. \see OPENCMISS::CMISSMeshCreateFinish
  INTERFACE CMISSMeshCreateStart
    MODULE PROCEDURE CMISSMeshCreateStartNumber
    MODULE PROCEDURE CMISSMeshCreateStartObj
    MODULE PROCEDURE CMISSMeshCreateStartInterfaceObj
  END INTERFACE !CMISSMeshCreateStart

  !>Destroys a mesh.
  INTERFACE CMISSMeshDestroy
    MODULE PROCEDURE CMISSMeshDestroyNumber
    MODULE PROCEDURE CMISSMeshDestroyObj
  END INTERFACE !CMISSMeshDestroy

  !>Returns the number of mesh components in a mesh.
  INTERFACE CMISSMeshNumberOfComponentsGet
    MODULE PROCEDURE CMISSMeshNumberOfComponentsGetNumber
    MODULE PROCEDURE CMISSMeshNumberOfComponentsGetObj
  END INTERFACE !CMISSMeshNumberOfComponentsGet

  !>Sets/changes the number of mesh components in a mesh.
  INTERFACE CMISSMeshNumberOfComponentsSet
    MODULE PROCEDURE CMISSMeshNumberOfComponentsSetNumber
    MODULE PROCEDURE CMISSMeshNumberOfComponentsSetObj
  END INTERFACE !CMISSMeshNumberOfComponentsSet

  !>Returns the number of elements in a mesh.
  INTERFACE CMISSMeshNumberOfElementsGet
    MODULE PROCEDURE CMISSMeshNumberOfElementsGetNumber
    MODULE PROCEDURE CMISSMeshNumberOfElementsGetObj
  END INTERFACE !CMISSMeshNumberOfElementsGet

  !>Sets/changes the number of elements in a mesh.
  INTERFACE CMISSMeshNumberOfElementsSet
    MODULE PROCEDURE CMISSMeshNumberOfElementsSetNumber
    MODULE PROCEDURE CMISSMeshNumberOfElementsSetObj
  END INTERFACE !CMISSMeshNumberOfElementsSet

  !>Sets/changes the surrounding elements calculate flag for the mesh.
  INTERFACE CMISSMeshSurroundingElementsCalculateSet
    MODULE PROCEDURE CMISSMeshSurroundingElementsCalculateSetNumber
    MODULE PROCEDURE CMISSMeshSurroundingElementsCalculateSetObj
  END INTERFACE !CMISSMeshSurroundingElementsCalculateSet

  !>Returns the basis for an element in a mesh.
  INTERFACE CMISSMeshElementsBasisGet
    MODULE PROCEDURE CMISSMeshElementsBasisGetNumber
    MODULE PROCEDURE CMISSMeshElementsBasisGetObj
  END INTERFACE !CMISSMeshElementsBasisGet

  !>Sets/changes the basis for an element in a mesh.
  INTERFACE CMISSMeshElementsBasisSet
    MODULE PROCEDURE CMISSMeshElementsBasisSetNumber
    MODULE PROCEDURE CMISSMeshElementsBasisSetObj
  END INTERFACE !CMISSMeshElementsBasisSet

  !>Finishes the creation of a mesh elements for a mesh component. \see OPENCMISS::CMISSMeshElementsCreateStart
  INTERFACE CMISSMeshElementsCreateFinish
    MODULE PROCEDURE CMISSMeshElementsCreateFinishNumber
    MODULE PROCEDURE CMISSMeshElementsCreateFinishObj
  END INTERFACE !CMISSMeshElementsCreateFinish

  !>Starts the creation of a mesh elements for a mesh component. \see OPENCMISS::CMISSMeshElementsCreateFinish
  INTERFACE CMISSMeshElementsCreateStart
    MODULE PROCEDURE CMISSMeshElementsCreateStartNumber
    MODULE PROCEDURE CMISSMeshElementsCreateStartObj
  END INTERFACE !CMISSMeshElementsCreateStart

  !>Get the mesh elements belonging to a mesh component.
  INTERFACE CMISSMeshElementsGet
    MODULE PROCEDURE CMISSMeshElementsGetNumber
    MODULE PROCEDURE CMISSMeshElementsGetObj
  END INTERFACE !CMISSMeshElementsGet

  !>Returns the element nodes for an element in a mesh.
  INTERFACE CMISSMeshElementsNodesGet
    MODULE PROCEDURE CMISSMeshElementsNodesGetNumber
    MODULE PROCEDURE CMISSMeshElementsNodesGetObj
  END INTERFACE !CMISSMeshElementsNodesGet

  !>Sets/changes the element nodes for an element in a mesh.
  INTERFACE CMISSMeshElementsNodesSet
    MODULE PROCEDURE CMISSMeshElementsNodesSetNumber
    MODULE PROCEDURE CMISSMeshElementsNodesSetObj
  END INTERFACE !CMISSMeshElementsNodesSet

  !>Sets/changes a user node's derivative version for an element in a mesh.
  INTERFACE CMISSMeshElementsUserNodeVersionSet
    MODULE PROCEDURE CMISSMeshElementsUserNodeVersionSetNumber
    MODULE PROCEDURE CMISSMeshElementsUserNodeVersionSetObj
  END INTERFACE !CMISSMeshElementsUserNodeVersionSet

  !>Sets/changes a local element's node derivative version for an element in a mesh.
  INTERFACE CMISSMeshElementsLocalElementNodeVersionSet
    MODULE PROCEDURE CMISSMeshElementsLocalElementNodeVersionSetNumber
    MODULE PROCEDURE CMISSMeshElementsLocalElementNodeVersionSetObj
  END INTERFACE !CMISSMeshElementsLocalElementNodeVersionSet


  !>Returns the element user number for an element in a mesh.
  INTERFACE CMISSMeshElementsUserNumberGet
    MODULE PROCEDURE CMISSMeshElementsUserNumberGetNumber
    MODULE PROCEDURE CMISSMeshElementsUserNumberGetObj
  END INTERFACE !CMISSMeshElementsUserNumberGet

  !>Sets/changes the element user number for an element in a mesh.
  INTERFACE CMISSMeshElementsUserNumberSet
    MODULE PROCEDURE CMISSMeshElementsUserNumberSetNumber
    MODULE PROCEDURE CMISSMeshElementsUserNumberSetObj
  END INTERFACE !CMISSMeshElementsUserNumberSet

  !>Returns true if the given node is in the given mesh component.
  INTERFACE CMISSMeshNodeExists
    MODULE PROCEDURE CMISSMeshNodeExistsNumber
    MODULE PROCEDURE CMISSMeshNodeExistsObj
  ENDINTERFACE !CMISSMeshNodeExists

  !>Returns true if the given element is in the given mesh component.
  INTERFACE CMISSMeshElementExists
    MODULE PROCEDURE CMISSMeshElementExistsNumber
    MODULE PROCEDURE CMISSMeshElementExistsObj
  ENDINTERFACE !CMISSMeshElementExists

    !>Returns the domain for a given element in a decomposition of a mesh.
  INTERFACE CMISSDecompositionNodeDomainGet
    MODULE PROCEDURE CMISSDecompositionNodeDomainGetNumber
    MODULE PROCEDURE CMISSDecompositionNodeDomainGetObj
  END INTERFACE !CMISSDecompositionElementDomainGet

  PUBLIC CMISS_DECOMPOSITION_ALL_TYPE,CMISS_DECOMPOSITION_CALCULATED_TYPE,CMISS_DECOMPOSITION_USER_DEFINED_TYPE

  PUBLIC CMISSDecompositionCreateFinish,CMISSDecompositionCreateStart

  PUBLIC CMISSDecompositionDestroy

  PUBLIC CMISSDecompositionElementDomainCalculate

  PUBLIC CMISSDecompositionElementDomainGet,CMISSDecompositionElementDomainSet

  PUBLIC CMISSDecompositionMeshComponentGet,CMISSDecompositionMeshComponentSet

  PUBLIC CMISSDecompositionNumberOfDomainsGet,CMISSDecompositionNumberOfDomainsSet

  PUBLIC CMISSDecompositionTypeGet,CMISSDecompositionTypeSet

  PUBLIC CMISSMeshCreateFinish,CMISSMeshCreateStart

  PUBLIC CMISSMeshDestroy

  PUBLIC CMISSMeshNumberOfComponentsGet,CMISSMeshNumberOfComponentsSet

  PUBLIC CMISSMeshNumberOfElementsGet,CMISSMeshNumberOfElementsSet

  PUBLIC CMISSMeshElementsBasisGet,CMISSMeshElementsBasisSet

  PUBLIC CMISSMeshElementsCreateFinish,CMISSMeshElementsCreateStart

  PUBLIC CMISSMeshElementsGet

  PUBLIC CMISSMeshElementsNodesGet,CMISSMeshElementsNodesSet

  PUBLIC CMISSMeshElementsUserNumberGet,CMISSMeshElementsUserNumberSet

  PUBLIC CMISSMeshNodeExists,CMISSMeshElementExists

  PUBLIC CMISSDecompositionNodeDomainGet,CMISSMeshElementsUserNodeVersionSet, CMISSMeshElementsLocalElementNodeVersionSet

  PUBLIC CMISSMeshSurroundingElementsCalculateSet


!!==================================================================================================================================
!!
!! NODE_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Finishes the process of creating nodes in a region. \see OPENCMISS::CMISSNodesCreateStart
  INTERFACE CMISSNodesCreateFinish
    MODULE PROCEDURE CMISSNodesCreateFinishNumber
    MODULE PROCEDURE CMISSNodesCreateFinishObj
  END INTERFACE !CMISSNodesCreateFinish

  !>Starts the process of creating nodes in a region. \see OPENCMISS::CMISSNodesCreateFinish
  INTERFACE CMISSNodesCreateStart
    MODULE PROCEDURE CMISSNodesCreateStartNumber
    MODULE PROCEDURE CMISSNodesCreateStartObj
    MODULE PROCEDURE CMISSNodesCreateStartInterfaceObj
  END INTERFACE !CMISSNodesCreateStart

  !>Destroys nodes.
  INTERFACE CMISSNodesDestroy
    MODULE PROCEDURE CMISSNodesDestroyNumber
    MODULE PROCEDURE CMISSNodesDestroyObj
  END INTERFACE !CMISSNodesDestroy

  !>Returns the number of nodes
  INTERFACE CMISSNodesNumberOfNodesGet
    MODULE PROCEDURE CMISSNodesNumberOfNodesGetNumber
    MODULE PROCEDURE CMISSNodesNumberOfNodesGetObj
  END INTERFACE !CMISSNodesNumberOfNodesGet

  !>Returns the label for a node identified by a given global number. \todo should this be a user number?
  INTERFACE CMISSNodesLabelGet
    MODULE PROCEDURE CMISSNodesLabelGetCNumber
    MODULE PROCEDURE CMISSNodesLabelGetCObj
    MODULE PROCEDURE CMISSNodesLabelGetVSNumber
    MODULE PROCEDURE CMISSNodesLabelGetVSObj
  END INTERFACE !CMISSNodesLabelGet

  !>Sets/changes the label for a node identified by a given global number. \todo should this be a user number?
  INTERFACE CMISSNodesLabelSet
    MODULE PROCEDURE CMISSNodesLabelSetCNumber
    MODULE PROCEDURE CMISSNodesLabelSetCObj
    MODULE PROCEDURE CMISSNodesLabelSetVSNumber
    MODULE PROCEDURE CMISSNodesLabelSetVSObj
  END INTERFACE !CMISSNodesLabelSet

  !>Returns the user number for a node identified by a given global number.
  INTERFACE CMISSNodesUserNumberGet
    MODULE PROCEDURE CMISSNodesUserNumberGetNumber
    MODULE PROCEDURE CMISSNodesUserNumberGetObj
  END INTERFACE !CMISSNodesUserNumberGet

  !>Sets/changes the user number for a node identified by a given global number.
  INTERFACE CMISSNodesUserNumberSet
    MODULE PROCEDURE CMISSNodesUserNumberSetNumber
    MODULE PROCEDURE CMISSNodesUserNumberSetObj
  END INTERFACE !CMISSNodesUserNumberSet

  PUBLIC CMISSNodesCreateFinish,CMISSNodesCreateStart

  PUBLIC CMISSNodesDestroy

  PUBLIC CMISSNodesNumberOfNodesGet

  PUBLIC CMISSNodesLabelGet,CMISSNodesLabelSet

  PUBLIC CMISSNodesUserNumberGet,CMISSNodesUserNumberSet

!!==================================================================================================================================
!!
!! PROBLEM_CONSTANTS_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_ProblemConstants OPENCMISS::Problem::Constants
  !> \brief Problem constants.
  !>@{
  !> \addtogroup OPENCMISS_ProblemClasses OPENCMISS::Problem::Classes
  !> \brief Problem classes.
  !> \see OPENCMISS::Problem,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_NO_CLASS = PROBLEM_NO_CLASS !<No problem class \see OPENCMISS_ProblemClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_ELASTICITY_CLASS = PROBLEM_ELASTICITY_CLASS !<Elasticity problem class \see OPENCMISS_ProblemClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_FLUID_MECHANICS_CLASS = PROBLEM_FLUID_MECHANICS_CLASS !<Fluid mechanics problem class \see OPENCMISS_ProblemClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_ELECTROMAGNETICS_CLASS = PROBLEM_ELECTROMAGNETICS_CLASS !<Electromagnetics problem class \see OPENCMISS_ProblemClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_CLASSICAL_FIELD_CLASS = PROBLEM_CLASSICAL_FIELD_CLASS !<Classical field problem class \see OPENCMISS_ProblemClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_BIOELECTRICS_CLASS = PROBLEM_BIOELECTRICS_CLASS !<Bioelectrics problem class \see OPENCMISS_ProblemClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_MODAL_CLASS = PROBLEM_MODAL_CLASS !<Modal problem class \see OPENCMISS_ProblemClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_FITTING_CLASS = PROBLEM_FITTING_CLASS !<Fitting problem class \see OPENCMISS_ProblemClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_OPTIMISATION_CLASS = PROBLEM_OPTIMISATION_CLASS !<Optimisation problem class \see OPENCMISS_ProblemClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_MULTI_PHYSICS_CLASS = PROBLEM_MULTI_PHYSICS_CLASS !<Multi physics problem class \see OPENCMISS_ProblemClasses,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_ProblemTypes OPENCMISS::Problem::Types
  !> \brief Problem Types.
  !> \see OPENCMISS::Problem,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_NO_TYPE = PROBLEM_NO_TYPE !<No problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_LINEAR_ELASTICITY_TYPE = PROBLEM_LINEAR_ELASTICITY_TYPE !<Linear elasticity problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_FINITE_ELASTICITY_TYPE = PROBLEM_FINITE_ELASTICITY_TYPE !<Finite elasticity problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_STOKES_EQUATION_TYPE = PROBLEM_STOKES_EQUATION_TYPE !<Stokes equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_NAVIER_STOKES_EQUATION_TYPE = PROBLEM_NAVIER_STOKES_EQUATION_TYPE !<Navier-Stokes problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_DARCY_EQUATION_TYPE = PROBLEM_DARCY_EQUATION_TYPE !<Darcy equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_POISEUILLE_EQUATION_TYPE = PROBLEM_POISEUILLE_EQUATION_TYPE !<Poiseuille equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_BURGERS_EQUATION_TYPE = PROBLEM_BURGERS_EQUATION_TYPE !<Burgers equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_ELECTROSTATIC_TYPE = PROBLEM_ELECTROSTATIC_TYPE !<Electrostatic problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_MAGNETOSTATIC_TYPE = PROBLEM_MAGNETOSTATIC_TYPE !<Magnetostatic problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_MAXWELLS_EQUATIONS_TYPE = PROBLEM_MAXWELLS_EQUATIONS_TYPE !<Maxwell's equations problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_LAPLACE_EQUATION_TYPE = PROBLEM_LAPLACE_EQUATION_TYPE !<Laplace problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_POISSON_EQUATION_TYPE = PROBLEM_POISSON_EQUATION_TYPE !<Poisson problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_HELMHOLTZ_EQUATION_TYPE = PROBLEM_HELMHOLTZ_EQUATION_TYPE !<Helmholtz problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_WAVE_EQUATION_TYPE = PROBLEM_WAVE_EQUATION_TYPE !<Wave equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_DIFFUSION_EQUATION_TYPE = PROBLEM_DIFFUSION_EQUATION_TYPE !<Diffusion equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_ADVECTION_DIFFUSION_EQUATION_TYPE = PROBLEM_ADVECTION_DIFFUSION_EQUATION_TYPE !<Advection-Diffusion equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_REACTION_DIFFUSION_EQUATION_TYPE = PROBLEM_REACTION_DIFFUSION_EQUATION_TYPE !<Reaction-Diffusion equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_BIHARMONIC_EQUATION_TYPE = PROBLEM_BIHARMONIC_EQUATION_TYPE !<Bi-harmonic equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_MONODOMAIN_EQUATION_TYPE = PROBLEM_MONODOMAIN_EQUATION_TYPE !<Monodomain equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_BIDOMAIN_EQUATION_TYPE = PROBLEM_BIDOMAIN_EQUATION_TYPE !<Bidomain equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_LINEAR_ELASTIC_MODAL_TYPE = PROBLEM_LINEAR_ELASTIC_MODAL_TYPE !<Linear elastic modal problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_DATA_FITTING_TYPE = PROBLEM_DATA_FITTING_TYPE !<Galerkin projection problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_FINITE_ELASTICITY_DARCY_TYPE = PROBLEM_FINITE_ELASTICITY_DARCY_TYPE !<Finite Elasticity Darcy problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_FINITE_ELASTICITY_STOKES_TYPE = PROBLEM_FINITE_ELASTICITY_STOKES_TYPE !<Finite Elasticity Stokes problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_FINITE_ELASTICITY_NAVIER_STOKES_TYPE = PROBLEM_FINITE_ELASTICITY_NAVIER_STOKES_TYPE !<Finite Elasticity NavierStokes problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_DIFFUSION_DIFFUSION_TYPE = PROBLEM_DIFFUSION_DIFFUSION_TYPE !<Diffusion Diffusion problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_DIFFUSION_ADVECTION_DIFFUSION_TYPE = PROBLEM_DIFFUSION_ADVECTION_DIFFUSION_TYPE !<Diffusion Advection Diffusion problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_MULTI_COMPARTMENT_TRANSPORT_TYPE = PROBLEM_MULTI_COMPARTMENT_TRANSPORT_TYPE !<Multi-compartment transport problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_FINITE_ELASTICITY_FLUID_PRESSURE_TYPE = PROBLEM_FINITE_ELASTICITY_FLUID_PRESSURE_TYPE !<Finite elasticity fluid pressure problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_BIOELECTRIC_FINITE_ELASTICITY_TYPE = PROBLEM_BIOELECTRIC_FINITE_ELASTICITY_TYPE !<Monodomain finite elasticity problem type \see OPENCMISS_ProblemTypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_MONODOMAIN_STRANG_SPLITTING_EQUATION_TYPE = &
    & PROBLEM_MONODOMAIN_STRANG_SPLITTING_EQUATION_TYPE !<Monodomain equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_ProblemSubTypes OPENCMISS::Problem::Subtypes
  !> \brief Problem Subtypes.
  !> \see OPENCMISS::Problem,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_NO_SUBTYPE = PROBLEM_NO_SUBTYPE !<No problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_STATIC_STOKES_SUBTYPE = PROBLEM_STATIC_STOKES_SUBTYPE !<Static Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_LAPLACE_STOKES_SUBTYPE = PROBLEM_LAPLACE_STOKES_SUBTYPE !<Laplace type Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_TRANSIENT_STOKES_SUBTYPE = PROBLEM_TRANSIENT_STOKES_SUBTYPE !<Transient Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_ALE_STOKES_SUBTYPE = PROBLEM_ALE_STOKES_SUBTYPE !<ALE Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_PGM_STOKES_SUBTYPE = PROBLEM_PGM_STOKES_SUBTYPE !<PGM Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_OPTIMISED_STOKES_SUBTYPE = PROBLEM_OPTIMISED_STOKES_SUBTYPE !<Optimised Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_STATIC_NAVIER_STOKES_SUBTYPE = PROBLEM_STATIC_NAVIER_STOKES_SUBTYPE !<Static Navier-Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_LAPLACE_NAVIER_STOKES_SUBTYPE = PROBLEM_LAPLACE_NAVIER_STOKES_SUBTYPE !<Laplace type Navier-Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_TRANSIENT_NAVIER_STOKES_SUBTYPE = PROBLEM_TRANSIENT_NAVIER_STOKES_SUBTYPE !<Transient Navier-Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_1DTRANSIENT_NAVIER_STOKES_SUBTYPE = PROBLEM_1DTRANSIENT_NAVIER_STOKES_SUBTYPE !<1DTransient Navier-Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_ALE_NAVIER_STOKES_SUBTYPE = PROBLEM_ALE_NAVIER_STOKES_SUBTYPE !<ALE Navier-Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_PGM_NAVIER_STOKES_SUBTYPE = PROBLEM_PGM_NAVIER_STOKES_SUBTYPE !<PGM Navier-Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_OPTIMISED_NAVIER_STOKES_SUBTYPE = PROBLEM_OPTIMISED_NAVIER_STOKES_SUBTYPE !<Optimised Navier-Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_STANDARD_DARCY_SUBTYPE = PROBLEM_STANDARD_DARCY_SUBTYPE !<Standard Darcy problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_QUASISTATIC_DARCY_SUBTYPE = PROBLEM_QUASISTATIC_DARCY_SUBTYPE !<Quasistatic Darcy problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_ALE_DARCY_SUBTYPE = PROBLEM_ALE_DARCY_SUBTYPE !<ALE Darcy problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_TRANSIENT_DARCY_SUBTYPE = PROBLEM_TRANSIENT_DARCY_SUBTYPE !<Transient Darcy problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_PGM_DARCY_SUBTYPE = PROBLEM_PGM_DARCY_SUBTYPE !<PGM Darcy problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_PGM_TRANSIENT_DARCY_SUBTYPE = PROBLEM_PGM_TRANSIENT_DARCY_SUBTYPE !<PGM Transient Darcy problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_STANDARD_LAPLACE_SUBTYPE = PROBLEM_STANDARD_LAPLACE_SUBTYPE !<Standard Laplace problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_GENERALISED_LAPLACE_SUBTYPE = PROBLEM_GENERALISED_LAPLACE_SUBTYPE !<Generalised Laplace problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_STATIC_POISEUILLE_SUBTYPE = PROBLEM_STATIC_POISEUILLE_SUBTYPE !<Static Poiseuille problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
 INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_DYNAMIC_POISEUILLE_SUBTYPE = PROBLEM_DYNAMIC_POISEUILLE_SUBTYPE !<Static Poiseuille problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_LINEAR_SOURCE_POISSON_SUBTYPE = PROBLEM_LINEAR_SOURCE_POISSON_SUBTYPE !<Linear source Poisson problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_LINEAR_PRESSURE_POISSON_SUBTYPE = PROBLEM_LINEAR_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_NONLINEAR_PRESSURE_POISSON_SUBTYPE = PROBLEM_NONLINEAR_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_ALE_PRESSURE_POISSON_SUBTYPE = PROBLEM_ALE_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_FITTED_PRESSURE_POISSON_SUBTYPE = PROBLEM_FITTED_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_NONLINEAR_SOURCE_POISSON_SUBTYPE = PROBLEM_NONLINEAR_SOURCE_POISSON_SUBTYPE !<Nonlinear source Poisson problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_STANDARD_HELMHOLTZ_SUBTYPE = PROBLEM_STANDARD_HELMHOLTZ_SUBTYPE !<No source Helmholtz problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_GENERALISED_HELMHOLTZ_SUBTYPE = PROBLEM_GENERALISED_HELMHOLTZ_SUBTYPE !<No source Helmholtz problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_NO_SOURCE_DIFFUSION_SUBTYPE = PROBLEM_NO_SOURCE_DIFFUSION_SUBTYPE !<No source Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_LINEAR_SOURCE_DIFFUSION_SUBTYPE = PROBLEM_LINEAR_SOURCE_DIFFUSION_SUBTYPE !<Linear source Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_NONLINEAR_SOURCE_DIFFUSION_SUBTYPE = PROBLEM_NONLINEAR_SOURCE_DIFFUSION_SUBTYPE !<Nonlinear source Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_NO_SOURCE_ALE_DIFFUSION_SUBTYPE = PROBLEM_NO_SOURCE_ALE_DIFFUSION_SUBTYPE !<No source Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_LINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE = PROBLEM_LINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE !<Linear source Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_NONLINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE = &
    & PROBLEM_NONLINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE !<Nonlinear source Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_NO_SOURCE_ADVECTION_DIFFUSION_SUBTYPE = &
    & PROBLEM_NO_SOURCE_ADVECTION_DIFFUSION_SUBTYPE !<No source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_LINEAR_SOURCE_ADVECTION_DIFFUSION_SUBTYPE = &
    & PROBLEM_LINEAR_SOURCE_ADVECTION_DIFFUSION_SUBTYPE !<Linear source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_NONLINEAR_SOURCE_ADVECTION_DIFFUSION_SUBTYPE = &
    & PROBLEM_NONLINEAR_SOURCE_ADVECTION_DIFFUSION_SUBTYPE !<Nonlinear source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_NO_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE = &
    & PROBLEM_NO_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE !<No source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_LINEAR_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE = &
    & PROBLEM_LINEAR_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE !<Linear source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_NONLINEAR_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE = &
    & PROBLEM_NONLINEAR_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE !<Nonlinear source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_NO_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE = PROBLEM_NO_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE !<No source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE = &
    & PROBLEM_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE !<Linear source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_NONLINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE = &
    & PROBLEM_NONLINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE !<Nonlinear source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_STATIC_BURGERS_SUBTYPE = PROBLEM_STATIC_BURGERS_SUBTYPE !<static Burgers problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_DYNAMIC_BURGERS_SUBTYPE = PROBLEM_DYNAMIC_BURGERS_SUBTYPE !<dynamic Burgers problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_CELLML_REAC_INTEG_REAC_DIFF_STRANG_SPLIT_SUBTYPE = &
    & PROBLEM_CELLML_REAC_INTEG_REAC_DIFF_STRANG_SPLIT_SUBTYPE !CellML reaction integrated strang-split subtype of reaction diffusion \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_CELLML_REAC_EVAL_REAC_DIFF_NO_SPLIT_SUBTYPE = &
    & PROBLEM_CELLML_REAC_EVAL_REAC_DIFF_NO_SPLIT_SUBTYPE !CellML reaction evaluated no-split subtype of reaction diffusion \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_CONSTANT_REAC_DIFF_NO_SPLIT_SUBTYPE = &
    & PROBLEM_CONSTANT_REAC_DIFF_NO_SPLIT_SUBTYPE !Standard constant reaction reaction diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_STANDARD_DATA_FITTING_SUBTYPE = &
    & PROBLEM_STANDARD_DATA_FITTING_SUBTYPE !<Standard Galerkin projection problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_VECTOR_DATA_FITTING_SUBTYPE = &
    & PROBLEM_VECTOR_DATA_FITTING_SUBTYPE !<Standard Galerkin projection problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_DIV_FREE_VECTOR_DATA_FITTING_SUBTYPE = &
    & PROBLEM_DIV_FREE_VECTOR_DATA_FITTING_SUBTYPE !<Standard Galerkin projection problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_VECTOR_DATA_PRE_FITTING_SUBTYPE = &
    & PROBLEM_VECTOR_DATA_PRE_FITTING_SUBTYPE !<Standard Galerkin projection problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_DIV_FREE_VECTOR_DATA_PRE_FITTING_SUBTYPE = &
    & PROBLEM_DIV_FREE_VECTOR_DATA_PRE_FITTING_SUBTYPE !<Standard Galerkin projection problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_GENERALISED_DATA_FITTING_SUBTYPE = &
    & PROBLEM_GENERALISED_DATA_FITTING_SUBTYPE !<Generalised Galerkin projection problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_MAT_PROPERTIES_DATA_FITTING_SUBTYPE = &
    & PROBLEM_MAT_PROPERTIES_DATA_FITTING_SUBTYPE !<Material Properties Galerkin projection problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_STANDARD_ELASTICITY_DARCY_SUBTYPE = PROBLEM_STANDARD_ELASTICITY_DARCY_SUBTYPE !<Standard Elasticity Darcy problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_PGM_ELASTICITY_DARCY_SUBTYPE = PROBLEM_PGM_ELASTICITY_DARCY_SUBTYPE !<PGM Elasticity Darcy problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_QUASISTATIC_ELASTICITY_TRANSIENT_DARCY_SUBTYPE = &
    & PROBLEM_QUASISTATIC_ELASTICITY_TRANSIENT_DARCY_SUBTYPE !<Quasistatic Elasticity Transient Darcy problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_QUASISTATIC_ELAST_TRANS_DARCY_MAT_SOLVE_SUBTYPE = &
    & PROBLEM_QUASISTATIC_ELAST_TRANS_DARCY_MAT_SOLVE_SUBTYPE !<Quasistatic Elasticity Transient Darcy Material Solve problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_COUPLED_SOURCE_DIFFUSION_DIFFUSION_SUBTYPE = &
    & PROBLEM_COUPLED_SOURCE_DIFFUSION_DIFFUSION_SUBTYPE !<Coupled source diffusion-diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_COUPLED_SOURCE_DIFFUSION_ADVEC_DIFFUSION_SUBTYPE = &
    & PROBLEM_COUPLED_SOURCE_DIFFUSION_ADVEC_DIFFUSION_SUBTYPE !<Coupled source diffusion & advection-diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_STANDARD_MULTI_COMPARTMENT_TRANSPORT_SUBTYPE = &
    & PROBLEM_STANDARD_MULTI_COMPARTMENT_TRANSPORT_SUBTYPE !<Standard multi-compartment transport problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_STANDARD_ELASTICITY_FLUID_PRESSURE_SUBTYPE = &
    & PROBLEM_STANDARD_ELASTICITY_FLUID_PRESSURE_SUBTYPE !<Standard elasticity fluid pressure problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_GUDUNOV_MONODOMAIN_SIMPLE_ELASTICITY_SUBTYPE = &
    & PROBLEM_GUDUNOV_MONODOMAIN_SIMPLE_ELASTICITY_SUBTYPE !<Transient monodomain simple elasticity problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_QUASISTATIC_FINITE_ELASTICITY_SUBTYPE = PROBLEM_QUASISTATIC_FINITE_ELASTICITY_SUBTYPE !<Quasistatic finite elasticity subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_FINITE_ELASTICITY_CELLML_SUBTYPE = PROBLEM_FINITE_ELASTICITY_CELLML_SUBTYPE !<Quasistatic finite elasticity subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_MONODOMAIN_GUDUNOV_SPLIT_SUBTYPE = PROBLEM_MONODOMAIN_GUDUNOV_SPLIT_SUBTYPE !<Monodomain Gudunov split problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_MONODOMAIN_STRANG_SPLIT_SUBTYPE = PROBLEM_MONODOMAIN_STRANG_SPLIT_SUBTYPE !<Monodomain Gudunov split problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_BIDOMAIN_GUDUNOV_SPLIT_SUBTYPE = PROBLEM_BIDOMAIN_GUDUNOV_SPLIT_SUBTYPE !<Bidomain Gudunov split problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_BIDOMAIN_STRANG_SPLIT_SUBTYPE = PROBLEM_BIDOMAIN_STRANG_SPLIT_SUBTYPE !<Bidomain Gudunov split problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_MONODOMAIN_BUENOOROVIO_SUBTYPE = PROBLEM_MONODOMAIN_BUENOOROVIO_SUBTYPE !<Generalised Laplace problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_MONODOMAIN_TENTUSSCHER06_SUBTYPE = PROBLEM_MONODOMAIN_TENTUSSCHER06_SUBTYPE !<Generalised Laplace problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS


  !>@}
  !> \addtogroup OPENCMISS_ProblemControlLoopTypes OPENCMISS::Problem::ControlLoopTypes
  !> \brief Problem control loop type parameters
  !> \see OPENCMISS::Problem,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_CONTROL_SIMPLE_TYPE = PROBLEM_CONTROL_SIMPLE_TYPE !<Simple, one iteration control loop. \see OPENCMISS_ProblemControlLoopTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_CONTROL_FIXED_LOOP_TYPE = PROBLEM_CONTROL_FIXED_LOOP_TYPE !<Fixed iteration control loop. \see OPENCMISS_ProblemControlLoopTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_CONTROL_TIME_LOOP_TYPE = PROBLEM_CONTROL_TIME_LOOP_TYPE !<Time control loop. \see OPENCMISS_ProblemControlLoopTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_CONTROL_WHILE_LOOP_TYPE = PROBLEM_CONTROL_WHILE_LOOP_TYPE !<While control loop. \see OPENCMISS_ProblemControlLoopTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_CONTROL_LOAD_INCREMENT_LOOP_TYPE = PROBLEM_CONTROL_LOAD_INCREMENT_LOOP_TYPE !<Load increment control loop. \see OPENCMISS_ProblemControlLoopTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  PUBLIC CMISS_PROBLEM_NO_CLASS,CMISS_PROBLEM_ELASTICITY_CLASS,CMISS_PROBLEM_FLUID_MECHANICS_CLASS, &
    & CMISS_PROBLEM_ELECTROMAGNETICS_CLASS, &
    & CMISS_PROBLEM_CLASSICAL_FIELD_CLASS,CMISS_PROBLEM_BIOELECTRICS_CLASS,CMISS_PROBLEM_MODAL_CLASS,CMISS_PROBLEM_FITTING_CLASS, &
    & CMISS_PROBLEM_OPTIMISATION_CLASS,CMISS_PROBLEM_MULTI_PHYSICS_CLASS

  PUBLIC CMISS_PROBLEM_NO_TYPE

  PUBLIC CMISS_PROBLEM_LINEAR_ELASTICITY_TYPE,CMISS_PROBLEM_FINITE_ELASTICITY_TYPE

  PUBLIC CMISS_PROBLEM_STOKES_EQUATION_TYPE,CMISS_PROBLEM_NAVIER_STOKES_EQUATION_TYPE,CMISS_PROBLEM_DARCY_EQUATION_TYPE, &
    & CMISS_PROBLEM_POISEUILLE_EQUATION_TYPE,CMISS_PROBLEM_BURGERS_EQUATION_TYPE

  PUBLIC CMISS_PROBLEM_ELECTROSTATIC_TYPE,CMISS_PROBLEM_MAGNETOSTATIC_TYPE,CMISS_PROBLEM_MAXWELLS_EQUATIONS_TYPE

  PUBLIC CMISS_PROBLEM_LAPLACE_EQUATION_TYPE,CMISS_PROBLEM_POISSON_EQUATION_TYPE,CMISS_PROBLEM_HELMHOLTZ_EQUATION_TYPE, &
    & CMISS_PROBLEM_WAVE_EQUATION_TYPE,CMISS_PROBLEM_DIFFUSION_EQUATION_TYPE,CMISS_PROBLEM_ADVECTION_DIFFUSION_EQUATION_TYPE, &
    & CMISS_PROBLEM_REACTION_DIFFUSION_EQUATION_TYPE,CMISS_PROBLEM_BIHARMONIC_EQUATION_TYPE

  PUBLIC CMISS_PROBLEM_MONODOMAIN_EQUATION_TYPE,CMISS_PROBLEM_BIDOMAIN_EQUATION_TYPE

  PUBLIC CMISS_PROBLEM_LINEAR_ELASTIC_MODAL_TYPE

  PUBLIC CMISS_PROBLEM_DATA_FITTING_TYPE

  PUBLIC CMISS_PROBLEM_FINITE_ELASTICITY_DARCY_TYPE, &
    & CMISS_PROBLEM_FINITE_ELASTICITY_STOKES_TYPE, CMISS_PROBLEM_FINITE_ELASTICITY_NAVIER_STOKES_TYPE, &
    & CMISS_PROBLEM_DIFFUSION_DIFFUSION_TYPE, CMISS_PROBLEM_DIFFUSION_ADVECTION_DIFFUSION_TYPE, &
    & CMISS_PROBLEM_MULTI_COMPARTMENT_TRANSPORT_TYPE,CMISS_PROBLEM_FINITE_ELASTICITY_FLUID_PRESSURE_TYPE, &
    & CMISS_PROBLEM_BIOELECTRIC_FINITE_ELASTICITY_TYPE

  PUBLIC CMISS_PROBLEM_NO_SUBTYPE

  PUBLIC CMISS_PROBLEM_STATIC_STOKES_SUBTYPE,CMISS_PROBLEM_LAPLACE_STOKES_SUBTYPE,CMISS_PROBLEM_TRANSIENT_STOKES_SUBTYPE, &
    & CMISS_PROBLEM_OPTIMISED_STOKES_SUBTYPE,CMISS_PROBLEM_ALE_STOKES_SUBTYPE,CMISS_PROBLEM_PGM_STOKES_SUBTYPE

  PUBLIC CMISS_PROBLEM_STATIC_NAVIER_STOKES_SUBTYPE,CMISS_PROBLEM_LAPLACE_NAVIER_STOKES_SUBTYPE, &
    & CMISS_PROBLEM_TRANSIENT_NAVIER_STOKES_SUBTYPE, &
    & CMISS_PROBLEM_1DTRANSIENT_NAVIER_STOKES_SUBTYPE,CMISS_PROBLEM_OPTIMISED_NAVIER_STOKES_SUBTYPE, &
    & CMISS_PROBLEM_ALE_NAVIER_STOKES_SUBTYPE, &
    & CMISS_PROBLEM_PGM_NAVIER_STOKES_SUBTYPE

  PUBLIC CMISS_PROBLEM_STANDARD_DARCY_SUBTYPE,CMISS_PROBLEM_QUASISTATIC_DARCY_SUBTYPE,CMISS_PROBLEM_ALE_DARCY_SUBTYPE, &
    & CMISS_PROBLEM_TRANSIENT_DARCY_SUBTYPE,CMISS_PROBLEM_PGM_DARCY_SUBTYPE,CMISS_PROBLEM_PGM_TRANSIENT_DARCY_SUBTYPE

  PUBLIC CMISS_PROBLEM_STATIC_POISEUILLE_SUBTYPE,CMISS_PROBLEM_DYNAMIC_POISEUILLE_SUBTYPE

  PUBLIC CMISS_PROBLEM_STATIC_BURGERS_SUBTYPE,CMISS_PROBLEM_DYNAMIC_BURGERS_SUBTYPE

  PUBLIC CMISS_PROBLEM_STANDARD_LAPLACE_SUBTYPE,CMISS_PROBLEM_GENERALISED_LAPLACE_SUBTYPE, &
    & CMISS_PROBLEM_MONODOMAIN_STRANG_SPLITTING_EQUATION_TYPE

  PUBLIC CMISS_PROBLEM_LINEAR_SOURCE_POISSON_SUBTYPE,CMISS_PROBLEM_NONLINEAR_SOURCE_POISSON_SUBTYPE, &
    & CMISS_PROBLEM_LINEAR_PRESSURE_POISSON_SUBTYPE,CMISS_PROBLEM_NONLINEAR_PRESSURE_POISSON_SUBTYPE, &
    & CMISS_PROBLEM_ALE_PRESSURE_POISSON_SUBTYPE, CMISS_PROBLEM_FITTED_PRESSURE_POISSON_SUBTYPE


  PUBLIC CMISS_PROBLEM_STANDARD_HELMHOLTZ_SUBTYPE,CMISS_PROBLEM_GENERALISED_HELMHOLTZ_SUBTYPE

  PUBLIC CMISS_PROBLEM_NO_SOURCE_DIFFUSION_SUBTYPE,CMISS_PROBLEM_LINEAR_SOURCE_DIFFUSION_SUBTYPE, &
    & CMISS_PROBLEM_NONLINEAR_SOURCE_DIFFUSION_SUBTYPE

  PUBLIC CMISS_PROBLEM_NO_SOURCE_ALE_DIFFUSION_SUBTYPE,CMISS_PROBLEM_LINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE, &
    & CMISS_PROBLEM_NONLINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE

  PUBLIC CMISS_PROBLEM_NO_SOURCE_ADVECTION_DIFFUSION_SUBTYPE,CMISS_PROBLEM_LINEAR_SOURCE_ADVECTION_DIFFUSION_SUBTYPE, &
    & CMISS_PROBLEM_NONLINEAR_SOURCE_ADVECTION_DIFFUSION_SUBTYPE

  PUBLIC CMISS_PROBLEM_NO_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE,CMISS_PROBLEM_LINEAR_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE, &
    & CMISS_PROBLEM_NONLINEAR_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE

  PUBLIC CMISS_PROBLEM_NO_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE,CMISS_PROBLEM_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE, &
    & CMISS_PROBLEM_NONLINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE

  PUBLIC CMISS_PROBLEM_CELLML_REAC_INTEG_REAC_DIFF_STRANG_SPLIT_SUBTYPE, &
    & CMISS_PROBLEM_CELLML_REAC_EVAL_REAC_DIFF_NO_SPLIT_SUBTYPE, &
    & CMISS_PROBLEM_CONSTANT_REAC_DIFF_NO_SPLIT_SUBTYPE


  PUBLIC CMISS_PROBLEM_STANDARD_DATA_FITTING_SUBTYPE,CMISS_PROBLEM_GENERALISED_DATA_FITTING_SUBTYPE, &
    & CMISS_PROBLEM_VECTOR_DATA_FITTING_SUBTYPE,CMISS_PROBLEM_DIV_FREE_VECTOR_DATA_FITTING_SUBTYPE, &
    & CMISS_PROBLEM_VECTOR_DATA_PRE_FITTING_SUBTYPE,CMISS_PROBLEM_DIV_FREE_VECTOR_DATA_PRE_FITTING_SUBTYPE, &
    & CMISS_PROBLEM_MAT_PROPERTIES_DATA_FITTING_SUBTYPE

  PUBLIC CMISS_PROBLEM_MONODOMAIN_GUDUNOV_SPLIT_SUBTYPE,CMISS_PROBLEM_MONODOMAIN_STRANG_SPLIT_SUBTYPE, &
    & CMISS_PROBLEM_BIDOMAIN_GUDUNOV_SPLIT_SUBTYPE,CMISS_PROBLEM_BIDOMAIN_STRANG_SPLIT_SUBTYPE

  PUBLIC CMISS_PROBLEM_MONODOMAIN_BUENOOROVIO_SUBTYPE, CMISS_PROBLEM_MONODOMAIN_TENTUSSCHER06_SUBTYPE

  PUBLIC CMISS_PROBLEM_CONTROL_SIMPLE_TYPE,CMISS_PROBLEM_CONTROL_FIXED_LOOP_TYPE,CMISS_PROBLEM_CONTROL_TIME_LOOP_TYPE, &
    & CMISS_PROBLEM_CONTROL_WHILE_LOOP_TYPE,CMISS_PROBLEM_CONTROL_LOAD_INCREMENT_LOOP_TYPE

  PUBLIC CMISS_PROBLEM_STANDARD_ELASTICITY_DARCY_SUBTYPE, CMISS_PROBLEM_PGM_ELASTICITY_DARCY_SUBTYPE, &
   & CMISS_PROBLEM_QUASISTATIC_ELASTICITY_TRANSIENT_DARCY_SUBTYPE,CMISS_PROBLEM_QUASISTATIC_ELAST_TRANS_DARCY_MAT_SOLVE_SUBTYPE, &
   & CMISS_PROBLEM_COUPLED_SOURCE_DIFFUSION_DIFFUSION_SUBTYPE, CMISS_PROBLEM_COUPLED_SOURCE_DIFFUSION_ADVEC_DIFFUSION_SUBTYPE, &
   & CMISS_PROBLEM_STANDARD_MULTI_COMPARTMENT_TRANSPORT_SUBTYPE,CMISS_PROBLEM_STANDARD_ELASTICITY_FLUID_PRESSURE_SUBTYPE, &
   & CMISS_PROBLEM_GUDUNOV_MONODOMAIN_SIMPLE_ELASTICITY_SUBTYPE

  PUBLIC CMISS_PROBLEM_QUASISTATIC_FINITE_ELASTICITY_SUBTYPE,CMISS_PROBLEM_FINITE_ELASTICITY_CELLML_SUBTYPE
!!==================================================================================================================================
!!
!! PROBLEM_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Finish the creation of CellML equations for a problem. \see OPENCMISS::CMISSProblemCellMLEquationsCreateStart
  INTERFACE CMISSProblemCellMLEquationsCreateFinish
    MODULE PROCEDURE CMISSProblemCellMLEquationsCreateFinishNumber
    MODULE PROCEDURE CMISSProblemCellMLEquationsCreateFinishObj
  END INTERFACE !CMISSProblemCellMLEquationsCreateFinish

  !>Start the creation of solver equations for a problem. \see OPENCMISS::CMISSProblemCellMLEquationsCreateFinish
  INTERFACE CMISSProblemCellMLEquationsCreateStart
    MODULE PROCEDURE CMISSProblemCellMLEquationsCreateStartNumber
    MODULE PROCEDURE CMISSProblemCellMLEquationsCreateStartObj
  END INTERFACE !CMISSProblemCellMLEquationsCreateStart

  !>Returns the CellML equations for a problem.
  INTERFACE CMISSProblemCellMLEquationsGet
    MODULE PROCEDURE CMISSProblemCellMLEquationsGetNumber0
    MODULE PROCEDURE CMISSProblemCellMLEquationsGetNumber1
    MODULE PROCEDURE CMISSProblemCellMLEquationsGetObj0
    MODULE PROCEDURE CMISSProblemCellMLEquationsGetObj1
  END INTERFACE !CMISSProblemCellMLEquationsGet

  !>Finishes the process of creating a problem. \see OPENCMISS::CMISSProblemCreateStart
  INTERFACE CMISSProblemCreateFinish
    MODULE PROCEDURE CMISSProblemCreateFinishNumber
    MODULE PROCEDURE CMISSProblemCreateFinishObj
  END INTERFACE !CMISSProblemCreateFinish

  !>Start the process of creating a problem. \see OPENCMISS::CMISSProblemCreateFinish
  INTERFACE CMISSProblemCreateStart
    MODULE PROCEDURE CMISSProblemCreateStartNumber
    MODULE PROCEDURE CMISSProblemCreateStartObj
  END INTERFACE !CMISSProblemCreateStart

  !>Finishes the process of creating a control loop on a problem. \see OPENCMISS::CMISSProblemControlLoopCreateStart
  INTERFACE CMISSProblemControlLoopCreateFinish
    MODULE PROCEDURE CMISSProblemControlLoopCreateFinishNumber
    MODULE PROCEDURE CMISSProblemControlLoopCreateFinishObj
  END INTERFACE !CMISSProblemControlLoopCreateFinish

  !>Starts the process of creating a control loop on a problem. \see OPENCMISS::CMISSProblemControlLoopCreateFinish
  INTERFACE CMISSProblemControlLoopCreateStart
    MODULE PROCEDURE CMISSProblemControlLoopCreateStartNumber
    MODULE PROCEDURE CMISSProblemControlLoopCreateStartObj
  END INTERFACE !CMISSProblemControlLoopCreateStart

  !>Destroys the control loop for a problem.
  INTERFACE CMISSProblemControlLoopDestroy
    MODULE PROCEDURE CMISSProblemControlLoopDestroyNumber
    MODULE PROCEDURE CMISSProblemControlLoopDestroyObj
  END INTERFACE !CMISSProblemControlLoopDestroy

  !>Returns a control loop for a problem.
  INTERFACE CMISSProblemControlLoopGet
    MODULE PROCEDURE CMISSProblemControlLoopGetNumber0
    MODULE PROCEDURE CMISSProblemControlLoopGetNumber1
    MODULE PROCEDURE CMISSProblemControlLoopGetObj0
    MODULE PROCEDURE CMISSProblemControlLoopGetObj1
  END INTERFACE !CMISSProblemControlLoopGet

  !>Destroys a problem.
  INTERFACE CMISSProblemDestroy
    MODULE PROCEDURE CMISSProblemDestroyNumber
    MODULE PROCEDURE CMISSProblemDestroyObj
  END INTERFACE !CMISSProblemDestroy

  !>Solve a problem.
  INTERFACE CMISSProblemSolve
    MODULE PROCEDURE CMISSProblemSolveNumber
    MODULE PROCEDURE CMISSProblemSolveObj
  END INTERFACE !CMISSProblemSolve

  !>Returns the solver for a problem control loop.
  INTERFACE CMISSProblemSolverGet
    MODULE PROCEDURE CMISSProblemSolverGetNumber0
    MODULE PROCEDURE CMISSProblemSolverGetNumber1
    MODULE PROCEDURE CMISSProblemSolverGetObj0
    MODULE PROCEDURE CMISSProblemSolverGetObj1
  END INTERFACE !CMISSProblemSolverGet

  !>Set boundary conditions for solver equations according to the analytic equations.
  INTERFACE CMISSProblemSolverEquationsBoundaryConditionsAnalytic
    MODULE PROCEDURE CMISSProblemSolverEquationsBoundaryConditionsAnalyticNumber0
    MODULE PROCEDURE CMISSProblemSolverEquationsBoundaryConditionsAnalyticNumber1
    MODULE PROCEDURE CMISSProblemSolverEquationsBoundaryConditionsAnalyticObj
  END INTERFACE !CMISSProblemSolverEquationsBoundaryConditionsAnalytic

  !>Finish the creation of solver equations for a problem. \see OPENCMISS::CMISSProblemSolverEquationsCreateStart
  INTERFACE CMISSProblemSolverEquationsCreateFinish
    MODULE PROCEDURE CMISSProblemSolverEquationsCreateFinishNumber
    MODULE PROCEDURE CMISSProblemSolverEquationsCreateFinishObj
  END INTERFACE !CMISSProblemSolverEquationsCreateFinish

  !>Start the creation of solver equations for a problem. \see OPENCMISS::CMISSProblemSolverEquationsCreateFinish
  INTERFACE CMISSProblemSolverEquationsCreateStart
    MODULE PROCEDURE CMISSProblemSolverEquationsCreateStartNumber
    MODULE PROCEDURE CMISSProblemSolverEquationsCreateStartObj
  END INTERFACE !CMISSProblemSolverEquationsCreateStart

  !>Destroys the solver equations for a problem.
  INTERFACE CMISSProblemSolverEquationsDestroy
    MODULE PROCEDURE CMISSProblemSolverEquationsDestroyNumber
    MODULE PROCEDURE CMISSProblemSolverEquationsDestroyObj
  END INTERFACE !CMISSProblemSolverEquationsDestroy

  !>Returns the solver equations for a problem.
  INTERFACE CMISSProblemSolverEquationsGet
    MODULE PROCEDURE CMISSProblemSolverEquationsGetNumber0
    MODULE PROCEDURE CMISSProblemSolverEquationsGetNumber1
    MODULE PROCEDURE CMISSProblemSolverEquationsGetObj0
    MODULE PROCEDURE CMISSProblemSolverEquationsGetObj1
  END INTERFACE !CMISSProblemSolverEquationsGet

  !>Finish the creation of solvers for a problem. \see OPENCMISS::CMISSProblemSolversCreateStart
  INTERFACE CMISSProblemSolversCreateFinish
    MODULE PROCEDURE CMISSProblemSolversCreateFinishNumber
    MODULE PROCEDURE CMISSProblemSolversCreateFinishObj
  END INTERFACE !CMISSProblemSolversCreateFinish

  !>Start the creation of solvers for a problem. \see OPENCMISS::CMISSProblemSolversCreateFinish
  INTERFACE CMISSProblemSolversCreateStart
    MODULE PROCEDURE CMISSProblemSolversCreateStartNumber
    MODULE PROCEDURE CMISSProblemSolversCreateStartObj
  END INTERFACE !CMISSProblemSolversCreateStart

  !>Destroy the solvers for a problem.
  INTERFACE CMISSProblemSolversDestroy
    MODULE PROCEDURE CMISSProblemSolversDestroyNumber
    MODULE PROCEDURE CMISSProblemSolversDestroyObj
  END INTERFACE !CMISSProblemSolversDestroy

  !>Returns the problem specification i.e., problem class, type and subtype for a problem.
  INTERFACE CMISSProblemSpecificationGet
    MODULE PROCEDURE CMISSProblemSpecificationGetNumber
    MODULE PROCEDURE CMISSProblemSpecificationGetObj
  END INTERFACE !CMISSProblemSpecificationGet

  !>Sets/changes the problem specification i.e., problem class, type and subtype for a problem.
  INTERFACE CMISSProblemSpecificationSet
    MODULE PROCEDURE CMISSProblemSpecificationSetNumber
    MODULE PROCEDURE CMISSProblemSpecificationSetObj
  END INTERFACE !CMISSProblemSpecificationSet

  PUBLIC CMISSProblemCellMLEquationsCreateFinish,CMISSProblemCellMLEquationsCreateStart

  PUBLIC CMISSProblemCellMLEquationsGet

  PUBLIC CMISSProblemCreateFinish,CMISSProblemCreateStart

  PUBLIC CMISSProblemControlLoopCreateFinish,CMISSProblemControlLoopCreateStart

  PUBLIC CMISSProblemControlLoopDestroy

  PUBLIC CMISSProblemControlLoopGet

  PUBLIC CMISSProblemDestroy

  PUBLIC CMISSProblemSolve

  PUBLIC CMISSProblemSolverGet

  PUBLIC CMISSProblemSolverEquationsBoundaryConditionsAnalytic

  PUBLIC CMISSProblemSolverEquationsCreateFinish,CMISSProblemSolverEquationsCreateStart

  PUBLIC CMISSProblemSolverEquationsDestroy

  PUBLIC CMISSProblemSolverEquationsGet

  PUBLIC CMISSProblemSolversCreateFinish,CMISSProblemSolversCreateStart

  PUBLIC CMISSProblemSolversDestroy

  PUBLIC CMISSProblemSpecificationGet,CMISSProblemSpecificationSet

!!==================================================================================================================================
!!
!! REGION_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Returns the coordinate system of region.
  INTERFACE CMISSRegionCoordinateSystemGet
    MODULE PROCEDURE CMISSRegionCoordinateSystemGetNumber
    MODULE PROCEDURE CMISSRegionCoordinateSystemGetObj
  END INTERFACE !CMISSRegionCoordinateSystemGet

  !>Sets/changes the coordinate system of region.
  INTERFACE CMISSRegionCoordinateSystemSet
    MODULE PROCEDURE CMISSRegionCoordinateSystemSetNumber
    MODULE PROCEDURE CMISSRegionCoordinateSystemSetObj
  END INTERFACE !CMISSRegionCoordinateSystemSet

  !>Finishes the creation of a region. \see OPENCMISS::CMISSRegionCreateStart
  INTERFACE CMISSRegionCreateFinish
    MODULE PROCEDURE CMISSRegionCreateFinishNumber
    MODULE PROCEDURE CMISSRegionCreateFinishObj
  END INTERFACE !CMISSRegionCreateFinish

  !>Starts the creation of a region. \see OPENCMISS::CMISSRegionCreateFinish
  INTERFACE CMISSRegionCreateStart
    MODULE PROCEDURE CMISSRegionCreateStartNumber
    MODULE PROCEDURE CMISSRegionCreateStartObj
  END INTERFACE !CMISSRegionCreateStart

  !>Returns the data points for a region.
  INTERFACE CMISSRegionDataPointsGet
    MODULE PROCEDURE CMISSRegionDataPointsGetObj
  END INTERFACE !CMISSRegionDataPointsGet

  !>Destroys a region.
  INTERFACE CMISSRegionDestroy
    MODULE PROCEDURE CMISSRegionDestroyNumber
    MODULE PROCEDURE CMISSRegionDestroyObj
  END INTERFACE !CMISSRegionDestroy

  !>Returns the label of a region.
  INTERFACE CMISSRegionLabelGet
    MODULE PROCEDURE CMISSRegionLabelGetCNumber
    MODULE PROCEDURE CMISSRegionLabelGetCObj
    MODULE PROCEDURE CMISSRegionLabelGetVSNumber
    MODULE PROCEDURE CMISSRegionLabelGetVSObj
  END INTERFACE !CMISSRegionLabelGet

  !>Sets/changes the label of a region.
  INTERFACE CMISSRegionLabelSet
    MODULE PROCEDURE CMISSRegionLabelSetCNumber
    MODULE PROCEDURE CMISSRegionLabelSetCObj
    MODULE PROCEDURE CMISSRegionLabelSetVSNumber
    MODULE PROCEDURE CMISSRegionLabelSetVSObj
  END INTERFACE !CMISSRegionLabelSet

  !>Returns the nodes for a region.
  INTERFACE CMISSRegionNodesGet
    MODULE PROCEDURE CMISSRegionNodesGetObj
  END INTERFACE !CMISSRegionNodesGet

  PUBLIC CMISSRegionCoordinateSystemGet,CMISSRegionCoordinateSystemSet

  PUBLIC CMISSRegionCreateFinish,CMISSRegionCreateStart

  PUBLIC CMISSRegionDataPointsGet

  PUBLIC CMISSRegionDestroy

  PUBLIC CMISSRegionLabelGet,CMISSRegionLabelSet

  PUBLIC CMISSRegionNodesGet

!!==================================================================================================================================
!!
!! SOLVER_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_SolverConstants OPENCMISS::Solver::Constants
  !> \brief Solver constants.
  !>@{
  !> \addtogroup OPENCMISS_SolverTypes OPENCMISS::Solver::SolverTypes
  !> \brief The types of solver
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_LINEAR_TYPE = SOLVER_LINEAR_TYPE !<A linear solver. \see OPENCMISS_SolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NONLINEAR_TYPE = SOLVER_NONLINEAR_TYPE !<A nonlinear solver. \see OPENCMISS_SolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_TYPE = SOLVER_DYNAMIC_TYPE !<A dynamic solver. \see  OPENCMISS_SolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DAE_TYPE = SOLVER_DAE_TYPE !<A differential-algebraic equation solver. \see OPENCMISS_SolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_EIGENPROBLEM_TYPE = SOLVER_EIGENPROBLEM_TYPE !<A eigenproblem solver. \see OPENCMISS_SolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_OPTIMISER_TYPE = SOLVER_OPTIMISER_TYPE !<An optimiser solver. \see OPENCMISS_SolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverCellMLEvaluatorType = SOLVER_CELLML_EVALUATOR_TYPE !<A CellML evaluator solver. \see OPENCMISS_SolverTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_SolverLibraries OPENCMISS::Solver::SolverLibraries
  !> \brief The types of solver libraries.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_CMISS_LIBRARY = SOLVER_CMISS_LIBRARY !<CMISS (internal) solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_PETSC_LIBRARY = SOLVER_PETSC_LIBRARY !<PETSc solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_MUMPS_LIBRARY = SOLVER_MUMPS_LIBRARY !<MUMPS solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_SUPERLU_LIBRARY = SOLVER_SUPERLU_LIBRARY !<SuperLU solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_SPOOLES_LIBRARY = SOLVER_SPOOLES_LIBRARY !<SPOOLES solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_UMFPACK_LIBRARY = SOLVER_UMFPACK_LIBRARY !<UMFPACK solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_LUSOL_LIBRARY = SOLVER_LUSOL_LIBRARY !<LUSOL solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_ESSL_LIBRARY = SOLVER_ESSL_LIBRARY !<ESSL solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_LAPACK_LIBRARY = SOLVER_LAPACK_LIBRARY !<LAPACK solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_TAO_LIBRARY = SOLVER_TAO_LIBRARY !<TAO solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_HYPRE_LIBRARY = SOLVER_HYPRE_LIBRARY !<Hypre solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_PASTIX_LIBRARY = SOLVER_PASTIX_LIBRARY !<PaStiX solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_LinearSolverTypes OPENCMISS::Solver::LinearSolverTypes
  !> \brief The types of linear solvers.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_LINEAR_DIRECT_SOLVE_TYPE = SOLVER_LINEAR_DIRECT_SOLVE_TYPE !<Direct linear solver type. \see OPENCMISS_LinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE = SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE !<Iterative linear solver type. \see OPENCMISS_LinearSolverTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_DirectLinearSolverTypes OPENCMISS::Solver::DirectLinearSolverTypes
  !> \brief The types of direct linear solvers. \todo Move libraries to a more appropriate place.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DIRECT_LU = SOLVER_DIRECT_LU !<LU direct linear solver. \see OPENCMISS_DirectLinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DIRECT_CHOLESKY = SOLVER_DIRECT_CHOLESKY !<Cholesky direct linear solver. \see OPENCMISS_DirectLinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DIRECT_SVD = SOLVER_DIRECT_SVD !<SVD direct linear solver. \see OPENCMISS_DirectLinearSolverTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_IterativeLinearSolverTypes OPENCMISS::Solver::IterativeLinearSolverTypes
  !> \brief The types of iterative linear solvers.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_ITERATIVE_RICHARDSON = SOLVER_ITERATIVE_RICHARDSON !<Richardson iterative solver type. \see  OPENCMISS_IterativeLinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_ITERATIVE_CHEBYCHEV = SOLVER_ITERATIVE_CHEBYCHEV !<Chebychev iterative solver type. \see OPENCMISS_IterativeLinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_ITERATIVE_CONJUGATE_GRADIENT = SOLVER_ITERATIVE_CONJUGATE_GRADIENT !<Conjugate gradient iterative solver type. \see OPENCMISS_IterativeLinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_ITERATIVE_BICONJUGATE_GRADIENT = SOLVER_ITERATIVE_BICONJUGATE_GRADIENT !<Bi-conjugate gradient iterative solver type. \see OPENCMISS_IterativeLinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_ITERATIVE_GMRES = SOLVER_ITERATIVE_GMRES !<Generalised minimum residual iterative solver type. \see OPENCMISS_IterativeLinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_ITERATIVE_BiCGSTAB = SOLVER_ITERATIVE_BiCGSTAB !<Stabalised bi-conjugate gradient iterative solver type. \see OPENCMISS_IterativeLinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_ITERATIVE_CONJGRAD_SQUARED = SOLVER_ITERATIVE_CONJGRAD_SQUARED !<Conjugate gradient squared iterative solver type. \see OPENCMISS_IterativeLinearSolverTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_IterativePreconditionerTypes OPENCMISS::Solver::IterativePreconditionerTypes
  !> \brief The types of iterative preconditioners.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_ITERATIVE_NO_PRECONDITIONER = SOLVER_ITERATIVE_NO_PRECONDITIONER !<No preconditioner type. \see OPENCMISS_IterativePreconditionerTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_ITERATIVE_JACOBI_PRECONDITIONER = SOLVER_ITERATIVE_JACOBI_PRECONDITIONER !<Jacobi preconditioner type. \see OPENCMISS_IterativePreconditionerTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_ITERATIVE_BLOCK_JACOBI_PRECONDITIONER = SOLVER_ITERATIVE_BLOCK_JACOBI_PRECONDITIONER !<Iterative block Jacobi preconditioner type. \see OPENCMISS_IterativePreconditionerTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_ITERATIVE_SOR_PRECONDITIONER = SOLVER_ITERATIVE_SOR_PRECONDITIONER !<Successive over relaxation preconditioner type. \see OPENCMISS_IterativePreconditionerTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_ITERATIVE_INCOMPLETE_CHOLESKY_PRECONDITIONER = &
    & SOLVER_ITERATIVE_INCOMPLETE_CHOLESKY_PRECONDITIONER !<Incomplete Cholesky preconditioner type. \see OPENCMISS_IterativePreconditionerTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_ITERATIVE_INCOMPLETE_LU_PRECONDITIONER = SOLVER_ITERATIVE_INCOMPLETE_LU_PRECONDITIONER !<Incomplete LU preconditioner type. \see OPENCMISS_IterativePreconditionerTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_ITERATIVE_ADDITIVE_SCHWARZ_PRECONDITIONER =  &
    & SOLVER_ITERATIVE_ADDITIVE_SCHWARZ_PRECONDITIONER !<Additive Schwrz preconditioner type. \see OPENCMISS_IterativePreconditionerTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_NonlinearSolverTypes OPENCMISS::Solver::NonlinearSolverTypes
  !> \brief The types of nonlinear solvers.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NONLINEAR_NEWTON = SOLVER_NONLINEAR_NEWTON !<Newton nonlinear solver type. \see OPENCMISS_NonlinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NONLINEAR_BFGS_INVERSE = SOLVER_NONLINEAR_BFGS_INVERSE !<BFGS inverse nonlinear solver type. \see OPENCMISS_NonlinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NONLINEAR_SQP = SOLVER_NONLINEAR_SQP !<Sequential Quadratic Program nonlinear solver type. \see OPENCMISS_NonlinearSolverTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_NewtonSolverTypes OPENCMISS::Solver::NewtonSolverTypes
  !> \brief The types of nonlinear Newton solvers.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NEWTON_LINESEARCH = SOLVER_NEWTON_LINESEARCH !<Newton line search nonlinear solver type. \see OPENCMISS_NewtonSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NEWTON_TRUSTREGION = SOLVER_NEWTON_TRUSTREGION !<Newton trust region nonlinear solver type. \see OPENCMISS_NewtonSolverTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_NewtonLineSearchTypes OPENCMISS::Solver::NewtonLineSearchTypes
  !> \brief The types line search techniques for Newton line search nonlinear solvers.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NEWTON_LINESEARCH_NONORMS = SOLVER_NEWTON_LINESEARCH_NONORMS !<No norms line search for Newton line search nonlinear solves \see OPENCMISS_NewtonLineSearchTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NEWTON_LINESEARCH_NONE = SOLVER_NEWTON_LINESEARCH_NONE !<No line search for Newton line search nonlinear solves \see OPENCMISS_NewtonLineSearchTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NEWTON_LINESEARCH_QUADRATIC = SOLVER_NEWTON_LINESEARCH_QUADRATIC !<Quadratic search for Newton line search nonlinear solves \see OPENCMISS_NewtonLineSearchTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NEWTON_LINESEARCH_CUBIC = SOLVER_NEWTON_LINESEARCH_CUBIC !<Cubic search for Newton line search nonlinear solves \see OPENCMISS_NewtonLineSearchTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_JacobianCalculationTypes OPENCMISS::Solver::JacobianCalculationTypes
  !> \brief The Jacobian calculation types for a nonlinear solver.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NEWTON_JACOBIAN_NOT_CALCULATED = SOLVER_NEWTON_JACOBIAN_NOT_CALCULATED !<The Jacobian values will not be calculated for the nonlinear equations set. \see OPENCMISS_JacobianCalculationTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NEWTON_JACOBIAN_ANALTYIC_CALCULATED = SOLVER_NEWTON_JACOBIAN_ANALTYIC_CALCULATED !<The Jacobian values will be calculated analytically for the nonlinear equations set. \see OPENCMISS_JacobianCalculationTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NEWTON_JACOBIAN_FD_CALCULATED = SOLVER_NEWTON_JACOBIAN_FD_CALCULATED !<The Jacobian values will be calcualted using finite differences for the nonlinear equations set. \see OPENCMISS_JacobianCalculationTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_DynamicOrderTypes OPENCMISS::Solver::DynamicOrderTypes
  !> \brief The order types for a dynamic solver.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_FIRST_ORDER = SOLVER_DYNAMIC_FIRST_ORDER !<Dynamic solver has first order terms. \see OPENCMISS_DynamicOrderTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_SECOND_ORDER = SOLVER_DYNAMIC_SECOND_ORDER !<Dynamic solver has second order terms. \see OPENCMISS_DynamicOrderTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_DynamicLinearityTypes OPENCMISS::Solver::DynamicLinearityTypes
  !> \brief The time linearity types for a dynamic solver.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_LINEAR = SOLVER_DYNAMIC_LINEAR !<Dynamic solver has linear terms. \see OPENCMISS_DynamicLinearityTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_NONLINEAR = SOLVER_DYNAMIC_NONLINEAR !<Dynamic solver has nonlinear terms. \see OPENCMISS_DynamicLinearityTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_DynamicDegreeTypes OPENCMISS::Solver::DynamicDegreeTypes
  !> \brief The time interpolation polynomial degree types for a dynamic solver.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_FIRST_DEGREE = SOLVER_DYNAMIC_FIRST_DEGREE !<Dynamic solver uses a first degree polynomial for time interpolation. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_SECOND_DEGREE = SOLVER_DYNAMIC_SECOND_DEGREE !<Dynamic solver uses a second degree polynomial for time interpolation. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_THIRD_DEGREE = SOLVER_DYNAMIC_THIRD_DEGREE !<Dynamic solver uses a third degree polynomial for time interpolation. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_DynamicSchemeTypes OPENCMISS::Solver::DynamicSchemeTypes
  !> \brief The types of dynamic solver scheme.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_EULER_SCHEME = SOLVER_DYNAMIC_EULER_SCHEME !<Euler (explicit) dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_BACKWARD_EULER_SCHEME = SOLVER_DYNAMIC_BACKWARD_EULER_SCHEME !<Backward Euler (implicit) dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_CRANK_NICOLSON_SCHEME = SOLVER_DYNAMIC_CRANK_NICOLSON_SCHEME !<Crank-Nicolson dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_GALERKIN_SCHEME = SOLVER_DYNAMIC_GALERKIN_SCHEME !<Galerkin dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_ZLAMAL_SCHEME = SOLVER_DYNAMIC_ZLAMAL_SCHEME !<Zlamal dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_SECOND_DEGREE_GEAR_SCHEME = SOLVER_DYNAMIC_SECOND_DEGREE_GEAR_SCHEME !<2nd degree Gear dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER1_SCHEME = SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER1_SCHEME !<1st 2nd degree Liniger dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER2_SCHEME = SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER2_SCHEME !<2nd 2nd degree Liniger dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_NEWMARK1_SCHEME = SOLVER_DYNAMIC_NEWMARK1_SCHEME !<1st Newmark dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_NEWMARK2_SCHEME = SOLVER_DYNAMIC_NEWMARK2_SCHEME !<2nd Newmark dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_NEWMARK3_SCHEME = SOLVER_DYNAMIC_NEWMARK3_SCHEME !<3rd Newmark dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_THIRD_DEGREE_GEAR_SCHEME = SOLVER_DYNAMIC_THIRD_DEGREE_GEAR_SCHEME !<3rd degree Gear dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER1_SCHEME = SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER1_SCHEME !<1st 3rd degree Liniger dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER2_SCHEME = SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER2_SCHEME !<2nd 3rd degree Liniger dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_HOUBOLT_SCHEME = SOLVER_DYNAMIC_HOUBOLT_SCHEME !<Houbolt dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_WILSON_SCHEME = SOLVER_DYNAMIC_WILSON_SCHEME !<Wilson dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_BOSSAK_NEWMARK1_SCHEME = SOLVER_DYNAMIC_BOSSAK_NEWMARK1_SCHEME !<1st Bossak-Newmark dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_BOSSAK_NEWMARK2_SCHEME = SOLVER_DYNAMIC_BOSSAK_NEWMARK2_SCHEME !<2nd Bossak-Newmark dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR1_SCHEME = SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR1_SCHEME !<1st Hilbert-Hughes-Taylor dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR2_SCHEME = SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR2_SCHEME !<1st Hilbert-Hughes-Taylor dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_USER_DEFINED_SCHEME = SOLVER_DYNAMIC_USER_DEFINED_SCHEME !<User specified degree and theta dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_DAETypes OPENCMISS::Solver::DAETypes
  !> \brief The type of differential-algebraic equation.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DAE_DIFFERENTIAL_ONLY = SOLVER_DAE_DIFFERENTIAL_ONLY !<Differential equations only. \see OPENCMISS_DAETypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DAE_INDEX_1 = SOLVER_DAE_INDEX_1 !<Index 1 differential-algebraic equation. \see OPENCMISS_DAETypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DAE_INDEX_2 = SOLVER_DAE_INDEX_2 !<Index 2 differential-algebraic equation. \see OPENCMISS_DAETypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DAE_INDEX_3 = SOLVER_DAE_INDEX_3 !<Index 3 differential-algebraic equation. \see OPENCMISS_DAETypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_DAESolverTypes OPENCMISS::Solver::DAESolverTypes
  !> \brief The differential-algebraic equation solver types for a differential-algebraic equation solver.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DAE_EULER = SOLVER_DAE_EULER !<Euler differential-algebraic equation solver. \see
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DAE_CRANK_NICOLSON = SOLVER_DAE_CRANK_NICOLSON !<Crank-Nicolson differential-algebraic equation solver. \see
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DAE_RUNGE_KUTTA = SOLVER_DAE_RUNGE_KUTTA !<Runge-Kutta differential-algebraic equation solver. \see
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DAE_ADAMS_MOULTON = SOLVER_DAE_ADAMS_MOULTON !<Adams-Moulton differential-algebraic equation solver. \see
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DAE_BDF = SOLVER_DAE_BDF !<General BDF differential-algebraic equation solver. \see
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DAE_RUSH_LARSON = SOLVER_DAE_RUSH_LARSON !<Rush-Larson differential-algebraic equation solver. \see
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DAE_EXTERNAL = SOLVER_DAE_EXTERNAL !<External (e.g., CellML generated) differential-algebraic equation solver. \see
  !>@}
  !> \addtogroup OPENCMISS_EulerDAESolverTypes OPENCMISS::Solver::EulerDAESolverTypes
  !> \brief The Euler solver types for a differential-algebriac equation solver.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DAE_EULER_FORWARD = SOLVER_DAE_EULER_FORWARD !<Forward Euler differential equation solver. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DAE_EULER_BACKWARD = SOLVER_DAE_EULER_BACKWARD !<Backward Euler differential equation solver. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DAE_EULER_IMPROVED = SOLVER_DAE_EULER_IMPROVED !<Improved Euler differential equation solver. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_SolutionInitialiseTypes OPENCMISS::Solver::SolutionInitialiseTypes
  !> \brief The types of solution initialisation.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_SOLUTION_INITIALISE_ZERO = SOLVER_SOLUTION_INITIALISE_ZERO !<Initialise the solution by zeroing it before a solve. \see OPENCMISS_SolutionInitialiseTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD = SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD !<Initialise the solution by copying in the current dependent field values. \see OPENCMISS_SolutionInitialiseTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_SOLUTION_INITIALISE_NO_CHANGE = SOLVER_SOLUTION_INITIALISE_NO_CHANGE !<Do not change the solution before a solve. \see OPENCMISS_SolutionInitialiseTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_SolverOutputTypes OPENCMISS::Solver::OutputTypes
  !> \brief The types of output.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NO_OUTPUT = SOLVER_NO_OUTPUT !<No output from the solver routines. \see OPENCMISS_SolverOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_PROGRESS_OUTPUT = SOLVER_PROGRESS_OUTPUT !<Progress output from solver routines. \see OPENCMISS_SolverOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_TIMING_OUTPUT = SOLVER_TIMING_OUTPUT !<Timing output from the solver routines plus below. \see OPENCMISS_SolverOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_SOLVER_OUTPUT = SOLVER_SOLVER_OUTPUT !<Solver specific output from the solver routines plus below. \see OPENCMISS_SolverOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_MATRIX_OUTPUT = SOLVER_MATRIX_OUTPUT !<Solver matrices output from the solver routines plus below. \see OPENCMISS_SolverOutputTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_SolverEquationsSparsityTypes OPENCMISS::SolverEquations::SparsityTypes
  !> \brief The types of sparse solver equations matrices.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_SPARSE_MATRICES = SOLVER_SPARSE_MATRICES !<Use sparse solver matrices. \see OPENCMISS_SolverEquationsSparsityTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_FULL_MATRICES = SOLVER_FULL_MATRICES !<Use fully populated solver matrices. \see OPENCMISS_SolverEquationsSparsityTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Returns the CellML equations for a solver.
  INTERFACE CMISSSolverCellMLEquationsGet
    MODULE PROCEDURE CMISSSolverCellMLEquationsGetNumber0
    MODULE PROCEDURE CMISSSolverCellMLEquationsGetNumber1
    MODULE PROCEDURE CMISSSolverCellMLEquationsGetObj
  END INTERFACE !CMISSSolverCellMLEquationsGet

  !>Adds CellML environments to CellML equations.
  INTERFACE CMISSCellMLEquationsCellMLAdd
    MODULE PROCEDURE CMISSCellMLEquationsCellMLAddNumber0
    MODULE PROCEDURE CMISSCellMLEquationsCellMLAddNumber1
    MODULE PROCEDURE CMISSCellMLEquationsCellMLAddObj
  END INTERFACE !CMISSCellMLEquationsCellMLAdd

  !>Returns the solver type for an Euler differential-algebraic equation solver. \todo should this be CMISSSolverDAEEulerSolverTypeGet???
  INTERFACE CMISSSolverDAEEulerSolverTypeGet
    MODULE PROCEDURE CMISSSolverDAEEulerSolverTypeGetNumber0
    MODULE PROCEDURE CMISSSolverDAEEulerSolverTypeGetNumber1
    MODULE PROCEDURE CMISSSolverDAEEulerSolverTypeGetObj
  END INTERFACE !CMISSSolverDAEEulerSolverTypeGet

  !>Sets/changes the solver type for an Euler differential-algebraic equation solver. \todo should this be CMISSSolverDAEEulerSolverTypeSet???
  INTERFACE CMISSSolverDAEEulerSolverTypeSet
    MODULE PROCEDURE CMISSSolverDAEEulerSolverTypeSetNumber0
    MODULE PROCEDURE CMISSSolverDAEEulerSolverTypeSetNumber1
    MODULE PROCEDURE CMISSSolverDAEEulerSolverTypeSetObj
  END INTERFACE !CMISSSolverDAEEulerSolverTypeSet

  !>Returns the solver type for an differential-algebraic equation solver.
  INTERFACE CMISSSolverDAESolverTypeGet
    MODULE PROCEDURE CMISSSolverDAESolverTypeGetNumber0
    MODULE PROCEDURE CMISSSolverDAESolverTypeGetNumber1
    MODULE PROCEDURE CMISSSolverDAESolverTypeGetObj
  END INTERFACE !CMISSSolverDAESolverTypeGet

  !>Sets/changes the solver type for an differential-algebraic equation solver.
  INTERFACE CMISSSolverDAESolverTypeSet
    MODULE PROCEDURE CMISSSolverDAESolverTypeSetNumber0
    MODULE PROCEDURE CMISSSolverDAESolverTypeSetNumber1
    MODULE PROCEDURE CMISSSolverDAESolverTypeSetObj
  END INTERFACE !CMISSSolverDAESolverTypeSet

  !>Sets/changes the times for a differential-algebraic equation solver.
  INTERFACE CMISSSolverDAETimesSet
    MODULE PROCEDURE CMISSSolverDAETimesSetNumber0
    MODULE PROCEDURE CMISSSolverDAETimesSetNumber1
    MODULE PROCEDURE CMISSSolverDAETimesSetObj
  END INTERFACE !CMISSSolverDAETimesSet

  !>Sets/changes the (initial) time step for a differential-algebraic equation solver.
  INTERFACE CMISSSolverDAETimeStepSet
    MODULE PROCEDURE CMISSSolverDAETimeStepSetNumber0
    MODULE PROCEDURE CMISSSolverDAETimeStepSetNumber1
    MODULE PROCEDURE CMISSSolverDAETimeStepSetObj
  END INTERFACE !CMISSSolverDAETimeStepSet

  !>Returns the degree of the polynomial used to interpolate time for a dynamic solver.
  INTERFACE CMISSSolverDynamicDegreeGet
    MODULE PROCEDURE CMISSSolverDynamicDegreeGetNumber0
    MODULE PROCEDURE CMISSSolverDynamicDegreeGetNumber1
    MODULE PROCEDURE CMISSSolverDynamicDegreeGetObj
  END INTERFACE !CMISSSolverDynamicDegreeGet

  !>Sets/changes the degree of the polynomial used to interpolate time for a dynamic solver.
  INTERFACE CMISSSolverDynamicDegreeSet
    MODULE PROCEDURE CMISSSolverDynamicDegreeSetNumber0
    MODULE PROCEDURE CMISSSolverDynamicDegreeSetNumber1
    MODULE PROCEDURE CMISSSolverDynamicDegreeSetObj
  END INTERFACE !CMISSSolverDynamicDegreeSet

  !>Returns the linearity type for the dynamic solver.
  INTERFACE CMISSSolverDynamicLinearityTypeGet
    MODULE PROCEDURE CMISSSolverDynamicLinearityTypeGetNumber0
    MODULE PROCEDURE CMISSSolverDynamicLinearityTypeGetNumber1
    MODULE PROCEDURE CMISSSolverDynamicLinearityTypeGetObj
  END INTERFACE !CMISSSolverDynamicLinearityTypeGet

  !>Returns the linear solver associated with a linear dynamic solver.
  INTERFACE CMISSSolverDynamicLinearSolverGet
    MODULE PROCEDURE CMISSSolverDynamicLinearSolverGetNumber0
    MODULE PROCEDURE CMISSSolverDynamicLinearSolverGetNumber1
    MODULE PROCEDURE CMISSSolverDynamicLinearSolverGetObj
  END INTERFACE !CMISSSolverDynamicNonlinearSolverGet

  !>Returns the nonlinear solver associated with a nonlinear dynamic solver.
  INTERFACE CMISSSolverDynamicNonlinearSolverGet
    MODULE PROCEDURE CMISSSolverDynamicNonlinearSolverGetNumber0
    MODULE PROCEDURE CMISSSolverDynamicNonlinearSolverGetNumber1
    MODULE PROCEDURE CMISSSolverDynamicNonlinearSolverGetObj
  END INTERFACE !CMISSSolverDynamicNonlinearSolverGet

  !>Sets/changes the scheme for a dynamic solver.
  INTERFACE CMISSSolverDynamicSchemeSet
    MODULE PROCEDURE CMISSSolverDynamicSchemeSetNumber0
    MODULE PROCEDURE CMISSSolverDynamicSchemeSetNumber1
    MODULE PROCEDURE CMISSSolverDynamicSchemeSetObj
  END INTERFACE !CMISSSolverDynamicSchemeSet

  !>Sets/changes the theta scheme values for a dynamic solver.
  INTERFACE CMISSSolverDynamicThetaSet
    MODULE PROCEDURE CMISSSolverDynamicThetaSetNumber00
    MODULE PROCEDURE CMISSSolverDynamicThetaSetNumber01
    MODULE PROCEDURE CMISSSolverDynamicThetaSetNumber10
    MODULE PROCEDURE CMISSSolverDynamicThetaSetNumber11
    MODULE PROCEDURE CMISSSolverDynamicThetaSetObj0
    MODULE PROCEDURE CMISSSolverDynamicThetaSetObj1
  END INTERFACE !CMISSSolverDynamicThetaSet

  !>Sets/changes the dynamic times for a dynamic solver.
  INTERFACE CMISSSolverDynamicTimesSet
    MODULE PROCEDURE CMISSSolverDynamicTimesSetNumber0
    MODULE PROCEDURE CMISSSolverDynamicTimesSetNumber1
    MODULE PROCEDURE CMISSSolverDynamicTimesSetObj
  END INTERFACE !CMISSSolverDynamicTimesSet

  !>Returns the label of a solver.
  INTERFACE CMISSSolverLabelGet
    MODULE PROCEDURE CMISSSolverLabelGetCNumber0
    MODULE PROCEDURE CMISSSolverLabelGetCNumber1
    MODULE PROCEDURE CMISSSolverLabelGetCObj
    MODULE PROCEDURE CMISSSolverLabelGetVSNumber0
    MODULE PROCEDURE CMISSSolverLabelGetVSNumber1
    MODULE PROCEDURE CMISSSolverLabelGetVSObj
  END INTERFACE !CMISSSolverLabelGet

  !>Sets/changes the label of a control loop.
  INTERFACE CMISSSolverLabelSet
    MODULE PROCEDURE CMISSSolverLabelSetCNumber0
    MODULE PROCEDURE CMISSSolverLabelSetCNumber1
    MODULE PROCEDURE CMISSSolverLabelSetCObj
    MODULE PROCEDURE CMISSSolverLabelSetVSNumber0
    MODULE PROCEDURE CMISSSolverLabelSetVSNumber1
    MODULE PROCEDURE CMISSSolverLabelSetVSObj
  END INTERFACE !CMISSSolverLabelSet

  !>Returns the type of library to use for the solver.
  INTERFACE CMISSSolverLibraryTypeGet
    MODULE PROCEDURE CMISSSolverLibraryTypeGetNumber0
    MODULE PROCEDURE CMISSSolverLibraryTypeGetNumber1
    MODULE PROCEDURE CMISSSolverLibraryTypeGetObj
  END INTERFACE !CMISSSolverLibraryTypeGet

  !>Sets/changes the type of library to use for the solver.
  INTERFACE CMISSSolverLibraryTypeSet
    MODULE PROCEDURE CMISSSolverLibraryTypeSetNumber0
    MODULE PROCEDURE CMISSSolverLibraryTypeSetNumber1
    MODULE PROCEDURE CMISSSolverLibraryTypeSetObj
  END INTERFACE !CMISSSolverLibraryTypeSet

  !>Sets/changes the type of direct linear solver.
  INTERFACE CMISSSolverLinearDirectTypeSet
    MODULE PROCEDURE CMISSSolverLinearDirectTypeSetNumber0
    MODULE PROCEDURE CMISSSolverLinearDirectTypeSetNumber1
    MODULE PROCEDURE CMISSSolverLinearDirectTypeSetObj
  END INTERFACE !CMISSSolverLinearDirectTypeSet

  !>Sets/changes the absolute tolerance for an iterative linear solver.
  INTERFACE CMISSSolverLinearIterativeAbsoluteToleranceSet
    MODULE PROCEDURE CMISSSolverLinearIterativeAbsoluteToleranceSetNumber0
    MODULE PROCEDURE CMISSSolverLinearIterativeAbsoluteToleranceSetNumber1
    MODULE PROCEDURE CMISSSolverLinearIterativeAbsoluteToleranceSetObj
  END INTERFACE !CMISSSolverLinearIterativeAbsoluteToleranceSet

  !>Sets/changes the divergence tolerance for an iterative linear solver.
  INTERFACE CMISSSolverLinearIterativeDivergenceToleranceSet
    MODULE PROCEDURE CMISSSolverLinearIterativeDivergenceToleranceSetNumber0
    MODULE PROCEDURE CMISSSolverLinearIterativeDivergenceToleranceSetNumber1
    MODULE PROCEDURE CMISSSolverLinearIterativeDivergenceToleranceSetObj
  END INTERFACE !CMISSSolverLinearIterativeDivergenceToleranceSet

  !>Sets/changes the GMRES restart value for a GMRES iterative linear solver.
  INTERFACE CMISSSolverLinearIterativeGMRESRestartSet
    MODULE PROCEDURE CMISSSolverLinearIterativeGMRESRestartSetNumber0
    MODULE PROCEDURE CMISSSolverLinearIterativeGMRESRestartSetNumber1
    MODULE PROCEDURE CMISSSolverLinearIterativeGMRESRestartSetObj
  END INTERFACE !CMISSSolverLinearIterativeGMRESRestartSet

  !>Sets/changes the maximum number of iterations for an iterative linear solver.
  INTERFACE CMISSSolverLinearIterativeMaximumIterationsSet
    MODULE PROCEDURE CMISSSolverLinearIterativeMaximumIterationsSetNumber0
    MODULE PROCEDURE CMISSSolverLinearIterativeMaximumIterationsSetNumber1
    MODULE PROCEDURE CMISSSolverLinearIterativeMaximumIterationsSetObj
  END INTERFACE !CMISSSolverLinearIterativeMaximumIterationsSet

  !>Sets/changes the type of preconditioner for an iterative linear solver.
  INTERFACE CMISSSolverLinearIterativePreconditionerTypeSet
    MODULE PROCEDURE CMISSSolverLinearIterativePreconditionerTypeSetNumber0
    MODULE PROCEDURE CMISSSolverLinearIterativePreconditionerTypeSetNumber1
    MODULE PROCEDURE CMISSSolverLinearIterativePreconditionerTypeSetObj
  END INTERFACE !CMISSSolverLinearIterativePreconditionerTypeSet

  !>Sets/changes the relative tolerance for an iterative linear solver.
  INTERFACE CMISSSolverLinearIterativeRelativeToleranceSet
    MODULE PROCEDURE CMISSSolverLinearIterativeRelativeToleranceSetNumber0
    MODULE PROCEDURE CMISSSolverLinearIterativeRelativeToleranceSetNumber1
    MODULE PROCEDURE CMISSSolverLinearIterativeRelativeToleranceSetObj
  END INTERFACE !CMISSSolverLinearIterativeRelativeToleranceSet

  !>Sets/changes the type of iterative linear solver.
  INTERFACE CMISSSolverLinearIterativeTypeSet
    MODULE PROCEDURE CMISSSolverLinearIterativeTypeSetNumber0
    MODULE PROCEDURE CMISSSolverLinearIterativeTypeSetNumber1
    MODULE PROCEDURE CMISSSolverLinearIterativeTypeSetObj
  END INTERFACE !CMISSSolverLinearIterativeTypeSet

  !>Sets/changes the type of linear solver.
  INTERFACE CMISSSolverLinearTypeSet
    MODULE PROCEDURE CMISSSolverLinearTypeSetNumber0
    MODULE PROCEDURE CMISSSolverLinearTypeSetNumber1
    MODULE PROCEDURE CMISSSolverLinearTypeSetObj
  END INTERFACE !CMISSSolverLinearTypeSet

  !>Sets/changes the absolute tolerance for a nonlinear Newton solver.
  INTERFACE CMISSSolverNewtonAbsoluteToleranceSet
    MODULE PROCEDURE CMISSSolverNewtonAbsoluteToleranceSetNumber0
    MODULE PROCEDURE CMISSSolverNewtonAbsoluteToleranceSetNumber1
    MODULE PROCEDURE CMISSSolverNewtonAbsoluteToleranceSetObj
  END INTERFACE !CMISSSolverNewtonAbsoluteToleranceSet

  !>Sets/changes the Jacobian calculation type for a nonlinear Newton solver.
  INTERFACE CMISSSolverNewtonJacobianCalculationTypeSet
    MODULE PROCEDURE CMISSSolverNewtonJacobianCalculationTypeSetNumber0
    MODULE PROCEDURE CMISSSolverNewtonJacobianCalculationTypeSetNumber1
    MODULE PROCEDURE CMISSSolverNewtonJacobianCalculationTypeSetObj
  END INTERFACE !CMISSSolverNewtonJacobianCalculationTypeSet

  !>Returns the linear solver associated with a nonlinear Newton solver.
  INTERFACE CMISSSolverNewtonLinearSolverGet
    MODULE PROCEDURE CMISSSolverNewtonLinearSolverGetNumber0
    MODULE PROCEDURE CMISSSolverNewtonLinearSolverGetNumber1
    MODULE PROCEDURE CMISSSolverNewtonLinearSolverGetObj
  END INTERFACE !CMISSSolverNewtonLinearSolverGet

  !>Returns the linear solver associated with a nonlinear Newton solver.
  INTERFACE CMISSSolverNewtonCellMLSolverGet
    MODULE PROCEDURE CMISSSolverNewtonCellMLSolverGetNumber0
    MODULE PROCEDURE CMISSSolverNewtonCellMLSolverGetNumber1
    MODULE PROCEDURE CMISSSolverNewtonCellMLSolverGetObj
  END INTERFACE !CMISSSolverNewtonCellMLSolverGet

  !>Sets/changes the line search alpha for a nonlinear Newton solver.
  INTERFACE CMISSSolverNewtonLineSearchAlphaSet
    MODULE PROCEDURE CMISSSolverNewtonLineSearchAlphaSetNumber0
    MODULE PROCEDURE CMISSSolverNewtonLineSearchAlphaSetNumber1
    MODULE PROCEDURE CMISSSolverNewtonLineSearchAlphaSetObj
  END INTERFACE !CMISSSolverNewtonLineSearchAlphaSet

  !>Sets/changes the line search maximum step for a nonlinear Newton solver.
  INTERFACE CMISSSolverNewtonLineSearchMaxStepSet
    MODULE PROCEDURE CMISSSolverNewtonLineSearchMaxStepSetNumber0
    MODULE PROCEDURE CMISSSolverNewtonLineSearchMaxStepSetNumber1
    MODULE PROCEDURE CMISSSolverNewtonLineSearchMaxStepSetObj
  END INTERFACE !CMISSSolverNewtonLineSearchMaxStepSet

  !>Sets/changes the line search step tolerance for a nonlinear Newton solver.
  INTERFACE CMISSSolverNewtonLineSearchStepTolSet
    MODULE PROCEDURE CMISSSolverNewtonLineSearchStepTolSetNumber0
    MODULE PROCEDURE CMISSSolverNewtonLineSearchStepTolSetNumber1
    MODULE PROCEDURE CMISSSolverNewtonLineSearchStepTolSetObj
  END INTERFACE !CMISSSolverNewtonLineSearchStepTolSet

  !>Sets/changes the type of line search for a nonlinear Newton solver.
  INTERFACE CMISSSolverNewtonLineSearchTypeSet
    MODULE PROCEDURE CMISSSolverNewtonLineSearchTypeSetNumber0
    MODULE PROCEDURE CMISSSolverNewtonLineSearchTypeSetNumber1
    MODULE PROCEDURE CMISSSolverNewtonLineSearchTypeSetObj
  END INTERFACE !CMISSSolverNewtonLineSearchTypeSet

  !>Sets/changes the maximum number of function evaluations for a nonlinear Newton solver.
  INTERFACE CMISSSolverNewtonMaximumFunctionEvaluationsSet
    MODULE PROCEDURE CMISSSolverNewtonMaximumFunctionEvaluationsSetNumber0
    MODULE PROCEDURE CMISSSolverNewtonMaximumFunctionEvaluationsSetNumber1
    MODULE PROCEDURE CMISSSolverNewtonMaximumFunctionEvaluationsSetObj
  END INTERFACE !CMISSSolverNewtonMaximumFunctionEvaluationsSet

  !>Sets/changes the maximum number of iterations for a nonlinear Newton solver.
  INTERFACE CMISSSolverNewtonMaximumIterationsSet
    MODULE PROCEDURE CMISSSolverNewtonMaximumIterationsSetNumber0
    MODULE PROCEDURE CMISSSolverNewtonMaximumIterationsSetNumber1
    MODULE PROCEDURE CMISSSolverNewtonMaximumIterationsSetObj
  END INTERFACE !CMISSSolverNewtonMaximumIterationsSet

  !>Sets/changes the relative tolerance for a nonlinear Newton solver.
  INTERFACE CMISSSolverNewtonRelativeToleranceSet
    MODULE PROCEDURE CMISSSolverNewtonRelativeToleranceSetNumber0
    MODULE PROCEDURE CMISSSolverNewtonRelativeToleranceSetNumber1
    MODULE PROCEDURE CMISSSolverNewtonRelativeToleranceSetObj
  END INTERFACE !CMISSSolverNewtonRelativeToleranceSet

  !>Sets/changes the solution tolerance for a nonlinear Newton solver.
  INTERFACE CMISSSolverNewtonSolutionToleranceSet
    MODULE PROCEDURE CMISSSolverNewtonSolutionToleranceSetNumber0
    MODULE PROCEDURE CMISSSolverNewtonSolutionToleranceSetNumber1
    MODULE PROCEDURE CMISSSolverNewtonSolutionToleranceSetObj
  END INTERFACE !CMISSSolverNewtonSolutionToleranceSet

  !>Sets/changes the trust region delta0 tolerance for a nonlinear Newton trust region solver.
  INTERFACE CMISSSolverNewtonTrustRegionDelta0Set
    MODULE PROCEDURE CMISSSolverNewtonTrustRegionDelta0SetNumber0
    MODULE PROCEDURE CMISSSolverNewtonTrustRegionDelta0SetNumber1
    MODULE PROCEDURE CMISSSolverNewtonTrustRegionDelta0SetObj
  END INTERFACE !CMISSSolverNewtonTrustRegionDelta0Set

  !>Sets/changes the trust region tolerance for a nonlinear Newton trust region solver.
  INTERFACE CMISSSolverNewtonTrustRegionToleranceSet
    MODULE PROCEDURE CMISSSolverNewtonTrustRegionToleranceSetNumber0
    MODULE PROCEDURE CMISSSolverNewtonTrustRegionToleranceSetNumber1
    MODULE PROCEDURE CMISSSolverNewtonTrustRegionToleranceSetObj
  END INTERFACE !CMISSSolverNewtonTrustRegionToleranceSet

  !>Sets/changes the type of nonlinear Newton trust region solver.
  INTERFACE CMISSSolverNewtonTypeSet
    MODULE PROCEDURE CMISSSolverNewtonTypeSetNumber0
    MODULE PROCEDURE CMISSSolverNewtonTypeSetNumber1
    MODULE PROCEDURE CMISSSolverNewtonTypeSetObj
  END INTERFACE !CMISSSolverNewtonTypeSet

  !>Sets/changes the type of nonlinear solver.
  INTERFACE CMISSSolverNonlinearTypeSet
    MODULE PROCEDURE CMISSSolverNonlinearTypeSetNumber0
    MODULE PROCEDURE CMISSSolverNonlinearTypeSetNumber1
    MODULE PROCEDURE CMISSSolverNonlinearTypeSetObj
  END INTERFACE !CMISSSolverNonlinearTypeSet

  !>Sets/changes the output type for a solver.
  INTERFACE CMISSSolverOutputTypeSet
    MODULE PROCEDURE CMISSSolverOutputTypeSetNumber0
    MODULE PROCEDURE CMISSSolverOutputTypeSetNumber1
    MODULE PROCEDURE CMISSSolverOutputTypeSetObj
  END INTERFACE !CMISSSolverOutputTypeSet

  !>Returns the solver equations for a solver.
  INTERFACE CMISSSolverSolverEquationsGet
    MODULE PROCEDURE CMISSSolverSolverEquationsGetNumber0
    MODULE PROCEDURE CMISSSolverSolverEquationsGetNumber1
    MODULE PROCEDURE CMISSSolverSolverEquationsGetObj
  END INTERFACE !CMISSSolverSolverEquationsGet

  !>Adds equations sets to solver equations.
  INTERFACE CMISSSolverEquationsEquationsSetAdd
    MODULE PROCEDURE CMISSSolverEquationsEquationsSetAddNumber0
    MODULE PROCEDURE CMISSSolverEquationsEquationsSetAddNumber1
    MODULE PROCEDURE CMISSSolverEquationsEquationsSetAddObj
  END INTERFACE !CMISSSolverEquationsEquationsSetAdd

  !>Adds an interface condition to solver equations.
  INTERFACE CMISSSolverEquationsInterfaceConditionAdd
    MODULE PROCEDURE CMISSSolverEquationsInterfaceConditionAddNumber0
    MODULE PROCEDURE CMISSSolverEquationsInterfaceConditionAddNumber1
    MODULE PROCEDURE CMISSSolverEquationsInterfaceConditionAddObj
  END INTERFACE !CMISSSolverEquationsInterfaceConditionAdd

  !>Sets/changes the sparsity type for solver equations.
  INTERFACE CMISSSolverEquationsSparsityTypeSet
    MODULE PROCEDURE CMISSSolverEquationsSparsityTypeSetNumber0
    MODULE PROCEDURE CMISSSolverEquationsSparsityTypeSetNumber1
    MODULE PROCEDURE CMISSSolverEquationsSparsityTypeSetObj
  END INTERFACE !CMISSSolverEquationsSparsityTypeSet

  !>Finish the creation of boundary conditions for solver equations. \see OPENCMISS::CMISSSolverEquationsBoundaryConditionsCreateStart
  INTERFACE CMISSSolverEquationsBoundaryConditionsCreateFinish
    MODULE PROCEDURE CMISSSolverEquationsBoundaryConditionsCreateFinishNumber0
    MODULE PROCEDURE CMISSSolverEquationsBoundaryConditionsCreateFinishNumber1
    MODULE PROCEDURE CMISSSolverEquationsBoundaryConditionsCreateFinishObj
  END INTERFACE !CMISSSolverEquationsBoundaryConditionsCreateFinish

  !>Start the creation of boundary conditions for solver equations. \see OPENCMISS::CMISSSolverEquationsBoundaryConditionsCreateFinish
  INTERFACE CMISSSolverEquationsBoundaryConditionsCreateStart
    MODULE PROCEDURE CMISSSolverEquationsBoundaryConditionsCreateStartNumber0
    MODULE PROCEDURE CMISSSolverEquationsBoundaryConditionsCreateStartNumber1
    MODULE PROCEDURE CMISSSolverEquationsBoundaryConditionsCreateStartObj
  END INTERFACE !CMISSSolverEquationsBoundaryConditionsCreateStart

  !>Get the boundary conditions for solver equations. \see OPENCMISS::CMISSSolverEquationsBoundaryConditionsCreateFinish
  INTERFACE CMISSSolverEquationsBoundaryConditionsGet
    MODULE PROCEDURE CMISSSolverEquationsBoundaryConditionsGetNumber0
    MODULE PROCEDURE CMISSSolverEquationsBoundaryConditionsGetNumber1
    MODULE PROCEDURE CMISSSolverEquationsBoundaryConditionsGetObj
  END INTERFACE !CMISSSolverEquationsBoundaryConditionsGet

  PUBLIC CMISS_SOLVER_LINEAR_TYPE,CMISS_SOLVER_NONLINEAR_TYPE,CMISS_SOLVER_DYNAMIC_TYPE,CMISS_SOLVER_DAE_TYPE, &
    & CMISS_SOLVER_EIGENPROBLEM_TYPE, &
    & CMISS_SOLVER_OPTIMISER_TYPE

  PUBLIC CMISS_SOLVER_CMISS_LIBRARY,CMISS_SOLVER_PETSC_LIBRARY,CMISS_SOLVER_MUMPS_LIBRARY,CMISS_SOLVER_SUPERLU_LIBRARY, &
    & CMISS_SOLVER_SPOOLES_LIBRARY,CMISS_SOLVER_UMFPACK_LIBRARY,CMISS_SOLVER_LUSOL_LIBRARY,CMISS_SOLVER_ESSL_LIBRARY, &
    & CMISS_SOLVER_LAPACK_LIBRARY,CMISS_SOLVER_TAO_LIBRARY,CMISS_SOLVER_HYPRE_LIBRARY,CMISS_SOLVER_PASTIX_LIBRARY

  PUBLIC CMISS_SOLVER_LINEAR_DIRECT_SOLVE_TYPE,CMISS_SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE

  PUBLIC CMISS_SOLVER_ITERATIVE_RICHARDSON,CMISS_SOLVER_ITERATIVE_CHEBYCHEV,CMISS_SOLVER_ITERATIVE_CONJUGATE_GRADIENT, &
    & CMISS_SOLVER_ITERATIVE_BICONJUGATE_GRADIENT,CMISS_SOLVER_ITERATIVE_GMRES,CMISS_SOLVER_ITERATIVE_BiCGSTAB, &
    & CMISS_SOLVER_ITERATIVE_CONJGRAD_SQUARED

  PUBLIC CMISS_SOLVER_ITERATIVE_NO_PRECONDITIONER,CMISS_SOLVER_ITERATIVE_JACOBI_PRECONDITIONER, &
    & CMISS_SOLVER_ITERATIVE_BLOCK_JACOBI_PRECONDITIONER,CMISS_SOLVER_ITERATIVE_SOR_PRECONDITIONER, &
    & CMISS_SOLVER_ITERATIVE_INCOMPLETE_CHOLESKY_PRECONDITIONER,CMISS_SOLVER_ITERATIVE_INCOMPLETE_LU_PRECONDITIONER, &
    & CMISS_SOLVER_ITERATIVE_ADDITIVE_SCHWARZ_PRECONDITIONER

  PUBLIC CMISS_SOLVER_NONLINEAR_NEWTON,CMISS_SOLVER_NONLINEAR_BFGS_INVERSE,CMISS_SOLVER_NONLINEAR_SQP

  PUBLIC CMISS_SOLVER_NEWTON_LINESEARCH,CMISS_SOLVER_NEWTON_TRUSTREGION

  PUBLIC CMISS_SOLVER_NEWTON_LINESEARCH_NONORMS,CMISS_SOLVER_NEWTON_LINESEARCH_NONE,CMISS_SOLVER_NEWTON_LINESEARCH_QUADRATIC, &
    & CMISS_SOLVER_NEWTON_LINESEARCH_CUBIC

  PUBLIC CMISS_SOLVER_NEWTON_JACOBIAN_NOT_CALCULATED,CMISS_SOLVER_NEWTON_JACOBIAN_ANALTYIC_CALCULATED, &
    & CMISS_SOLVER_NEWTON_JACOBIAN_FD_CALCULATED

  PUBLIC CMISS_SOLVER_DYNAMIC_FIRST_ORDER,CMISS_SOLVER_DYNAMIC_SECOND_ORDER

  PUBLIC CMISS_SOLVER_DYNAMIC_LINEAR,CMISS_SOLVER_DYNAMIC_NONLINEAR

  PUBLIC CMISS_SOLVER_DYNAMIC_FIRST_DEGREE,CMISS_SOLVER_DYNAMIC_SECOND_DEGREE,CMISS_SOLVER_DYNAMIC_THIRD_DEGREE

  PUBLIC CMISS_SOLVER_DYNAMIC_EULER_SCHEME,CMISS_SOLVER_DYNAMIC_BACKWARD_EULER_SCHEME,CMISS_SOLVER_DYNAMIC_CRANK_NICOLSON_SCHEME, &
    & CMISS_SOLVER_DYNAMIC_GALERKIN_SCHEME,CMISS_SOLVER_DYNAMIC_ZLAMAL_SCHEME,CMISS_SOLVER_DYNAMIC_SECOND_DEGREE_GEAR_SCHEME, &
    & CMISS_SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER1_SCHEME,CMISS_SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER2_SCHEME, &
    & CMISS_SOLVER_DYNAMIC_NEWMARK1_SCHEME,CMISS_SOLVER_DYNAMIC_NEWMARK2_SCHEME,CMISS_SOLVER_DYNAMIC_NEWMARK3_SCHEME, &
    & CMISS_SOLVER_DYNAMIC_THIRD_DEGREE_GEAR_SCHEME,CMISS_SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER1_SCHEME, &
    & CMISS_SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER2_SCHEME,CMISS_SOLVER_DYNAMIC_HOUBOLT_SCHEME,CMISS_SOLVER_DYNAMIC_WILSON_SCHEME, &
    & CMISS_SOLVER_DYNAMIC_BOSSAK_NEWMARK1_SCHEME,CMISS_SOLVER_DYNAMIC_BOSSAK_NEWMARK2_SCHEME, &
    & CMISS_SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR1_SCHEME, &
    & CMISS_SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR2_SCHEME,CMISS_SOLVER_DYNAMIC_USER_DEFINED_SCHEME

  PUBLIC CMISS_SOLVER_DAE_DIFFERENTIAL_ONLY,CMISS_SOLVER_DAE_INDEX_1,CMISS_SOLVER_DAE_INDEX_2,CMISS_SOLVER_DAE_INDEX_3

  PUBLIC CMISS_SOLVER_DAE_EULER,CMISS_SOLVER_DAE_CRANK_NICOLSON,CMISS_SOLVER_DAE_RUNGE_KUTTA,CMISS_SOLVER_DAE_ADAMS_MOULTON, &
    & CMISS_SOLVER_DAE_BDF, &
    & CMISS_SOLVER_DAE_RUSH_LARSON,CMISS_SOLVER_DAE_EXTERNAL

  PUBLIC CMISS_SOLVER_DAE_EULER_FORWARD,CMISS_SOLVER_DAE_EULER_BACKWARD,CMISS_SOLVER_DAE_EULER_IMPROVED

  PUBLIC CMISS_SOLVER_SOLUTION_INITIALISE_ZERO,CMISS_SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD, &
    & CMISS_SOLVER_SOLUTION_INITIALISE_NO_CHANGE

  PUBLIC CMISS_SOLVER_NO_OUTPUT,CMISS_SOLVER_PROGRESS_OUTPUT,CMISS_SOLVER_TIMING_OUTPUT,CMISS_SOLVER_SOLVER_OUTPUT, &
    & CMISS_SOLVER_MATRIX_OUTPUT

  PUBLIC CMISS_SOLVER_SPARSE_MATRICES,CMISS_SOLVER_FULL_MATRICES

  PUBLIC CMISSSolverCellMLEquationsGet

  PUBLIC CMISSCellMLEquationsCellMLAdd

  PUBLIC CMISSSolverDAEEulerSolverTypeGet, CMISSSolverDAEEulerSolverTypeSet

  PUBLIC CMISSSolverDAESolverTypeGet,CMISSSolverDAESolverTypeSet

  PUBLIC CMISSSolverDAETimesSet,CMISSSolverDAETimeStepSet

  PUBLIC CMISSSolverDynamicDegreeGet,CMISSSolverDynamicDegreeSet

  PUBLIC CMISSSolverDynamicLinearityTypeGet

  PUBLIC CMISSSolverDynamicLinearSolverGet,CMISSSolverDynamicNonlinearSolverGet

  PUBLIC CMISSSolverDynamicSchemeSet

  PUBLIC CMISSSolverDynamicThetaSet

  PUBLIC CMISSSolverDynamicTimesSet

  PUBLIC CMISSSolverLabelGet,CMISSSolverLabelSet

  PUBLIC CMISSSolverLibraryTypeGet,CMISSSolverLibraryTypeSet

  PUBLIC CMISSSolverLinearDirectTypeSet

  PUBLIC CMISSSolverLinearIterativeAbsoluteToleranceSet

  PUBLIC CMISSSolverLinearIterativeDivergenceToleranceSet

  PUBLIC CMISSSolverLinearIterativeGMRESRestartSet

  PUBLIC CMISSSolverLinearIterativeMaximumIterationsSet

  PUBLIC CMISSSolverLinearIterativePreconditionerTypeSet

  PUBLIC CMISSSolverLinearIterativeRelativeToleranceSet

  PUBLIC CMISSSolverLinearIterativeTypeSet

  PUBLIC CMISSSolverLinearTypeSet

  PUBLIC CMISSSolverNewtonAbsoluteToleranceSet

  PUBLIC CMISSSolverNewtonJacobianCalculationTypeSet

  PUBLIC CMISSSolverNewtonLinearSolverGet

  PUBLIC CMISSSolverNewtonCellMLSolverGet

  PUBLIC CMISSSolverNewtonLineSearchAlphaSet

  PUBLIC CMISSSolverNewtonLineSearchMaxStepSet

  PUBLIC CMISSSolverNewtonLineSearchStepTolSet

  PUBLIC CMISSSolverNewtonLineSearchTypeSet

  PUBLIC CMISSSolverNewtonMaximumFunctionEvaluationsSet

  PUBLIC CMISSSolverNewtonMaximumIterationsSet

  PUBLIC CMISSSolverNewtonRelativeToleranceSet

  PUBLIC CMISSSolverNewtonSolutionToleranceSet

  PUBLIC CMISSSolverNewtonTrustRegionDelta0Set

  PUBLIC CMISSSolverNewtonTrustRegionToleranceSet

  PUBLIC CMISSSolverNewtonTypeSet

  PUBLIC CMISSSolverNonlinearTypeSet

  PUBLIC CMISSSolverOutputTypeSet

  PUBLIC CMISSSolverSolverEquationsGet

  PUBLIC CMISSSolverEquationsEquationsSetAdd

  PUBLIC CMISSSolverEquationsInterfaceConditionAdd

  PUBLIC CMISSSolverEquationsSparsityTypeSet

  PUBLIC CMISSSolverEquationsBoundaryConditionsCreateFinish,CMISSSolverEquationsBoundaryConditionsCreateStart

  PUBLIC CMISSSolverEquationsBoundaryConditionsGet

!!==================================================================================================================================
!!
!! FieldML routines
!!
!!==================================================================================================================================

  !> Provides input and output of fields through the FieldML API
  TYPE CMISSFieldMLIOType
    PRIVATE
#ifdef USEFIELDML
    TYPE(FIELDML_IO_TYPE), POINTER :: fieldmlInfo
#endif
  END TYPE CMISSFieldMLIOType

  !> Creates a mesh component using the given FieldML evaluator.
  INTERFACE CMISSFieldMLInputCreateMeshComponent
    MODULE PROCEDURE CMISSFieldMLInputCreateMeshComponentObjVS
    MODULE PROCEDURE CMISSFieldMLInputCreateMeshComponentNumberVS
    MODULE PROCEDURE CMISSFieldMLInputCreateMeshComponentObjC
    MODULE PROCEDURE CMISSFieldMLInputCreateMeshComponentNumberC
  END INTERFACE CMISSFieldMLInputCreateMeshComponent

  !> Creates a field component using the given FieldML evaluator.
  INTERFACE CMISSFieldMLInputFieldCreateStart
    MODULE PROCEDURE CMISSFieldMLInputFieldCreateStartObjVS
    MODULE PROCEDURE CMISSFieldMLInputFieldCreateStartNumberVS
    MODULE PROCEDURE CMISSFieldMLInputFieldCreateStartObjC
    MODULE PROCEDURE CMISSFieldMLInputFieldCreateStartNumberC
  END INTERFACE CMISSFieldMLInputFieldCreateStart

  !> Updates the given field's dofs using the given parameter evaluator.
  INTERFACE CMISSFieldMLInputFieldParametersUpdate
    MODULE PROCEDURE CMISSFieldMLInputFieldParametersUpdateObjVS
    MODULE PROCEDURE CMISSFieldMLInputFieldParametersUpdateNumberVS
    MODULE PROCEDURE CMISSFieldMLInputFieldParametersUpdateObjC
    MODULE PROCEDURE CMISSFieldMLInputFieldParametersUpdateNumberC
  END INTERFACE CMISSFieldMLInputFieldParametersUpdate

  !> Creates a basis using the given FieldML evaluator.
  INTERFACE CMISSFieldMLInputBasisCreateStart
    MODULE PROCEDURE CMISSFieldMLInputBasisCreateStartObjVS
    MODULE PROCEDURE CMISSFieldMLInputBasisCreateStartNumberVS
    MODULE PROCEDURE CMISSFieldMLInputBasisCreateStartObjC
    MODULE PROCEDURE CMISSFieldMLInputBasisCreateStartNumberC
  END INTERFACE CMISSFieldMLInputBasisCreateStart

  !> Creates the region's nodes using the given FieldML evaluator.
  INTERFACE CMISSFieldMLInputNodesCreateStart
    MODULE PROCEDURE CMISSFieldMLInputNodesCreateStartObjVS
    MODULE PROCEDURE CMISSFieldMLInputNodesCreateStartNumberVS
    MODULE PROCEDURE CMISSFieldMLInputNodesCreateStartObjC
    MODULE PROCEDURE CMISSFieldMLInputNodesCreateStartNumberC
  END INTERFACE CMISSFieldMLInputNodesCreateStart

  !> Creates the region's coordinate system using the given FieldML evaluator.
  INTERFACE CMISSFieldMLInputCoordinateSystemCreateStart
    MODULE PROCEDURE CMISSFieldMLInputCoordinateSystemCreateStartObjVS
    MODULE PROCEDURE CMISSFieldMLInputCoordinateSystemCreateStartNumberVS
    MODULE PROCEDURE CMISSFieldMLInputCoordinateSystemCreateStartObjC
    MODULE PROCEDURE CMISSFieldMLInputCoordinateSystemCreateStartNumberC
  END INTERFACE CMISSFieldMLInputCoordinateSystemCreateStart

  !> Creates a mesh using the given FieldML evaluator.
  INTERFACE CMISSFieldMLInputMeshCreateStart
    MODULE PROCEDURE CMISSFieldMLInputMeshCreateStartObjVS
    MODULE PROCEDURE CMISSFieldMLInputMeshCreateStartNumberVS
    MODULE PROCEDURE CMISSFieldMLInputMeshCreateStartObjC
    MODULE PROCEDURE CMISSFieldMLInputMeshCreateStartNumberC
  END INTERFACE CMISSFieldMLInputMeshCreateStart

  !> Initialise the given FieldML context using the given FieldML XML file.
  INTERFACE CMISSFieldMLInputCreateFromFile
    MODULE PROCEDURE CMISSFieldMLInputCreateFromFileVS
    MODULE PROCEDURE CMISSFieldMLInputCreateFromFileC
  END INTERFACE CMISSFieldMLInputCreateFromFile

  PUBLIC :: CMISSFieldMLInputCreateFromFile, CMISSFieldMLInputMeshCreateStart, &
    & CMISSFieldMLInputCoordinateSystemCreateStart, CMISSFieldMLInputCreateMeshComponent, &
    & CMISSFieldMLInputFieldCreateStart, CMISSFieldMLInputBasisCreateStart, CMISSFieldMLInputNodesCreateStart, &
    & CMISSFieldMLInputFieldParametersUpdate

  PUBLIC :: CMISSFieldMLIOTypeFinalise, CMISSFieldMLIOTypeInitialise, CMISSFieldMLIOGetSession

  !> Add the given field to the current FieldML context.
  INTERFACE CMISSFieldMLOutputAddField
    MODULE PROCEDURE CMISSFieldMLOutputAddFieldNoTypeObjVS
    MODULE PROCEDURE CMISSFieldMLOutputAddFieldNoTypeNumberVS
    MODULE PROCEDURE CMISSFieldMLOutputAddFieldWithTypeObjVS
    MODULE PROCEDURE CMISSFieldMLOutputAddFieldWithTypeNumberVS
    MODULE PROCEDURE CMISSFieldMLOutputAddFieldNoTypeObjC
    MODULE PROCEDURE CMISSFieldMLOutputAddFieldNoTypeNumberC
    MODULE PROCEDURE CMISSFieldMLOutputAddFieldWithTypeObjC
    MODULE PROCEDURE CMISSFieldMLOutputAddFieldWithTypeNumberC
  END INTERFACE CMISSFieldMLOutputAddField

  !> Initialise a new FieldML context.
  INTERFACE CMISSFieldMLOutputCreate
    MODULE PROCEDURE CMISSFieldMLOutputCreateObjVS
    MODULE PROCEDURE CMISSFieldMLOutputCreateNumberVS
    MODULE PROCEDURE CMISSFieldMLOutputCreateObjC
    MODULE PROCEDURE CMISSFieldMLOutputCreateNumberC
  END INTERFACE CMISSFieldMLOutputCreate

  !> Add the given field to the current FieldML context, using only the given components.
  INTERFACE CMISSFieldMLOutputAddFieldComponents
    MODULE PROCEDURE CMISSFieldMLOutputAddFieldComponentsObjVS
    MODULE PROCEDURE CMISSFieldMLOutputAddFieldComponentsNumberVS
    MODULE PROCEDURE CMISSFieldMLOutputAddFieldComponentsObjC
    MODULE PROCEDURE CMISSFieldMLOutputAddFieldComponentsNumberC
  END INTERFACE CMISSFieldMLOutputAddFieldComponents

  !> Write the current FieldML document to the given file.
  INTERFACE CMISSFieldMLOutputWrite
    MODULE PROCEDURE CMISSFieldMLOutputWriteVS
    MODULE PROCEDURE CMISSFieldMLOutputWriteC
  END INTERFACE CMISSFieldMLOutputWrite

  PUBLIC :: CMISSFieldMLIOType

  PUBLIC :: CMISSFieldMLOutputWrite, CMISSFieldMLOutputAddField, CMISSFieldMLOutputCreate, CMISSFieldMLOutputAddFieldComponents, &
    & CMISSFieldMLOutputAddImport

!!==================================================================================================================================
!!
!! GENERAL_ROUTINES
!!
!!==================================================================================================================================

  !>Returns the user number of an object.
  INTERFACE CMISSUserNumberGet
    MODULE PROCEDURE CMISSUserNumberGetRegion
    MODULE PROCEDURE CMISSUserNumberGetMesh
    MODULE PROCEDURE CMISSUserNumberGetBasis
  END INTERFACE !CMISSUserNumberGet

  PUBLIC CMISSUserNumberGet

!!
!!==================================================================================================================================
!!

CONTAINS

  !
  !================================================================================================================================
  !

  !>Finalises CMISS.
  SUBROUTINE CMISSFinalise(err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL CMISS_FINALISE(err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('OpenCMISS World Phase')
#endif

    RETURN
999 CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFinalise

  !
  !================================================================================================================================
  !

  !>Initialises CMISS returning a user number to the world coordinate system and region.
  SUBROUTINE CMISSInitialiseNumber(worldCoordinateSystemUserNumber,worldRegionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: worldCoordinateSystemUserNumber !<On return, the world coordinate system user number.
    INTEGER(INTG), INTENT(OUT) :: worldRegionUserNumber !<On return, the world region user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: WORLD_COORDINATE_SYSTEM
    TYPE(REGION_TYPE), POINTER :: WORLD_REGION

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('OpenCMISS World Phase')
#endif

    NULLIFY(WORLD_COORDINATE_SYSTEM)
    NULLIFY(WORLD_REGION)
    CALL CMISS_Initialise(WORLD_REGION,err,error,*999)
    !CALL CMISS_Initialise(WORLD_COORDINATE_SYSTEM,WORLD_REGION,err,error,*999)
    worldCoordinateSystemUserNumber=0
    !WorldCoordinateUserNumber=WORLD_COORDINATE_SYSTEM%USER_NUMBER
    worldRegionUserNumber=WORLD_REGION%USER_NUMBER

    RETURN
999 CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInitialiseNumber

  !
  !================================================================================================================================
  !

  !>Initialises CMISS returning a pointer to the world coordinate system and region.
  SUBROUTINE CMISSInitialiseObj(worldCoordinateSystem,worldRegion,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT) :: worldCoordinateSystem !<On return, the world coordinate system.
    TYPE(CMISSRegionType), INTENT(INOUT) :: worldRegion !<On return, the world region.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('OpenCMISS World Phase')
#endif

    CALL CMISSCoordinateSystemTypeInitialise(worldCoordinateSystem,err)
    CALL CMISSRegionTypeInitialise(worldRegion,err)
    CALL CMISS_INITIALISE(worldRegion%REGION,err,error,*999)
    !CALL CMISS_Initialise(worldCoordinateSystem%COORDINATE_SYSTEM,worldRegion%REGION,err,error,*999)

    RETURN
999 CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInitialiseObj

  !
  !================================================================================================================================
  !

  !>Copy an array of CMISSBasisTypes from C to an allocated Fortran array, for use by the C bindings
  SUBROUTINE CMISSBasisTypesCopy(bases,basesSize,basesPtr,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(INOUT) :: bases(:) !<On return, the array of CMISSBasisTypes
    INTEGER(C_INT), INTENT(IN) :: basesSize !<The length of the C array of pointers to CMISSBasisTypes
    TYPE(C_PTR), INTENT(IN) :: basesPtr !<The pointer to the first CMISSBasisType pointer
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: basis_idx
    TYPE(C_PTR), POINTER :: BasesCPtrs(:)
    TYPE(CMISSBasisType), POINTER :: Basis

    CALL ENTERS("CMISSBasisTypesCopy",err,error,*999)

    IF(C_ASSOCIATED(basesPtr)) THEN
      CALL C_F_POINTER(basesPtr,BasesCPtrs,[basesSize])
      IF(ASSOCIATED(BasesCPtrs)) THEN
        DO basis_idx=1,basesSize
          CALL C_F_POINTER(BasesCPtrs(basis_idx),Basis)
          IF(ASSOCIATED(BasesCPtrs)) THEN
            bases(basis_idx)%BASIS => Basis%BASIS
          ELSE
            CALL FLAG_ERROR("error converting C pointer.",ERR,error,*999)
          ENDIF
        ENDDO
      ELSE
        CALL FLAG_ERROR("error converting C pointer.",ERR,error,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("bases C pointer is not associated.",ERR,error,*999)
    ENDIF

    CALL EXITS("CMISSBasisTypesCopy")
    RETURN
999 CALL ERRORS("CMISSBasisTypesCopy",err,error)
    CALL EXITS("CMISSBasisTypesCopy")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisTypesCopy

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSBasisType object.
  SUBROUTINE CMISSBasisTypeFinalise(CMISSBasis,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(OUT) :: CMISSBasis !<The CMISSBasisType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisTypeFinalise",err,error,*999)

    IF(ASSOCIATED(CMISSBasis%BASIS)) CALL BASIS_DESTROY(CMISSBasis%BASIS,err,error,*999)

    CALL EXITS("CMISSBasisTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSBasisTypeFinalise",err,error)
    CALL EXITS("CMISSBasisTypeFinalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisTypeFinalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSBasisType object.
  SUBROUTINE CMISSBasisTypeInitialise(CMISSBasis,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(OUT) :: CMISSBasis !<The CMISSBasisType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisTypeInitialise",err,error,*999)

    NULLIFY(CMISSBasis%BASIS)

    CALL EXITS("CMISSBasisTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSBasisTypeInitialise",err,error)
    CALL EXITS("CMISSBasisTypeInitialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSBoundaryConditionsType object.
  SUBROUTINE CMISSBoundaryConditionsTypeFinalise(CMISSBoundaryConditions,err)

    !Argument variables
    TYPE(CMISSBoundaryConditionsType), INTENT(OUT) :: CMISSBoundaryConditions !<The CMISSBoundaryConditionsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBoundaryConditionsTypeFinalise",err,error,*999)

    IF(ASSOCIATED(CMISSBoundaryConditions%BOUNDARY_CONDITIONS))  &
      & CALL BOUNDARY_CONDITIONS_DESTROY(CMISSBoundaryConditions%BOUNDARY_CONDITIONS,err,error,*999)

    CALL EXITS("CMISSBoundaryConditionsTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsTypeFinalise",err,error)
    CALL EXITS("CMISSBoundaryConditionsTypeFinalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditionsTypeFinalise
  !
  !================================================================================================================================
  !

  !>Initialises a CMISSBoundaryConditionsType object.
  SUBROUTINE CMISSBoundaryConditionsTypeInitialise(CMISSBoundaryConditions,err)

    !Argument variables
    TYPE(CMISSBoundaryConditionsType), INTENT(OUT) :: CMISSBoundaryConditions !<The CMISSBoundaryConditionsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBoundaryConditionsTypeInitialise",err,error,*999)

    NULLIFY(CMISSBoundaryConditions%BOUNDARY_CONDITIONS)

    CALL EXITS("CMISSBoundaryConditionsTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsTypeInitialise",err,error)
    CALL EXITS("CMISSBoundaryConditionsTypeInitialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditionsTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSCellMLType object.
  SUBROUTINE CMISSCellMLTypeFinalise(CMISSCellML,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(OUT) :: CMISSCellML !<The CMISSCellMLType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLTypeFinalise",err,error,*999)

    IF(ASSOCIATED(CMISSCellML%CELLML))  &
      & CALL CELLML_DESTROY(CMISSCellML%CELLML,err,error,*999)

    CALL EXITS("CMISSCellMLTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSCellMLTypeFinalise",err,error)
    CALL EXITS("CMISSCellMLTypeFinalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLTypeFinalise
  !
  !================================================================================================================================
  !

  !>Initialises a CMISSCellMLType object.
  SUBROUTINE CMISSCellMLTypeInitialise(CMISSCellML,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(OUT) :: CMISSCellML !<The CMISSCellMLType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLTypeInitialise",err,error,*999)

    NULLIFY(CMISSCellML%CELLML)

    CALL EXITS("CMISSCellMLTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSCellMLTypeInitialise",err,error)
    CALL EXITS("CMISSCellMLTypeInitialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSCellMLEquationsType object.
  SUBROUTINE CMISSCellMLEquationsTypeFinalise(CMISSCellMLEquations,err)

    !Argument variables
    TYPE(CMISSCellMLEquationsType), INTENT(OUT) :: CMISSCellMLEquations !<The CMISSCellMLEquationsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLEquationsTypeFinalise",err,error,*999)

    IF(ASSOCIATED(CMISSCellMLEquations%CELLML_EQUATIONS))  &
      & CALL CELLML_EQUATIONS_DESTROY(CMISSCellMLEquations%CELLML_EQUATIONS,err,error,*999)

    CALL EXITS("CMISSCellMLEquationsTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSCellMLEquationsTypeFinalise",err,error)
    CALL EXITS("CMISSCellMLEquationsTypeFinalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLEquationsTypeFinalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSComputationalWorkGroupType object.
  SUBROUTINE CMISSComputationalWorkGroupTypeInitialise(CMISSComputationalWorkGroup,err)

    !Argument variables
    TYPE(CMISSComputationalWorkGroupType), INTENT(OUT) :: CMISSComputationalWorkGroup !<The CMISSComputationalWorkGroupType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSComputationalWorkGroupTypeInitialise",err,error,*999)

    NULLIFY(CMISSComputationalWorkGroup%COMPUTATIONAL_WORK_GROUP)

    CALL EXITS("CMISSComputationalWorkGroupTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSComputationalWorkGroupTypeInitialise",err,error)
    CALL EXITS("CMISSComputationalWorkGroupTypeInitialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSComputationalWorkGroupTypeInitialise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSCellMLEquationsType object.
  SUBROUTINE CMISSCellMLEquationsTypeInitialise(CMISSCellMLEquations,err)

    !Argument variables
    TYPE(CMISSCellMLEquationsType), INTENT(OUT) :: CMISSCellMLEquations !<The CMISSCellMLEquationsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLEquationsTypeInitialise",err,error,*999)

    NULLIFY(CMISSCellMLEquations%CELLML_EQUATIONS)

    CALL EXITS("CMISSCellMLEquationsTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSCellMLEquationsTypeInitialise",err,error)
    CALL EXITS("CMISSCellMLEquationsTypeInitialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLEquationsTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSControlLoopType object.
  SUBROUTINE CMISSControlLoopTypeFinalise(CMISSControlLoop,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(OUT) :: CMISSControlLoop !<The CMISSControlLoopType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopTypeFinalise",err,error,*999)

    IF(ASSOCIATED(CMISSControlLoop%CONTROL_LOOP))  &
      & CALL CONTROL_LOOP_DESTROY(CMISSControlLoop%CONTROL_LOOP,err,error,*999)

    CALL EXITS("CMISSControlLoopTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSControlLoopTypeFinalise",err,error)
    CALL EXITS("CMISSControlLoopTypeFinalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopTypeFinalise
  !
  !================================================================================================================================
  !

  !>Initialises a CMISSControlLoopType object.
  SUBROUTINE CMISSControlLoopTypeInitialise(CMISSControlLoop,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(OUT) :: CMISSControlLoop !<The CMISSControlLoopType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopTypeInitialise",err,error,*999)

    NULLIFY(CMISSControlLoop%CONTROL_LOOP)

    CALL EXITS("CMISSControlLoopTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSControlLoopTypeInitialise",err,error)
    CALL EXITS("CMISSControlLoopTypeInitialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSCoordinateSystemType object.
  SUBROUTINE CMISSCoordinateSystemTypeFinalise(CMISSCoordinateSystem,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(OUT) :: CMISSCoordinateSystem !<The CMISSCoordinateSystemType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystemTypeFinalise",err,error,*999)

    IF(ASSOCIATED(CMISSCoordinateSystem%COORDINATE_SYSTEM))  &
      & CALL COORDINATE_SYSTEM_DESTROY(CMISSCoordinateSystem%COORDINATE_SYSTEM,err,error,*999)

    CALL EXITS("CMISSCoordinateSystemTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemTypeFinalise",err,error)
    CALL EXITS("CMISSCoordinateSystemTypeFinalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystemTypeFinalise
  !
  !================================================================================================================================
  !

  !>Initialises a CMISSCoordinateSystemType object.
  SUBROUTINE CMISSCoordinateSystemTypeInitialise(CMISSCoordinateSystem,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(OUT) :: CMISSCoordinateSystem !<The CMISSCoordinateSystemType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables


    CALL ENTERS("CMISSCoordinateSystemTypeInitialise",err,error,*999)

    NULLIFY(CMISSCoordinateSystem%COORDINATE_SYSTEM)

    CALL EXITS("CMISSCoordinateSystemTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemTypeInitialise",err,error)
    CALL EXITS("CMISSCoordinateSystemTypeInitialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystemTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSDataPointsType object.
  SUBROUTINE CMISSDataPointsTypeFinalise(CMISSDataPoints,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(OUT) :: CMISSDataPoints !<The CMISSDataPointsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPointsTypeFinalise",err,error,*999)

    IF(ASSOCIATED(CMISSDataPoints%DATA_POINTS))  &
      & CALL DATA_POINTS_DESTROY(CMISSDataPoints%DATA_POINTS,err,error,*999)

    CALL EXITS("CMISSDataPointsTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSDataPointsTypeFinalise",err,error)
    CALL EXITS("CMISSDataPointsTypeFinalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsTypeFinalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSDataPointsType object.
  SUBROUTINE CMISSDataPointsTypeInitialise(CMISSDataPoints,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(OUT) :: CMISSDataPoints !<The CMISSDataPointsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPointsTypeInitialise",err,error,*999)

    NULLIFY(CMISSDataPoints%DATA_POINTS)

    CALL EXITS("CMISSDataPointsTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSDataPointsTypeInitialise",err,error)
    CALL EXITS("CMISSDataPointsTypeInitialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSDataProjectionType object.
  SUBROUTINE CMISSDataProjectionTypeFinalise(CMISSDataProjection,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(OUT) :: CMISSDataProjection !<The CMISSDataProjectionType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjectionTypeFinalise",err,error,*999)

    IF(ASSOCIATED(CMISSDataProjection%DATA_PROJECTION))  &
      & CALL DATA_PROJECTION_DESTROY(CMISSDataProjection%DATA_PROJECTION,err,error,*999)

    CALL EXITS("CMISSDataProjectionTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSDataProjectionTypeFinalise",err,error)
    CALL EXITS("CMISSDataProjectionTypeFinalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionTypeFinalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSDataProjectionType object.
  SUBROUTINE CMISSDataProjectionTypeInitialise(CMISSDataProjection,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(OUT) :: CMISSDataProjection !<The CMISSDataProjectionType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjectionTypeInitialise",err,error,*999)

    NULLIFY(CMISSDataProjection%DATA_PROJECTION)

    CALL EXITS("CMISSDataProjectionTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSDataProjectionTypeInitialise",err,error)
    CALL EXITS("CMISSDataProjectionTypeInitialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSDecompositionType object.
  SUBROUTINE CMISSDecompositionTypeFinalise(CMISSDecomposition,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(OUT) :: CMISSDecomposition !<The CMISSDecompositionType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecompositionTypeFinalise",err,error,*999)

    IF(ASSOCIATED(CMISSDecomposition%DECOMPOSITION))  &
      & CALL DECOMPOSITION_DESTROY(CMISSDecomposition%DECOMPOSITION,err,error,*999)

    CALL EXITS("CMISSDecompositionTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSDecompositionTypeFinalise",err,error)
    CALL EXITS("CMISSDecompositionTypeFinalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionTypeFinalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSDecompositionType object.
  SUBROUTINE CMISSDecompositionTypeInitialise(CMISSDecomposition,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(OUT) :: CMISSDecomposition !<The CMISSDecompositionType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecompositionTypeInitialise",err,error,*999)

    NULLIFY(CMISSDecomposition%DECOMPOSITION)

    CALL EXITS("CMISSDecompositionTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSDecompositionTypeInitialise",err,error)
    CALL EXITS("CMISSDecompositionTypeInitialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSEquationsType object.
  SUBROUTINE CMISSEquationsTypeFinalise(CMISSEquations,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(OUT) :: CMISSEquations !<The CMISSEquationsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsTypeFinalise",err,error,*999)

    IF(ASSOCIATED(CMISSEquations%EQUATIONS))  &
      & CALL EQUATIONS_DESTROY(CMISSEquations%EQUATIONS,err,error,*999)

    CALL EXITS("CMISSEquationsTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSEquationsTypeFinalise",err,error)
    CALL EXITS("CMISSEquationsTypeFinalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsTypeFinalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSEquationsType object.
  SUBROUTINE CMISSEquationsTypeInitialise(CMISSEquations,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(OUT) :: CMISSEquations !<The CMISSEquationsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsTypeInitialise",err,error,*999)

    NULLIFY(CMISSEquations%EQUATIONS)

    CALL EXITS("CMISSEquationsTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSEquationsTypeInitialise",err,error)
    CALL EXITS("CMISSEquationsTypeInitialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSEquationsSetType object.
  SUBROUTINE CMISSEquationsSetTypeFinalise(CMISSEquationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(OUT) :: CMISSEquationsSet !<The CMISSEquationsSetType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetTypeFinalise",err,error,*999)

    IF(ASSOCIATED(CMISSEquationsSet%EQUATIONS_SET))  &
      & CALL EQUATIONS_SET_DESTROY(CMISSEquationsSet%EQUATIONS_SET,err,error,*999)

    CALL EXITS("CMISSEquationsSetTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSEquationsSetTypeFinalise",err,error)
    CALL EXITS("CMISSEquationsSetTypeFinalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetTypeFinalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSEquationsSetType object.
  SUBROUTINE CMISSEquationsSetTypeInitialise(CMISSEquationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(OUT) :: CMISSEquationsSet !<The CMISSEquationsSetType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetTypeInitialise",err,error,*999)

    NULLIFY(CMISSEquationsSet%EQUATIONS_SET)

    CALL EXITS("CMISSEquationsSetTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSEquationsSetTypeInitialise",err,error)
    CALL EXITS("CMISSEquationsSetTypeInitialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSFieldType object.
  SUBROUTINE CMISSFieldTypeFinalise(CMISSField,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(OUT) :: CMISSField !<The CMISSFieldType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldTypeFinalise",err,error,*999)

    IF(ASSOCIATED(CMISSField%FIELD))  &
      & CALL FIELD_DESTROY(CMISSField%FIELD,err,error,*999)

    CALL EXITS("CMISSFieldTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSFieldTypeFinalise",err,error)
    CALL EXITS("CMISSFieldTypeFinalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldTypeFinalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSFieldType object.
  SUBROUTINE CMISSFieldTypeInitialise(CMISSField,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(OUT) :: CMISSField !<The CMISSFieldType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldTypeInitialise",err,error,*999)

    NULLIFY(CMISSField%FIELD)

    CALL EXITS("CMISSFieldTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSFieldTypeInitialise",err,error)
    CALL EXITS("CMISSFieldTypeInitialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldTypeInitialise

  !
  !================================================================================================================================
  !

  !>Creates a CMISSFieldsType object for an inteface by an object reference.
  SUBROUTINE CMISSFieldsTypeCreateInterface(iNTERFACE,fields,err)

    !Argument variables
    TYPE(CMISSInterfaceType), INTENT(IN) :: Interface !<The interface to get the fields from
    TYPE(CMISSFieldsType), INTENT(INOUT) :: fields !<On return, the fields attached to the specified interface. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldsTypeCreateInterface",err,error,*999)

    IF(ASSOCIATED(Interface%iNTERFACE)) THEN
      IF(ASSOCIATED(fields%FIELDS)) THEN
        CALL FLAG_ERROR("fields is already associated.",ERR,error,*999)
      ELSE
        fields%FIELDS=>Interface%iNTERFACE%FIELDS
      ENDIF
    ELSE
      CALL FLAG_ERROR("The interface is not associated.",ERR,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldsTypeCreateInterface")
    RETURN
999 CALL ERRORS("CMISSFieldsTypeCreateInterface",err,error)
    CALL EXITS("CMISSFieldsTypeCreateInterface")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldsTypeCreateInterface

  !
  !================================================================================================================================
  !

  !>Creates a CMISSFieldsType object for a region by an object reference.
  SUBROUTINE CMISSFieldsTypeCreateRegion(region,fields,err)

    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region to get the fields from
    TYPE(CMISSFieldsType), INTENT(INOUT) :: fields !<On return, the fields attached to the specified region. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldsTypeCreateRegion",err,error,*999)

    IF(ASSOCIATED(region%REGION)) THEN
      IF(ASSOCIATED(fields%FIELDS)) THEN
        CALL FLAG_ERROR("fields is already associated.",ERR,error,*999)
      ELSE
        fields%FIELDS=>region%REGION%FIELDS
      ENDIF
    ELSE
      CALL FLAG_ERROR("The region is not associated.",ERR,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldsTypeCreateRegion")
    RETURN
999 CALL ERRORS("CMISSFieldsTypeCreateRegion",err,error)
    CALL EXITS("CMISSFieldsTypeCreateRegion")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldsTypeCreateRegion

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSFieldsType object.
  SUBROUTINE CMISSFieldsTypeFinalise(CMISSFields,err)

    !Argument variables
    TYPE(CMISSFieldsType), INTENT(OUT) :: CMISSFields !<The CMISSFieldsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldsTypeFinalise",err,error,*999)

    NULLIFY(CMISSFields%FIELDS)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Fields Type')
#endif

    CALL EXITS("CMISSFieldsTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSFieldsTypeFinalise",err,error)
    CALL EXITS("CMISSFieldsTypeFinalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldsTypeFinalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSFieldsType object.
  SUBROUTINE CMISSFieldsTypeInitialise(CMISSFields,err)

    !Argument variables
    TYPE(CMISSFieldsType), INTENT(OUT) :: CMISSFields !<The CMISSFieldsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldsTypeInitialise",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Fields Type')
#endif

    NULLIFY(CMISSFields%FIELDS)

    CALL EXITS("CMISSFieldsTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSFieldsTypeInitialise",err,error)
    CALL EXITS("CMISSFieldsTypeInitialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldsTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSGeneratedMeshType object.
  SUBROUTINE CMISSGeneratedMeshTypeFinalise(CMISSGeneratedMesh,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(OUT) :: CMISSGeneratedMesh !<The CMISSGeneratedMeshType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMeshTypeFinalise",err,error,*999)

    IF(ASSOCIATED(CMISSGeneratedMesh%GENERATED_MESH))  &
      & CALL GENERATED_MESH_DESTROY(CMISSGeneratedMesh%GENERATED_MESH,err,error,*999)

    CALL EXITS("CMISSGeneratedMeshTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshTypeFinalise",err,error)
    CALL EXITS("CMISSGeneratedMeshTypeFinalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshTypeFinalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSGeneratedMeshType object.
  SUBROUTINE CMISSGeneratedMeshTypeInitialise(CMISSGeneratedMesh,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(OUT) :: CMISSGeneratedMesh !<The CMISSGeneratedMeshType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMeshTypeInitialise",err,error,*999)

    NULLIFY(CMISSGeneratedMesh%GENERATED_MESH)

    CALL EXITS("CMISSGeneratedMeshTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshTypeInitialise",err,error)
    CALL EXITS("CMISSGeneratedMeshTypeInitialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSInterfaceType object.
  SUBROUTINE CMISSInterfaceTypeFinalise(CMISSInterface,err)

    !Argument variables
    TYPE(CMISSInterfaceType), INTENT(OUT) :: CMISSInterface !<The CMISSInterfaceType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceTypeFinalise",err,error,*999)

    IF(ASSOCIATED(CMISSInterface%INTERFACE))  &
      & CALL INTERFACE_DESTROY(CMISSInterface%INTERFACE,err,error,*999)

    CALL EXITS("CMISSInterfaceTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSInterfaceTypeFinalise",err,error)
    CALL EXITS("CMISSInterfaceTypeFinalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceTypeFinalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSInterfaceType object.
  SUBROUTINE CMISSInterfaceTypeInitialise(CMISSInterface,err)

    !Argument variables
    TYPE(CMISSInterfaceType), INTENT(OUT) :: CMISSInterface !<The CMISSInterfaceType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceTypeInitialise",err,error,*999)

    NULLIFY(CMISSInterface%Interface)

    CALL EXITS("CMISSInterfaceTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSInterfaceTypeInitialise",err,error)
    CALL EXITS("CMISSInterfaceTypeInitialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSInterfaceConditionType object.
  SUBROUTINE CMISSInterfaceConditionTypeFinalise(CMISSInterfaceCondition,err)

    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(OUT) :: CMISSInterfaceCondition !<The CMISSInterfaceConditionType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceConditionTypeFinalise",err,error,*999)

    IF(ASSOCIATED(CMISSInterfaceCondition%INTERFACE_CONDITION))  &
      & CALL INTERFACE_CONDITION_DESTROY(CMISSInterfaceCondition%INTERFACE_CONDITION,err,error,*999)

    CALL EXITS("CMISSInterfaceConditionTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSInterfaceTypeConditionFinalise",err,error)
    CALL EXITS("CMISSInterfaceTypeConditionFinalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceConditionTypeFinalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSInterfaceConditionType object.
  SUBROUTINE CMISSInterfaceConditionTypeInitialise(CMISSInterfaceCondition,err)

    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(OUT) :: CMISSInterfaceCondition !<The CMISSInterfaceConditionType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceConditionTypeInitialise",err,error,*999)

    NULLIFY(CMISSInterfaceCondition%INTERFACE_CONDITION)

    CALL EXITS("CMISSInterfaceConditionTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSInterfaceConditionTypeInitialise",err,error)
    CALL EXITS("CMISSInterfaceConditionTypeInitialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceConditionTypeInitialise

   !
  !================================================================================================================================
  !

  !>Finalises a CMISSInterfaceEquationsType object.
  SUBROUTINE CMISSInterfaceEquationsTypeFinalise(CMISSInterfaceEquations,err)

    !Argument variables
    TYPE(CMISSInterfaceEquationsType), INTENT(OUT) :: CMISSInterfaceEquations !<The CMISSInterfaceEquationsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceEquationsTypeFinalise",err,error,*999)

    IF(ASSOCIATED(CMISSInterfaceEquations%INTERFACE_EQUATIONS))  &
      & CALL INTERFACE_EQUATIONS_DESTROY(CMISSInterfaceEquations%INTERFACE_EQUATIONS,err,error,*999)

    CALL EXITS("CMISSInterfaceEquationsTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSInterfaceEquationsTypeFinalise",err,error)
    CALL EXITS("CMISSInterfaceEquationsTypeFinalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceEquationsTypeFinalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSInterfaceEquationsType object.
  SUBROUTINE CMISSInterfaceEquationsTypeInitialise(CMISSInterfaceEquations,err)

    !Argument variables
    TYPE(CMISSInterfaceEquationsType), INTENT(OUT) :: CMISSInterfaceEquations !<The CMISSInterfaceEquationsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceEquationsTypeInitialise",err,error,*999)

    NULLIFY(CMISSInterfaceEquations%INTERFACE_EQUATIONS)

    CALL EXITS("CMISSInterfaceEquationsTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSInterfaceEquationsTypeInitialise",err,error)
    CALL EXITS("CMISSInterfaceEquationsTypeInitialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceEquationsTypeInitialise

  !
  !================================================================================================================================
  !

   !>Finalises a CMISSInterfaceMeshConnectivityType object.
   SUBROUTINE CMISSInterfaceMeshConnectivityTypeFinalise(CMISSInterfaceMeshConnectivity,err)

     !Argument variables
     TYPE(CMISSInterfaceMeshConnectivityType), INTENT(OUT) :: CMISSInterfaceMeshConnectivity !<The CMISSInterfaceMeshConnectivityType object to finalise.
     INTEGER(INTG), INTENT(OUT) :: err !<The error code.
     !Local variables

     CALL ENTERS("CMISSInterfaceMeshConnectivityTypeFinalise",err,error,*999)

     IF(ASSOCIATED(CMISSInterfaceMeshConnectivity%MESH_CONNECTIVITY)) &
       & CALL INTERFACE_MESH_CONNECTIVITY_DESTROY(CMISSInterfaceMeshConnectivity%MESH_CONNECTIVITY,err,error,*999)

     CALL EXITS("CMISSInterfaceMeshConnectivityTypeFinalise")
     RETURN
 999 CALL ERRORS("CMISSInterfaceMeshConnectivityTypeFinalise",err,error)
     CALL EXITS("CMISSInterfaceMeshConnectivityTypeFinalise")
     CALL CMISS_HANDLE_ERROR(err,error)
     RETURN

   END SUBROUTINE CMISSInterfaceMeshConnectivityTypeFinalise

  !
  !================================================================================================================================
  !

   !>Initialises a CMISSInterfaceMeshConnectivityType object.
   SUBROUTINE CMISSInterfaceMeshConnectivityTypeInitialise(CMISSInterfaceMeshConnectivity,err)

     !Argument variables
     TYPE(CMISSInterfaceMeshConnectivityType), INTENT(OUT) :: CMISSInterfaceMeshConnectivity !<The CMISSInterfaceMeshConnectivityType object to initialise.
     INTEGER(INTG), INTENT(OUT) :: err !<The error code.
     !Local variables

     CALL ENTERS("CMISSInterfaceMeshConnectivityTypeInitialise",err,error,*999)

     NULLIFY(CMISSInterfaceMeshConnectivity%MESH_CONNECTIVITY)

     CALL EXITS("CMISSInterfaceMeshConnectivityTypeInitialise")
     RETURN
 999 CALL ERRORS("CMISSInterfaceMeshConnectivityTypeInitialise",err,error)
     CALL EXITS("CMISSInterfaceMeshConnectivityTypeInitialise")
     CALL CMISS_HANDLE_ERROR(err,error)
     RETURN

   END SUBROUTINE CMISSInterfaceMeshConnectivityTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSHistoryType object.
  SUBROUTINE CMISSHistoryTypeFinalise(CMISSHistory,err)

    !Argument variables
    TYPE(CMISSHistoryType), INTENT(OUT) :: CMISSHistory !<The CMISSHistoryType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSHistoryTypeFinalise",err,error,*999)

    IF(ASSOCIATED(CMISSHistory%HISTORY))  &
      & CALL HISTORY_DESTROY(CMISSHistory%HISTORY,err,error,*999)

    CALL EXITS("CMISSHistoryTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSHistoryTypeFinalise",err,error)
    CALL EXITS("CMISSHistoryTypeFinalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSHistoryTypeFinalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSHistoryType object.
  SUBROUTINE CMISSHistoryTypeInitialise(CMISSHistory,err)

    !Argument variables
    TYPE(CMISSHistoryType), INTENT(OUT) :: CMISSHistory !<The CMISSHistoryType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSHistoryTypeInitialise",err,error,*999)

    NULLIFY(CMISSHistory%HISTORY)

    CALL EXITS("CMISSHistoryTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSHistoryTypeInitialise",err,error)
    CALL EXITS("CMISSHistoryTypeInitialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSHistoryTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSMeshType object.
  SUBROUTINE CMISSMeshTypeFinalise(CMISSMesh,err)

    !Argument variables
    TYPE(CMISSMeshType), INTENT(OUT) :: CMISSMesh !<The CMISSMeshType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshTypeFinalise",err,error,*999)

    IF(ASSOCIATED(CMISSMesh%MESH))  &
      & CALL MESH_DESTROY(CMISSMesh%MESH,err,error,*999)

    CALL EXITS("CMISSMeshTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSMeshTypeFinalise",err,error)
    CALL EXITS("CMISSMeshTypeFinalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshTypeFinalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSMeshType object.
  SUBROUTINE CMISSMeshTypeInitialise(CMISSMesh,err)

    !Argument variables
    TYPE(CMISSMeshType), INTENT(OUT) :: CMISSMesh !<The CMISSMeshType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshTypeInitialise",err,error,*999)

    NULLIFY(CMISSMesh%MESH)

    CALL EXITS("CMISSMeshTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSMeshTypeInitialise",err,error)
    CALL EXITS("CMISSMeshTypeInitialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSMeshElementsType object.
  SUBROUTINE CMISSMeshElementsTypeFinalise(CMISSMeshElements,err)

    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(OUT) :: CMISSMeshElements !<The CMISSMeshElementsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshElementsTypeFinalise",err,error,*999)

    IF(ASSOCIATED(CMISSMeshElements%MESH_ELEMENTS))  &
      & CALL MESH_TOPOLOGY_ELEMENTS_DESTROY(CMISSMeshElements%MESH_ELEMENTS,err,error,*999)

    CALL EXITS("CMISSMeshElementsTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSMeshElementsTypeFinalise",err,error)
    CALL EXITS("CMISSMeshElementsTypeFinalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElementsTypeFinalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSMeshElementsType object.
  SUBROUTINE CMISSMeshElementsTypeInitialise(CMISSMeshElements,err)

    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(OUT) :: CMISSMeshElements !<The CMISSMeshElementsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshElementsTypeInitialise",err,error,*999)

    NULLIFY(CMISSMeshElements%MESH_ELEMENTS)

    CALL EXITS("CMISSMeshElementsTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSMeshElementsTypeInitialise",err,error)
    CALL EXITS("CMISSMeshElementsTypeInitialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElementsTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSNodesType object.
  SUBROUTINE CMISSNodesTypeFinalise(CMISSNodes,err)

    !Argument variables
    TYPE(CMISSNodesType), INTENT(OUT) :: CMISSNodes !<The CMISSNodesType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSNodesTypeFinalise",err,error,*999)

    IF(ASSOCIATED(CMISSNodes%NODES))  &
      & CALL NODES_DESTROY(CMISSNodes%NODES,err,error,*999)

    CALL EXITS("CMISSNodesTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSNodesTypeFinalise",err,error)
    CALL EXITS("CMISSNodesTypeFinalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodesTypeFinalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSNodesType object.
  SUBROUTINE CMISSNodesTypeInitialise(CMISSNodes,err)

    !Argument variables
    TYPE(CMISSNodesType), INTENT(OUT) :: CMISSNodes !<The CMISSNodesType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSNodesTypeInitialise",err,error,*999)

    NULLIFY(CMISSNodes%NODES)

    CALL EXITS("CMISSNodesTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSNodesTypeInitialise",err,error)
    CALL EXITS("CMISSNodesTypeInitialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodesTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSProblemType object.
  SUBROUTINE CMISSProblemTypeFinalise(CMISSProblem,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(OUT) :: CMISSProblem !<The CMISSProblemType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemTypeFinalise",err,error,*999)

    IF(ASSOCIATED(CMISSProblem%PROBLEM))  &
      & CALL PROBLEM_DESTROY(CMISSProblem%PROBLEM,err,error,*999)

    CALL EXITS("CMISSProblemTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSProblemTypeFinalise",err,error)
    CALL EXITS("CMISSProblemTypeFinalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemTypeFinalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSProblemType object.
  SUBROUTINE CMISSProblemTypeInitialise(CMISSProblem,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(OUT) :: CMISSProblem !<The CMISSProblemType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemTypeInitialise",err,error,*999)

    NULLIFY(CMISSProblem%PROBLEM)

    CALL EXITS("CMISSProblemTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSProblemTypeInitialise",err,error)
    CALL EXITS("CMISSProblemTypeInitialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSQuadratureType object.
  SUBROUTINE CMISSQuadratureTypeFinalise(CMISSQuadrature,err)

    !Argument variables
    TYPE(CMISSQuadratureType), INTENT(OUT) :: CMISSQuadrature !<The CMISSQuadratureType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSQuadratureTypeFinalise",err,error,*999)

    IF(ASSOCIATED(CMISSQuadrature%QUADRATURE))  &
      & CALL BASIS_QUADRATURE_DESTROY(CMISSQuadrature%QUADRATURE,err,error,*999)

    CALL EXITS("CMISSQuadratureTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSQuadratureTypeFinalise",err,error)
    CALL EXITS("CMISSQuadratureTypeFinalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSQuadratureTypeFinalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSQuadratureType object.
  SUBROUTINE CMISSQuadratureTypeInitialise(CMISSQuadrature,err)

    !Argument variables
    TYPE(CMISSQuadratureType), INTENT(OUT) :: CMISSQuadrature !<The CMISSQuadratureType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSQuadratureTypeInitialise",err,error,*999)

    NULLIFY(CMISSQuadrature%QUADRATURE)

    CALL EXITS("CMISSQuadratureTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSQuadratureTypeInitialise",err,error)
    CALL EXITS("CMISSQuadratureTypeInitialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSQuadratureTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSRegionType object.
  SUBROUTINE CMISSRegionTypeFinalise(CMISSRegion,err)

    !Argument variables
    TYPE(CMISSRegionType), INTENT(OUT) :: CMISSRegion !<The CMISSRegionType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRegionTypeFinalise",err,error,*999)

    IF(ASSOCIATED(CMISSRegion%REGION))  &
      & CALL REGION_DESTROY(CMISSRegion%REGION,err,error,*999)

    CALL EXITS("CMISSRegionTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSRegionTypeFinalise",err,error)
    CALL EXITS("CMISSRegionTypeFinalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegionTypeFinalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSRegionType object.
  SUBROUTINE CMISSRegionTypeInitialise(CMISSRegion,err)

    !Argument variables
    TYPE(CMISSRegionType), INTENT(OUT) :: CMISSRegion !<The CMISSRegionType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRegionTypeInitialise",err,error,*999)

    NULLIFY(CMISSRegion%REGION)

    CALL EXITS("CMISSRegionTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSRegionTypeInitialise",err,error)
    CALL EXITS("CMISSRegionTypeInitialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegionTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSSolverType object.
  SUBROUTINE CMISSSolverTypeFinalise(CMISSSolver,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(OUT) :: CMISSSolver !<The CMISSSolverType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverTypeFinalise",err,error,*999)

    IF(ASSOCIATED(CMISSSolver%SOLVER))  &
      & CALL SOLVER_DESTROY(CMISSSolver%SOLVER,err,error,*999)

    CALL EXITS("CMISSSolverTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSSolverTypeFinalise",err,error)
    CALL EXITS("CMISSSolverTypeFinalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverTypeFinalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSSolverType object.
  SUBROUTINE CMISSSolverTypeInitialise(CMISSSolver,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(OUT) :: CMISSSolver !<The CMISSSolverType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverTypeInitialise",err,error,*999)

    NULLIFY(CMISSSolver%SOLVER)

    CALL EXITS("CMISSSolverTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSSolverTypeInitialise",err,error)
    CALL EXITS("CMISSSolverTypeInitialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverTypeInitialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSSolverEquationsType object.
  SUBROUTINE CMISSSolverEquationsTypeFinalise(CMISSSolverEquations,err)

    !Argument variables
    TYPE(CMISSSolverEquationsType), INTENT(OUT) :: CMISSSolverEquations !<The CMISSSolverEquationsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverEquationsTypeFinalise",err,error,*999)

    IF(ASSOCIATED(CMISSSolverEquations%SOLVER_EQUATIONS))  &
      & CALL SOLVER_EQUATIONS_DESTROY(CMISSSolverEquations%SOLVER_EQUATIONS,err,error,*999)

    CALL EXITS("CMISSSolverEquationsTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSSolverEquationsTypeFinalise",err,error)
    CALL EXITS("CMISSSolverEquationsTypeFinalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquationsTypeFinalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSSolverEquationsType object.
  SUBROUTINE CMISSSolverEquationsTypeInitialise(CMISSSolverEquations,err)

    !Argument variables
    TYPE(CMISSSolverEquationsType), INTENT(OUT) :: CMISSSolverEquations !<The CMISSSolverEquationsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverEquationsTypeInitialise",err,error,*999)

    NULLIFY(CMISSSolverEquations%SOLVER_EQUATIONS)

    CALL EXITS("CMISSSolverEquationsTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSSolverEquationsTypeInitialise",err,error)
    CALL EXITS("CMISSSolverEquationsTypeInitialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquationsTypeInitialise

!!==================================================================================================================================
!!
!! ANALYTIC_ANALYSIS_ROUTINES
!!
!!==================================================================================================================================

  !>Output the analytic error analysis for a field specified by a user number compared to the analytic values parameter set.
  SUBROUTINE CMISSAnalyticAnalysisOutputNumber(regionUserNumber,fieldUserNumber,fileName,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<If not empty, the filename to output the analytic analysis to. If empty, the analysis will be output to the standard output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisOutputNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_OUTPUT(FIELD,fileName,err,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSAnalyticAnalysisOutputNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisOutputNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisOutputNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisOutputNumber

  !
  !================================================================================================================================
  !

  !>Output the analytic error analysis for a field identified by an object compared to the analytic values parameter set.
  SUBROUTINE CMISSAnalyticAnalysisOutputObj(field,fileName,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<If not empty, the filename to output the analytic analysis to. If empty, the analysis will be output to the standard output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisOutputObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_OUTPUT(field%FIELD,fileName,err,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisOutputObj")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisOutputObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisOutputObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisOutputObj

  !
  !================================================================================================================================
  !

  !>Get absolute error value for the node in a field specified by a user number compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetNodeNumber(regionUserNumber,fieldUserNumber,variableType,versionNumber, &
    & derivativeNumber, nodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<derivative version number
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisAbsoluteErrorGetNodeNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_ABSOLUTE_ERROR_GET_NODE(FIELD,variableType,versionNumber,derivativeNumber,nodeNumber, &
          & componentNumber,value,ERR, error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetNodeNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisAbsoluteErrorGetNodeNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetNodeNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetNodeNumber

  !
  !================================================================================================================================
  !

  !>Get absolute error value for the node in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetNodeObj(field,variableType,versionNumber,derivativeNumber,nodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<derivative version number
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisAbsoluteErrorGetNodeObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_ABSOLUTE_ERROR_GET_NODE(field%FIELD,variableType,versionNumber,derivativeNumber,nodeNumber, &
      & componentNumber,value,ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetNodeObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisAbsoluteErrorGetNodeObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetNodeObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetNodeObj

  !
  !================================================================================================================================
  !

  !>Get percentage error value for the node in a field specified by a user number compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetNodeNumber(regionUserNumber,fieldUserNumber,variableType,versionNumber, &
    & derivativeNumber,nodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<derivative version number
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisPercentageErrorGetNodeNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_PERCENTAGE_ERROR_GET_NODE(FIELD,variableType,versionNumber,derivativeNumber,nodeNumber, &
          & componentNumber,value,ERR,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetNodeNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisPercentageErrorGetNodeNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetNodeNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetNodeNumber

  !
  !================================================================================================================================
  !

  !>Get percentage error value for the node in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetNodeObj(field,variableType,versionNumber,derivativeNumber,nodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<derivative version number
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisPercentageErrorGetNodeObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_PERCENTAGE_ERROR_GET_NODE(field%FIELD,variableType,versionNumber,derivativeNumber,nodeNumber, &
      & componentNumber,value,ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetNodeObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisPercentageErrorGetNodeObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetNodeObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetNodeObj


  !
  !================================================================================================================================
  !

  !>Get relative error value for the node in a field specified by a user number compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetNodeNumber(regionUserNumber,fieldUserNumber,variableType,versionNumber, &
    & derivativeNumber,nodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<derivative version number
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisRelativeErrorGetNodeNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_RELATIVE_ERROR_GET_NODE(FIELD,variableType,versionNumber,derivativeNumber,nodeNumber, &
          & componentNumber,value,ERR,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetNodeNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisRelativeErrorGetNodeNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetNodeNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetNodeNumber

  !
  !================================================================================================================================
  !

  !>Get relative error value for the node in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetNodeObj(field,variableType,versionNumber,derivativeNumber,nodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<derivative version number
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisRelativeErrorGetNodeObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_RELATIVE_ERROR_GET_NODE(field%FIELD,variableType,versionNumber,derivativeNumber,nodeNumber, &
      & componentNumber,value,ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetNodeObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisRelativeErrorGetNodeObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetNodeObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetNodeObj

  !
  !================================================================================================================================
  !

  !>Get absolute error value for the element in a field specified by a user number compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetElementNumber(regionUserNumber,fieldUserNumber,variableType,elementNumber, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisAbsoluteErrorGetElementNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_ABSOLUTE_ERROR_GET_ELEMENT(FIELD,variableType,elementNumber,componentNumber,value,ERR,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetElementNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisAbsoluteErrorGetElementNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetElementNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetElementNumber

  !
  !================================================================================================================================
  !

  !>Get absolute error value for the element in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetElementObj(field,variableType,elementNumber,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisAbsoluteErrorGetElementObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_ABSOLUTE_ERROR_GET_ELEMENT(field%FIELD,variableType,elementNumber,componentNumber,value,ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetElementObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisAbsoluteErrorGetElementObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetElementObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetElementObj

  !
  !================================================================================================================================
  !

  !>Get percentage error value for the element in a field specified by a user number compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetElementNumber(regionUserNumber,fieldUserNumber,variableType,elementNumber, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisPercentageErrorGetElementNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_PERCENTAGE_ERROR_GET_ELEMENT(FIELD,variableType,elementNumber,componentNumber,value,ERR,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetElementNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisPercentageErrorGetElementNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetElementNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetElementNumber

  !
  !================================================================================================================================
  !

  !>Get percentage error value for the element in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetElementObj(field,variableType,elementNumber,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisPercentageErrorGetElementObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_PERCENTAGE_ERROR_GET_ELEMENT(field%FIELD,variableType,elementNumber,componentNumber,value,ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetElementObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisPercentageErrorGetElementObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetElementObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetElementObj


  !
  !================================================================================================================================
  !

  !>Get relative error value for the element in a field specified by a user number compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetElementNumber(regionUserNumber,fieldUserNumber,variableType,elementNumber, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisRelativeErrorGetElementNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_RELATIVE_ERROR_GET_ELEMENT(FIELD,variableType,elementNumber,componentNumber,value,ERR,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetElementNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisRelativeErrorGetElementNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetElementNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetElementNumber

  !
  !================================================================================================================================
  !

  !>Get relative error value for the element in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetElementObj(field,variableType,elementNumber,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisRelativeErrorGetElementObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_RELATIVE_ERROR_GET_ELEMENT(field%FIELD,variableType,elementNumber,componentNumber,value,ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetElementObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisRelativeErrorGetElementObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetElementObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetElementObj

  !
  !================================================================================================================================
  !

  !>Get absolute error value for the constant in a field specified by a user number compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetConstantNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisAbsoluteErrorGetConstantNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_ABSOLUTE_ERROR_GET_CONSTANT(FIELD,variableType,componentNumber,value,ERR,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetConstantNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisAbsoluteErrorGetConstantNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetElementNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetConstantNumber

  !
  !================================================================================================================================
  !

  !>Get absolute error value for the constant in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetConstantObj(field,variableType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisAbsoluteErrorGetConstantObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_ABSOLUTE_ERROR_GET_CONSTANT(field%FIELD,variableType,componentNumber,value,ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetConstantObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisAbsoluteErrorGetConstantObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetConstantObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetConstantObj

  !
  !================================================================================================================================
  !

  !>Get percentage error value for the constant in a field specified by a user number compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetConstantNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisPercentageErrorGetConstantNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_PERCENTAGE_ERROR_GET_CONSTANT(FIELD,variableType,componentNumber,value,ERR,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetConstantNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisPercentageErrorGetConstantNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetConstantNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetConstantNumber

  !
  !================================================================================================================================
  !

  !>Get percentage error value for the constant in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetConstantObj(field,variableType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisPercentageErrorGetConstantObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_PERCENTAGE_ERROR_GET_CONSTANT(field%FIELD,variableType,componentNumber,value,ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetConstantObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisPercentageErrorGetConstantObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetConstantObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetConstantObj


  !
  !================================================================================================================================
  !

  !>Get relative error value for the constant in a field specified by a user number compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetConstantNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisRelativeErrorGetConstantNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_RELATIVE_ERROR_GET_CONSTANT(FIELD,variableType,componentNumber,value,ERR,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetConstantNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisRelativeErrorGetConstantNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetConstantNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetConstantNumber

  !
  !================================================================================================================================
  !

  !>Get relative error value for the constant in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetConstantObj(field,variableType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisRelativeErrorGetConstantObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_RELATIVE_ERROR_GET_CONSTANT(field%FIELD,variableType,componentNumber,value,ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetConstantObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisRelativeErrorGetConstantObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetConstantObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetConstantObj

  !
  !================================================================================================================================
  !

  !>Get rms error value for nodes in a field compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisRmsErrorGetNodeNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, errorType, &
    & localValue,localGhostValue,globalValue,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    INTEGER(INTG), INTENT(IN) :: errorType !<error type
    REAL(DP), INTENT(OUT) :: localValue(8) !<On return, the local error
    REAL(DP), INTENT(OUT) :: localGhostValue(8) !<On return, the local ghost error
    REAL(DP), INTENT(OUT) :: globalValue(8) !<On return, the global error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisRmsErrorGetNodeNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_RMS_ERROR_GET_NODE(FIELD,variableType,componentNumber,errorType,localValue,localGhostValue, &
          & globalValue,ERR,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSAnalyticAnalysisRmsErrorGetNodeNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisRmsErrorGetNodeNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisRmsErrorGetNodeNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisRmsErrorGetNodeNumber

  !
  !================================================================================================================================
  !

  !>Get rms error value for nodes in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisRmsErrorGetNodeObj(field,variableType,componentNumber,errorType,localValue,localGhostValue, &
    & globalValue,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    INTEGER(INTG), INTENT(IN) :: errorType !<error type
    REAL(DP), INTENT(OUT) :: localValue(8) !<On return, the local error
    REAL(DP), INTENT(OUT) :: localGhostValue(8) !<On return, the local ghost error
    REAL(DP), INTENT(OUT) :: globalValue(8) !<On return, the global error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisRmsErrorGetNodeObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_RMS_ERROR_GET_NODE(field%FIELD,variableType,componentNumber,errorType,localValue,localGhostValue, &
      & globalValue,ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisRmsErrorGetNodeObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisRmsErrorGetNodeObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisRmsErrorGetNodeObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisRmsErrorGetNodeObj

  !
  !================================================================================================================================
  !

  !>Get rms error value for elements in a field compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisRmsErrorGetElementNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & errorType,localValue,localGhostValue,globalValue,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    INTEGER(INTG), INTENT(IN) :: errorType !<error type
    REAL(DP), INTENT(OUT) :: localValue !<On return, the local error
    REAL(DP), INTENT(OUT) :: localGhostValue !<On return, the local ghost error
    REAL(DP), INTENT(OUT) :: globalValue !<On return, the global error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisRmsErrorGetElementNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_RMS_ERROR_GET_ELEMENT(FIELD,variableType,componentNumber,errorType,localValue,localGhostValue, &
          & globalValue,ERR,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSAnalyticAnalysisRmsErrorGetElementNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisRmsErrorGetElementNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisRmsErrorGetElementNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisRmsErrorGetElementNumber

  !
  !================================================================================================================================
  !

  !>Get relative error value for the constant in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisRmsErrorGetElementObj(field,variableType,componentNumber,errorType,localValue,localGhostValue, &
    & globalValue,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    INTEGER(INTG), INTENT(IN) :: errorType !<error type
    REAL(DP), INTENT(OUT) :: localValue !<On return, the local error
    REAL(DP), INTENT(OUT) :: localGhostValue !<On return, the local ghost error
    REAL(DP), INTENT(OUT) :: globalValue !<On return, the global error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisRmsErrorGetNodeObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_RMS_ERROR_GET_ELEMENT(field%FIELD,variableType,componentNumber,errorType,localValue,localGhostValue, &
      & globalValue,ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisRmsErrorGetElementObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisRmsErrorGetElementObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisRmsErrorGetElementObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisRmsErrorGetElementObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the numerical values.
  SUBROUTINE CMISSAnalyticAnalysisIntegralNumericalValueGetNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & integralValue,ghostIntegralValue,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisIntegralNumericalValueGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_INTEGRAL_NUMERICAL_VALUE_GET(FIELD,variableType,componentNumber,integralValue,ghostIntegralValue, &
          & ERR,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSAnalyticAnalysisIntegralNumericalValueGetNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralNumericalValueGetNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisIntegralNumericalValueGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisIntegralNumericalValueGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the numerical values.
  SUBROUTINE CMISSAnalyticAnalysisIntegralNumericalValueGetObj(field,variableType,componentNumber,integralValue, &
    & ghostIntegralValue,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisIntegralNumericalValueGetObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_INTEGRAL_NUMERICAL_VALUE_GET(field%FIELD,variableType,componentNumber,integralValue,ghostIntegralValue, &
          & ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisIntegralNumericalValueGetObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralNumericalValueGetObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisIntegralNumericalValueGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisIntegralNumericalValueGetObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the analytic values.
  SUBROUTINE CMISSAnalyticAnalysisIntegralAnalyticValueGetNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & integralValue,ghostIntegralValue,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisIntegralAnalyticValueGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_INTEGRAL_ANALYTIC_VALUE_GET(FIELD,variableType,componentNumber,integralValue,ghostIntegralValue, &
          & ERR,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSAnalyticAnalysisIntegralAnalyticValueGetNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralAnalyticValueGetNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisIntegralAnalyticValueGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisIntegralAnalyticValueGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the analytic values.
  SUBROUTINE CMISSAnalyticAnalysisIntegralAnalyticValueGetObj(field,variableType,componentNumber,integralValue, &
    & ghostIntegralValue,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisIntegralAnalyticValueGetObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_INTEGRAL_ANALYTIC_VALUE_GET(field%FIELD,variableType,componentNumber,integralValue,ghostIntegralValue, &
          & ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisIntegralAnalyticValueGetObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralAnalyticValueGetObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisIntegralAnalyticValueGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisIntegralAnalyticValueGetObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the percentage errors.
  SUBROUTINE CMISSAnalyticAnalysisIntegralPercentageErrorGetNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & integralValue,ghostIntegralValue,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisIntegralPercentageErrorGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_INTEGRAL_PERCENTAGE_ERROR_GET(FIELD,variableType,componentNumber,integralValue,ghostIntegralValue, &
          & ERR,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSAnalyticAnalysisIntegralPercentageErrorGetNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralPercentageErrorGetNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisIntegralPercentageErrorGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisIntegralPercentageErrorGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the percentage errors.
  SUBROUTINE CMISSAnalyticAnalysisIntegralPercentageErrorGetObj(field,variableType,componentNumber,integralValue, &
    & ghostIntegralValue,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisIntegralPercentageErrorGetObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_INTEGRAL_PERCENTAGE_ERROR_GET(field%FIELD,variableType,componentNumber,integralValue, &
      & ghostIntegralValue,ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisIntegralPercentageErrorGetObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralPercentageErrorGetObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisIntegralPercentageErrorGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisIntegralPercentageErrorGetObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the absolute errors.
  SUBROUTINE CMISSAnalyticAnalysisIntegralAbsoluteErrorGetNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & integralValue,ghostIntegralValue,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisIntegralAbsoluteErrorGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_INTEGRAL_ABSOLUTE_ERROR_GET(FIELD,variableType,componentNumber,integralValue,ghostIntegralValue, &
          & ERR,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSAnalyticAnalysisIntegralAbsoluteErrorGetNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralAbsoluteErrorGetNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisIntegralAbsoluteErrorGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisIntegralAbsoluteErrorGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the absolute errors.
  SUBROUTINE CMISSAnalyticAnalysisIntegralAbsoluteErrorGetObj(field,variableType,componentNumber,integralValue, &
    & ghostIntegralValue,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisIntegralAbsoluteErrorGetObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_INTEGRAL_ABSOLUTE_ERROR_GET(field%FIELD,variableType,componentNumber,integralValue,ghostIntegralValue, &
          & ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisIntegralAbsoluteErrorGetObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralAbsoluteErrorGetObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisIntegralAbsoluteErrorGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisIntegralAbsoluteErrorGetObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the relative error.
  SUBROUTINE CMISSAnalyticAnalysisIntegralRelativeErrorGetNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & integralValue,ghostIntegralValue,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisIntegralRelativeErrorGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_INTEGRAL_RELATIVE_ERROR_GET(FIELD,variableType,componentNumber,integralValue,ghostIntegralValue, &
          & ERR,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSAnalyticAnalysisIntegralRelativeErrorGetNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralRelativeErrorGetNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisIntegralRelativeErrorGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisIntegralRelativeErrorGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the relative error.
  SUBROUTINE CMISSAnalyticAnalysisIntegralRelativeErrorGetObj(field,variableType,componentNumber,integralValue, &
    & ghostIntegralValue,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisIntegralRelativeErrorGetObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_INTEGRAL_RELATIVE_ERROR_GET(field%FIELD,variableType,componentNumber,integralValue,ghostIntegralValue, &
      & ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisIntegralRelativeErrorGetObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralRelativeErrorGetObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisIntegralRelativeErrorGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisIntegralRelativeErrorGetObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the nid numerical.
  SUBROUTINE CMISSAnalyticAnalysisIntegralNidNumericalValueGetNumber(regionUserNumber,fieldUserNumber,variableType, &
    & componentNumber,integralValue,ghostIntegralValue,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisIntegralNidNumericalValueGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_INTEGRAL_NID_NUMERICAL_VALUE_GET(FIELD,variableType,componentNumber,integralValue, &
          & ghostIntegralValue,ERR,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSAnalyticAnalysisIntegralNidNumericalValueGetNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralNidNumericalValueGetNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisIntegralNidNumericalValueGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisIntegralNidNumericalValueGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the nid numerical.
  SUBROUTINE CMISSAnalyticAnalysisIntegralNidNumericalValueGetObj(field,variableType,componentNumber,integralValue, &
    & ghostIntegralValue,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisIntegralNidNumericalValueGetObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_INTEGRAL_NID_NUMERICAL_VALUE_GET(field%FIELD,variableType,componentNumber,integralValue, &
      & ghostIntegralValue,ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisIntegralNidNumericalValueGetObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralNidNumericalValueGetObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisIntegralNidNumericalValueGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisIntegralNidNumericalValueGetObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the nid error.
  SUBROUTINE CMISSAnalyticAnalysisIntegralNidErrorGetNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & integralValue,ghostIntegralValue,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisIntegralNidErrorGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_INTEGRAL_NID_ERROR_GET(FIELD,variableType,componentNumber,integralValue,ghostIntegralValue,ERR, &
          & error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSAnalyticAnalysisIntegralNidErrorGetNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralNidErrorGetNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisIntegralNidErrorGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisIntegralNidErrorGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the nid error.
  SUBROUTINE CMISSAnalyticAnalysisIntegralNidErrorGetObj(field,variableType,componentNumber,integralValue,ghostIntegralValue,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisIntegralNidErrorGetObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_INTEGRAL_NID_ERROR_GET(field%FIELD,variableType,componentNumber,integralValue,ghostIntegralValue,ERR, &
      & error,*999)

    CALL EXITS("CMISSAnalyticAnalysisIntegralNidErrorGetObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralNidErrorGetObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisIntegralNidErrorGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisIntegralNidErrorGetObj




!!==================================================================================================================================
!!
!! BASE_ROUTINES
!!
!!==================================================================================================================================

  !>Sets diagnostics off. \see OPENCMISS::CMISSDiagnosticsSetOn
  SUBROUTINE CMISSDiagnosticsSetOff(err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    CALL ENTERS("CMISSDiagnosticsSetOff",err,error,*999)

    CALL DIAGNOSTICS_SET_OFF(err,error,*999)

    CALL EXITS("CMISSDiagnosticsSetOff")
    RETURN
999 CALL ERRORS("CMISSDiagnosticsSetOff",err,error)
    CALL EXITS("CMISSDiagnosticsSetOff")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDiagnosticsSetOff

  !
  !================================================================================================================================
  !

  !>Sets diagnostics on \see OPENCMISS::CMISSDiagnosticsSetOff
  SUBROUTINE CMISSDiagnosticsSetOn(diagType,levelList,diagFilename,routineList,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: diagType !<The type of diagnostics to set on \see OPENCMISS_DiagnosticTypes.
    INTEGER(INTG), INTENT(IN) :: levelList(:) !<The list of diagnostic levels to set on.
    CHARACTER(LEN=*), INTENT(IN) :: diagFilename !<If present the name of the file to output diagnostic information to. If omitted the diagnostic output is sent to the screen.
    CHARACTER(LEN=*), INTENT(IN) :: routineList(:) !<The list of routines to set diagnostics on in.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    CALL ENTERS("CMISSDiagnosticsSetOn",err,error,*999)

    CALL DIAGNOSTICS_SET_ON(diagType,levelList,diagFilename,routineList,err,error,*999)

    CALL EXITS("CMISSDiagnosticsSetOn")
    RETURN
999 CALL ERRORS("CMISSDiagnosticsSetOn",err,error)
    CALL EXITS("CMISSDiagnosticsSetOn")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDiagnosticsSetOn

  !
  !================================================================================================================================
  !

  !>Sets output off \see OPENCMISS::CMISSOutputSetOff
  SUBROUTINE CMISSOutputSetOff(err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    CALL ENTERS("CMISSOutputSetOff",err,error,*999)

    CALL OUTPUT_SET_OFF(err,error,*999)

    CALL EXITS("CMISSOutputSetOff")
    RETURN
999 CALL ERRORS("CMISSOutputSetOff",err,error)
    CALL EXITS("CMISSOutputSetOff")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSOutputSetOff

  !
  !================================================================================================================================
  !

  !>Sets output on \see OPENCMISS::CMISSOutputSetOff
  SUBROUTINE CMISSOutputSetOn(echoFilename,err)

    !Argument variables
    CHARACTER(LEN=*), INTENT(IN) :: echoFilename !<The filename of the file to echo output to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    CALL ENTERS("CMISSOutputSetOn",err,error,*999)

    CALL OUTPUT_SET_ON(echoFilename,err,error,*999)

    CALL EXITS("CMISSOutputSetOn")
    RETURN
999 CALL ERRORS("CMISSOutputSetOn",err,error)
    CALL EXITS("CMISSOutputSetOn")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSOutputSetOn

  !
  !================================================================================================================================
  !

  !>Sets timing off \see OPENCMISS::CMISSTimingSetOn
  SUBROUTINE CMISSTimingSetOff(err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    CALL ENTERS("CMISSTimingSetOff",ERR,error,*999)

    CALL TIMING_SET_OFF(err,error,*999)

    CALL EXITS("CMISSTimingSetOff")
    RETURN
999 CALL ERRORS("CMISSTimingSetOff",err,error)
    CALL EXITS("CMISSTimingSetOff")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSTimingSetOff

  !
  !================================================================================================================================
  !

  !>Sets timing on \see OPENCMISS::CMISSTimingSetOff
  SUBROUTINE CMISSTimingSetOn(timingType,timingSummaryFlag,timingFilename,routineList,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: timingType !<The type of timing to set on \see OPENCMISS_TimingTypes.
    LOGICAL, INTENT(IN) :: timingSummaryFlag !<.TRUE. if the timing information will be output with subsequent OPENCMISS::CMISSTimingSummaryOutput calls, .FALSE. if the timing information will be output every time the routine exits.
    CHARACTER(LEN=*), INTENT(IN) :: timingFilename !<If present the name of the file to output timing information to. If omitted the timing output is sent to the screen.
    CHARACTER(LEN=*), INTENT(IN) :: routineList(:) !<The list of routines to set timing on in.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    CALL ENTERS("CMISSTimingSetOn",err,error,*999)

    CALL TIMING_SET_ON(timingType,timingSummaryFlag,timingFilename,routineList,err,error,*999)

    CALL EXITS("CMISSTimingSetOn")
    RETURN
999 CALL ERRORS("CMISSTimingSetOn",err,error)
    CALL EXITS("CMISSTimingSetOn")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSTimingSetOn

  !
  !================================================================================================================================
  !

  !>Outputs the timing summary.
  SUBROUTINE CMISSTimingSummaryOutput(err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    !Local variables

    CALL ENTERS("CMISSTimingSummaryOutput",err,error,*999)

    CALL TIMING_SUMMARY_OUTPUT(err,error,*999)

    CALL EXITS("CMISSTimingSummaryOutput")
    RETURN
999 CALL ERRORS("CMISSTimingSummaryOutput",err,error)
    CALL EXITS("CMISSTimingSummaryOutput")
    RETURN

  END SUBROUTINE CMISSTimingSummaryOutput

!!==================================================================================================================================
!!
!! BASIS_ROUTINES
!!
!!==================================================================================================================================

  !>Returns the collapsed Xi flags of a basis identified by a user number.
  SUBROUTINE CMISSBasisCollapsedXiGetNumber(userNumber,collapsedXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the collapsed Xi flags for.
    INTEGER(INTG), INTENT(OUT) :: collapsedXi(:) !<collapsedXi(ni). On return, the collapsed Xi parameter for the ni'th Xi direction. \see OPENCMISS_BasisXiCollapse
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisCollapsedXiGetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_COLLAPSED_XI_GET(BASIS,collapsedXi,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSBasisCollapsedXiGetNumber")
    RETURN
999 CALL ERRORS("CMISSBasisCollapsedXiGetNumber",err,error)
    CALL EXITS("CMISSBasisCollapsedXiGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisCollapsedXiGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the collapsed Xi flags of a basis identified by an object.
  SUBROUTINE CMISSBasisCollapsedXiGetObj(basis,collapsedXi,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(IN) :: basis !<The basis to get the collapsed Xi flags for.
    INTEGER(INTG), INTENT(OUT) :: collapsedXi(:) !<collapsedXi(ni). On return, the collapsed Xi parameter for the ni'th Xi direction. \see OPENCMISS_BasisXiCollapse
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisCollapsedXiGetObj",err,error,*999)

    CALL BASIS_COLLAPSED_XI_GET(basis%BASIS,collapsedXi,err,error,*999)

    CALL EXITS("CMISSBasisCollapsedXiGetObj")
    RETURN
999 CALL ERRORS("CMISSBasisCollapsedXiGetObj",err,error)
    CALL EXITS("CMISSBasisCollapsedXiGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisCollapsedXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the collapsed Xi flags of a basis identified by a user number.
  SUBROUTINE CMISSBasisCollapsedXiSetNumber(userNumber,collapsedXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to set the collapsed Xi flags for.
    INTEGER(INTG), INTENT(IN) :: collapsedXi(:) !<collapsedXi(ni). The collapsed Xi parameter for the ni'th Xi direction to set. \see OPENCMISS_BasisXiCollapse
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisCollapsedXiSetNumber",ERR,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_COLLAPSED_XI_SET(BASIS,collapsedXi,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSBasisCollapsedXiSetNumber")
    RETURN
999 CALL ERRORS("CMISSBasisCollapsedXiSetNumber",err,error)
    CALL EXITS("CMISSBasisCollapsedXiSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisCollapsedXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the collapsed Xi flags of a basis identified by an object.
  SUBROUTINE CMISSBasisCollapsedXiSetObj(basis,collapsedXi,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(INOUT) :: basis !<The basis to set the collapsed Xi flags for.
    INTEGER(INTG), INTENT(IN) :: collapsedXi(:) !<collapsedXi(ni). The collapsed Xi parameter for the ni'th Xi direction to set. \see OPENCMISS_BasisXiCollapse
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisCollapsedXiSetObj",err,error,*999)

    CALL BASIS_COLLAPSED_XI_SET(basis%BASIS,collapsedXi,err,error,*999)

    CALL EXITS("CMISSBasisCollapsedXiSetObj")
    RETURN
999 CALL ERRORS("CMISSBasisCollapsedXiSetObj",err,error)
    CALL EXITS("CMISSBasisCollapsedXiSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisCollapsedXiSetObj

  !
  !================================================================================================================================
  !

   !>Finishes the creation of a new basis identified by a user number.
  SUBROUTINE CMISSBasisCreateFinishNumber(userNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisCreateFinishNumber",ERR,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,err,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_CREATE_FINISH(Basis,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Basis Create')
#endif

    CALL EXITS("CMISSBasisCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSBasisCreateFinishNumber",err,error)
    CALL EXITS("CMISSBasisCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a new basis identified by an object.
  SUBROUTINE CMISSBasisCreateFinishObj(basis,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(INOUT) :: basis !<The basis to finish the creation of
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    CALL ENTERS("CMISSBasisCreateFinishObj",err,error,*999)

    CALL BASIS_CREATE_FINISH(basis%BASIS,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('basis Create')
#endif

    CALL EXITS("CMISSBasisCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSBasisCreateFinishObj",err,error)
    CALL EXITS("CMISSBasisCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a new basis for a basis identified by a user number.
  SUBROUTINE CMISSBasisCreateStartNumber(userNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to start the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS

    CALL ENTERS("CMISSBasisCreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Basis Create')
#endif

    NULLIFY(BASIS)
    CALL BASIS_CREATE_START(userNumber,BASIS,err,error,*999)

    CALL EXITS("CMISSBasisCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSBasisCreateStartNumber",err,error)
    CALL EXITS("CMISSBasisCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a new basis for a basis identified by an object.
  SUBROUTINE CMISSBasisCreateStartObj(userNumber,basis,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to start the creation of.
    TYPE(CMISSBasisType), INTENT(INOUT) :: basis !<On exit, the newly created basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisCreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('basis Create')
#endif

    CALL BASIS_CREATE_START(userNumber,basis%BASIS,err,error,*999)

    CALL EXITS("CMISSBasisCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSBasisCreateStartObj",err,error)
    CALL EXITS("CMISSBasisCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys a basis identified by its basis user number.
  SUBROUTINE CMISSBasisDestroyNumber(userNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisDestroyNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_DESTROY(BASIS,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSBasisDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSBasisDestroyNumber",err,error)
    CALL EXITS("CMISSBasisDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a basis identified by an object.
  SUBROUTINE CMISSBasisDestroyObj(basis,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(INOUT) :: basis !<The basis to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisDestroyObj",err,error,*999)

    CALL BASIS_DESTROY(basis%BASIS,err,error,*999)

    CALL EXITS("CMISSBasisDestroyObj")
    RETURN
999 CALL ERRORS("CMISSBasisDestroyObj",err,error)
    CALL EXITS("CMISSBasisDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisDestroyObj

  !
  !================================================================================================================================
  !

  !>Get the interpolation type in each xi directions for a basis identified by a user number.
  SUBROUTINE CMISSBasisInterpolationXiGetNumber(userNumber,interpolationXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the interpolation xi for.
    INTEGER(INTG), INTENT(OUT) :: interpolationXi(:) !<On return, the interpolation xi parameters for each Xi direction \see OPENCMISS_BasisInterpolationSpecifications.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisInterpolationXiGetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_INTERPOLATION_XI_GET(BASIS,interpolationXi,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSBasisInterpolationXiGetNumber")
    RETURN
999 CALL ERRORS("CMISSBasisInterpolationXiGetNumber",err,error)
    CALL EXITS("CMISSBasisInterpolationXiGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisInterpolationXiGetNumber

  !
  !================================================================================================================================
  !

  !>Get the interpolation type in each xi directions for a basis indentified by an object.
  SUBROUTINE CMISSBasisInterpolationXiGetObj(basis,interpolationXi,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(IN) :: basis !<The basis to get the interpolation xi for.
    INTEGER(INTG), INTENT(OUT) :: interpolationXi(:) !<On return, the interpolation xi parameters for each Xi direction \see OPENCMISS_BasisInterpolationSpecifications.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisInterpolationXiGetObj",err,error,*999)

    CALL BASIS_INTERPOLATION_XI_GET(basis%BASIS,interpolationXi,err,error,*999)

    CALL EXITS("CMISSBasisInterpolationXiGetObj")
    RETURN
999 CALL ERRORS("CMISSBasisInterpolationXiGetObj",err,error)
    CALL CMISS_HANDLE_ERROR(err,error)
    CALL EXITS("CMISSBasisInterpolationXiGetObj")
    RETURN

  END SUBROUTINE CMISSBasisInterpolationXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the interpolation type in each xi directions for a basis identified by a user number.
  SUBROUTINE CMISSBasisInterpolationXiSetNumber(userNumber,interpolationXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the interpolation xi for.
    INTEGER(INTG), INTENT(IN) :: interpolationXi(:) !<The interpolation xi parameters for each Xi direction \see OPENCMISS_BasisInterpolationSpecifications.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisInterpolationXiSetNumber",ERR,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_INTERPOLATION_XI_SET(BASIS,interpolationXi,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSBasisInterpolationXiSetNumber")
    RETURN
999 CALL ERRORS("CMISSBasisInterpolationXiSetNumber",err,error)
    CALL EXITS("CMISSBasisInterpolationXiSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisInterpolationXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the interpolation type in each xi directions for a basis indentified by an object.
  SUBROUTINE CMISSBasisInterpolationXiSetObj(basis,interpolationXi,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(IN) :: basis !<The basis to get the interpolation xi for.
    INTEGER(INTG), INTENT(IN) :: interpolationXi(:) !<The interpolation xi parameters for each Xi direction \see OPENCMISS_BasisInterpolationSpecifications.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisInterpolationXiSetObj",err,error,*999)

    CALL BASIS_INTERPOLATION_XI_SET(basis%BASIS,interpolationXi,err,error,*999)

    CALL EXITS("CMISSBasisInterpolationXiSetObj")
    RETURN
999 CALL ERRORS("CMISSBasisInterpolationXiSetObj",err,error)
    CALL EXITS("CMISSBasisInterpolationXiSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisInterpolationXiSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of local nodes in a basis identified by a user number.
  SUBROUTINE CMISSBasisNumberOfLocalNodesGetNumber(userNumber,numberOfLocalNodes,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the interpolation xi for.
    INTEGER(INTG), INTENT(OUT) :: numberOfLocalNodes !<On return, the number of local nodes in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisNumberOfLocalNodesGetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_NUMBER_OF_LOCAL_NODES_GET(BASIS,numberOfLocalNodes,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSBasisNumberOfLocalNodesGetNumber")
    RETURN
999 CALL ERRORS("CMISSBasisNumberOfLocalNodesGetNumber",err,error)
    CALL EXITS("CMISSBasisNumberOfLocalNodesGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisNumberOfLocalNodesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of local nodes in a basis identified by an object.
  SUBROUTINE CMISSBasisNumberOfLocalNodesGetObj(basis,numberOfLocalNodes,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(IN) :: basis !<The basis to get the number of local nodes for.
    INTEGER(INTG), INTENT(OUT) :: numberOfLocalNodes !<On return, the number of local nodes in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisNumberOfLocalNodesGetObj",err,error,*999)

    CALL BASIS_NUMBER_OF_LOCAL_NODES_GET(basis%BASIS,numberOfLocalNodes,err,error,*999)

    CALL EXITS("CMISSBasisNumberOfLocalNodesGetObj")
    RETURN
999 CALL ERRORS("CMISSBasisNumberOfLocalNodesGetObj",err,error)
    CALL EXITS("CMISSBasisNumberOfLocalNodesGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisNumberOfLocalNodesGetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of Xi directions in a basis identified by a user number.
  SUBROUTINE CMISSBasisNumberOfXiGetNumber(userNumber,numberOfXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the number xi for.
    INTEGER(INTG), INTENT(OUT) :: numberOfXi !<On return, the number of xi directions in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisNumberOfXiGetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_NUMBER_OF_XI_GET(BASIS,numberOfXi,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSBasisNumberOfXiGetNumber")
    RETURN
999 CALL ERRORS("CMISSBasisNumberOfXiGetNumber",err,error)
    CALL EXITS("CMISSBasisNumberOfXiGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisNumberOfXiGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of Xi directions in a basis identified by an object.
  SUBROUTINE CMISSBasisNumberOfXiGetObj(basis,numberOfXi,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(IN) :: basis !<The basis to get the number of xi directions for.
    INTEGER(INTG), INTENT(OUT) :: numberOfXi !<On return, the number of xi directions in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisNumberOfXiGetObj",err,error,*999)

    CALL BASIS_NUMBER_OF_XI_GET(basis%BASIS,numberOfXi,err,error,*999)

    CALL EXITS("CMISSBasisNumberOfXiGetObj")
    RETURN
999 CALL ERRORS("CMISSBasisNumberOfXiGetObj",err,error)
    CALL EXITS("CMISSBasisNumberOfXiGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisNumberOfXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of Xi directions in a basis identified by a user number.
  SUBROUTINE CMISSBasisNumberOfXiSetNumber(userNumber,numberOfXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to set the number xi for.
    INTEGER(INTG), INTENT(IN) :: numberOfXi !<The number of xi directions in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisNumberOfXiSetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_NUMBER_OF_XI_SET(BASIS,numberOfXi,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSBasisNumberOfXiSetNumber")
    RETURN
999 CALL ERRORS("CMISSBasisNumberOfXiSetNumber",err,error)
    CALL EXITS("CMISSBasisNumberOfXiSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisNumberOfXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of Xi directions in a basis identified by an object.
  SUBROUTINE CMISSBasisNumberOfXiSetObj(basis,numberOfXi,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(INOUT) :: basis !<The basis to set the number of xi directions for.
    INTEGER(INTG), INTENT(IN) :: numberOfXi !<The number of xi directions in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisNumberOfXiSetObj",err,error,*999)

    CALL BASIS_NUMBER_OF_XI_SET(basis%BASIS,numberOfXi,err,error,*999)

    CALL EXITS("CMISSBasisNumberOfXiSetObj")
    RETURN
999 CALL ERRORS("CMISSBasisNumberOfXiSetObj",err,error)
    CALL EXITS("CMISSBasisNumberOfXiSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisNumberOfXiSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of Gauss points in each Xi directions for a basis quadrature identified by a user number.
  SUBROUTINE CMISSBasisQuadratureNumberOfGaussXiGetNumber(userNumber,numberOfGaussXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the number of Gauss Xi for.
    INTEGER(INTG), INTENT(OUT) :: numberOfGaussXi(:) !<On return, the number of Gauss points in each Xi directions in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisQuadratureNumberOfGaussXiGetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_QUADRATURE_NUMBER_OF_GAUSS_XI_GET(BASIS,numberOfGaussXi,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSBasisQuadratureNumberOfGaussXiGetNumber")
    RETURN
999 CALL ERRORS("CMISSBasisQuadratureNumberOfGaussXiGetNumber",err,error)
    CALL EXITS("CMISSBasisQuadratureNumberOfGaussXiGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisQuadratureNumberOfGaussXiGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number Gauss points in each Xi directions for a basis quadrature identified by an object.
  SUBROUTINE CMISSBasisQuadratureNumberOfGaussXiGetObj(basis,numberOfGaussXi,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(IN) :: basis !<The basis to get the number of Gauss Xi for.
    INTEGER(INTG), INTENT(OUT) :: numberOfGaussXi(:) !<On return, the number of Gauss points in each Xi directions in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisQuadratureNumberOfGaussXiGetObj",err,error,*999)

    CALL BASIS_QUADRATURE_NUMBER_OF_GAUSS_XI_GET(basis%BASIS,numberOfGaussXi,err,error,*999)

    CALL EXITS("CMISSBasisQuadratureNumberOfGaussXiGetObj")
    RETURN
999 CALL ERRORS("CMISSBasisQuadratureNumberOfGaussXiGetObj",err,error)
    CALL EXITS("CMISSBasisQuadratureNumberOfGaussXiGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisQuadratureNumberOfGaussXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of Gauss points in each Xi directions for a basis quadrature identified by a user number.
  SUBROUTINE CMISSBasisQuadratureNumberOfGaussXiSetNumber(userNumber,numberOfGaussXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to set the number of Gauss Xi for.
    INTEGER(INTG), INTENT(IN) :: numberOfGaussXi(:) !<The number of Gauss points in each Xi directions in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisQuadratureNumberOfGaussXiSetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_QUADRATURE_NUMBER_OF_GAUSS_XI_SET(BASIS,numberOfGaussXi,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSBasisQuadratureNumberOfGaussXiSetNumber")
    RETURN
999 CALL ERRORS("CMISSBasisQuadratureNumberOfGaussXiSetNumber",err,error)
    CALL EXITS("CMISSBasisQuadratureNumberOfGaussXiSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisQuadratureNumberOfGaussXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the number Gauss points in each Xi directions for a basis quadrature identified by an object.
  SUBROUTINE CMISSBasisQuadratureNumberOfGaussXiSetObj(basis,numberOfGaussXi,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(INOUT) :: basis !<The basis to get the number of Gauss Xi for.
    INTEGER(INTG), INTENT(IN) :: numberOfGaussXi(:) !<The number of Gauss points in each Xi directions in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisQuadratureNumberOfGaussXiSetObj",err,error,*999)

    CALL BASIS_QUADRATURE_NUMBER_OF_GAUSS_XI_SET(basis%BASIS,numberOfGaussXi,err,error,*999)

    CALL EXITS("CMISSBasisQuadratureNumberOfGaussXiSetObj")
    RETURN
999 CALL ERRORS("CMISSBasisQuadratureNumberOfGaussXiSetObj",err,error)
    CALL EXITS("CMISSBasisQuadratureNumberOfGaussXiSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisQuadratureNumberOfGaussXiSetObj

  !
  !================================================================================================================================
  !

  !>Returns the order of quadrature a basis quadrature identified by a user number.
  SUBROUTINE CMISSBasisQuadratureOrderGetNumber(userNumber,quadratureOrder,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the quadrature order for.
    INTEGER(INTG), INTENT(OUT) :: quadratureOrder !<On return, the order of quadrature in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisQuadratureOrderGetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_QUADRATURE_ORDER_GET(BASIS,quadratureOrder,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSBasisQuadratureOrderGetNumber")
    RETURN
999 CALL ERRORS("CMISSBasisQuadratureOrderGetNumber",err,error)
    CALL EXITS("CMISSBasisQuadratureOrderGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisQuadratureOrderGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the the order of quadrature for a basis quadrature identified by an object.
  SUBROUTINE CMISSBasisQuadratureOrderGetObj(basis,quadratureOrder,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(IN) :: basis !<The basis to get the quadrature order for.
    INTEGER(INTG), INTENT(OUT) :: quadratureOrder !<On return, the order of quadrature in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisQuadratureOrderGetObj",err,error,*999)

    CALL BASIS_QUADRATURE_ORDER_GET(basis%BASIS,quadratureOrder,err,error,*999)

    CALL EXITS("CMISSBasisQuadratureOrderGetObj")
    RETURN
999 CALL ERRORS("CMISSBasisQuadratureOrderGetObj",err,error)
    CALL EXITS("CMISSBasisQuadratureOrderGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisQuadratureOrderGetObj


  !
  !================================================================================================================================
  !

  !>Sets/changes the order of quadrature a basis quadrature identified by a user number.
  SUBROUTINE CMISSBasisQuadratureOrderSetNumber(userNumber,quadratureOrder,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to set the quadrature order for.
    INTEGER(INTG), INTENT(IN) :: quadratureOrder !<The order of quadrature in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisQuadratureOrderSetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_QUADRATURE_ORDER_SET(BASIS,quadratureOrder,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSBasisQuadratureOrderSetNumber")
    RETURN
999 CALL ERRORS("CMISSBasisQuadratureOrderSetNumber",err,error)
    CALL EXITS("CMISSBasisQuadratureOrderSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisQuadratureOrderSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the the order of quadrature for a basis quadrature identified by an object.
  SUBROUTINE CMISSBasisQuadratureOrderSetObj(basis,quadratureOrder,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(INOUT) :: basis !<The basis to set the quadrature order for.
    INTEGER(INTG), INTENT(IN) :: quadratureOrder !<The order of quadrature in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisQuadratureOrderSetObj",err,error,*999)

    CALL BASIS_QUADRATURE_ORDER_SET(basis%BASIS,quadratureOrder,err,error,*999)

    CALL EXITS("CMISSBasisQuadratureOrderSetObj")
    RETURN
999 CALL ERRORS("CMISSBasisQuadratureOrderSetObj",err,error)
    CALL EXITS("CMISSBasisQuadratureOrderSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisQuadratureOrderSetObj

  !
  !================================================================================================================================
  !

  !>Returns the type of quadrature a basis quadrature identified by a user number.
  SUBROUTINE CMISSBasisQuadratureTypeGetNumber(userNumber,quadratureType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the quadrature type for.
    INTEGER(INTG), INTENT(OUT) :: quadratureType !<On return, the type of quadrature in the specified basis. \see OPENCMISS_QuadratureTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisQuadratureTypeGetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_QUADRATURE_TYPE_GET(BASIS,quadratureType,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSBasisQuadratureTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSBasisQuadratureTypeGetNumber",err,error)
    CALL EXITS("CMISSBasisQuadratureTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisQuadratureTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the the type of quadrature for a basis quadrature identified by an object.
  SUBROUTINE CMISSBasisQuadratureTypeGetObj(basis,quadratureType,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(IN) :: basis !<The basis to get the quadrature order for.
    INTEGER(INTG), INTENT(OUT) :: quadratureType !<On return, the type of quadrature in the specified basis. \see OPENCMISS_QuadratureTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisQuadratureTypeGetObj",err,error,*999)

    CALL BASIS_QUADRATURE_TYPE_GET(basis%BASIS,quadratureType,err,error,*999)

    CALL EXITS("CMISSBasisQuadratureTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSBasisQuadratureTypeGetObj",err,error)
    CALL EXITS("CMISSBasisQuadratureTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisQuadratureTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of quadrature a basis quadrature identified by a user number.
  SUBROUTINE CMISSBasisQuadratureTypeSetNumber(userNumber,quadratureType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the quadrature type for.
    INTEGER(INTG), INTENT(IN) :: quadratureType !<The type of quadrature in the specified basis to set. \see OPENCMISS_QuadratureTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisQuadratureTypeSetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_QUADRATURE_TYPE_SET(BASIS,quadratureType,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSBasisQuadratureTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSBasisQuadratureTypeSetNumber",err,error)
    CALL EXITS("CMISSBasisQuadratureTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisQuadratureTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the the type of quadrature for a basis quadrature identified by an object.
  SUBROUTINE CMISSBasisQuadratureTypeSetObj(basis,quadratureType,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(INOUT) :: basis !<The basis to get the quadrature type for.
    INTEGER(INTG), INTENT(OUT) :: quadratureType !<The type of quadrature in the specified basis to set. \see OPENCMISS_QuadratureTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisQuadratureTypeSetObj",err,error,*999)

    CALL BASIS_QUADRATURE_TYPE_SET(basis%BASIS,quadratureType,err,error,*999)

    CALL EXITS("CMISSBasisQuadratureTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSBasisQuadratureTypeSetObj",err,error)
    CALL EXITS("CMISSBasisQuadratureTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisQuadratureTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the local face Gauss scheme calculation, on a basis identified by a user number.
  SUBROUTINE CMISSBasisQuadratureLocalFaceGaussEvaluateSetNumber(userNumber,faceGaussEvaluate,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the quadrature type for.
    LOGICAL, INTENT(IN) :: faceGaussEvaluate !<The value to set face Gauss evaluation flag to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisQuadratureLocalFaceGaussEvaluateSetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_QUADRATURE_LOCAL_FACE_GAUSS_EVALUATE_SET(BASIS,faceGaussEvaluate,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSBasisQuadratureLocalFaceGaussEvaluateSetNumber")
    RETURN
999 CALL ERRORS("CMISSBasisQuadratureLocalFaceGaussEvaluateSetNumber",err,error)
    CALL EXITS("CMISSBasisQuadratureLocalFaceGaussEvaluateSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisQuadratureLocalFaceGaussEvaluateSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the local face Gauss scheme calculation, on a basis identified by an object.
  SUBROUTINE CMISSBasisQuadratureLocalFaceGaussEvaluateSetObj(basis,faceGaussEvaluate,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(INOUT) :: basis !<The basis to get the quadrature type for.
    LOGICAL, INTENT(IN) :: faceGaussEvaluate !<The type of quadrature in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL ENTERS("CMISSBasisQuadratureLocalFaceGaussEvaluateSetObj",err,error,*999)

    CALL BASIS_QUADRATURE_LOCAL_FACE_GAUSS_EVALUATE_SET(basis%BASIS,faceGaussEvaluate,err,error,*999)

    CALL EXITS("CMISSBasisQuadratureLocalFaceGaussEvaluateSetObj")
    RETURN
999 CALL ERRORS("CMISSBasisQuadratureLocalFaceGaussEvaluateSetObj",err,error)
    CALL EXITS("CMISSBasisQuadratureLocalFaceGaussEvaluateSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisQuadratureLocalFaceGaussEvaluateSetObj

  !
  !================================================================================================================================
  !

  !>Returns the type of a basis identified by a user number.
  SUBROUTINE CMISSBasisTypeGetNumber(userNumber,basisType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the type for.
    INTEGER(INTG), INTENT(OUT) :: basisType !<On return, the type of the specified basis. \see OPENCMISS_BasisTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisTypeGetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_TYPE_GET(BASIS,basisType,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSBasisTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSBasisTypeGetNumber",err,error)
    CALL EXITS("CMISSBasisTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the type of a basis identified by an object.
  SUBROUTINE CMISSBasisTypeGetObj(basis,basisType,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(IN) :: basis !<The basis to get the type for.
    INTEGER(INTG), INTENT(OUT) :: basisType !<On return, the type of the specified basis. \see OPENCMISS_BasisTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisTypeGetObj",err,error,*999)

    CALL BASIS_TYPE_GET(basis%BASIS,basisType,err,error,*999)

    CALL EXITS("CMISSBasisTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSBasisTypeGetObj",err,error)
    CALL EXITS("CMISSBasisTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a basis identified by a user number.
  SUBROUTINE CMISSBasisTypeSetNumber(userNumber,basisType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to set the type for.
    INTEGER(INTG), INTENT(IN) :: basisType !<The type of the specified basis to set. \see OPENCMISS_BasisTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasisTypeSetNumber",ERR,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_TYPE_SET(BASIS,basisType,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSBasisTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSBasisTypeSetNumber",err,error)
    CALL EXITS("CMISSBasisTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a basis identified by an object.
  SUBROUTINE CMISSBasisTypeSetObj(basis,basisType,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(INOUT) :: basis !<The basis to set the type for.
    INTEGER(INTG), INTENT(IN) :: basisType !<The type of the specified basis to set. \see OPENCMISS_BasisTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasisTypeSetObj",err,error,*999)

    CALL BASIS_TYPE_SET(basis%BASIS,basisType,err,error,*999)

    CALL EXITS("CMISSBasisTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSBasisTypeSetObj",err,error)
    CALL EXITS("CMISSBasisTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisTypeSetObj


!!==================================================================================================================================
!!
!! BOUNDARY_CONDITIONS_ROUTINES
!!
!!==================================================================================================================================

  !>Destroys the boundary conditions for solver equations identified by a control loop identifier.
  SUBROUTINE CMISSBoundaryConditionsDestroyNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBoundaryConditionsDestroyNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER_EQUATIONS,err,error,*999)
      IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
        CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
        IF(ASSOCIATED(BOUNDARY_CONDITIONS)) THEN
          CALL BOUNDARY_CONDITIONS_DESTROY(BOUNDARY_CONDITIONS,err,error,*999)
        ELSE
          LOCAL_ERROR="Solver equations boundary conditions is not associated."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSBoundaryConditionsDestroyNumber0")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsDestroyNumber0",err,error)
    CALL EXITS("CMISSBoundaryConditionsDestroyNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditionsDestroyNumber0

  !
  !================================================================================================================================
  !

  !>Destroys the boundary conditions for solver equations identified by a control loop identifier.
  SUBROUTINE CMISSBoundaryConditionsDestroyNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBoundaryConditionsDestroyNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
      IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
        CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
        IF(ASSOCIATED(BOUNDARY_CONDITIONS)) THEN
          CALL BOUNDARY_CONDITIONS_DESTROY(BOUNDARY_CONDITIONS,err,error,*999)
        ELSE
          LOCAL_ERROR="Solver equations boundary conditions is not associated."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSBoundaryConditionsDestroyNumber1")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsDestroyNumber1",err,error)
    CALL EXITS("CMISSBoundaryConditionsDestroyNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditionsDestroyNumber1

  !
  !================================================================================================================================
  !

  !>Destroys boundary conditions identified by an object.
  SUBROUTINE CMISSBoundaryConditionsDestroyObj(boundaryConditions,err)

    !Argument variables
    TYPE(CMISSBoundaryConditionsType), INTENT(INOUT) :: boundaryConditions !<The boundary conditions to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBoundaryConditionsDestroyObj",err,error,*999)

    CALL BOUNDARY_CONDITIONS_DESTROY(boundaryConditions%BOUNDARY_CONDITIONS,err,error,*999)

    CALL EXITS("CMISSBoundaryConditionsDestroyObj")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsDestroyObj",err,error)
    CALL EXITS("CMISSBoundaryConditionsDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditionsDestroyObj

  !
  !================================================================================================================================
  !

  !>Adds to the value of the specified constant and sets this as a boundary condition on the specified constant for boundary conditions identified by a user number.
  SUBROUTINE CMISSBoundaryConditionsAddConstantNumber(regionUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & fieldUserNumber,variableType,componentNumber,condition,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the dependent field to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to add the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to add the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditions,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBoundaryConditionsAddConstantNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    NULLIFY(DEPENDENT_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
      IF(ASSOCIATED(PROBLEM)) THEN
        CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
        IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
          CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
          IF(ASSOCIATED(BOUNDARY_CONDITIONS)) THEN
            CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,DEPENDENT_FIELD,err,error,*999)
            IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
              CALL BOUNDARY_CONDITIONS_ADD_CONSTANT(BOUNDARY_CONDITIONS,DEPENDENT_FIELD,variableType,componentNumber, &
                & condition,value,err,error,*999)
            ELSE
              LOCAL_ERROR="A field with a user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
                & " does not exist."
              CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
            ENDIF
          ELSE
            CALL FLAG_ERROR("The solver equations boundary conditions are not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FLAG_ERROR("The solver equations are not associated.",err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A problem with a user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSBoundaryConditionsAddConstantNumber")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsAddConstantNumber",err,error)
    CALL EXITS("CMISSBoundaryConditionsAddConstantNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditionsAddConstantNumber

  !
  !================================================================================================================================
  !

  !>Adds to the value of the specified constant and sets this as a boundary condition on the specified constant for boundary conditions identified by an object.
  SUBROUTINE CMISSBoundaryConditionsAddConstantObj(boundaryConditions,field,variableType,componentNumber,condition,value,err)

    !Argument variables
    TYPE(CMISSBoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to add the constant to.
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to set the boundary condition on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditions,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBoundaryConditionsAddConstantObj",err,error,*999)

    CALL BOUNDARY_CONDITIONS_ADD_CONSTANT(boundaryConditions%BOUNDARY_CONDITIONS,field%FIELD,variableType,componentNumber, &
      & condition,value,err,error,*999)

    CALL EXITS("CMISSBoundaryConditionsAddConstantObj")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsAddConstantObj",err,error)
    CALL EXITS("CMISSBoundaryConditionsAddConstantObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditionsAddConstantObj

  !
  !================================================================================================================================
  !


  !>Sets the value of the specified constant as a boundary condition on the specified constant for boundary conditions identified by a user number.
  SUBROUTINE CMISSBoundaryConditionsSetConstantNumber(regionUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & variableType,fieldUserNumber,componentNumber,condition,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditions,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBoundaryConditionsSetConstantNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    NULLIFY(DEPENDENT_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
      IF(ASSOCIATED(PROBLEM)) THEN
        CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
        IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
          CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
          IF(ASSOCIATED(BOUNDARY_CONDITIONS)) THEN
            CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,DEPENDENT_FIELD,err,error,*999)
            IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
              CALL BOUNDARY_CONDITIONS_SET_CONSTANT(BOUNDARY_CONDITIONS,DEPENDENT_FIELD,variableType,componentNumber, &
                & condition,value,err,error,*999)
            ELSE
              LOCAL_ERROR="A field with a user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
                & " does not exist."
              CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
            ENDIF
          ELSE
            CALL FLAG_ERROR("The solver equations boundary conditions are not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FLAG_ERROR("The solver equations are not associated.",err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A problem with a user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSBoundaryConditionsSetConstantNumber")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsSetConstantNumber",err,error)
    CALL EXITS("CMISSBoundaryConditionsSetConstantNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditionsSetConstantNumber

  !
  !================================================================================================================================
  !

  !>Sets the value of the specified constant and sets this as a boundary condition on the specified constant for boundary conditions identified by an object.
  SUBROUTINE CMISSBoundaryConditionsSetConstantObj(boundaryConditions,field,variableType,componentNumber,condition,value,err)

    !Argument variables
    TYPE(CMISSBoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to set the constant to.
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to set the boundary condition on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditions,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBoundaryConditionsSetConstantObj",ERR,error,*999)

    CALL BOUNDARY_CONDITIONS_SET_CONSTANT(boundaryConditions%BOUNDARY_CONDITIONS,field%FIELD,variableType,componentNumber, &
      & condition,value,err,error,*999)

    CALL EXITS("CMISSBoundaryConditionsSetConstantObj")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsSetConstantObj",err,error)
    CALL EXITS("CMISSBoundaryConditionsSetConstantObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditionsSetConstantObj

  !
  !================================================================================================================================
  !

  !>Adds the value to the specified element and sets this as a boundary condition on the specified element for boundary conditions identified by a user number.
  SUBROUTINE CMISSBoundaryConditionsAddElementNumber(regionUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & fieldUserNumber,variableType,elementUserNumber,componentNumber,condition,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to add the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to add the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditions,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBoundaryConditionsAddElementNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    NULLIFY(DEPENDENT_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
      IF(ASSOCIATED(PROBLEM)) THEN
        CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
        IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
          CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
          IF(ASSOCIATED(BOUNDARY_CONDITIONS)) THEN
            CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,DEPENDENT_FIELD,err,error,*999)
            IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
              CALL BOUNDARY_CONDITIONS_ADD_ELEMENT(BOUNDARY_CONDITIONS,DEPENDENT_FIELD,variableType,elementUserNumber, &
                & componentNumber,condition,value,err,error,*999)
            ELSE
              LOCAL_ERROR="A field with a user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
                & " does not exist."
              CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
            ENDIF
          ELSE
            CALL FLAG_ERROR("The solver equations boundary conditions are not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FLAG_ERROR("The solver equations are not associated.",err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A problem with a user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSBoundaryConditionsAddElementNumber")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsAddElementNumber",err,error)
    CALL EXITS("CMISSBoundaryConditionsAddElementNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditionsAddElementNumber

  !
  !================================================================================================================================
  !

  !>Adds to the value of the specified element and sets this as a boundary condition on the specified element for boundary conditions identified by an object.
  SUBROUTINE CMISSBoundaryConditionsAddElementObj(boundaryConditions,field,variableType,elementUserNumber,componentNumber, &
    & condition,value,err)

    !Argument variables
    TYPE(CMISSBoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to add the element to.
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to set the boundary condition on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to add the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditions,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBoundaryConditionsAddElementObj",err,error,*999)

    CALL BOUNDARY_CONDITIONS_ADD_ELEMENT(boundaryConditions%BOUNDARY_CONDITIONS,field%FIELD,variableType,elementUserNumber, &
      & componentNumber,condition,value,err,error,*999)

    CALL EXITS("CMISSBoundaryConditionsAddElementObj")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsAddElementObj",err,error)
    CALL EXITS("CMISSBoundaryConditionsAddElementObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditionsAddElementObj

  !
  !================================================================================================================================
  !

  !>Sets the value of the specified element as a boundary condition on the specified element for boundary conditions identified by a user number.
  SUBROUTINE CMISSBoundaryConditionsSetElementNumber(regionUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & fieldUserNumber,variableType,elementUserNumber,componentNumber,condition,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditions,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBoundaryConditionsSetElementNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    NULLIFY(DEPENDENT_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
      IF(ASSOCIATED(PROBLEM)) THEN
        CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
        IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
          CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
          IF(ASSOCIATED(BOUNDARY_CONDITIONS)) THEN
            CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,DEPENDENT_FIELD,err,error,*999)
            IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
              CALL BOUNDARY_CONDITIONS_SET_ELEMENT(BOUNDARY_CONDITIONS,DEPENDENT_FIELD,variableType,elementUserNumber, &
                & componentNumber,condition,value,err,error,*999)
            ELSE
              LOCAL_ERROR="A field with a user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
                & " does not exist."
              CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
            ENDIF
          ELSE
            CALL FLAG_ERROR("The solver equations boundary conditions are not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FLAG_ERROR("The solver equations are not associated.",err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A problem with a user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSBoundaryConditionsSetElementNumber")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsSetElementNumber",err,error)
    CALL EXITS("CMISSBoundaryConditionsSetElementNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditionsSetElementNumber

  !
  !================================================================================================================================
  !

  !>Sets the value of the specified element and sets this as a boundary condition on the specified elements for boundary conditions identified by an object.
  SUBROUTINE CMISSBoundaryConditionsSetElementObj(boundaryConditions,field,variableType,elementUserNumber,componentNumber, &
    & condition,value,err)

    !Argument variables
    TYPE(CMISSBoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to set the element to.
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to set the boundary condition on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditions,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBoundaryConditionsSetElementObj",err,error,*999)

    CALL BOUNDARY_CONDITIONS_SET_ELEMENT(boundaryConditions%BOUNDARY_CONDITIONS,field%FIELD,variableType,elementUserNumber, &
      & componentNumber,condition,value,err,error,*999)

    CALL EXITS("CMISSBoundaryConditionsSetElementObj")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsSetElementObj",err,error)
    CALL EXITS("CMISSBoundaryConditionsSetElementObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditionsSetElementObj

  !
  !================================================================================================================================
  !

  !>Adds the value to the specified node and sets this as a boundary condition on the specified node for boundary conditions identified by a user number.
  SUBROUTINE CMISSBoundaryConditionsAddNodeNumber(regionUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & fieldUserNumber,variableType,versionNumber,derivativeNumber,nodeUserNumber,componentNumber,condition,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to add the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to add the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditions,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBoundaryConditionsAddNodeNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    NULLIFY(DEPENDENT_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
      IF(ASSOCIATED(PROBLEM)) THEN
        CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
        IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
          CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
          IF(ASSOCIATED(BOUNDARY_CONDITIONS)) THEN
            CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,DEPENDENT_FIELD,err,error,*999)
            IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
              CALL BOUNDARY_CONDITIONS_ADD_NODE(BOUNDARY_CONDITIONS,DEPENDENT_FIELD,variableType,versionNumber,derivativeNumber, &
                & nodeUserNumber,componentNumber,condition,value,err,error,*999)
            ELSE
              LOCAL_ERROR="A field with a user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
                & " does not exist."
              CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
            ENDIF
          ELSE
            CALL FLAG_ERROR("The solver equations boundary conditions are not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FLAG_ERROR("The solver equations are not associated.",err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A problem with a user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSBoundaryConditionsAddNodeNumber")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsAddNodeNumber",err,error)
    CALL EXITS("CMISSBoundaryConditionsAddNodeNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditionsAddNodeNumber

  !
  !================================================================================================================================
  !

  !>Adds to the value of the specified node and sets this as a boundary condition on the specified node for boundary conditions identified by an object.
  SUBROUTINE CMISSBoundaryConditionsAddNodeObj(boundaryConditions,field,variableType,versionNumber,derivativeNumber, &
      & nodeUserNumber,componentNumber,condition,value,err)

    !Argument variables
    TYPE(CMISSBoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to add the node to.
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to set the boundary condition on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to add the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditions,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBoundaryConditionsAddNodeObj",err,error,*999)

    CALL BOUNDARY_CONDITIONS_ADD_NODE(boundaryConditions%BOUNDARY_CONDITIONS,field%FIELD,variableType,versionNumber, &
      & derivativeNumber,nodeUserNumber,componentNumber,condition,value,err,error,*999)

    CALL EXITS("CMISSBoundaryConditionsAddNodeObj")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsAddNodeObj",err,error)
    CALL EXITS("CMISSBoundaryConditionsAddNodeObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditionsAddNodeObj

  !
  !================================================================================================================================
  !

  !>Sets the value of the specified node as a boundary condition on the specified node for boundary conditions identified by a user number.
  SUBROUTINE CMISSBoundaryConditionsSetNodeNumber0(regionUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & fieldUserNumber,variableType,versionNumber,derivativeNumber,nodeUserNumber,componentNumber,condition,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditions,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBoundaryConditionsSetNodeNumber0",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    NULLIFY(DEPENDENT_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
      IF(ASSOCIATED(PROBLEM)) THEN
        CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER_EQUATIONS,err,error,*999)
        IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
          CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
          IF(ASSOCIATED(BOUNDARY_CONDITIONS)) THEN
            CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,DEPENDENT_FIELD,err,error,*999)
            IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
              CALL BOUNDARY_CONDITIONS_SET_NODE(BOUNDARY_CONDITIONS,DEPENDENT_FIELD,variableType,versionNumber,derivativeNumber, &
                & nodeUserNumber,componentNumber,condition,value,err,error,*999)
            ELSE
              LOCAL_ERROR="A field with a user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
                & " does not exist."
              CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
            ENDIF
          ELSE
            CALL FLAG_ERROR("The solver equations boundary conditions are not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FLAG_ERROR("The solver equations are not associated.",err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A problem with a user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSBoundaryConditionsSetNodeNumber0")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsSetNodeNumber0",err,error)
    CALL EXITS("CMISSBoundaryConditionsSetNodeNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditionsSetNodeNumber0

  !
  !================================================================================================================================
  !

  !>Sets the value of the specified node as a boundary condition on the specified node for boundary conditions identified by a user number.
  SUBROUTINE CMISSBoundaryConditionsSetNodeNumber1(regionUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & fieldUserNumber,variableType,versionNumber,derivativeNumber,nodeUserNumber,componentNumber,condition,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditions,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBoundaryConditionsSetNodeNumber1",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    NULLIFY(DEPENDENT_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
      IF(ASSOCIATED(PROBLEM)) THEN
        CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
        IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
          CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
          IF(ASSOCIATED(BOUNDARY_CONDITIONS)) THEN
            CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,DEPENDENT_FIELD,err,error,*999)
            IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
              CALL BOUNDARY_CONDITIONS_SET_NODE(BOUNDARY_CONDITIONS,DEPENDENT_FIELD,variableType,versionNumber,derivativeNumber, &
                & nodeUserNumber,componentNumber,condition,value,err,error,*999)
            ELSE
              LOCAL_ERROR="A field with a user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
                & " does not exist."
              CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
            ENDIF
          ELSE
            CALL FLAG_ERROR("The solver equations boundary conditions are not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FLAG_ERROR("The solver equations are not associated.",err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A problem with a user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSBoundaryConditionsSetNodeNumber1")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsSetNodeNumber1",err,error)
    CALL EXITS("CMISSBoundaryConditionsSetNodeNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditionsSetNodeNumber1

  !
  !================================================================================================================================
  !

  !>Sets the value of the specified node and sets this as a boundary condition on the specified node for boundary conditions identified by an object.
  SUBROUTINE CMISSBoundaryConditionsSetNodeObj(boundaryConditions,field,variableType,versionNumber,derivativeNumber, &
    & nodeUserNumber,componentNumber,condition,value,err)

    !Argument variables
    TYPE(CMISSBoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to set the node to.
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to set the boundary condition on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditions,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBoundaryConditionsSetNodeObj",err,error,*999)

    CALL BOUNDARY_CONDITIONS_SET_NODE(boundaryConditions%BOUNDARY_CONDITIONS,field%FIELD,variableType,versionNumber, &
      & derivativeNumber,nodeUserNumber,componentNumber,condition,value,err,error,*999)

    CALL EXITS("CMISSBoundaryConditionsSetNodeObj")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsSetNodeObj",err,error)
    CALL EXITS("CMISSBoundaryConditionsSetNodeObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditionsSetNodeObj

  !
  !================================================================================================================================
  !

  !>Sets the value of the specified dof as a boundary condition on the specified dof for boundary conditions identified by a user number.
  SUBROUTINE CMISSBoundaryConditionsAddDOFToBoundaryNumber(regionUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & fieldUserNumber,variableType,dOFNumber,value,condition,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to add the boundary condition for.
    INTEGER(INTG), INTENT(IN) :: dOFNumber(:) !<The global number of the dof to add the boundary conditions for.
    REAL(DP), INTENT(IN) :: value(:) !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(IN) :: condition(:) !<The boundary condition type to set \see OPENCMISS_BoundaryConditions,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBoundaryConditionsAddDOFToBoundaryNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    NULLIFY(DEPENDENT_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
      IF(ASSOCIATED(PROBLEM)) THEN
        CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
        IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
          CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
          IF(ASSOCIATED(BOUNDARY_CONDITIONS)) THEN
            CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,DEPENDENT_FIELD,err,error,*999)
            IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
              CALL BOUNDARY_CONDITIONS_BOUNDARY_ADD_DOF(BOUNDARY_CONDITIONS,DEPENDENT_FIELD,variableType,dOFNumber,value, &
                & condition,err,error,*999)
            ELSE
              LOCAL_ERROR="A field with a user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
                & " does not exist."
              CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
            ENDIF
          ELSE
            CALL FLAG_ERROR("The solver equations boundary conditions are not associated.",err,error,*999)
          ENDIF
        ELSE
          CALL FLAG_ERROR("The solver equations are not associated.",err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A problem with a user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSBoundaryConditionsAddDOFToBoundaryNumber")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsAddDOFToBoundaryNumber",err,error)
    CALL EXITS("CMISSBoundaryConditionsAddDOFToBoundaryNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditionsAddDOFToBoundaryNumber

  !
  !================================================================================================================================
  !

  !>Sets the value of the specified dof and sets this as a boundary condition on the specified dof for boundary conditions identified by an object.
  SUBROUTINE CMISSBoundaryConditionsAddDOFToBoundaryObj(boundaryConditions,field,variableType,dOFNumber,value,condition,err)

    !Argument variables
    TYPE(CMISSBoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to add the node to.
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to set the boundary condition on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: dOFNumber(:) !<The number of the dof to set the boundary conditions for.
    REAL(DP), INTENT(IN) :: value(:) !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(IN) :: condition(:) !<The boundary condition type to set \see OPENCMISS_BoundaryConditions,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBoundaryConditionsAddDOFToBoundaryObj",err,error,*999)

    CALL BOUNDARY_CONDITIONS_BOUNDARY_ADD_DOF(boundaryConditions%BOUNDARY_CONDITIONS,field%FIELD,variableType,dOFNumber,value,&
       & condition,err,error,*999)

    CALL EXITS("CMISSBoundaryConditionsAddDOFToBoundaryObj")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditionsAddDOFToBoundaryObj",err,error)
    CALL EXITS("CMISSBoundaryConditionsAddDOFToBoundaryObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditionsAddDOFToBoundaryObj

!!==================================================================================================================================
!!
!! CMISS
!!
!!==================================================================================================================================

  !>Returns the error handling mode for OpenCMISS
  SUBROUTINE CMISSErrorHandlingModeGet(errorHandlingMode,err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: errorHandlingMode !<On return, the error handling mode. \see OPENCMISS_CMISSErrorHandlingModes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSErrorHandlingModeGet",err,error,*999)

    CALL CMISS_ERROR_HANDLING_MODE_GET(errorHandlingMode,err,error,*999)

    CALL EXITS("CMISSErrorHandlingModeGet")
    RETURN
999 CALL ERRORS("CMISSErrorHandlingModeGet",err,error)
    CALL EXITS("CMISSErrorHandlingModeGet")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSErrorHandlingModeGet

  !
  !================================================================================================================================
  !

  !>Sets the error handling mode for OpenCMISS
  SUBROUTINE CMISSErrorHandlingModeSet(errorHandlingMode,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: errorHandlingMode !<The error handling mode to set. \see OPENCMISS_CMISSErrorHandlingModes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSErrorHandlingModeSet",err,error,*999)

    CALL CMISS_ERROR_HANDLING_MODE_SET(errorHandlingMode,err,error,*999)

    CALL EXITS("CMISSErrorHandlingModeSet")
    RETURN
999 CALL ERRORS("CMISSErrorHandlingModeSet",err,error)
    CALL EXITS("CMISSErrorHandlingModeSet")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSErrorHandlingModeSet

  !
  !================================================================================================================================
  !

  !>Extracts the most recent error string for OpenCMISS
  SUBROUTINE CMISSExtractErrorMessageC(errorMessage,err)

    !Argument variables
    CHARACTER(LEN=*), INTENT(OUT) :: errorMessage !<On return, the extracted error message.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL EXTRACT_ERROR_MESSAGE(errorMessage,err,error,*999)

    RETURN
999 RETURN 1

  END SUBROUTINE CMISSExtractErrorMessageC

  !
  !================================================================================================================================
  !

  !>Extracts the most recent error string for OpenCMISS
  SUBROUTINE CMISSExtractErrorMessageVS(errorMessage,err)

    !Argument variables
    TYPE(VARYING_STRING), INTENT(OUT) :: errorMessage !<On return, the extracted error message.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL EXTRACT_ERROR_MESSAGE(errorMessage,err,error,*999)

    RETURN
999 RETURN 1

  END SUBROUTINE CMISSExtractErrorMessageVS

  !
  !================================================================================================================================
  !

  !>Returns the random seeds for OpenCMISS
  SUBROUTINE CMISSRandomSeedsGet0(randomSeed,err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: randomSeed !<On return, the random seed.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: RandomSeeds(1)

    CALL ENTERS("CMISSRandomSeedsGet0",err,error,*999)

    CALL RANDOM_SEEDS_GET(RandomSeeds,err,error,*999)
    randomSeed=RandomSeeds(1)

    CALL EXITS("CMISSRandomSeedsGet0")
    RETURN
999 CALL ERRORS("CMISSRandomSeedsGet0",err,error)
    CALL EXITS("CMISSRandomSeedsGet0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRandomSeedsGet0

  !
  !================================================================================================================================
  !

  !>Returns the random seeds for OpenCMISS
  SUBROUTINE CMISSRandomSeedsGet1(randomSeeds,err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: randomSeeds(:) !<On return, the random seeds.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRandomSeedsGet1",err,error,*999)

    CALL RANDOM_SEEDS_GET(randomSeeds,err,error,*999)

    CALL EXITS("CMISSRandomSeedsGet1")
    RETURN
999 CALL ERRORS("CMISSRandomSeedsGet1",err,error)
    CALL EXITS("CMISSRandomSeedsGet1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRandomSeedsGet1

  !
  !================================================================================================================================
  !

  !>Returns the size of the random seeds array for OpenCMISS
  SUBROUTINE CMISSRandomSeedsSizeGet(randomSeedsSize,err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: randomSeedsSize !<On return, the size of the random seeds array.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRandomSeedsSizeGet",err,error,*999)

    CALL RANDOM_SEEDS_SIZE_GET(randomSeedsSize,err,error,*999)

    CALL EXITS("CMISSRandomSeedsSizeGet")
    RETURN
999 CALL ERRORS("CMISSRandomSeedsSizeGet",err,error)
    CALL EXITS("CMISSRandomSeedsSizeGet")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRandomSeedsSizeGet

  !
  !================================================================================================================================
  !

  !>Sets the random seeds for OpenCMISS
  SUBROUTINE CMISSRandomSeedsSet0(randomSeed,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: randomSeed !<The random seed to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRandomSeedsSet0",err,error,*999)

    CALL RANDOM_SEEDS_SET([randomSeed],err,error,*999)

    CALL EXITS("CMISSRandomSeedsSet0")
    RETURN
999 CALL ERRORS("CMISSRandomSeedsSet0",err,error)
    CALL EXITS("CMISSRandomSeedsSet0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRandomSeedsSet0

  !
  !================================================================================================================================
  !

  !>Sets the random seeds for OpenCMISS
  SUBROUTINE CMISSRandomSeedsSet1(randomSeeds,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: randomSeeds(:) !<The random seeds to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRandomSeedsSet1",err,error,*999)

    CALL RANDOM_SEEDS_SET(randomSeeds,err,error,*999)

    CALL EXITS("CMISSRandomSeedsSet1")
    RETURN
999 CALL ERRORS("CMISSRandomSeedsSet1",err,error)
    CALL EXITS("CMISSRandomSeedsSet1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRandomSeedsSet1

!!==================================================================================================================================
!!
!! CMISS_CELLML
!!
!!==================================================================================================================================

  !>Sets a CellML model variable to be known by user number.
  SUBROUTINE CMISSCellMLVariableSetAsKnownNumberC(regionUserNumber,CellMLUserNumber,CellMLModelUserNumber,variableID,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The CellML variable to set as known (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLVariableSetAsKnownNumberC",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_VARIABLE_SET_AS_KNOWN(CELLML,CellMLModelUserNumber,variableID,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCellMLVariableSetAsKnownNumberC")
    RETURN
999 CALL ERRORS("CMISSCellMLVariableSetAsKnownNumberC",err,error)
    CALL EXITS("CMISSCellMLVariableSetAsKnownNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLVariableSetAsKnownNumberC

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be known by object.
  SUBROUTINE CMISSCellMLVariableSetAsKnownObjC(CellML,CellMLModelUserNumber,variableID,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(IN) :: CellML !<The CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The CellML variable to set as known (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLVariableSetAsKnownObjC",err,error,*999)

    CALL CELLML_VARIABLE_SET_AS_KNOWN(CellML%CELLML,CellMLModelUserNumber,variableID,err,error,*999)

    CALL EXITS("CMISSCellMLVariableSetAsKnownObjC")
    RETURN
999 CALL ERRORS("CMISSCellMLVariableSetAsKnownObjC",err,error)
    CALL EXITS("CMISSCellMLVariableSetAsKnownObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLVariableSetAsKnownObjC

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be known by user number.
  SUBROUTINE CMISSCellMLVariableSetAsKnownNumberVS(regionUserNumber,CellMLUserNumber,CellMLModelUserNumber,variableID,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The CellML variable to set as known (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLVariableSetAsKnownNumberVS",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_VARIABLE_SET_AS_KNOWN(CELLML,CellMLModelUserNumber,variableID,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCellMLVariableSetAsKnownNumberVS")
    RETURN
999 CALL ERRORS("CMISSCellMLVariableSetAsKnownNumberVS",err,error)
    CALL EXITS("CMISSCellMLVariableSetAsKnownNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLVariableSetAsKnownNumberVS

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be known by object.
  SUBROUTINE CMISSCellMLVariableSetAsKnownObjVS(CellML,CellMLModelUserNumber,variableID,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(IN) :: CellML !<The CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The CellML variable to set as known (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLVariableSetAsKnownObjVS",err,error,*999)

    CALL CELLML_VARIABLE_SET_AS_KNOWN(CellML%CELLML,CellMLModelUserNumber,variableID,err,error,*999)

    CALL EXITS("CMISSCellMLVariableSetAsKnownObjVS")
    RETURN
999 CALL ERRORS("CMISSCellMLVariableSetAsKnownObjVS",err,error)
    CALL EXITS("CMISSCellMLVariableSetAsKnownObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLVariableSetAsKnownObjVS

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be wanted by user number.
  SUBROUTINE CMISSCellMLVariableSetAsWantedNumberC(regionUserNumber,CellMLUserNumber,CellMLModelUserNumber,variableID,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The CellML variable to set as wanted (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLVariableSetAsWantedNumberC",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_VARIABLE_SET_AS_WANTED(CELLML,CellMLModelUserNumber,variableID,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCellMLVariableSetAsWantedNumberC")
    RETURN
999 CALL ERRORS("CMISSCellMLVariableSetAsWantedNumberC",err,error)
    CALL EXITS("CMISSCellMLVariableSetAsWantedNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLVariableSetAsWantedNumberC

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be wanted by object.
  SUBROUTINE CMISSCellMLVariableSetAsWantedObjC(CellML,CellMLModelUserNumber,variableID,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(IN) :: CellML !<The CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The CellML variable to set as wanted (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLVariableSetAsWantedObjC",err,error,*999)

    CALL CELLML_VARIABLE_SET_AS_WANTED(CellML%CELLML,CellMLModelUserNumber,variableID,err,error,*999)

    CALL EXITS("CMISSCellMLVariableSetAsWantedObjC")
    RETURN
999 CALL ERRORS("CMISSCellMLVariableSetAsWantedObjC",err,error)
    CALL EXITS("CMISSCellMLVariableSetAsWantedObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLVariableSetAsWantedObjC

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be wanted by user number.
  SUBROUTINE CMISSCellMLVariableSetAsWantedNumberVS(regionUserNumber,CellMLUserNumber,CellMLModelUserNumber,variableID,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The CellML variable to set as wanted (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLVariableSetAsWantedNumberVS",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_VARIABLE_SET_AS_WANTED(CELLML,CellMLModelUserNumber,variableID,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCellMLVariableSetAsWantedNumberVS")
    RETURN
999 CALL ERRORS("CMISSCellMLVariableSetAsWantedNumberVS",err,error)
    CALL EXITS("CMISSCellMLVariableSetAsWantedNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLVariableSetAsWantedNumberVS

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be wanted by object.
  SUBROUTINE CMISSCellMLVariableSetAsWantedObjVS(CellML,CellMLModelUserNumber,variableID,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(IN) :: CellML !<The CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The CellML variable to set as wanted (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLVariableSetAsWantedObjVS",err,error,*999)

    CALL CELLML_VARIABLE_SET_AS_WANTED(CellML%CELLML,CellMLModelUserNumber,variableID,err,error,*999)

    CALL EXITS("CMISSCellMLVariableSetAsWantedObjVS")
    RETURN
999 CALL ERRORS("CMISSCellMLVariableSetAsWantedObjVS",err,error)
    CALL EXITS("CMISSCellMLVariableSetAsWantedObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLVariableSetAsWantedObjVS

  !
  !================================================================================================================================
  !

  !>Defines a CellML model variable to field variable component map by user number
  SUBROUTINE CMISSCellMLCreateCellMLToFieldMapNumberC(regionUserNumber,CellMLUserNumber,CellMLModelUserNumber,variableID, &
    & CellMLParameterSet,fieldUserNumber,variableType,componentNumber,fieldParameterSet,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map fom.
    INTEGER(INTG), INTENT(IN) :: CellMLParameterSet !<The CellML variable parameter set to map from.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The of the CellML variable in the given model to map from.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to map to
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to map to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to map to.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLCreateCellMLToFieldMapNumberC",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
        IF(ASSOCIATED(FIELD)) THEN
          CALL CELLML_CREATE_CELLML_TO_FIELD_MAP(CELLML,CellMLModelUserNumber,variableID,CellMLParameterSet, &
            & FIELD,variableType,componentNumber,fieldParameterSet,err,error,*999)
        ELSE
          LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
            & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCellMLCreateCellMLToFieldMapNumberC")
    RETURN
999 CALL ERRORS("CMISSCellMLCreateCellMLToFieldMapNumberC",err,error)
    CALL EXITS("CMISSCellMLCreateCellMLToFieldMapNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLCreateCellMLToFieldMapNumberC

  !
  !================================================================================================================================
  !

  !>Defines a CellML model variable to field variable component map by object.
  SUBROUTINE CMISSCellMLCreateCellMLToFieldMapObjC(CellML, CellMLModelUserNumber,variableID,CellMLParameterSet, &
    & field,variableType,componentNumber,fieldParameterSet,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(IN) :: CellML !<The CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map from.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The of the CellML variable in the given model to map from.
    INTEGER(INTG), INTENT(IN) :: CellMLParameterSet !<The CellML variable parameter set to map from.
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to map to.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to map to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLCreateCellMLToFieldMapObjC",err,error,*999)

    CALL CELLML_CREATE_CELLML_TO_FIELD_MAP(CellML%CELLML,CellMLModelUserNumber,variableID,CellMLParameterSet, &
      & field%FIELD,variableType,componentNumber,fieldParameterSet,err,error,*999)

    CALL EXITS("CMISSCellMLCreateCellMLToFieldMapObjC")
    RETURN
999 CALL ERRORS("CMISSCellMLCreateCellMLToFieldMapObjC",err,error)
    CALL EXITS("CMISSCellMLCreateCellMLToFieldMapObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLCreateCellMLToFieldMapObjC

  !
  !================================================================================================================================
  !

  !>Defines a CellML model variable to field variable component map by user number
  SUBROUTINE CMISSCellMLCreateCellMLToFieldMapNumberVS(regionUserNumber,CellMLUserNumber,CellMLModelUserNumber,variableID, &
    & CellMLParameterSet,fieldUserNumber,variableType,componentNumber,fieldParameterSet,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map from.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The CellML variable ID in the given model to map from.
    INTEGER(INTG), INTENT(IN) :: CellMLParameterSet !<The CellML variable parameter set to map from.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to map to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to map to.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLCreateCellMLToFieldMapNumberVS",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
        IF(ASSOCIATED(FIELD)) THEN
          CALL CELLML_CREATE_CELLML_TO_FIELD_MAP(CELLML,CellMLModelUserNumber,variableID,CellMLParameterSet, &
            & FIELD,variableType,componentNumber,fieldParameterSet,err,error,*999)
        ELSE
          LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
            & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCellMLCreateCellMLToFieldMapNumberVS")
    RETURN
999 CALL ERRORS("CMISSCellMLCreateCellMLToFieldMapNumberVS",err,error)
    CALL EXITS("CMISSCellMLCreateCellMLToFieldMapNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLCreateCellMLToFieldMapNumberVS

  !
  !================================================================================================================================
  !

  !>Defines a field variable component to CellML model variable map, by object.
  SUBROUTINE CMISSCellMLCreateCellMLToFieldMapObjVS(CellML,CellMLModelUserNumber,variableID,CellMLParameterSet, &
    & field,variableType,componentNumber,fieldParameterSet,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(IN) :: CellML !<The CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map from.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The of the CellML variable in the given model to map from.
    INTEGER(INTG), INTENT(IN) :: CellMLParameterSet !<The CellML variable parameter set to map from.
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to map to.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to map to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to map to.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLCreateCellMLToFieldMapNumberVS",err,error,*999)

    CALL CELLML_CREATE_CELLML_TO_FIELD_MAP(CellML%CELLML,CellMLModelUserNumber,variableID,CellMLParameterSet, &
      & field%FIELD,variableType,componentNumber,fieldParameterSet,err,error,*999)

    CALL EXITS("CMISSCellMLCreateCellMLToFieldMapObjVS")
    RETURN
999 CALL ERRORS("CMISSCellMLCreateCellMLToFieldMapObjVS",err,error)
    CALL EXITS("CMISSCellMLCreateCellMLToFieldMapObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLCreateCellMLToFieldMapObjVS

  !
  !================================================================================================================================
  !

  !>Defines a field variable component to CellML model variable map by user number.
  SUBROUTINE CMISSCellMLCreateFieldToCellMLMapNumberC(regionUserNumber,CellMLUserNumber,fieldUserNumber,variableType, &
    & componentNumber,fieldParameterSet,CellMLModelUserNumber,variableID,CellMLParameterSet,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to map from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to map from.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to map from.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map from.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map to.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The of the CellML variable in the given model to map to.
    INTEGER(INTG), INTENT(IN) :: CellMLParameterSet !<The CellML variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLCreateFieldToCellMLMapNumberC",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
        IF(ASSOCIATED(FIELD)) THEN
          CALL CELLML_CREATE_FIELD_TO_CELLML_MAP(CELLML,FIELD,variableType,componentNumber,fieldParameterSet, &
            & CellMLModelUserNumber,variableID,CellMLParameterSet,err,error,*999)
        ELSE
          LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
            & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCellMLCreateFieldToCellMLMapNumberC")
    RETURN
999 CALL ERRORS("CMISSCellMLCreateFieldToCellMLMapNumberC",err,error)
    CALL EXITS("CMISSCellMLCreateFieldToCellMLMapNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLCreateFieldToCellMLMapNumberC

  !
  !================================================================================================================================
  !

  !>Defines a field variable component to CellML model variable map by object.
  SUBROUTINE CMISSCellMLCreateFieldToCellMLMapObjC(CellML,field,variableType,componentNumber,fieldParameterSet, &
    & CellMLModelUserNumber,variableID,CellMLParameterSet,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(IN) :: CellML !<The CellML enviroment.
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to map from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable to map from.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number to map from the given field variable.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map from.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map to.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The of the CellML variable in the given model to map to.
    INTEGER(INTG), INTENT(IN) :: CellMLParameterSet !<The CellML variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLCreateFieldToCellMLMapObjC",err,error,*999)

    CALL CELLML_CREATE_FIELD_TO_CELLML_MAP(CellML%CELLML,field%FIELD,variableType,componentNumber,fieldParameterSet, &
      & CellMLModelUserNumber,variableID,CellMLParameterSet,err,error,*999)

    CALL EXITS("CMISSCellMLCreateFieldToCellMLMapObjC")
    RETURN
999 CALL ERRORS("CMISSCellMLCreateFieldToCellMLMapObjC",err,error)
    CALL EXITS("CMISSCellMLCreateFieldToCellMLMapObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLCreateFieldToCellMLMapObjC

  !
  !================================================================================================================================
  !

  !>Defines a field variable component to CellML model variable map by user number
  SUBROUTINE CMISSCellMLCreateFieldToCellMLMapNumberVS(regionUserNumber,CellMLUserNumber,fieldUserNumber,variableType, &
    & fieldParameterSet,componentNumber,CellMLModelUserNumber,variableID,CellMLParameterSet,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to map from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable to map from.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to map from.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map from.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map to.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The of the CellML variable in the given model to map to.
    INTEGER(INTG), INTENT(IN) :: CellMLParameterSet !<The CellML variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLCreateFieldToCellMLMapNumberVS",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
        IF(ASSOCIATED(FIELD)) THEN
          CALL CELLML_CREATE_FIELD_TO_CELLML_MAP(CELLML,FIELD,variableType,componentNumber,fieldParameterSet, &
            & CellMLModelUserNumber,variableID,CellMLParameterSet,err,error,*999)
        ELSE
          LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
            & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCellMLCreateFieldToCellMLMapNumberVS")
    RETURN
999 CALL ERRORS("CMISSCellMLCreateFieldToCellMLMapNumberVS",err,error)
    CALL EXITS("CMISSCellMLCreateFieldToCellMLMapNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLCreateFieldToCellMLMapNumberVS

  !
  !================================================================================================================================
  !

  !>Defines a field variable component to CellML model variable map by by object.
  SUBROUTINE CMISSCellMLCreateFieldToCellMLMapObjVS(CellML,field,variableType,componentNumber,fieldParameterSet, &
    & CellMLModelUserNumber,variableID,CellMLParameterSet,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(IN) :: CellML !<The CellML enviroment.
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to map from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to map from.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to map from.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map from.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map to.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The CellML variable ID in the given model to map to.
    INTEGER(INTG), INTENT(IN) :: CellMLParameterSet !<The CellML variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLCreateFieldToCellMLMapNumberVS",err,error,*999)

    CALL CELLML_CREATE_FIELD_TO_CELLML_MAP(CellML%CELLML,field%FIELD,variableType,componentNumber,fieldParameterSet, &
      & CellMLModelUserNumber,variableID,CellMLParameterSet,err,error,*999)

    CALL EXITS("CMISSCellMLCreateFieldToCellMLMapObjVS")
    RETURN
999 CALL ERRORS("CMISSCellMLCreateFieldToCellMLMapObjVS",err,error)
    CALL EXITS("CMISSCellMLCreateFieldToCellMLMapObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLCreateFieldToCellMLMapObjVS

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLCreateFinishNumber(regionUserNumber,CellMLUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_CREATE_FINISH(CELLML,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Create')
#endif

    CALL EXITS("CMISSCellMLCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLCreateFinishNumber",err,error)
    CALL EXITS("CMISSCellMLCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLCreateFinishObj(CellML,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLCreateFinishObj",err,error,*999)

    CALL CELLML_CREATE_FINISH(CellML%CELLML,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Create')
#endif

    CALL EXITS("CMISSCellMLCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSCellMLCreateFinishObj",err,error)
    CALL EXITS("CMISSCellMLCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLCreateStartNumber(CellMLUserNumber,regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to start creating.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the field to start the CellML enviroment creation on.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLCreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Create')
#endif

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_CREATE_START(CellMLUserNumber,REGION,CELLML,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCellMLCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLCreateStartNumber",err,error)
    CALL EXITS("CMISSCellMLCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLCreateStartObj(CellMLUserNumber,region,CellML,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to start creating.
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region containing the field to start the CellML enviroment creation on.
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<On return, the created CellML environment.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLCreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Create')
#endif

    CALL CELLML_CREATE_START(CellMLUserNumber,region%REGION,CellML%CELLML,err,error,*999)

    CALL EXITS("CMISSCellMLCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSCellMLCreateStartObj",err,error)
    CALL EXITS("CMISSCellMLCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLDestroyNumber(regionUserNumber,CellMLUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment to destroy.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_DESTROY(CELLML,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCellMLDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLDestroyNumber",err,error)
    CALL EXITS("CMISSCellMLDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLDestroyObj(CellML,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLDestroyObj",err,error,*999)

    CALL CELLML_DESTROY(CellML%CELLML,err,error,*999)

    CALL EXITS("CMISSCellMLDestroyObj")
    RETURN
999 CALL ERRORS("CMISSCellMLDestroyObj",err,error)
    CALL EXITS("CMISSCellMLDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLDestroyObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of field maps for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLFieldMapsCreateFinishNumber(regionUserNumber,CellMLUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLFieldMapsCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_FIELD_MAPS_CREATE_FINISH(CELLML,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Create')
#endif

    CALL EXITS("CMISSCellMLFieldMapsCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLFieldMapsCreateFinishNumber",err,error)
    CALL EXITS("CMISSCellMLFieldMapsCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLFieldMapsCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of field maps for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLFieldMapsCreateFinishObj(CellML,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to finish the creation of maps for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLFieldMapsCreateFinishObj",err,error,*999)

    CALL CELLML_FIELD_MAPS_CREATE_FINISH(CellML%CELLML,err,error,*999)

    CALL EXITS("CMISSCellMLFieldMapsCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSCellMLFieldMapsCreateFinishObj",err,error)
    CALL EXITS("CMISSCellMLFieldMapsCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLFieldMapsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of field maps for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLFieldMapsCreateStartNumber(regionUserNumber,CellMLUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to start creating the maps for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLFieldMapsCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_FIELD_MAPS_CREATE_START(CELLML,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCellMLFieldCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLFieldCreateStartNumber",err,error)
    CALL EXITS("CMISSCellMLFieldCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLFieldMapsCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of field maps for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLFieldMapsCreateStartObj(CellML,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment object to start the creation of maps for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLFieldMapsCreateStartObj",err,error,*999)

    CALL CELLML_FIELD_MAPS_CREATE_START(CellML%CELLML,err,error,*999)

    CALL EXITS("CMISSCellMLFieldMapsCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSCellMLFieldMapsCreateStartObj",err,error)
    CALL EXITS("CMISSCellMLFieldMapsCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLFieldMapsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Imports a specified CellML model as specified by a character URI into a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLModelImportNumberC(regionUserNumber,CellMLUserNumber,uRI,modelIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment to import the model into.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to import the model into.
    CHARACTER(LEN=*), INTENT(IN) :: uRI !<The uRI of the CellML model to import.
    INTEGER(INTG), INTENT(OUT) :: modelIndex !<On return, the index of the imported model.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLModelImportNumberC",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_MODEL_IMPORT(CELLML,uRI,modelIndex,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCellMLModelImportNumberC")
    RETURN
999 CALL ERRORS("CMISSCellMLModelImportNumberC",err,error)
    CALL EXITS("CMISSCellMLModelImportNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLModelImportNumberC

  !
  !================================================================================================================================
  !

  !>Imports a specified CellML model as specified by a character URI into a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLModelImportObjC(CellML,uRI,modelIndex,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to import the model into.
    CHARACTER(LEN=*), INTENT(IN) :: uRI !<The uRI of the CellML model to import.
    INTEGER(INTG), INTENT(OUT) :: modelIndex !<On return, the index of the imported model.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLModelImportObjC",err,error,*999)

    CALL CELLML_MODEL_IMPORT(CellML%CELLML,uRI,modelIndex,err,error,*999)

    CALL EXITS("CMISSCellMLModelImportObjC")
    RETURN
999 CALL ERRORS("CMISSCellMLModelImportObjC",err,error)
    CALL EXITS("CMISSCellMLModelImportObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLModelImportObjC

  !
  !================================================================================================================================
  !

  !>Imports a specified CellML model as specified by a varying string URI into a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLModelImportNumberVS(regionUserNumber,CellMLUserNumber,uRI,modelIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment to import the model into.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to import the model into.
    TYPE(VARYING_STRING), INTENT(IN) :: uRI !<The uRI of the CellML model to import.
    INTEGER(INTG), INTENT(OUT) :: modelIndex !<On return, the index of the imported model.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLModelImportNumberVS",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_MODEL_IMPORT(CELLML,uRI,modelIndex,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCellMLModelImportNumberVS")
    RETURN
999 CALL ERRORS("CMISSCellMLModelImportNumberVS",err,error)
    CALL EXITS("CMISSCellMLModelImportNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLModelImportNumberVS

  !
  !================================================================================================================================
  !

  !>Imports a specified CellML model as specified by a varying string URI into a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLModelImportObjVS(CellML,uRI,modelIndex,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to import the model into.
    TYPE(VARYING_STRING), INTENT(IN) :: uRI !<The uRI of the CellML model to import.
    INTEGER(INTG), INTENT(OUT) :: modelIndex !<On return, the index of the imported model.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLModelImportObjVS",err,error,*999)

    CALL CELLML_MODEL_IMPORT(CellML%CELLML,uRI,modelIndex,err,error,*999)

    CALL EXITS("CMISSCellMLModelImportObjVS")
    RETURN
999 CALL ERRORS("CMISSCellMLModelImportObjVS",err,error)
    CALL EXITS("CMISSCellMLModelImportObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLModelImportObjVS

  !
  !================================================================================================================================
  !

  !>Finishes the creation of CellML models field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLModelsFieldCreateFinishNumber(regionUserNumber,CellMLUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment to finish creating.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to finish creating the models field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLModelsFieldCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_MODELS_FIELD_CREATE_FINISH(CELLML,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCellMLModelsFieldCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLModelsFieldCreateFinishNumber",err,error)
    CALL EXITS("CMISSCellMLModelsFieldCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLModelsFieldCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of CellML models field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLModelsFieldCreateFinishObj(CellML,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to finish the creation of the models field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLModelsFieldCreateFinishObj",err,error,*999)

    CALL CELLML_MODELS_FIELD_CREATE_FINISH(CellML%CELLML,err,error,*999)

    CALL EXITS("CMISSCellMLModelsFieldCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSCellMLModelsFieldCreateFinishObj",err,error)
    CALL EXITS("CMISSCellMLModelsFieldCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLModelsFieldCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of CellML models field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLModelsFieldCreateStartNumber(CellMLModelsFieldUserNumber,regionUserNumber,CellMLUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLModelsFieldUserNumber !<The user number of the CellML models field to start creating.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML environment to start creating the models field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLModelsFieldCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_MODELS_FIELD_CREATE_START(CellMLModelsFieldUserNumber,CELLML,FIELD,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCellMLModelsFieldCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLModelsFieldCreateStartNumber",err,error)
    CALL EXITS("CMISSCellMLModelsFieldCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLModelsFieldCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of CellML models field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLModelsFieldCreateStartObj(CellMLModelsFieldUserNumber,CellML,field,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLModelsFieldUserNumber !<The user number of the CellML models field to start creating.
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to start the creation of models field for.
    TYPE(CMISSFieldType), INTENT(INOUT) :: field !<On return, the created CellML models field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLModelsFieldCreateStartObj",err,error,*999)

    CALL CELLML_MODELS_FIELD_CREATE_START(CellMLModelsFieldUserNumber,CellML%CELLML,field%FIELD,err,error,*999)

    CALL EXITS("CMISSCellMLModelsFieldCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSCellMLModelsFieldCreateStartObj",err,error)
    CALL EXITS("CMISSCellMLModelsFieldCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLModelsFieldCreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML models field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLModelsFieldGetNumber(regionUserNumber,CellMLUserNumber,CellMLModelsFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment to get the CellML models field for.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to get the CellML models field for.
    INTEGER(INTG), INTENT(OUT) :: CellMLModelsFieldUserNumber !<On return, the user number of the CellML models field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLModelsFieldGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_MODELS_FIELD_GET(CELLML,FIELD,err,error,*999)
        CellMLModelsFieldUserNumber = FIELD%USER_NUMBER
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCellMLModelsFieldGetNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLModelsFieldGetNumber",err,error)
    CALL EXITS("CMISSCellMLModelsFieldGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLModelsFieldGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the CellML models field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLModelsFieldGetObj(CellML,field,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to get the models field for.
    TYPE(CMISSFieldType), INTENT(INOUT) :: field !<On return, the CellML models field. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLModelsFieldGetObj",err,error,*999)

    CALL CELLML_MODELS_FIELD_GET(CellML%CELLML,field%FIELD,err,error,*999)

    CALL EXITS("CMISSCellMLModelsFieldGetObj")
    RETURN
999 CALL ERRORS("CMISSCellMLModelsFieldGetObj",err,error)
    CALL EXITS("CMISSCellMLModelsFieldGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLModelsFieldGetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of CellML state field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLStateFieldCreateFinishNumber(regionUserNumber,CellMLUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to finish creating the state field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLStateFieldCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_STATE_FIELD_CREATE_FINISH(CELLML,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCellMLStateFieldCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLStateFieldCreateFinishNumber",err,error)
    CALL EXITS("CMISSCellMLStateFieldCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLStateFieldCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of CellML state field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLStateFieldCreateFinishObj(CellML,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to finish the creation of the state field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLStateFieldCreateFinishObj",err,error,*999)

    CALL CELLML_STATE_FIELD_CREATE_FINISH(CellML%CELLML,err,error,*999)

    CALL EXITS("CMISSCellMLStateFieldCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSCellMLStateFieldCreateFinishObj",err,error)
    CALL EXITS("CMISSCellMLStateFieldCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLStateFieldCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of CellML state field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLStateFieldCreateStartNumber(CellMLStateFieldUserNumber,regionUserNumber,CellMLUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLStateFieldUserNumber !<The user number of the CellML state field to start creating.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML environment to start creating the state field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLStateFieldCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_STATE_FIELD_CREATE_START(CellMLStateFieldUserNumber,CELLML,FIELD,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCellMLStateFieldCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLStateFieldCreateStartNumber",err,error)
    CALL EXITS("CMISSCellMLStateFieldCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLStateFieldCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of CellML state field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLStateFieldCreateStartObj(CellMLStateFieldUserNumber,CellML,field,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLStateFieldUserNumber !<The user number of the CellML state field to start creating.
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to start the creation of state field for.
    TYPE(CMISSFieldType), INTENT(INOUT) :: field !<On return, the created CellML state field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLStateFieldCreateStartObj",err,error,*999)

    CALL CELLML_STATE_FIELD_CREATE_START(CellMLStateFieldUserNumber,CellML%CELLML,field%FIELD,err,error,*999)

    CALL EXITS("CMISSCellMLStateFieldCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSCellMLStateFieldCreateStartObj",err,error)
    CALL EXITS("CMISSCellMLStateFieldCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLStateFieldCreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML state field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLStateFieldGetNumber(regionUserNumber,CellMLUserNumber,CellMLStateFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to get the CellML state field for.
    INTEGER(INTG), INTENT(OUT) :: CellMLStateFieldUserNumber !<On return, the user number of the CellML state field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLStateFieldGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_STATE_FIELD_GET(CELLML,FIELD,err,error,*999)
        CellMLStateFieldUserNumber = FIELD%USER_NUMBER
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCellMLStateFieldGetNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLStateFieldGetNumber",err,error)
    CALL EXITS("CMISSCellMLStateFieldGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLStateFieldGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the CellML state field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLStateFieldGetObj(CellML,field,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to get the state field for.
    TYPE(CMISSFieldType), INTENT(INOUT) :: field !<On return, the CellML state field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLStateFieldGetObj",err,error,*999)

    CALL CELLML_STATE_FIELD_GET(CellML%CELLML,field%FIELD,err,error,*999)

    CALL EXITS("CMISSCellMLStateFieldGetObj")
    RETURN
999 CALL ERRORS("CMISSCellMLStateFieldGetObj",err,error)
    CALL EXITS("CMISSCellMLStateFieldGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLStateFieldGetObj

  !
  !================================================================================================================================
  !

  !>Returns the field component number that corresponds to a character string VariableID for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLFieldComponentGetNumberC(regionUserNumber,CellMLUserNumber,CellMLModelUserNumber,CellMLFieldType,&
  & variableID,fieldComponent,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to get the field component for.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map fom.
    INTEGER(INTG), INTENT(IN) :: CellMLFieldType !<The type of CellML field to get the component for. \see OPENCMISS_CellMLFieldTypes,OPENCMISS
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The variable ID to get the corresponding field component for.
    INTEGER(INTG), INTENT(OUT) :: fieldComponent !<On return, the field component corresponding to the ID.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLFieldComponentGetNumberC",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_FIELD_COMPONENT_GET(CELLML,CellMLModelUserNumber,CellMLFieldType,variableID,fieldComponent,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCellMLFieldComponentGetNumberC")
    RETURN
999 CALL ERRORS("CMISSCellMLFieldComponentGetNumberC",err,error)
    CALL EXITS("CMISSCellMLFieldComponentGetNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)

    RETURN

  END SUBROUTINE CMISSCellMLFieldComponentGetNumberC

  !
  !================================================================================================================================
  !

  !>Returns the field component number that corresponds to a character string variable ID for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLFieldComponentGetObjC(CellML,CellMLModelUserNumber,CellMLFieldType,variableID,fieldComponent,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to get the field component for.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map from.
    INTEGER(INTG), INTENT(IN) :: CellMLFieldType !<The type of CellML field to get the component for. \see OPENCMISS_CellMLFieldTypes,OPENCMISS
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The ID to get the corresponding field component for.
    INTEGER(INTG), INTENT(OUT) :: fieldComponent !<On return, the field component corresponding to the ID.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLFieldComponentGetObjC",err,error,*999)

    CALL CELLML_FIELD_COMPONENT_GET(CellML%CELLML,CellMLModelUserNumber,CellMLFieldType,variableID,fieldComponent,err,error,*999)

    CALL EXITS("CMISSCellMLFieldComponentGetObjC")
    RETURN
999 CALL ERRORS("CMISSCellMLFieldComponentGetObjC",err,error)
    CALL EXITS("CMISSCellMLFieldComponentGetObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLFieldComponentGetObjC

  !
  !================================================================================================================================
  !

  !>Returns the field component number that corresponds to a varying string variable ID for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLFieldComponentGetNumberVS(regionUserNumber,CellMLUserNumber,CellMLModelUserNumber,CellMLFieldType,&
  & variableID,fieldComponent,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to get the field component for.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map from.
    INTEGER(INTG), INTENT(IN) :: CellMLFieldType !<The type of CellML field to get the component for. \see OPENCMISS_CellMLFieldTypes,OPENCMISS
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The ID to get the corresponding field component for.
    INTEGER(INTG), INTENT(OUT) :: fieldComponent !<On return, the field component corresponding to the ID.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLFieldComponentGetNumberVS",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_FIELD_COMPONENT_GET(CELLML,CellMLModelUserNumber,CellMLFieldType,variableID,fieldComponent,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCellMLFieldComponentGetNumberVS")
    RETURN
999 CALL ERRORS("CMISSCellMLFieldComponentGetNumberVS",err,error)
    CALL EXITS("CMISSCellMLFieldComponentGetNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLFieldComponentGetNumberVS

  !
  !================================================================================================================================
  !

  !>Returns the field component number that corresponds to a varying string variable ID for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLFieldComponentGetObjVS(CellML,CellMLModelUserNumber,CellMLFieldType,variableID,fieldComponent,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to get the field component for.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map from.
    INTEGER(INTG), INTENT(IN) :: CellMLFieldType !<The type of CellML field to get the component for. \see OPENCMISS_CellMLFieldTypes,OPENCMISS
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The ID to get the corresponding field component for.
    INTEGER(INTG), INTENT(OUT) :: fieldComponent !<On return, the field component corresponding to the ID.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLFieldComponentGetObjVS",err,error,*999)

    CALL CELLML_FIELD_COMPONENT_GET(CellML%CELLML,CellMLModelUserNumber,CellMLFieldType,variableID,fieldComponent,err,error,*999)

    CALL EXITS("CMISSCellMLFieldComponentGetObjVS")
    RETURN
999 CALL ERRORS("CMISSCellMLFieldComponentGetObjVS",err,error)
    CALL EXITS("CMISSCellMLFieldComponentGetObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLFieldComponentGetObjVS

  !
  !================================================================================================================================
  !

  !>Finishes the creation of CellML intermediate field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLIntermediateFieldCreateFinishNumber(regionUserNumber,CellMLUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to finish creating the intermediate field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLIntermediateFieldCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_INTERMEDIATE_FIELD_CREATE_FINISH(CELLML,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCellMLIntermediateFieldCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLIntermediateFieldCreateFinishNumber",err,error)
    CALL EXITS("CMISSCellMLIntermediateFieldCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLIntermediateFieldCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of CellML intermediate field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLIntermediateFieldCreateFinishObj(CellML,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to finish the creation of the intermediate field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLIntermediateFieldCreateFinishObj",err,error,*999)

    CALL CELLML_INTERMEDIATE_FIELD_CREATE_FINISH(CellML%CELLML,err,error,*999)

    CALL EXITS("CMISSCellMLIntermediateFieldCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSCellMLIntermediateFieldCreateFinishObj",err,error)
    CALL EXITS("CMISSCellMLIntermediateFieldCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLIntermediateFieldCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of CellML intermediate field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLIntermediateFieldCreateStartNumber(CellMLIntermediateFieldUserNumber,regionUserNumber,CellMLUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLIntermediateFieldUserNumber !<The user number of the CellML intermediate field to start creating.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML environment to start creating the intermediate field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLIntermediateFieldCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_INTERMEDIATE_FIELD_CREATE_START(CellMLIntermediateFieldUserNumber,CELLML,FIELD,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCellMLIntermediateFieldCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLIntermediateFieldCreateStartNumber",err,error)
    CALL EXITS("CMISSCellMLIntermediateFieldCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLIntermediateFieldCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of CellML intermediate field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLIntermediateFieldCreateStartObj(CellMLIntermediateFieldUserNumber,CellML,field,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLIntermediateFieldUserNumber !<The user number of the CellML intermediate field to start creating.
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to start the creation of intermediate field for.
    TYPE(CMISSFieldType), INTENT(INOUT) :: field !<On return, the created CellML intermediate field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLIntermediateFieldCreateStartObj",err,error,*999)

    CALL CELLML_INTERMEDIATE_FIELD_CREATE_START(CellMLIntermediateFieldUserNumber,CellML%CELLML,field%FIELD,err,error,*999)

    CALL EXITS("CMISSCellMLIntermediateFieldCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSCellMLIntermediateFieldCreateStartObj",err,error)
    CALL EXITS("CMISSCellMLIntermediateFieldCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLIntermediateFieldCreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML intermediate field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLIntermediateFieldGetNumber(regionUserNumber,CellMLUserNumber,CellMLIntermediateFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to get the CellML intermediate field for.
    INTEGER(INTG), INTENT(OUT) :: CellMLIntermediateFieldUserNumber !<On return, the user number of the CellML intermediate field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLIntermediateFieldGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_INTERMEDIATE_FIELD_GET(CELLML,FIELD,err,error,*999)
        CellMLIntermediateFieldUserNumber = FIELD%USER_NUMBER
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCellMLIntermediateFieldGetNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLIntermediateFieldGetNumber",err,error)
    CALL EXITS("CMISSCellMLIntermediateFieldGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLIntermediateFieldGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the CellML intermediate field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLIntermediateFieldGetObj(CellML,field,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to get the intermediate field for.
    TYPE(CMISSFieldType), INTENT(INOUT) :: field !<On return, the CellML intermediate field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLIntermediateFieldGetObj",err,error,*999)

    CALL CELLML_INTERMEDIATE_FIELD_GET(CellML%CELLML,field%FIELD,err,error,*999)

    CALL EXITS("CMISSCellMLIntermediateFieldGetObj")
    RETURN
999 CALL ERRORS("CMISSCellMLIntermediateFieldGetObj",err,error)
    CALL EXITS("CMISSCellMLIntermediateFieldGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLIntermediateFieldGetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of CellML parameters field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLParametersFieldCreateFinishNumber(regionUserNumber,CellMLUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to finish creating the parameters field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLParametersFieldCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_PARAMETERS_FIELD_CREATE_FINISH(CELLML,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCellMLParametersFieldCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLParametersFieldCreateFinishNumber",err,error)
    CALL EXITS("CMISSCellMLParametersFieldCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLParametersFieldCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of CellML parameters field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLParametersFieldCreateFinishObj(CellML,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to finish the creation of the parameters field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLParametersFieldCreateFinishObj",err,error,*999)

    CALL CELLML_PARAMETERS_FIELD_CREATE_FINISH(CellML%CELLML,err,error,*999)

    CALL EXITS("CMISSCellMLParametersFieldCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSCellMLParametersFieldCreateFinishObj",err,error)
    CALL EXITS("CMISSCellMLParametersFieldCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLParametersFieldCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of CellML parameters field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLParametersFieldCreateStartNumber(CellMLParametersFieldUserNumber,regionUserNumber,CellMLUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLParametersFieldUserNumber !<The user number of the CellML parameters field to start creating.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML environment to start creating the parameters field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLParametersFieldCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_PARAMETERS_FIELD_CREATE_START(CellMLParametersFieldUserNumber,CELLML,FIELD,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCellMLParametersFieldCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLParametersFieldCreateStartNumber",err,error)
    CALL EXITS("CMISSCellMLParametersFieldCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLParametersFieldCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of CellML parameters field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLParametersFieldCreateStartObj(CellMLParametersFieldUserNumber,CellML,field,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLParametersFieldUserNumber !<The user number of the CellML parameters field to start creating.
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to start the creation of parameters field for.
    TYPE(CMISSFieldType), INTENT(INOUT) :: field !<On return, the created CellML parameters field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLParametersFieldCreateStartObj",err,error,*999)

    CALL CELLML_PARAMETERS_FIELD_CREATE_START(CellMLParametersFieldUserNumber,CellML%CELLML,field%FIELD,err,error,*999)

    CALL EXITS("CMISSCellMLParametersFieldCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSCellMLParametersFieldCreateStartObj",err,error)
    CALL EXITS("CMISSCellMLParametersFieldCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLParametersFieldCreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML parameters field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLParametersFieldGetNumber(regionUserNumber,CellMLUserNumber,CellMLParametersFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to get the CellML parameters field for.
    INTEGER(INTG), INTENT(OUT) :: CellMLParametersFieldUserNumber !<On return, the user number of the CellML parameters field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLParametersFieldGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_PARAMETERS_FIELD_GET(CELLML,FIELD,err,error,*999)
        CellMLParametersFieldUserNumber = FIELD%USER_NUMBER
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCellMLParametersFieldGetNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLParametersFieldGetNumber",err,error)
    CALL EXITS("CMISSCellMLParametersFieldGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLParametersFieldGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the CellML parameters field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLParametersFieldGetObj(CellML,field,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to get the parameters field for.
    TYPE(CMISSFieldType), INTENT(INOUT) :: field !<On return, the CellML parameters field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLParametersFieldGetObj",err,error,*999)

    CALL CELLML_PARAMETERS_FIELD_GET(CellML%CELLML,field%FIELD,err,error,*999)

    CALL EXITS("CMISSCellMLParametersFieldGetObj")
    RETURN
999 CALL ERRORS("CMISSCellMLParametersFieldGetObj",err,error)
    CALL EXITS("CMISSCellMLParametersFieldGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLParametersFieldGetObj

  !
  !================================================================================================================================
  !

  !>Validiate and instantiate a CellML environment identified by a user number.
  SUBROUTINE CMISSCellMLGenerateNumber(regionUserNumber,CellMLUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to generate.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLGenerateNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_GENERATE(CELLML,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCellMLGenerateNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLGenerateNumber",err,error)
    CALL EXITS("CMISSCellMLGenerateNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLGenerateNumber

  !
  !================================================================================================================================
  !

  !>Validiate and instantiate a CellML environment identified by an object.
  SUBROUTINE CMISSCellMLGenerateObj(CellML,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to generate.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLGenerateObj",err,error,*999)

    CALL CELLML_GENERATE(CellML%CELLML,err,error,*999)

    CALL EXITS("CMISSCellMLGenerateObj")
    RETURN
999 CALL ERRORS("CMISSCellMLGenerateObj",err,error)
    CALL EXITS("CMISSCellMLGenerateObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLGenerateObj


!!==================================================================================================================================
!!
!! COMP_ENVIRONMENT
!!
!!==================================================================================================================================

  !>Returns the computational node number of the running process.
  SUBROUTINE CMISSComputationalNodeNumberGet(nodeNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: nodeNumber !<On return, the computational node number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSComputationalNodeNumberGet",ERR,error,*999)

    nodeNumber = COMPUTATIONAL_NODE_NUMBER_GET(err,error)

    CALL EXITS("CMISSComputationalNodeNumberGet")
    RETURN
999 CALL ERRORS("CMISSComputationalNodeNumberGet",err,error)
    CALL EXITS("CMISSComputationalNodeNumberGet")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSComputationalNodeNumberGet

  !
  !================================================================================================================================
  !

  !>Returns the number of computational nodes for the running process.
  SUBROUTINE CMISSComputationalNumberOfNodesGet(numberOfNodes,err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: numberOfNodes !<On return, the number of computational nodes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSComputationalNumberOfNodesGet",ERR,error,*999)

    numberOfNodes = COMPUTATIONAL_NODES_NUMBER_GET(err,error)

    CALL EXITS("CMISSComputationalNumberOfNodesGet")
    RETURN
999 CALL ERRORS("CMISSComputationalNumberOfNodesGet",err,error)
    CALL EXITS("CMISSComputationalNumberOfNodesGet")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSComputationalNumberOfNodesGet

  !
  !================================================================================================================================
  !

  !>CREATE THE HIGHEST LEVEL WORK GROUP (DEFAULT: GROUP_WORLD)
  SUBROUTINE CMISSComputationalWorkGroupCreateStart(worldWorkGroup, numberComputationalNodes, err)
    !Argument Variables
    TYPE(CMISSComputationalWorkGroupType), INTENT(INOUT) :: worldWorkGroup
    INTEGER(INTG),INTENT(IN) :: numberComputationalNodes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    CALL ENTERS("CMISSComputationalWorkGroupCreateStart",ERR,error,*999)

    CALL COMPUTATIONAL_WORK_GROUP_CREATE_START(worldWorkGroup%COMPUTATIONAL_WORK_GROUP,numberComputationalNodes, &
      & err,error,*999)

    CALL EXITS("CMISSComputationalWorkGroupCreateStart")
    RETURN
999 CALL ERRORS("CMISSComputationalWorkGroupCreateStart",err,error)
    CALL EXITS("CMISSComputationalWorkGroupCreateStart")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSComputationalWorkGroupCreateStart

  !
  !================================================================================================================================
  !

  !>GENERATE THE HIERARCHY COMPUTATIONAL ENVIRONMENT BASED ON WORK GROUP TREE
  SUBROUTINE CMISSComputationalWorkGroupCreateFinish(worldWorkGroup, err)
    !Argument Variables
    TYPE(CMISSComputationalWorkGroupType), INTENT(INOUT) :: worldWorkGroup
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    CALL ENTERS("CMISSComputationalWorkGroupCreateFinish",ERR,error,*999)

    CALL COMPUTATIONAL_WORK_GROUP_CREATE_FINISH(worldWorkGroup%COMPUTATIONAL_WORK_GROUP, err,error,*999)

    CALL EXITS("CMISSComputationalWorkGroupCreateFinish")
    RETURN
999 CALL ERRORS("CMISSComputationalWorkGroupCreateFinish",err,error)
    CALL EXITS("CMISSComputationalWorkGroupCreateFinish")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSComputationalWorkGroupCreateFinish

  !
  !================================================================================================================================
  !

  !>ADD WORK SUB-GROUP TO THE PARENT GROUP BASED ON THE COMPUTATIONAL REQUIREMENTS (CALLED BY THE USER)
  SUBROUTINE CMISSComputationalWorkGroupSubgroupAdd(parentWorkGroup, numberComputationalNodes,addedWorkGroup, err)
    !Argument Variables
    TYPE(CMISSComputationalWorkGroupType), INTENT(INOUT) :: parentWorkGroup
    TYPE(CMISSComputationalWorkGroupType), INTENT(INOUT) :: addedWorkGroup
    INTEGER(INTG),INTENT(IN) :: numberComputationalNodes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    CALL ENTERS("CMISSComputationalWorkGroupSubgroupAdd",ERR,error,*999)

    CALL COMPUTATIONAL_WORK_GROUP_SUBGROUP_ADD(parentWorkGroup%COMPUTATIONAL_WORK_GROUP,numberComputationalNodes, &
    & addedWorkGroup%COMPUTATIONAL_WORK_GROUP, err,error,*999)

    CALL EXITS("CMISSComputationalWorkGroupSubgroupAdd")
    RETURN
999 CALL ERRORS("CMISSComputationalWorkGroupSubgroupAdd",err,error)
    CALL EXITS("CMISSComputationalWorkGroupSubgroupAdd")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSComputationalWorkGroupSubgroupAdd  !
  !================================================================================================================================
  !

  !>Set the working group tree in order to performe mesh decomposition
  SUBROUTINE CMISSDecompositionWorldWorkGroupSet(decomposition, worldWorkGroup, err)
    !Argument Variables
    TYPE(CMISSDecompositionType), INTENT(INOUT) :: decomposition
    TYPE(CMISSComputationalWorkGroupType),INTENT(IN) :: worldWorkGroup
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    CALL ENTERS("CMISSDecompositionWorldWorkGroupSet",err,error,*999)

    ! todo
    CALL FLAG_ERROR('not implemented yet', err,error, *999)

    CALL EXITS("CMISSDecompositionWorldWorkGroupSet")
    RETURN
999 CALL ERRORS("CMISSDecompositionWorldWorkGroupSet",err,error)
    CALL EXITS("CMISSDecompositionWorldWorkGroupSet")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionWorldWorkGroupSet

!!==================================================================================================================================
!!
!! CONTROL_LOOP_ROUTINES
!!
!!==================================================================================================================================

  !>Gets the current time parameters for a time control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopCurrentTimesGetNumber0(problemUserNumber,controlLoopIdentifier,currentTime,timeIncrement,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the current time of the time control loop.
    REAL(DP), INTENT(OUT) :: timeIncrement !<On return, the current time increment of the time control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopCurrentTimesGetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_CURRENT_TIMES_GET(CONTROL_LOOP,currentTime,timeIncrement,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopCurrentTimesGetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoopCurrentTimesGetNumber0",err,error)
    CALL EXITS("CMISSControlLoopCurrentTimesGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopCurrentTimesGetNumber0

  !
  !================================================================================================================================
  !

  !>Gets the current time parameters for a time control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopCurrentTimesGetNumber1(problemUserNumber,controlLoopIdentifiers,currentTime,timeIncrement,err)

    !Argument variables
     INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the control loop for.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the current time of the time control loop.
    REAL(DP), INTENT(OUT) :: timeIncrement !<On return, the current time increment of the time control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopCurrentTimesGetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_CURRENT_TIMES_GET(CONTROL_LOOP,currentTime,timeIncrement,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopCurrentTimesGetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoopCurrentTimesGetNumber1",err,error)
    CALL EXITS("CMISSControlLoopCurrentTimesGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopCurrentTimesGetNumber1

  !
  !================================================================================================================================
  !

  !>Gets the current time parameters for a time control loop identified by an object.
  SUBROUTINE CMISSControlLoopCurrentTimesGetObj(controlLoop,currentTime,timeIncrement,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the current times for.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the current time of the time control loop.
    REAL(DP), INTENT(OUT) :: timeIncrement !<On return, the current time increment of the time control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopCurrentTimesGetObj",err,error,*999)

    CALL CONTROL_LOOP_CURRENT_TIMES_GET(controlLoop%CONTROL_LOOP,currentTime,timeIncrement,err,error,*999)

    CALL EXITS("CMISSControlLoopCurrentTimesGetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoopCurrentTimesGetObj",err,error)
    CALL EXITS("CMISSControlLoopCurrentTimesGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopCurrentTimesGetObj

  !
  !================================================================================================================================
  !

  !>Destroys a control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopDestroyNumber0(problemUserNumber,controlLoopIdentifier,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to destroy the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopDestroyNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_DESTROY(CONTROL_LOOP,err,error,*999)
   ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopDestroyNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoopDestroyNumber0",err,error)
    CALL EXITS("CMISSControlLoopDestroyNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopDestroyNumber0

  !
  !================================================================================================================================
  !

  !>Destroys a control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopDestroyNumber1(problemUserNumber,controlLoopIdentifiers,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to destroy the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopDestroyNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_DESTROY(CONTROL_LOOP,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopDestroyNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoopDestroyNumber1",err,error)
    CALL EXITS("CMISSControlLoopDestroyNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopDestroyNumber1

  !
  !================================================================================================================================
  !

  !>Destroys a control loop identified by an object.
  SUBROUTINE CMISSControlLoopDestroyObj(controlLoop,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopDestroyObj",err,error,*999)

    CALL CONTROL_LOOP_DESTROY(controlLoop%CONTROL_LOOP,err,error,*999)

    CALL EXITS("CMISSControlLoopDestroyObj")
    RETURN
999 CALL ERRORS("CMISSControlLoopDestroyObj",err,error)
    CALL EXITS("CMISSControlLoopDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root identified by user numbers.
  SUBROUTINE CMISSControlLoopGetNumber00(problemUserNumber,controlLoopRootIdentifier,controlLoopIdentifier,controlLoop,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopRootIdentifier !<The root control loop identifier.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: ROOT_CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopGetNumber00",err,error,*999)

    NULLIFY(ROOT_CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopRootIdentifier,ROOT_CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_GET(ROOT_CONTROL_LOOP,controlLoopIdentifier,controlLoop%CONTROL_LOOP,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopGetNumber00")
    RETURN
999 CALL ERRORS("CMISSControlLoopGetNumber00",err,error)
    CALL EXITS("CMISSControlLoopGetNumber00")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopGetNumber00

  !
  !================================================================================================================================
  !

  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root identified by user numbers.
  SUBROUTINE CMISSControlLoopGetNumber10(problemUserNumber,controlLoopRootIdentifiers,controlLoopIdentifier,controlLoop,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopRootIdentifiers(:) !<The root control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: ROOT_CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopGetNumber10",err,error,*999)

    NULLIFY(ROOT_CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopRootIdentifiers,ROOT_CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_GET(ROOT_CONTROL_LOOP,controlLoopIdentifier,controlLoop%CONTROL_LOOP,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopGetNumber10")
    RETURN
999 CALL ERRORS("CMISSControlLoopGetNumber10",err,error)
    CALL EXITS("CMISSControlLoopGetNumber10")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopGetNumber10

  !
  !================================================================================================================================
  !

  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root identified by user numbers.
  SUBROUTINE CMISSControlLoopGetNumber01(problemUserNumber,controlLoopRootIdentifier,controlLoopIdentifiers,controlLoop,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopRootIdentifier !<The root control loop identifier.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: ROOT_CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopGetNumber01",err,error,*999)

    NULLIFY(ROOT_CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopRootIdentifier,ROOT_CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_GET(ROOT_CONTROL_LOOP,controlLoopIdentifiers,controlLoop%CONTROL_LOOP,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopGetNumber01")
    RETURN
999 CALL ERRORS("CMISSControlLoopGetNumber01",err,error)
    CALL EXITS("CMISSControlLoopGetNumber01")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopGetNumber01

  !
  !================================================================================================================================
  !

  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root identified by user numbers.
  SUBROUTINE CMISSControlLoopGetNumber11(problemUserNumber,controlLoopRootIdentifiers,controlLoopIdentifiers,controlLoop,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopRootIdentifiers(:) !<The root control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: ROOT_CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopGetNumber11",err,error,*999)

    NULLIFY(ROOT_CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopRootIdentifiers,ROOT_CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_GET(ROOT_CONTROL_LOOP,controlLoopIdentifiers,controlLoop%CONTROL_LOOP,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopGetNumber11")
    RETURN
999 CALL ERRORS("CMISSControlLoopGetNumber11",err,error)
    CALL EXITS("CMISSControlLoopGetNumber11")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopGetNumber11

  !
  !================================================================================================================================
  !

  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root.
  SUBROUTINE CMISSControlLoopGetObj0(controlLoopRoot,controlLoopIdentifier,controlLoop,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(IN) :: controlLoopRoot !<The root control loop.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopGetObj0",err,error,*999)

    CALL CONTROL_LOOP_GET(controlLoopRoot%CONTROL_LOOP,controlLoopIdentifier,controlLoop%CONTROL_LOOP,err,error,*999)

    CALL EXITS("CMISSControlLoopGetObj0")
    RETURN
999 CALL ERRORS("CMISSControlLoopGetObj0",err,error)
    CALL EXITS("CMISSControlLoopGetObj0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopGetObj0

  !
  !================================================================================================================================
  !

  !>Returns the specified control loop as indexed by the control loop identifiers from the control loop root.
  SUBROUTINE CMISSControlLoopGetObj1(controlLoopRoot,controlLoopIdentifiers,controlLoop,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(IN) :: controlLoopRoot !<The root control loop.
    INTEGER(INTG), INTENT(INOUT) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    TYPE(CMISSControlLoopType), INTENT(OUT) :: controlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopGetObj1",err,error,*999)

    CALL CONTROL_LOOP_GET(controlLoopRoot%CONTROL_LOOP,controlLoopIdentifiers,controlLoop%CONTROL_LOOP,err,error,*999)

    CALL EXITS("CMISSControlLoopGetObj1")
    RETURN
999 CALL ERRORS("CMISSControlLoopGetObj1",err,error)
    CALL EXITS("CMISSControlLoopGetObj1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopGetObj1

  !
  !================================================================================================================================
  !

  !>Sets/changes the iteration parameters for a fixed control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopIterationsSetNumber0(problemUserNumber,controlLoopIdentifier,startIteration,stopIteration, &
    & iterationIncrement,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the iteration parameters for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: startIteration !<The start iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: stopIteration !<The stop iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: iterationIncrement !<The iteration increment of the fixed control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopIterationsSetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_ITERATIONS_SET(CONTROL_LOOP,startIteration,stopIteration,iterationIncrement,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopIterationsSetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoopIterationsSetNumber0",err,error)
    CALL EXITS("CMISSControlLoopIterationsSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopIterationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the iteration parameters for a fixed control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopIterationsSetNumber1(problemUserNumber,controlLoopIdentifiers,startIteration,stopIteration, &
    & iterationIncrement,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the iteration parameters for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: startIteration !<The start iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: stopIteration !<The stop iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: iterationIncrement !<The iteration increment of the fixed control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopIterationsSetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_ITERATIONS_SET(CONTROL_LOOP,startIteration,stopIteration,iterationIncrement,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopIterationsSetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoopIterationsSetNumber1",err,error)
    CALL EXITS("CMISSControlLoopIterationsSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopIterationsSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the iteration parameters for a fixed control loop identified by an object.
  SUBROUTINE CMISSControlLoopIterationsSetObj(controlLoop,startIteration,stopIteration,iterationIncrement,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the iteration parameters for.
    INTEGER(INTG), INTENT(IN) :: startIteration !<The start iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: stopIteration !<The stop iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: iterationIncrement !<The iteration increment of the fixed control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopIterationsSetObj",err,error,*999)

    CALL CONTROL_LOOP_ITERATIONS_SET(controlLoop%CONTROL_LOOP,startIteration,stopIteration,iterationIncrement,err,error,*999)

    CALL EXITS("CMISSControlLoopIterationsSetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoopIterationsSetObj",err,error)
    CALL EXITS("CMISSControlLoopIterationsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopIterationsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a control loop identified by an user number.
  SUBROUTINE CMISSControlLoopLabelGetCNumber0(problemUserNumber,controlLoopIdentifier,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the control loop label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopLabelGetCNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_LABEL_GET(CONTROL_LOOP,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopLabelGetCNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoopLabelGetCNumber0",err,error)
    CALL EXITS("CMISSControlLoopLabelGetCNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopLabelGetCNumber0

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a control loop identified by an user number.
  SUBROUTINE CMISSControlLoopLabelGetCNumber1(problemUserNumber,controlLoopIdentifiers,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the control loop label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopLabelGetCNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_LABEL_GET(CONTROL_LOOP,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopLabelGetCNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoopLabelGetCNumber1",err,error)
    CALL EXITS("CMISSControlLoopLabelGetCNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopLabelGetCNumber1

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a control loop identified by an object.
  SUBROUTINE CMISSControlLoopLabelGetCObj(controlLoop,label,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopLabelGetCObj",err,error,*999)

    CALL CONTROL_LOOP_LABEL_GET(controlLoop%CONTROL_LOOP,label,err,error,*999)

    CALL EXITS("CMISSControlLoopLabelGetCObj")
    RETURN
999 CALL ERRORS("CMISSControlLoopLabelGetCObj",err,error)
    CALL EXITS("CMISSControlLoopLabelGetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopLabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a control loop identified by an user number.
  SUBROUTINE CMISSControlLoopLabelGetVSNumber0(problemUserNumber,controlLoopIdentifier,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the control loop label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopLabelGetVSNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_LABEL_GET(CONTROL_LOOP,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopLabelGetVSNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoopLabelGetVSNumber0",err,error)
    CALL EXITS("CMISSControlLoopLabelGetVSNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopLabelGetVSNumber0

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a control loop identified by an user number.
  SUBROUTINE CMISSControlLoopLabelGetVSNumber1(problemUserNumber,controlLoopIdentifiers,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the control loop label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopLabelGetVSNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_LABEL_GET(CONTROL_LOOP,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopLabelGetVSNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoopLabelGetVSNumber1",err,error)
    CALL EXITS("CMISSControlLoopLabelGetVSNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopLabelGetVSNumber1

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a control loop identified by an object.
  SUBROUTINE CMISSControlLoopLabelGetVSObj(controlLoop,label,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the control loop label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopLabelGetVSObj",err,error,*999)

    CALL CONTROL_LOOP_LABEL_GET(controlLoop%CONTROL_LOOP,label,err,error,*999)

    CALL EXITS("CMISSControlLoopLabelGetVSObj")
    RETURN
999 CALL ERRORS("CMISSControlLoopLabelGetVSObj",err,error)
    CALL EXITS("CMISSControlLoopLabelGetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopLabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a control loop identified by an user number.
  SUBROUTINE CMISSControlLoopLabelSetCNumber0(problemUserNumber,controlLoopIdentifier,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopLabelSetCNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_LABEL_SET(CONTROL_LOOP,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopLabelSetCNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoopLabelSetCNumber0",err,error)
    CALL EXITS("CMISSControlLoopLabelSetCNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopLabelSetCNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a control loop identified by an user number.
  SUBROUTINE CMISSControlLoopLabelSetCNumber1(problemUserNumber,controlLoopIdentifiers,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopLabelSetCNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_LABEL_SET(CONTROL_LOOP,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopLabelSetCNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoopLabelSetCNumber1",err,error)
    CALL EXITS("CMISSControlLoopLabelSetCNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopLabelSetCNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a control loop identified by an object.
  SUBROUTINE CMISSControlLoopLabelSetCObj(controlLoop,label,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(IN) :: controlLoop !<The control loop to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The control loop label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopLabelSetCObj",err,error,*999)

    CALL CONTROL_LOOP_LABEL_SET(controlLoop%CONTROL_LOOP,label,err,error,*999)

    CALL EXITS("CMISSControlLoopLabelSetCObj")
    RETURN
999 CALL ERRORS("CMISSControlLoopLabelSetCObj",err,error)
    CALL EXITS("CMISSControlLoopLabelSetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopLabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a control loop identified by an user number.
  SUBROUTINE CMISSControlLoopLabelSetVSNumber0(problemUserNumber,controlLoopIdentifier,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The control loop label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopLabelSetVSNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_LABEL_SET(CONTROL_LOOP,CHAR(label),err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopLabelStVSNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoopLabelSetVSNumber0",err,error)
    CALL EXITS("CMISSControlLabelSetVSNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopLabelSetVSNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a control loop identified by an user number.
  SUBROUTINE CMISSControlLoopLabelSetVSNumber1(problemUserNumber,controlLoopIdentifiers,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The control loop label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopLabelSetVSNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_LABEL_SET(CONTROL_LOOP,CHAR(label),err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopLabelStVSNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoopLabelSetVSNumber1",err,error)
    CALL EXITS("CMISSControlLabelSetVSNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopLabelSetVSNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes string label for a control loop identified by an object.
  SUBROUTINE CMISSControlLoopLabelSetVSObj(controlLoop,label,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(IN) :: controlLoop !<The control loop to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The control loop label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopLabelSetVSObj",err,error,*999)

    CALL CONTROL_LOOP_LABEL_SET(controlLoop%CONTROL_LOOP,CHAR(label),err,error,*999)

    CALL EXITS("CMISSControlLoopLabelSetVSObj")
    RETURN
999 CALL ERRORS("CMISSControlLoopLabelSetVSObj",err,error)
    CALL EXITS("CMISSControlLoopLabelSetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopLabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum iterations for a while control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopMaximumIterationsSetNumber0(problemUserNumber,controlLoopIdentifier,maximumIterations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum iterations of the while control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopMaximumIterationsSetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_MAXIMUM_ITERATIONS_SET(CONTROL_LOOP,maximumIterations,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopMaximumIterationsSetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoopMaximumIterationsSetNumber0",err,error)
    CALL EXITS("CMISSControlLoopMaximumIterationsSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopMaximumIterationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum iterations for a while control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopMaximumIterationsSetNumber1(problemUserNumber,controlLoopIdentifiers,maximumIterations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum iterations of the while control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopMaximumIterationsSetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_MAXIMUM_ITERATIONS_SET(CONTROL_LOOP,maximumIterations,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopMaximumIterationsSetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoopMaximumIterationsSetNumber1",err,error)
    CALL EXITS("CMISSControlLoopMaximumIterationsSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopMaximumIterationsSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum iterations for a while control loop identified by an object.
  SUBROUTINE CMISSControlLoopMaximumIterationsSetObj(controlLoop,maximumIterations,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum iterations of the while control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopMaximumIterationsSetObj",err,error,*999)

    CALL CONTROL_LOOP_MAXIMUM_ITERATIONS_SET(controlLoop%CONTROL_LOOP,maximumIterations,err,error,*999)

    CALL EXITS("CMISSControlLoopMaximumIterationsSetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoopMaximumIterationsSetObj",err,error)
    CALL EXITS("CMISSControlLoopMaximumIterationsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopMaximumIterationsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of sub-control loops for a control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopNumberOfSubLoopsGetNumber0(problemUserNumber,controlLoopIdentifier,numberOfSubLoops,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the number of sub loops for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(OUT) :: numberOfSubLoops !<On return, the number of sub loops for the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopNumberOfSubLoopsGetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_NUMBER_OF_SUB_LOOPS_GET(CONTROL_LOOP,numberOfSubLoops,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopNumberOfSubLoopsGetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoopNumberOfSubLoopsGetNumber0",err,error)
    CALL EXITS("CMISSControlLoopNumberOfSubLoopsGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopNumberOfSubLoopsGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the number of sub-control loops for a control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopNumberOfSubLoopsGetNumber1(problemUserNumber,controlLoopIdentifiers,numberOfSubLoops,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the number of sub loops for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(OUT) :: numberOfSubLoops !<On return, the number of sub loops for the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopNumberOfSubLoopsGetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_NUMBER_OF_SUB_LOOPS_GET(CONTROL_LOOP,numberOfSubLoops,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopNumberOfSubLoopsGetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoopNumberOfSubLoopsGetNumber1",err,error)
    CALL EXITS("CMISSControlLoopNumberOfSubLoopsGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopNumberOfSubLoopsGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the number of sub-control loops for a control loop identified by an object.
  SUBROUTINE CMISSControlLoopNumberOfSubLoopsGetObj(controlLoop,numberOfSubLoops,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the number of sub loops for.
    INTEGER(INTG), INTENT(OUT) :: numberOfSubLoops !<On return, the number of sub loops for the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopNumberOfSubLoopsGetObj",err,error,*999)

    CALL CONTROL_LOOP_NUMBER_OF_SUB_LOOPS_GET(controlLoop%CONTROL_LOOP,numberOfSubLoops,err,error,*999)

    CALL EXITS("CMISSControlLoopNumberOfSubLoopsGetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoopNumberOfSubLoopsGetObj",err,error)
    CALL EXITS("CMISSControlLoopNumberOfSubLoopsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopNumberOfSubLoopsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of sub-control loops for a control loop identified by user numbers. \todo is this really public???
  SUBROUTINE CMISSControlLoopNumberOfSubLoopsSetNumber0(problemUserNumber,controlLoopIdentifier,numberOfSubLoops,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the number of sub loops for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: numberOfSubLoops !<The number of sub loops for the specified control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopNumberOfSubLoopsSetNumber",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_NUMBER_OF_SUB_LOOPS_SET(CONTROL_LOOP,numberOfSubLoops,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopNumberOfSubLoopsSetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoopNumberOfSubLoopsSetNumber0",err,error)
    CALL EXITS("CMISSControlLoopNumberOfSubLoopsSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopNumberOfSubLoopsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of sub-control loops for a control loop identified by user numbers. \todo is this really public???
  SUBROUTINE CMISSControlLoopNumberOfSubLoopsSetNumber1(problemUserNumber,controlLoopIdentifiers,numberOfSubLoops,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the number of sub loops for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: numberOfSubLoops !<The number of sub loops for the specified control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopNumberOfSubLoopsSetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_NUMBER_OF_SUB_LOOPS_SET(CONTROL_LOOP,numberOfSubLoops,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopNumberOfSubLoopsSetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoopNumberOfSubLoopsSetNumber1",err,error)
    CALL EXITS("CMISSControlLoopNumberOfSubLoopsSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopNumberOfSubLoopsSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of sub-control loops for a control loop identified by an object. \todo is this really public???
  SUBROUTINE CMISSControlLoopNumberOfSubLoopsSetObj(controlLoop,numberOfSubLoops,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the number of sub loops for.
    INTEGER(INTG), INTENT(IN) :: numberOfSubLoops !<The number of sub loops for the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopNumberOfSubLoopsSetObj",err,error,*999)

    CALL CONTROL_LOOP_NUMBER_OF_SUB_LOOPS_SET(controlLoop%CONTROL_LOOP,numberOfSubLoops,err,error,*999)

    CALL EXITS("CMISSControlLoopNumberOfSubLoopsSetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoopNumberOfSubLoopsSetObj",err,error)
    CALL EXITS("CMISSControlLoopNumberOfSubLoopsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopNumberOfSubLoopsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the output type for a control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopOutputTypeGetNumber0(problemUserNumber,controlLoopIdentifier,outputType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the output type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the control loop \see OPENCMISS_ControlLoopOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopOutputTypeGetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_OUTPUT_TYPE_GET(CONTROL_LOOP,outputType,err,error,*999)
   ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopOutputTypeGetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoopOutputTypeGetNumber0",err,error)
    CALL EXITS("CMISSControlLoopOutputTypeGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopOutputTypeGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the output type for a control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopOutputTypeGetNumber1(problemUserNumber,controlLoopIdentifiers,outputType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the output type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the control loop \see OPENCMISS_ControlLoopOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopOutputTypeGetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_OUTPUT_TYPE_GET(CONTROL_LOOP,outputType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopOutputTypeGetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoopOutputTypeGetNumber1",err,error)
    CALL EXITS("CMISSControlLoopOutputTypeGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopOutputTypeGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the output type for a control loop identified by an object.
  SUBROUTINE CMISSControlLoopOutputTypeGetObj(controlLoop,outputType,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the control loop \see OPENCMISS_ControlLoopOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopOutputTypeGetObj",err,error,*999)

    CALL CONTROL_LOOP_OUTPUT_TYPE_GET(controlLoop%CONTROL_LOOP,outputType,err,error,*999)

    CALL EXITS("CMISSControlLoopOutputTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoopOutputTypeGetObj",err,error)
    CALL EXITS("CMISSControlLoopOutputTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopOutputTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets the output type for a control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopOutputTypeSetNumber0(problemUserNumber,controlLoopIdentifier,outputType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the output type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type to set \see OPENCMISS_ControlLoopOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopOutputTypeSetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_OUTPUT_TYPE_SET(CONTROL_LOOP,outputType,err,error,*999)
   ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopOutputTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoopOutputTypeSetNumber0",err,error)
    CALL EXITS("CMISSControlLoopOutputTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopOutputTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets the output type for a control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopOutputTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,outputType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the output type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type to set \see OPENCMISS_ControlLoopOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopOutputTypeSetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_OUTPUT_TYPE_SET(CONTROL_LOOP,outputType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopOutputTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoopOutputTypeSetNumber1",err,error)
    CALL EXITS("CMISSControlLoopOutputTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopOutputTypeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets the output type for a control loop identified by an object.
  SUBROUTINE CMISSControlLoopOutputTypeSetObj(controlLoop,outputType,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(IN) :: controlLoop !<The control loop to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type to set \see OPENCMISS_ControlLoopOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopOutputTypeSetObj",err,error,*999)

    CALL CONTROL_LOOP_OUTPUT_TYPE_SET(controlLoop%CONTROL_LOOP,outputType,err,error,*999)

    CALL EXITS("CMISSControlLoopOutputTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoopOutputTypeSetObj",err,error)
    CALL EXITS("CMISSControlLoopOutputTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopOutputTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the output parameters for a time control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopTimeOutputSetNumber0(problemUserNumber,controlLoopIdentifier,outputFrequency,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the output parameters for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: outputFrequency !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopTimeOutputSetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_TIME_OUTPUT_SET(CONTROL_LOOP,outputFrequency,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopTimeOutputSetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoopTimeOutputSetNumber0",err,error)
    CALL EXITS("CMISSControlLoopTimeOutputSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopTimeOutputSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the output parameters for a time control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopTimeOutputSetNumber1(problemUserNumber,controlLoopIdentifiers,outputFrequency,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the output parameters for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: outputFrequency !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM

    CALL ENTERS("CMISSControlLoopTimeOutputSetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_TIME_OUTPUT_SET(CONTROL_LOOP,outputFrequency,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopTimeOutputSetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoopTimeOutputSetNumber1",err,error)
    CALL EXITS("CMISSControlLoopTimeOutputSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopTimeOutputSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the output parameters for a time control loop identified by an object.
  SUBROUTINE CMISSControlLoopTimeOutputSetObj(controlLoop,outputFrequency,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the output parameters for.
    INTEGER(INTG), INTENT(IN) ::  outputFrequency !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopTimeOutputSetObj",err,error,*999)

    CALL CONTROL_LOOP_TIME_OUTPUT_SET(controlLoop%CONTROL_LOOP,outputFrequency,err,error,*999)

    CALL EXITS("CMISSControlLoopTimeOutputSetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoopTimeOutputSetObj",err,error)
    CALL EXITS("CMISSControlLoopTimeOuputSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopTimeOutputSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the input parameters for a time control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopTimeInputSetNumber0(problemUserNumber,controlLoopIdentifier,inputOption,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the output parameters for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: inputOption !<The input option modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopTimeInputSetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_TIME_OUTPUT_SET(CONTROL_LOOP,inputOption,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopTimeInputSetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoopTimeInputSetNumber0",err,error)
    CALL EXITS("CMISSControlLoopTimeInputSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopTimeInputSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the input parameters for a time control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopTimeInputSetNumber1(problemUserNumber,controlLoopIdentifiers,inputOption,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the output parameters for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: inputOption !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM

    CALL ENTERS("CMISSControlLoopTimeInputSetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_TIME_OUTPUT_SET(CONTROL_LOOP,inputOption,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopTimeInputSetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoopTimeInputSetNumber1",err,error)
    CALL EXITS("CMISSControlLoopTimeInputSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopTimeInputSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the input parameters for a time control loop identified by an object.
  SUBROUTINE CMISSControlLoopTimeInputSetObj(controlLoop,inputOption,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the output parameters for.
    INTEGER(INTG), INTENT(IN) ::  inputOption !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopTimeInputSetObj",err,error,*999)

    CALL CONTROL_LOOP_TIME_INPUT_SET(controlLoop%CONTROL_LOOP,inputOption,err,error,*999)

    CALL EXITS("CMISSControlLoopTimeInputSetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoopTimeInputSetObj",err,error)
    CALL EXITS("CMISSControlLoopTimeInputSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopTimeInputSetObj


  !
  !================================================================================================================================
  !

  !>Returns the time parameters for a time control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopTimesGetNumber0(problemUserNumber,controlLoopIdentifier,startTime,stopTime,timeIncrement, &
    & currentTime,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the time parameters for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    REAL(DP), INTENT(OUT) :: startTime !<On return, the start time for the time control loop.
    REAL(DP), INTENT(OUT) :: stopTime !<On return, the stop time for the time control loop.
    REAL(DP), INTENT(OUT) :: timeIncrement !<On return, the time increment for the time control loop.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the current time for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopTimesGetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_TIMES_GET(CONTROL_LOOP,startTime,stopTime,timeIncrement,currentTime,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopTimesGetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoopTimesGetNumber0",err,error)
    CALL EXITS("CMISSControlLoopTimesGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopTimesGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the time parameters for a time control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopTimesGetNumber1(problemUserNumber,controlLoopIdentifiers,startTime,stopTime,timeIncrement, &
    & currentTime,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the time parameters for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    REAL(DP), INTENT(OUT) :: startTime !<On return, the start time for the time control loop.
    REAL(DP), INTENT(OUT) :: stopTime !<On return, the stop time for the time control loop.
    REAL(DP), INTENT(OUT) :: timeIncrement !<On return, the time increment for the time control loop.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the current time for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopTimesGetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_TIMES_GET(CONTROL_LOOP,startTime,stopTime,timeIncrement,currentTime,err,error,*999)
   ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopTimesGetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoopTimesGetNumber1",err,error)
    CALL EXITS("CMISSControlLoopTimesGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopTimesGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the time parameters for a time control loop identified by an object.
  SUBROUTINE CMISSControlLoopTimesGetObj(controlLoop,startTime,stopTime,timeIncrement,currentTime,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the times for.
    REAL(DP), INTENT(OUT) :: startTime !<On return, the start time for the time control loop.
    REAL(DP), INTENT(OUT) :: stopTime !<On return, the stop time for the time control loop.
    REAL(DP), INTENT(OUT) :: timeIncrement !<On return, the time increment for the time control loop.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the current time for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopTimesGetObj",err,error,*999)

    CALL CONTROL_LOOP_TIMES_GET(controlLoop%CONTROL_LOOP,startTime,stopTime,timeIncrement,currentTime,err,error,*999)

    CALL EXITS("CMISSControlLoopTimesGetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoopTimesGetObj",err,error)
    CALL EXITS("CMISSControlLoopTimesGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopTimesGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the time parameters for a time control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopTimesSetNumber0(problemUserNumber,controlLoopIdentifier,startTime,stopTime,timeIncrement,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the time parameters for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    REAL(DP), INTENT(IN) :: startTime !<The start time for the time control loop to set.
    REAL(DP), INTENT(IN) :: stopTime !<The stop time for the time control loop to set.
    REAL(DP), INTENT(IN) :: timeIncrement !<The time increment for the time control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopTimesSetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_TIMES_SET(CONTROL_LOOP,startTime,stopTime,timeIncrement,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopTimesSetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoopTimesSetNumber0",err,error)
    CALL EXITS("CMISSControlLoopTimesSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopTimesSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the time parameters for a time control loop identified by user numbers.
  SUBROUTINE CMISSControlLoopTimesSetNumber1(problemUserNumber,controlLoopIdentifiers,startTime,stopTime,timeIncrement,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the time parameters for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    REAL(DP), INTENT(IN) :: startTime !<The start time for the time control loop to set.
    REAL(DP), INTENT(IN) :: stopTime !<The stop time for the time control loop to set.
    REAL(DP), INTENT(IN) :: timeIncrement !<The time increment for the time control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM

    CALL ENTERS("CMISSControlLoopTimesSetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_TIMES_SET(CONTROL_LOOP,startTime,stopTime,timeIncrement,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopTimesSetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoopTimesSetNumber1",err,error)
    CALL EXITS("CMISSControlLoopTimesSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopTimesSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the time parameters for a time control loop identified by an object.
  SUBROUTINE CMISSControlLoopTimesSetObj(controlLoop,startTime,stopTime,timeIncrement,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the times for.
    REAL(DP), INTENT(IN) :: startTime !<The start time for the time control loop to set.
    REAL(DP), INTENT(IN) :: stopTime !<The stop time for the time control loop to set.
    REAL(DP), INTENT(IN) :: timeIncrement !<The time increment for the time control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopTimesSetObj",err,error,*999)

    CALL CONTROL_LOOP_TIMES_SET(controlLoop%CONTROL_LOOP,startTime,stopTime,timeIncrement,err,error,*999)

    CALL EXITS("CMISSControlLoopTimesSetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoopTimesSetObj",err,error)
    CALL EXITS("CMISSControlLoopTimesSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopTimesSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the loop type for a control loop identified by user numbers. \todo is this really public???
  SUBROUTINE CMISSControlLoopTypeSetNumber0(problemUserNumber,controlLoopIdentifier,loopType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the loop type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: loopType !<The type of control loop to set. \see OPENCMISS_ProblemControlLoopTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopTypeSetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_TYPE_SET(CONTROL_LOOP,loopType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoopTypeSetNumber0",err,error)
    CALL EXITS("CMISSControlLoopTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the loop type for a control loop identified by user numbers. \todo is this really public???
  SUBROUTINE CMISSControlLoopTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,loopType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the loop type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: loopType !<The type of control loop to set. \see OPENCMISS_ProblemControlLoopTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopTypeSetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_TYPE_SET(CONTROL_LOOP,loopType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSControlLoopTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoopTypeSetNumber1",err,error)
    CALL EXITS("CMISSControlLoopTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopTypeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the loop type for a control loop identified by an object. \todo is this really public???
  SUBROUTINE CMISSControlLoopTypeSetObj(controlLoop,loopType,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the loop type for.
    INTEGER(INTG), INTENT(IN) :: loopType !<The type of control loop to set. \see OPENCMISS_ProblemControlLoopTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoopTypeSetObj",err,error,*999)

    CALL CONTROL_LOOP_TYPE_SET(controlLoop%CONTROL_LOOP,loopType,err,error,*999)

    CALL EXITS("CMISSControlLoopTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoopTypeSetObj",err,error)
    CALL EXITS("CMISSControlLoopTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoopTypeSetObj

!!==================================================================================================================================
!!
!! COORDINATE_ROUTINES
!!
!!==================================================================================================================================

  !>Finishes the creation of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystemCreateFinishNumber(coordinateSystemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystemCreateFinishNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_CREATE_FINISH(COORDINATE_SYSTEM,err,error,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Coordinate System Create')
#endif

    CALL EXITS("CMISSCoordinateSystemCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemCreateFinishNumber",err,error)
    CALL EXITS("CMISSCoordinateSystemCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystemCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystemCreateFinishObj(coordinateSystem,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<The coordinate system to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystemCreateFinishObj",err,error,*999)

    CALL COORDINATE_SYSTEM_CREATE_FINISH(coordinateSystem%COORDINATE_SYSTEM,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Coordinate System Create')
#endif

    CALL EXITS("CMISSCoordinateSystemCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemCreateFinishObj",err,error)
    CALL EXITS("CMISSCoordinateSystemCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystemCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystemCreateStartNumber(coordinateSystemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to start creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM

    CALL ENTERS("CMISSCoordinateSystemCreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Coordinate System Create')
#endif

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_CREATE_START(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)

    CALL EXITS("CMISSCoordinateSystemCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemCreateStartNumber",err,error)
    CALL EXITS("CMISSCoordinateSystemCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystemCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystemCreateStartObj(coordinateSystemUserNumber,coordinateSystem,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to start creating.
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<On return, the coordinate system that has been created.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystemCreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Coordinate System Create')
#endif

    CALL COORDINATE_SYSTEM_CREATE_START(coordinateSystemUserNumber,coordinateSystem%COORDINATE_SYSTEM,err,error,*999)

    CALL EXITS("CMISSCoordinateSystemCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemCreateStartObj",err,error)
    CALL EXITS("CMISSCoordinateSystemCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystemCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystemDestroyNumber(coordinateSystemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystemDestroyNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_DESTROY(COORDINATE_SYSTEM,err,error,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCoordinateSystemDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemDestroyNumber",err,error)
    CALL EXITS("CMISSCoordinateSystemDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystemDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystemDestroyObj(coordinateSystem,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<The coordinate system to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSysteDestroyObj",err,error,*999)

    CALL COORDINATE_SYSTEM_DESTROY(coordinateSystem%COORDINATE_SYSTEM,err,error,*999)

    CALL EXITS("CMISSCoordinateSystemDestroyObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemDestroyObj",err,error)
    CALL EXITS("CMISSCoordinateSystemDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystemDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the dimension of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystemDimensionGetNumber(coordinateSystemUserNumber,coordinateSystemDimension,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to get the dimension for.
    INTEGER(INTG), INTENT(OUT) :: coordinateSystemDimension !<On return, the dimension of the coordinate system
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystemDimensionGetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_DIMENSION_GET(COORDINATE_SYSTEM,coordinateSystemDimension,err,error,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCoordinateSystemDimensionGetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemDimensionGetNumber",err,error)
    CALL EXITS("CMISSCoordinateSystemDimensionGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystemDimensionGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the dimension of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystemDimensionGetObj(coordinateSystem,coordinateSystemDimension,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to get the dimension for.
    INTEGER(INTG), INTENT(OUT) :: coordinateSystemDimension !<On return, the dimension of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystemDimensionGetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_DIMENSION_GET(coordinateSystem%COORDINATE_SYSTEM,coordinateSystemDimension,err,error,*999)

    CALL EXITS("CMISSCoordinateSystemDimensionGetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemDimensionGetObj",err,error)
    CALL EXITS("CMISSCoordinateSystemDimensionGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystemDimensionGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the dimension of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystemDimensionSetNumber(coordinateSystemUserNumber,coordinateSystemDimension,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set the dimension for.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemDimension !<The dimension of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystemDimensionSetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_DIMENSION_SET(COORDINATE_SYSTEM,coordinateSystemDimension,err,error,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCoordinateSystemDimensionSetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemDimensionSetNumber",err,error)
    CALL EXITS("CMISSCoordinateSystemDimensionSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystemDimensionSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the dimension of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystemDimensionSetObj(coordinateSystem,coordinateSystemDimension,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT)  :: coordinateSystem !<The coordinate system to set the dimension for.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemDimension !<The dimension of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystemDimensionSetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_DIMENSION_SET(coordinateSystem%COORDINATE_SYSTEM,coordinateSystemDimension,err,error,*999)

    CALL EXITS("CMISSCoordinateSystemDimensionSetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemDimensionSetObj",err,error)
    CALL EXITS("CMISSCoordinateSystemDimensionSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystemDimensionSetObj

  !
  !================================================================================================================================
  !

  !>Returns the focus of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystemFocusGetNumber(coordinateSystemUserNumber,focus,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to get the focus for.
    REAL(DP), INTENT(OUT) :: focus !<On return, the focus of the coordinate system
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystemFocusGetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_FOCUS_GET(COORDINATE_SYSTEM,focus,err,error,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCoordinateSystemFocusGetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemFocusGetNumber",err,error)
    CALL EXITS("CMISSCoordinateSystemFocusGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystemFocusGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the focus of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystemFocusGetObj(coordinateSystem,focus,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to get the focus for.
    REAL(DP), INTENT(OUT) :: focus !<On return, the focus of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystemFocusGetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_FOCUS_GET(coordinateSystem%COORDINATE_SYSTEM,focus,err,error,*999)

    CALL EXITS("CMISSCoordinateSystemFocusGetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemFocusGetObj",err,error)
    CALL EXITS("CMISSCoordinateSystemFocusGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystemFocusGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the focus of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystemFocusSetNumber(coordinateSystemUserNumber,focus,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set the focus for.
    REAL(DP), INTENT(IN) :: focus !<The focus of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystemFocusSetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_FOCUS_SET(COORDINATE_SYSTEM,focus,err,error,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCoordinateSystemFocusSetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemFocusSetNumber",err,error)
    CALL EXITS("CMISSCoordinateSystemFocusSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystemFocusSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the focus of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystemFocusSetObj(coordinateSystem,focus,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<The coordinate system to set the focus for.
    REAL(DP), INTENT(IN) :: focus !<The focus of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystemFocusSetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_FOCUS_SET(coordinateSystem%COORDINATE_SYSTEM,focus,err,error,*999)

    CALL EXITS("CMISSCoordinateSystemFocusSetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemFocusSetObj",err,error)
    CALL EXITS("CMISSCoordinateSystemFocusSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystemFocusSetObj

  !
  !================================================================================================================================
  !

  !>Returns the radial interpolation type of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystemRadialInterpolationGetNumber(coordinateSystemUserNumber,radialInterpolationType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to get the radial interpolation for.
    INTEGER(INTG), INTENT(OUT) :: radialInterpolationType !<On return, the radial interpolation type of the coordinate system \see OPENCMISS_CoordinateRadialInterpolations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystemRadialInterpolationGetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_RADIAL_INTERPOLATION_TYPE_GET(COORDINATE_SYSTEM,radialInterpolationType,err,error,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCoordinateSystemRadialInterpolationGetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemRadialInterpolationGetNumber",err,error)
    CALL EXITS("CMISSCoordinateSystemRadialInterpolationGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystemRadialInterpolationGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the radial interpolation type of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystemRadialInterpolationGetObj(coordinateSystem,radialInterpolationType,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<The coordinate system to get the radial interpolation type for.
    INTEGER(INTG), INTENT(OUT) :: radialInterpolationType !<On return, the radial interpolation type of the coordinate system. \see OPENCMISS_CoordinateRadialInterpolations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystemRadialInterpolationGetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_RADIAL_INTERPOLATION_TYPE_GET(coordinateSystem%COORDINATE_SYSTEM,radialInterpolationType,err,error,*999)

    CALL EXITS("CMISSCoordinateSystemRadialInterpolationGetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemRadialInterpolationGetObj",err,error)
    CALL EXITS("CMISSCoordinateSystemRadialInterpolationGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystemRadialInterpolationGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the radial interpolation type of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystemRadialInterpolationSetNumber(coordinateSystemUserNumber,radialInterpolationType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set the radial interpolation for.
    INTEGER(INTG), INTENT(IN) :: radialInterpolationType !<The radial interpolation type of the coordinate system to set.\see OPENCMISS_CoordinateRadialInterpolations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystemRadialInterpolationSetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_RADIAL_INTERPOLATION_TYPE_SET(COORDINATE_SYSTEM,radialInterpolationType,err,error,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCoordinateSystemRadialInterpolationSetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemRadialInterpolationSetNumber",err,error)
    CALL EXITS("CMISSCoordinateSystemRadialInterpolationSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystemRadialInterpolationSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the radial interpolation type of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystemRadialInterpolationSetObj(coordinateSystem,radialInterpolationType,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT)  :: coordinateSystem !<The coordinate system to set the radial interpolation type for.
    INTEGER(INTG), INTENT(IN) :: radialInterpolationType !<The radial interpolation type of the coordinate system to set. \see OPENCMISS_CoordinateRadialInterpolations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystemRadialInterpolationSetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_RADIAL_INTERPOLATION_TYPE_SET(coordinateSystem%COORDINATE_SYSTEM,radialInterpolationType,err,error,*999)

    CALL EXITS("CMISSCoordinateSystemRadialInterpolationSetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemRadialInterpolationSetObj",err,error)
    CALL EXITS("CMISSCoordinateSystemRadialInterpolationSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystemRadialInterpolationSetObj

  !
  !================================================================================================================================
  !

  !>Returns the type of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystemTypeGetNumber(coordinateSystemUserNumber,coordinateSystemType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to get the type for.
    INTEGER(INTG), INTENT(OUT) :: coordinateSystemType !<On return, the type of the coordinate system. \see OPENCMISS_CoordinateSystemTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystemTypeGetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_TYPE_GET(COORDINATE_SYSTEM,coordinateSystemType,err,error,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCoordinateSystemTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemTypeGetNumber",err,error)
    CALL EXITS("CMISSCoordinateSystemTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystemTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the type of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystemTypeGetObj(coordinateSystem,coordinateSystemType,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to get the type for.
    INTEGER(INTG), INTENT(OUT) :: coordinateSystemType !<On return, the type of the coordinate system. \see OPENCMISS_CoordinateSystemTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystemTypeGetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_TYPE_GET(coordinateSystem%COORDINATE_SYSTEM,coordinateSystemType,err,error,*999)

    CALL EXITS("CMISSCoordinateSystemTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemTypeGetObj",err,error)
    CALL EXITS("CMISSCoordinateSystemTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystemTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystemTypeSetNumber(coordinateSystemUserNumber,coordinateSystemType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set the type for.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemType !<The type of the coordinate system to set. \see OPENCMISS_CoordinateSystemTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystemTypeSetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_TYPE_SET(COORDINATE_SYSTEM,coordinateSystemType,err,error,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCoordinateSystemTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemTypeSetNumber",err,error)
    CALL EXITS("CMISSCoordinateSystemTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystemTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystemTypeSetObj(coordinateSystem,coordinateSystemType,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<The coordinate system to set the type for.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemType !<The type of the coordinate system to set. \see OPENCMISS_CoordinateSystemTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystemTypeSetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_TYPE_SET(coordinateSystem%COORDINATE_SYSTEM,coordinateSystemType,err,error,*999)

    CALL EXITS("CMISSCoordinateSystemTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemTypeSetObj",err,error)
    CALL EXITS("CMISSCoordinateSystemTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystemTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the origin of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystemOriginGetNumber(coordinateSystemUserNumber,origin,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to get the origin for.
    REAL(DP), INTENT(OUT) :: origin(:) !<On return, the orign of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystemOriginGetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_ORIGIN_GET(COORDINATE_SYSTEM,origin,err,error,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCoordinateSystemOriginGetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemOriginGetNumber",err,error)
    CALL EXITS("CMISSCoordinateSystemOriginGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystemOriginGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the origin of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystemOriginGetObj(coordinateSystem,origin,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to get the origin for.
    REAL(DP), INTENT(OUT) :: origin(:) !<On return, the origin of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystemOriginGetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_ORIGIN_GET(coordinateSystem%COORDINATE_SYSTEM,origin,err,error,*999)

    CALL EXITS("CMISSCoordinateSystemOriginGetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemOriginGetObj",err,error)
    CALL EXITS("CMISSCoordinateSystemOriginGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystemOriginGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the origin of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystemOriginSetNumber(coordinateSystemUserNumber,origin,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set the origin for.
    REAL(DP), INTENT(IN) :: origin(:) !<The orign of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystemOriginSetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_ORIGIN_SET(COORDINATE_SYSTEM,origin,err,error,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCoordinateSystemOriginSetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemOriginSetNumber",err,error)
    CALL EXITS("CMISSCoordinateSystemOriginSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystemOriginSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the origin of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystemOriginSetObj(coordinateSystem,origin,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to set the origin for.
    REAL(DP), INTENT(IN) :: origin(:) !<The origin of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystemOriginSetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_ORIGIN_SET(coordinateSystem%COORDINATE_SYSTEM,origin,err,error,*999)

    CALL EXITS("CMISSCoordinateSystemOriginSetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemOriginSetObj",err,error)
    CALL EXITS("CMISSCoordinateSystemOriginSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystemOriginSetObj

  !
  !================================================================================================================================
  !

  !>Returns the orientation of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystemOrientationGetNumber(coordinateSystemUserNumber,orientation,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to get the orientation for.
    REAL(DP), INTENT(OUT) :: orientation(:,:) !<On return, the orientation of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystemOrientationGetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_ORIENTATION_GET(COORDINATE_SYSTEM,ORIENTATION,err,error,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCoordinateSystemOrientationGetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemOrientationGetNumber",err,error)
    CALL EXITS("CMISSCoordinateSystemOrientationGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystemOrientationGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the orientation of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystemOrientationGetObj(coordinateSystem,orientation,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to get the orientation for.
    REAL(DP), INTENT(OUT) :: orientation(:,:) !<On return, the orientation of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystemOrientationGetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_ORIENTATION_GET(coordinateSystem%COORDINATE_SYSTEM,orientation,err,error,*999)

    CALL EXITS("CMISSCoordinateSystemOrientationGetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemOrientationGetObj",err,error)
    CALL EXITS("CMISSCoordinateSystemOrientationGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystemOrientationGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the orientation of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystemOrientationSetNumber(coordinateSystemUserNumber,orientation,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set the orientation for.
    REAL(DP), INTENT(IN) :: orientation(:,:) !<The orientation of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystemOrientationSetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_ORIENTATION_SET(COORDINATE_SYSTEM,ORIENTATION,err,error,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCoordinateSystemOrientationSetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemOrientationSetNumber",err,error)
    CALL EXITS("CMISSCoordinateSystemOrientationSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystemOrientationSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the orientation of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystemOrientationSetObj(coordinateSystem,orientation,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<The coordinate system to set the orientation for.
    REAL(DP), INTENT(IN) :: orientation(:,:) !<The orientation of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystemOrientationSetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_ORIENTATION_SET(coordinateSystem%COORDINATE_SYSTEM,orientation,err,error,*999)

    CALL EXITS("CMISSCoordinateSystemOrientationSetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystemOrientationSetObj",err,error)
    CALL EXITS("CMISSCoordinateSystemOrientationSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystemOrientationSetObj

!!==================================================================================================================================
!!
!! DATA_POINT_ROUTINES
!!
!!==================================================================================================================================

  !>Finishes the process of creating data points in a region for data points identified by user number.
  SUBROUTINE CMISSDataPointsCreateFinishNumber(regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPointsCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_CREATE_FINISH(DATA_POINTS,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataPointsCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSDataPointsCreateFinishNumber",err,error)
    CALL EXITS("CMISSDataPointsCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a data points in a region for data points identified by an object.
  SUBROUTINE CMISSDataPointsCreateFinishObj(dataPoints,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPointsCreateFinishObj",err,error,*999)

    CALL DATA_POINTS_CREATE_FINISH(dataPoints%DATA_POINTS,err,error,*999)

    CALL EXITS("CMISSDataPointsCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSDataPointsCreateFinishObj",err,error)
    CALL EXITS("CMISSDataPointsCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of creating data points in a region for data points identified by user number.
  SUBROUTINE CMISSDataPointsCreateStartNumber(regionUserNumber,numberOfDataPoints,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to start the creation of.
    INTEGER(INTG), INTENT(IN) :: numberOfDataPoints !<The number of data points to create.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPointsCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL DATA_POINTS_CREATE_START(REGION,numberOfDataPoints,DATA_POINTS,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataPointsCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSDataPointsCreateStartNumber",err,error)
    CALL EXITS("CMISSDataPointsCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a data points in a region for data points identified by an object.
  SUBROUTINE CMISSDataPointsCreateStartObj(region,numberOfDataPoints,dataPoints,err)

    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region to start the creation of data points on.
    INTEGER(INTG), INTENT(IN) :: numberOfDataPoints !<The number of data points to create.
    TYPE(CMISSDataPointsType), INTENT(INOUT) :: dataPoints !<On return, the created data points.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPointsCreateStartObj",err,error,*999)

    CALL DATA_POINTS_CREATE_START(region%REGION,numberOfDataPoints,dataPoints%DATA_POINTS,err,error,*999)

    CALL EXITS("CMISSDataPointsCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSDataPointsCreateStartObj",err,error)
    CALL EXITS("CMISSDataPointsCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a data points in a region for data points identified by an object.
  SUBROUTINE CMISSDataPointsCreateStartInterfaceObj(iNTERFACE,numberOfDataPoints,dataPoints,err)

    !Argument variables
    TYPE(CMISSInterfaceType), INTENT(IN) :: iNTERFACE !<The interface to start the creation of data points on.
    INTEGER(INTG), INTENT(IN) :: numberOfDataPoints !<The number of data points to create.
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<On return, the created data points.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPointsCreateStartInterfaceObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('dataPoints Create')
#endif

    CALL DATA_POINTS_CREATE_START(Interface%iNTERFACE,numberOfDataPoints,dataPoints%DATA_POINTS,err,error,*999)

    CALL EXITS("CMISSDataPointsCreateStartInterfaceObj")
    RETURN
999 CALL ERRORS("CMISSDataPointsCreateStartInterfaceObj",err,error)
    CALL EXITS("CMISSDataPointsCreateStartInterfaceObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsCreateStartInterfaceObj


  !
  !================================================================================================================================
  !

  !>Destroys the data points in a region for data points identified by user number.
  SUBROUTINE CMISSDataPointsDestroyNumber(regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPointsDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DESTROY(DATA_POINTS,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataPointsDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSDataPointsDestroyNumber",err,error)
    CALL EXITS("CMISSDataPointsDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the data points in a region for data points identified by an object.
  SUBROUTINE CMISSDataPointsDestroyObj(dataPoints,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPointsDestroyObj",err,error,*999)

    CALL DATA_POINTS_DESTROY(dataPoints%DATA_POINTS,err,error,*999)

    CALL EXITS("CMISSDataPointsDestroyObj")
    RETURN
999 CALL ERRORS("CMISSDataPointsDestroyObj",err,error)
    CALL EXITS("CMISSDataPointsDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the number of data points
  SUBROUTINE CMISSDataPointsNumberOfDataPointsGetNumber(regionUserNumber,numberOfDataPoints,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get data point count for.
    INTEGER(INTG), INTENT(OUT) :: numberOfDataPoints !<On return, the number of data points
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPointsNumberOfDataPointsGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_NUMBER_OF_DATA_POINTS_GET(DATA_POINTS,numberOfDataPoints,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataPointsNumberOfDataPointsGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataPointsNumberOfDataPointsGetNumber",err,error)
    CALL EXITS("CMISSDataPointsNumberOfDataPointsGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsNumberOfDataPointsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of data points
  SUBROUTINE CMISSDataPointsNumberOfDataPointsGetObj(dataPoints,numberOfDataPoints,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points get data point count for.
    INTEGER(INTG), INTENT(OUT) :: numberOfDataPoints !<The number of data points
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPointsNumberOfDataPointsGetObj",err,error,*999)

    CALL DATA_POINTS_NUMBER_OF_DATA_POINTS_GET(dataPoints%DATA_POINTS,numberOfDataPoints,err,error,*999)

    CALL EXITS("CMISSDataPointsNumberOfDataPointsGetObj")
    RETURN
999 CALL ERRORS("CMISSDataPointsNumberOfDataPointsGetObj",err,error)
    CALL EXITS("CMISSDataPointsNumberOfDataPointsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsNumberOfDataPointsGetObj


  !
  !================================================================================================================================
  !

  !>Returns the character label for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataPointsLabelGetCNumber(regionUserNumber,dataPointGlobalNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the label for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPointsLabelGetCNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_LABEL_GET(DATA_POINTS,dataPointGlobalNumber,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataPointsLabelGetCNumber")
    RETURN
999 CALL ERRORS("CMISSDataPointsLabelGetCNumber",err,error)
    CALL EXITS("CMISSDataPointsLabelGetCNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsLabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character label for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataPointsLabelGetCObj(dataPoints,dataPointGlobalNumber,label,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points to get the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the label for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPointsLabelGetCObj",err,error,*999)

    CALL DATA_POINTS_LABEL_GET(dataPoints%DATA_POINTS,dataPointGlobalNumber,label,err,error,*999)

    CALL EXITS("CMISSDataPointsLabelGetCObj")
    RETURN
999 CALL ERRORS("CMISSDataPointsLabelGetCObj",err,error)
    CALL EXITS("CMISSDataPointsLabelGetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsLabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataPointsLabelGetVSNumber(regionUserNumber,dataPointGlobalNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the label for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPointsLabelGetVSNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_LABEL_GET(DATA_POINTS,dataPointGlobalNumber,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataPointsLabelGetVSNumber")
    RETURN
999 CALL ERRORS("CMISSDataPointsLabelGetVSNumber",err,error)
    CALL EXITS("CMISSDataPointsLabelGetVSNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsLabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataPointsLabelGetVSObj(dataPoints,dataPointGlobalNumber,label,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points to get the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the label for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPointsLabelGetVSObj",err,error,*999)

    CALL DATA_POINTS_LABEL_GET(dataPoints%DATA_POINTS,dataPointGlobalNumber,label,err,error,*999)

    CALL EXITS("CMISSDataPointsLabelGetVSObj")
    RETURN
999 CALL ERRORS("CMISSDataPointsLabelGetVSObj",err,error)
    CALL EXITS("CMISSDataPointsLabelGetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsLabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character label for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataPointsLabelSetCNumber(regionUserNumber,dataPointGlobalNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to set the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The label for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPointsLabelSetCNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_LABEL_SET(DATA_POINTS,dataPointGlobalNumber,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataPointsLabelSetCNumber")
    RETURN
999 CALL ERRORS("CMISSDataPointsLabelSetCNumber",err,error)
    CALL EXITS("CMISSDataPointsLabelSetCNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsLabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character label for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataPointsLabelSetCObj(dataPoints,dataPointGlobalNumber,label,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points to set the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The label for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPointsLabelSetCObj",err,error,*999)

    CALL DATA_POINTS_LABEL_SET(dataPoints%DATA_POINTS,dataPointGlobalNumber,label,err,error,*999)

    CALL EXITS("CMISSDataPointsLabelSetCObj")
    RETURN
999 CALL ERRORS("CMISSDataPointsLabelSetCObj",err,error)
    CALL EXITS("CMISSDataPointsLabelSetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsLabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataPointsLabelSetVSNumber(regionUserNumber,dataPointGlobalNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to set the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The label for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPointsLabelSetVSNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_LABEL_SET(DATA_POINTS,dataPointGlobalNumber,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataPointsLabelSetVSNumber")
    RETURN
999 CALL ERRORS("CMISSDataPointsLabelSetVSNumber",err,error)
    CALL EXITS("CMISSDataPointsLabelSetVSNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsLabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataPointsLabelSetVSObj(dataPoints,dataPointGlobalNumber,label,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points to set the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The label for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPointsLabelSetVSObj",err,error,*999)

    CALL DATA_POINTS_LABEL_SET(dataPoints%DATA_POINTS,dataPointGlobalNumber,label,err,error,*999)

    CALL EXITS("CMISSDataPointsLabelSetVSObj")
    RETURN
999 CALL ERRORS("CMISSDataPointsLabelSetVSObj",err,error)
    CALL EXITS("CMISSDataPointsLabelSetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsLabelSetVSObj


  !
  !================================================================================================================================
  !

  !>Returns the projection distance for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataPointsProjectionDistanceGetNumber(regionUserNumber,dataPointGlobalNumber,dataPointProjectionDistance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point user number for.
    REAL(DP), INTENT(OUT) :: dataPointProjectionDistance !<On return, the projection distance for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPointsProjectionDistanceGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_PROJECTION_DISTANCE_GET(DATA_POINTS,dataPointGlobalNumber,dataPointProjectionDistance,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataPointsProjectionDistanceGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataPointsProjectionDistanceGetNumber",err,error)
    CALL EXITS("CMISSDataPointsProjectionDistanceGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsProjectionDistanceGetNumber


   !
   !================================================================================================================================
   !

  !>Returns the projection distance for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataPointsProjectionDistanceGetObj(dataPoints,dataPointGlobalNumber,dataPointProjectionDistance,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point user number for.
    REAL(DP), INTENT(OUT) :: dataPointProjectionDistance !<On return, the projection distance for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPointsProjectionDistanceGetObj",err,error,*999)

    CALL DATA_POINTS_PROJECTION_DISTANCE_GET(dataPoints%DATA_POINTS,dataPointGlobalNumber,dataPointProjectionDistance, &
      & err,error,*999)

    CALL EXITS("CMISSDataPointsProjectionDistanceGetObj")
    RETURN
999 CALL ERRORS("CMISSDataPointsProjectionDistanceGetObj",err,error)
    CALL EXITS("CMISSDataPointsProjectionDistanceGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsProjectionDistanceGetObj

  !
  !================================================================================================================================
  !

  !>Returns the projection element number for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataPointsProjectionElementNumberGetNumber(regionUserNumber,dataPointGlobalNumber, &
    & dataPointProjectionElementNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point user number for.
    INTEGER(INTG), INTENT(OUT) :: dataPointProjectionElementNumber !<On return, the projection element number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPointsProjectionElementNumberGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_PROJECTION_ELEMENT_NUMBER_GET(DATA_POINTS,dataPointGlobalNumber,dataPointProjectionElementNumber, &
        & err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataPointsProjectionElementNumberGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataPointsProjectionElementNumberGetNumber",err,error)
    CALL EXITS("CMISSDataPointsProjectionElementNumberGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsProjectionElementNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection element number for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataPointsProjectionElementNumberGetObj(dataPoints,dataPointGlobalNumber,dataPointProjectionElementNumber,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point user number for.
    INTEGER(INTG), INTENT(OUT) :: dataPointProjectionElementNumber !<On return, the projection element number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPointsProjectionElementNumberGetObj",err,error,*999)

    CALL DATA_POINTS_PROJECTION_ELEMENT_NUMBER_GET(dataPoints%DATA_POINTS,dataPointGlobalNumber,dataPointProjectionElementNumber, &
      & err,error,*999)

    CALL EXITS("CMISSDataPointsProjectionElementNumberGetObj")
    RETURN
999 CALL ERRORS("CMISSDataPointsProjectionElementNumberGetObj",err,error)
    CALL EXITS("CMISSDataPointsProjectionElementNumberGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsProjectionElementNumberGetObj

  !
  !================================================================================================================================
  !

  !>Returns the projection element face number for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataPointsProjectionElementFaceNumberGetNumber(regionUserNumber,dataPointGlobalNumber, &
    & dataPointProjectionElementFaceNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point user number for.
    INTEGER(INTG), INTENT(OUT) :: dataPointProjectionElementFaceNumber !<On return, the projection element face number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPointsProjectionElementFaceNumberGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_PROJECTION_ELEMENT_FACE_NUMBER_GET(DATA_POINTS,dataPointGlobalNumber,dataPointProjectionElementFaceNumber, &
        & err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataPointsProjectionElementFaceNumberGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataPointsProjectionElementFaceNumberGetNumber",err,error)
    CALL EXITS("CMISSDataPointsProjectionElementFaceNumberGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsProjectionElementFaceNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection element face number for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataPointsProjectionElementFaceNumberGetObj(dataPoints,dataPointGlobalNumber, &
    & dataPointProjectionElementFaceNumber,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point user number for.
    INTEGER(INTG), INTENT(OUT) :: dataPointProjectionElementFaceNumber !<On return, the projection element face number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPointsProjectionElementFaceNumberGetObj",err,error,*999)

    CALL DATA_POINTS_PROJECTION_ELEMENT_FACE_NUMBER_GET(dataPoints%DATA_POINTS,dataPointGlobalNumber, &
      & dataPointProjectionElementFaceNumber,err,error,*999)

    CALL EXITS("CMISSDataPointsProjectionElementFaceNumberGetObj")
    RETURN
999 CALL ERRORS("CMISSDataPointsProjectionElementFaceNumberGetObj",err,error)
    CALL EXITS("CMISSDataPointsProjectionElementFaceNumberGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsProjectionElementFaceNumberGetObj

  !
  !================================================================================================================================
  !

  !>Returns the projection element line number for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataPointsProjectionElementLineNumberGetNumber(regionUserNumber,dataPointGlobalNumber, &
    & dataPointProjectionElementLineNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point user number for.
    INTEGER(INTG), INTENT(OUT) :: dataPointProjectionElementLineNumber !<On return, the projection element line number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPointsProjectionElementLineNumberGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_PROJECTION_ELEMENT_LINE_NUMBER_GET(DATA_POINTS,dataPointGlobalNumber,dataPointProjectionElementLineNumber, &
        & err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataPointsProjectionElementLineNumberGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataPointsProjectionElementLineNumberGetNumber",err,error)
    CALL EXITS("CMISSDataPointsProjectionElementLineNumberGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsProjectionElementLineNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection element line number for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataPointsProjectionElementLineNumberGetObj(dataPoints,dataPointGlobalNumber, &
    & dataPointProjectionElementLineNumber,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point user number for.
    INTEGER(INTG), INTENT(OUT) :: dataPointProjectionElementLineNumber !<On return, the projection element line number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPointsProjectionElementLineNumberGetObj",err,error,*999)

    CALL DATA_POINTS_PROJECTION_ELEMENT_LINE_NUMBER_GET(dataPoints%DATA_POINTS,dataPointGlobalNumber, &
      & dataPointProjectionElementLineNumber,err,error,*999)

    CALL EXITS("CMISSDataPointsProjectionElementLineNumberGetObj")
    RETURN
999 CALL ERRORS("CMISSDataPointsProjectionElementLineNumberGetObj",err,error)
    CALL EXITS("CMISSDataPointsProjectionElementLineNumberGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsProjectionElementLineNumberGetObj

  !
  !================================================================================================================================
  !

  !>Returns the projection exit tag for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataPointsProjectionExitTagGetNumber(regionUserNumber,dataPointGlobalNumber,dataPointProjectionExitTag,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point user number for.
    INTEGER(INTG), INTENT(OUT) :: dataPointProjectionExitTag !<On return, the projection exit tag for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPointsProjectionExitTagGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_PROJECTION_EXIT_TAG_GET(DATA_POINTS,dataPointGlobalNumber,dataPointProjectionExitTag,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataPointsProjectionExitTagGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataPointsProjectionExitTagGetNumber",err,error)
    CALL EXITS("CMISSDataPointsProjectionExitTagGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsProjectionExitTagGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection exit tag for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataPointsProjectionExitTagGetObj(dataPoints,dataPointGlobalNumber,dataPointProjectionExitTag,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point user number for.
    INTEGER(INTG), INTENT(OUT) :: dataPointProjectionExitTag !<On return, the projection exit tag for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPointsProjectionExitTagGetObj",err,error,*999)

    CALL DATA_POINTS_PROJECTION_EXIT_TAG_GET(dataPoints%DATA_POINTS,dataPointGlobalNumber,dataPointProjectionExitTag, &
      & err,error,*999)

    CALL EXITS("CMISSDataPointsProjectionExitTagGetObj")
    RETURN
999 CALL ERRORS("CMISSDataPointsProjectionExitTagGetObj",err,error)
    CALL EXITS("CMISSDataPointsProjectionExitTagGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsProjectionExitTagGetObj

  !
  !================================================================================================================================
  !

  !>Returns the projection xi for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataPointsProjectionXiGetNumber(regionUserNumber,dataPointGlobalNumber,dataPointProjectionXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point user number for.
    REAL(DP), INTENT(OUT) :: dataPointProjectionXi(:) !<On return, the projection xi for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPointsProjectionXiGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_PROJECTION_XI_GET(DATA_POINTS,dataPointGlobalNumber,dataPointProjectionXi,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataPointsProjectionXiGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataPointsProjectionXiGetNumber",err,error)
    CALL EXITS("CMISSDataPointsProjectionXiGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsProjectionXiGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection xi for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataPointsProjectionXiGetObj(dataPoints,dataPointGlobalNumber,dataPointProjectionXi,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point user number for.
    REAL(DP), INTENT(OUT) :: dataPointProjectionXi(:) !<On return, the projection xi for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPointsProjectionXiGetObj",err,error,*999)

    CALL DATA_POINTS_PROJECTION_XI_GET(dataPoints%DATA_POINTS,dataPointGlobalNumber,dataPointProjectionXi,err,error,*999)

    CALL EXITS("CMISSDataPointsProjectionXiGetObj")
    RETURN
999 CALL ERRORS("CMISSDataPointsProjectionXiGetObj",err,error)
    CALL EXITS("CMISSDataPointsProjectionXiGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsProjectionXiGetObj

  !
  !================================================================================================================================
  !

  !
  !================================================================================================================================
  !

  !>Returns the user number for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataPointsUserNumberGetNumber(regionUserNumber,dataPointGlobalNumber,dataPointUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point user number for.
    INTEGER(INTG), INTENT(OUT) :: dataPointUserNumber !<On return, the user number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPointsUserNumberGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_USER_NUMBER_GET(DATA_POINTS,dataPointGlobalNumber,dataPointUserNumber,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataPointsUserNumberGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataPointsUserNumberGetNumber",err,error)
    CALL EXITS("CMISSDataPointsUserNumberGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsUserNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the user number for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataPointsUserNumberGetObj(dataPoints,dataPointGlobalNumber,dataPointUserNumber,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point user number for.
    INTEGER(INTG), INTENT(OUT) :: dataPointUserNumber !<On return, the user number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPointsUserNumberGetObj",err,error,*999)

    CALL DATA_POINTS_USER_NUMBER_GET(dataPoints%DATA_POINTS,dataPointGlobalNumber,dataPointUserNumber,err,error,*999)

    CALL EXITS("CMISSDataPointsUserNumberGetObj")
    RETURN
999 CALL ERRORS("CMISSDataPointsUserNumberGetObj",err,error)
    CALL EXITS("CMISSDataPointsUserNumberGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsUserNumberGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the user number for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataPointsUserNumberSetNumber(regionUserNumber,dataPointGlobalNumber,dataPointUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPointsUserNumberSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_USER_NUMBER_SET(DATA_POINTS,dataPointGlobalNumber,dataPointUserNumber,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataPointsUserNumberSetNumber")
    RETURN
999 CALL ERRORS("CMISSDataPointsUserNumberSetNumber",err,error)
    CALL EXITS("CMISSDataPointsUserNumberSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsUserNumberSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the user number for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataPointsUserNumberSetObj(dataPoints,dataPointGlobalNumber,dataPointUserNumber,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPointsUserNumberSetObj",err,error,*999)

    CALL DATA_POINTS_USER_NUMBER_SET(dataPoints%DATA_POINTS,dataPointGlobalNumber,dataPointUserNumber,err,error,*999)

    CALL EXITS("CMISSDataPointsUserNumberSetObj")
    RETURN
999 CALL ERRORS("CMISSDataPointsUserNumberSetObj",err,error)
    CALL EXITS("CMISSDataPointsUserNumberSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsUserNumberSetObj

  !
  !================================================================================================================================
  !

  !>Returns the values for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataPointsValuesGetNumber(regionUserNumber,dataPointGlobalNumber,dataPointValues,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point values for.
    REAL(DP), INTENT(OUT) :: dataPointValues(:) !<On return, the values for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPointsValuesGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_VALUES_GET(DATA_POINTS,dataPointGlobalNumber,dataPointValues,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataPointsValuesGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataPointsValuesGetNumber",err,error)
    CALL EXITS("CMISSDataPointsValuesGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsValuesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the values for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataPointsValuesGetObj(dataPoints,dataPointGlobalNumber,dataPointValues,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point user number for.
    REAL(DP), INTENT(OUT) :: dataPointValues(:) !<On return, the values for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPointsValuesGetObj",err,error,*999)

    CALL DATA_POINTS_VALUES_GET(dataPoints%DATA_POINTS,dataPointGlobalNumber,dataPointValues,err,error,*999)

    CALL EXITS("CMISSDataPointsValuesGetObj")
    RETURN
999 CALL ERRORS("CMISSDataPointsValuesGetObj",err,error)
    CALL EXITS("CMISSDataPointsValuesGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsValuesGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the values for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataPointsValuesSetNumber(regionUserNumber,dataPointGlobalNumber,dataPointValues,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the data point user number for.
    REAL(DP), INTENT(IN) :: dataPointValues(:) !<The values for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPointsValuesSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_VALUES_SET(DATA_POINTS,dataPointGlobalNumber,dataPointValues,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataPointsValuesSetNumber")
    RETURN
999 CALL ERRORS("CMISSDataPointsValuesSetNumber",err,error)
    CALL EXITS("CMISSDataPointsValuesSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsValuesSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the values for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataPointsValuesSetObj(dataPoints,dataPointGlobalNumber,dataPointValues,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the data point user number for.
    REAL(DP), INTENT(IN) :: dataPointValues(:) !<The values for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPointsValuesSetObj",err,error,*999)

    CALL DATA_POINTS_VALUES_SET(dataPoints%DATA_POINTS,dataPointGlobalNumber,dataPointValues,err,error,*999)

    CALL EXITS("CMISSDataPointsValuesSetObj")
    RETURN
999 CALL ERRORS("CMISSDataPointsValuesSetObj",err,error)
    CALL EXITS("CMISSDataPointsValuesSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsValuesSetObj

  !
  !================================================================================================================================
  !

  !>Returns the weights for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataPointsWeightsGetNumber(regionUserNumber,dataPointGlobalNumber,dataPointWeights,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point user number for.
    REAL(DP), INTENT(OUT) :: dataPointWeights(:) !<On return, the weights for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPointsWeightsGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_WEIGHTS_GET(DATA_POINTS,dataPointGlobalNumber,dataPointWeights,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataPointsWeightsGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataPointsWeightsGetNumber",err,error)
    CALL EXITS("CMISSDataPointsWeightsGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsWeightsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the weights for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataPointsWeightsGetObj(dataPoints,dataPointGlobalNumber,dataPointWeights,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point user number for.
    REAL(DP), INTENT(OUT) :: dataPointWeights(:) !<On return, the weights for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPointsWeightsGetObj",err,error,*999)

    CALL DATA_POINTS_WEIGHTS_GET(dataPoints%DATA_POINTS,dataPointGlobalNumber,dataPointWeights,err,error,*999)

    CALL EXITS("CMISSDataPointsWeightsGetObj")
    RETURN
999 CALL ERRORS("CMISSDataPointsWeightsGetObj",err,error)
    CALL EXITS("CMISSDataPointsWeightsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsWeightsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the weights for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataPointsWeightsSetNumber(regionUserNumber,dataPointGlobalNumber,dataPointWeights,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the data point user number for.
    REAL(DP), INTENT(IN) :: dataPointWeights(:) !<The weights for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPointsWeightsSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_WEIGHTS_SET(DATA_POINTS,dataPointGlobalNumber,dataPointWeights,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataPointsWeightsSetNumber")
    RETURN
999 CALL ERRORS("CMISSDataPointsWeightsSetNumber",err,error)
    CALL EXITS("CMISSDataPointsWeightsSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsWeightsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the weights for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataPointsWeightsSetObj(dataPoints,dataPointGlobalNumber,dataPointWeights,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the data point user number for.
    REAL(DP), INTENT(IN) :: dataPointWeights(:) !<The weights for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPointsWeightsSetObj",err,error,*999)

    CALL DATA_POINTS_WEIGHTS_SET(dataPoints%DATA_POINTS,dataPointGlobalNumber,dataPointWeights,err,error,*999)

    CALL EXITS("CMISSDataPointsWeightsSetObj")
    RETURN
999 CALL ERRORS("CMISSDataPointsWeightsSetObj",err,error)
    CALL EXITS("CMISSDataPointsWeightsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPointsWeightsSetObj

!!==================================================================================================================================
!!
!! DATA_PROJECTION_ROUTINES
!!
!!==================================================================================================================================

  !>Returns the absolute tolerance of data projection identified by a region user number.
  SUBROUTINE CMISSDataProjectionAbsoluteToleranceGetNumber(regionUserNumber,absoluteTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get tolerance for.
    REAL(DP), INTENT(OUT) :: absoluteTolerance !<On exit, the absolute tolerance of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataProjectionAbsoluteToleranceGetNumber",ERR,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION,ERR,error,*999)
      CALL DATA_PROJECTION_ABSOLUTE_TOLERANCE_GET(DATA_PROJECTION,absoluteTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataProjectionAbsoluteToleranceGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjectionAbsoluteToleranceGetNumber",err,error)
    CALL EXITS("CMISSDataProjectionAbsoluteToleranceGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionAbsoluteToleranceGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the absolute tolerance of data projection identified an object.
  SUBROUTINE CMISSDataProjectionAbsoluteToleranceGetObj(dataProjection,absoluteTolerance,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get tolerance for.
    REAL(DP), INTENT(OUT) :: absoluteTolerance !<On exit, the absolute tolerance of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjectionAbsoluteToleranceGetObj",err,error,*999)

    CALL DATA_PROJECTION_ABSOLUTE_TOLERANCE_GET(dataProjection%DATA_PROJECTION,absoluteTolerance,err,error,*999)

    CALL EXITS("CMISSDataProjectionAbsoluteToleranceGetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjectionAbsoluteToleranceGetObj",err,error)
    CALL EXITS("CMISSDataProjectionAbsoluteToleranceGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionAbsoluteToleranceGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance of data projection identified by a region user number.
  SUBROUTINE CMISSDataProjectionAbsoluteToleranceSetNumber(regionUserNumber,absoluteTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<the absolute tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataProjectionAbsoluteToleranceSetNumber",ERR,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION,ERR,error,*999)
      CALL DATA_PROJECTION_ABSOLUTE_TOLERANCE_SET(DATA_PROJECTION,absoluteTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataProjectionAbsoluteToleranceSetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjectionAbsoluteToleranceSetNumber",err,error)
    CALL EXITS("CMISSDataProjectionAbsoluteToleranceSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionAbsoluteToleranceSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance of data projection identified an object.
  SUBROUTINE CMISSDataProjectionAbsoluteToleranceSetObj(dataProjection,absoluteTolerance,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<the absolute tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjectionAbsoluteToleranceSetObj",err,error,*999)

    CALL DATA_PROJECTION_ABSOLUTE_TOLERANCE_SET(dataProjection%DATA_PROJECTION,absoluteTolerance,err,error,*999)

    CALL EXITS("CMISSDataProjectionAbsoluteToleranceSetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjectionAbsoluteToleranceSetObj",err,error)
    CALL EXITS("CMISSDataProjectionAbsoluteToleranceSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionAbsoluteToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a new data projection identified by a region user number.
  SUBROUTINE CMISSDataProjectionCreateFinishNumber(regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points which associates to the data projection to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataProjectionCreateFinishNumber",ERR,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION,ERR,error,*999)
      CALL DATA_PROJECTION_CREATE_FINISH(DATA_PROJECTION,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataProjectionCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjectionCreateFinishNumber",err,error)
    CALL EXITS("CMISSDataProjectionCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a new data projection identified by an object.
  SUBROUTINE CMISSDataProjectionCreateFinishObj(dataProjection,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to finish the creation of
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    CALL ENTERS("CMISSDataProjectionCreateFinishObj",err,error,*999)

    CALL DATA_PROJECTION_CREATE_FINISH(dataProjection%DATA_PROJECTION,err,error,*999)

    CALL EXITS("CMISSDataProjectionCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSDataProjectionCreateFinishObj",err,error)
    CALL EXITS("CMISSDataProjectionCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a new data projection for a data projection identified by a region user number.
  SUBROUTINE CMISSDataProjectionCreateStartNumber(dataPointRegionUserNumber,fieldUserNumber, &
    & fieldRegionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataPointRegionUserNumber !<The region user number of the data points to be projected
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field user number of the geometric field data points are be projected on
    INTEGER(INTG), INTENT(IN) :: fieldRegionUserNumber !<The region user number of the geometric field data points are be projected on
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(FIELD_TYPE), POINTER :: GEOMETRIC_FIELD
    TYPE(REGION_TYPE), POINTER :: DATA_POINTS_REGION
    TYPE(REGION_TYPE), POINTER :: GEOMETRIC_FIELD_REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataProjectionCreateStartNumber",err,error,*999)

    NULLIFY(DATA_PROJECTION)
    NULLIFY(DATA_POINTS)
    NULLIFY(GEOMETRIC_FIELD)
    NULLIFY(DATA_POINTS_REGION)
    NULLIFY(GEOMETRIC_FIELD_REGION)
    CALL REGION_USER_NUMBER_FIND(dataPointRegionUserNumber,DATA_POINTS_REGION,err,error,*999)
    CALL REGION_USER_NUMBER_FIND(fieldRegionUserNumber,GEOMETRIC_FIELD_REGION,err,error,*999)
    IF(ASSOCIATED(DATA_POINTS_REGION)) THEN
      IF(ASSOCIATED(GEOMETRIC_FIELD_REGION)) THEN
        CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,GEOMETRIC_FIELD_REGION,GEOMETRIC_FIELD,ERR,error,*999)
        IF(ASSOCIATED(GEOMETRIC_FIELD)) THEN
          CALL REGION_DATA_POINTS_GET(DATA_POINTS_REGION,DATA_POINTS,err,error,*999)
          CALL DATA_PROJECTION_CREATE_START(DATA_POINTS,GEOMETRIC_FIELD,DATA_PROJECTION,err,error,*999)
        ELSE
          LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
            & " does not exist."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldRegionUserNumber,"*",err,error))// &
          & " does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(dataPointRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataProjectionCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjectionCreateStartNumber",err,error)
    CALL EXITS("CMISSDataProjectionCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a new data projection for a data projection identified by an object.
  SUBROUTINE CMISSDataProjectionCreateStartObj(dataPoints,geometricField,dataProjection,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points to be projected
    TYPE(CMISSFieldType), INTENT(IN) :: geometricField !<The geometric field data points is projected on
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<On exit, the newly created data projection.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjectionCreateStartObj",err,error,*999)

    CALL DATA_PROJECTION_CREATE_START(dataPoints%DATA_POINTS,geometricField%FIELD,dataProjection%DATA_PROJECTION,err,error,*999)

    CALL EXITS("CMISSDataProjectionCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSDataProjectionCreateStartObj",err,error)
    CALL EXITS("CMISSDataProjectionCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys a data projection identified by region user number.
  SUBROUTINE CMISSDataProjectionDestroyNumber(regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataProjectionDestroyNumber",ERR,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION,ERR,error,*999)
      CALL DATA_PROJECTION_DESTROY(DATA_PROJECTION,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataProjectionDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjectionDestroyNumber",err,error)
    CALL EXITS("CMISSDataProjectionDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a data projection identified by an object.
  SUBROUTINE CMISSDataProjectionDestroyObj(dataProjection,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjectionDestroyObj",err,error,*999)

    CALL DATA_PROJECTION_DESTROY(dataProjection%DATA_PROJECTION,err,error,*999)

    CALL EXITS("CMISSDataProjectionDestroyObj")
    RETURN
999 CALL ERRORS("CMISSDataProjectionDestroyObj",err,error)
    CALL EXITS("CMISSDataProjectionDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionDestroyObj

  !
  !================================================================================================================================
  !

  !>Evaluate a data projection identified by a region user number.
  SUBROUTINE CMISSDataProjectionEvaluateNumber(regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to evaluate.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataProjectionEvaluateNumber",ERR,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION,ERR,error,*999)
      CALL DATA_PROJECTION_EVALUATE(DATA_PROJECTION,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataProjectionEvaluateNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjectionEvaluateNumber",err,error)
    CALL EXITS("CMISSDataProjectionEvaluateNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionEvaluateNumber

  !
  !================================================================================================================================
  !

  !>Evaluate a data projection identified by an object.
  SUBROUTINE CMISSDataProjectionEvaluateObj(dataProjection,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to evaluate.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjectionEvaluateObj",err,error,*999)

    CALL DATA_PROJECTION_EVALUATE(dataProjection%DATA_PROJECTION,err,error,*999)

    CALL EXITS("CMISSDataProjectionEvaluateObj")
    RETURN
999 CALL ERRORS("CMISSDataProjectionEvaluateObj",err,error)
    CALL EXITS("CMISSDataProjectionEvaluateObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionEvaluateObj

  !
  !================================================================================================================================
  !

  !>Returns the relative tolerance of data projection identified by a region user number.
  SUBROUTINE CMISSDataProjectionMaximumIterationUpdateGetNumber(regionUserNumber,maximumIterationUpdate,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get tolerance for.
    REAL(DP), INTENT(OUT) :: maximumIterationUpdate !<On exit, the maximum iteration update of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataProjectionMaximumIterationUpdateGetNumber",ERR,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION,ERR,error,*999)
      CALL DATA_PROJECTION_MAXIMUM_ITERATION_UPDATE_GET(DATA_PROJECTION,maximumIterationUpdate,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataProjectionMaximumIterationUpdateGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjectionMaximumIterationUpdateGetNumber",err,error)
    CALL EXITS("CMISSDataProjectionMaximumIterationUpdateGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionMaximumIterationUpdateGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the relative tolerance of data projection identified an object.
  SUBROUTINE CMISSDataProjectionMaximumIterationUpdateGetObj(dataProjection,maximumIterationUpdate,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get tolerance for.
    REAL(DP), INTENT(OUT) :: maximumIterationUpdate !<On exit, the maximum iteration update of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjectionMaximumIterationUpdateGetObj",err,error,*999)

    CALL DATA_PROJECTION_MAXIMUM_ITERATION_UPDATE_GET(dataProjection%DATA_PROJECTION,maximumIterationUpdate,err,error,*999)

    CALL EXITS("CMISSDataProjectionMaximumIterationUpdateGetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjectionMaximumIterationUpdateGetObj",err,error)
    CALL EXITS("CMISSDataProjectionMaximumIterationUpdateGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionMaximumIterationUpdateGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance of data projection identified by a region user number.
  SUBROUTINE CMISSDataProjectionMaximumIterationUpdateSetNumber(regionUserNumber,maximumIterationUpdate,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set tolerance for.
    REAL(DP), INTENT(IN) :: maximumIterationUpdate !<the maximum iteration update to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataProjectionMaximumIterationUpdateSetNumber",ERR,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION,ERR,error,*999)
      CALL DATA_PROJECTION_MAXIMUM_ITERATION_UPDATE_SET(DATA_PROJECTION,maximumIterationUpdate,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataProjectionMaximumIterationUpdateSetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjectionMaximumIterationUpdateSetNumber",err,error)
    CALL EXITS("CMISSDataProjectionMaximumIterationUpdateSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionMaximumIterationUpdateSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance of data projection identified an object.
  SUBROUTINE CMISSDataProjectionMaximumIterationUpdateSetObj(dataProjection,maximumIterationUpdate,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set tolerance for.
    REAL(DP), INTENT(IN) :: maximumIterationUpdate !<the maximum iteration update to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjectionMaximumIterationUpdateSetObj",err,error,*999)

    CALL DATA_PROJECTION_MAXIMUM_ITERATION_UPDATE_SET(dataProjection%DATA_PROJECTION,maximumIterationUpdate,err,error,*999)

    CALL EXITS("CMISSDataProjectionMaximumIterationUpdateSetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjectionMaximumIterationUpdateSetObj",err,error)
    CALL EXITS("CMISSDataProjectionMaximumIterationUpdateSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionMaximumIterationUpdateSetObj

  !
  !================================================================================================================================
  !

  !>Returns the maximum number of iterations of data projection identified by a region user number.
  SUBROUTINE CMISSDataProjectionMaximumNumberOfIterationsGetNumber(regionUserNumber,maximumNumberOfIterations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get maximum number of iterations for.
    INTEGER(INTG), INTENT(OUT) :: maximumNumberOfIterations !<On exit, the maximum number of iterations of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataProjectionMaximumNumberOfIterationsGetNumber",ERR,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION,ERR,error,*999)
      CALL DATA_PROJECTION_MAXIMUM_NUMBER_OF_ITERATIONS_GET(DATA_PROJECTION,maximumNumberOfIterations,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataProjectionMaximumNumberOfIterationsGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjectionMaximumNumberOfIterationsGetNumber",err,error)
    CALL EXITS("CMISSDataProjectionMaximumNumberOfIterationsGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionMaximumNumberOfIterationsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the maximum number of iterations of data projection identified an object.
  SUBROUTINE CMISSDataProjectionMaximumNumberOfIterationsGetObj(dataProjection,maximumNumberOfIterations,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get maximum number of iterations for.
    INTEGER(INTG), INTENT(OUT) :: maximumNumberOfIterations !<On exit, the maximum number of iterations of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjectionMaximumNumberOfIterationsGetObj",err,error,*999)

    CALL DATA_PROJECTION_MAXIMUM_NUMBER_OF_ITERATIONS_GET(dataProjection%DATA_PROJECTION,maximumNumberOfIterations,err,error,*999)

    CALL EXITS("CMISSDataProjectionMaximumNumberOfIterationsGetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjectionMaximumNumberOfIterationsGetObj",err,error)
    CALL EXITS("CMISSDataProjectionMaximumNumberOfIterationsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionMaximumNumberOfIterationsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations of data projection identified by a region user number.
  SUBROUTINE CMISSDataProjectionMaximumNumberOfIterationsSetNumber(regionUserNumber,maximumNumberOfIterations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set maximum number of iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumNumberOfIterations !<the maximum number of iterations to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataProjectionMaximumNumberOfIterationsSetNumber",ERR,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION,ERR,error,*999)
      CALL DATA_PROJECTION_MAXIMUM_NUMBER_OF_ITERATIONS_SET(DATA_PROJECTION,maximumNumberOfIterations,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataProjectionMaximumNumberOfIterationsSetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjectionMaximumNumberOfIterationsSetNumber",err,error)
    CALL EXITS("CMISSDataProjectionMaximumNumberOfIterationsSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionMaximumNumberOfIterationsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations of data projection identified an object.
  SUBROUTINE CMISSDataProjectionMaximumNumberOfIterationsSetObj(dataProjection,maximumNumberOfIterations,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set maximum number of iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumNumberOfIterations !<the maximum number of iterations to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjectionMaximumNumberOfIterationsSetObj",err,error,*999)

    CALL DATA_PROJECTION_MAXIMUM_NUMBER_OF_ITERATIONS_SET(dataProjection%DATA_PROJECTION,maximumNumberOfIterations,err,error,*999)

    CALL EXITS("CMISSDataProjectionMaximumNumberOfIterationsSetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjectionMaximumNumberOfIterationsSetObj",err,error)
    CALL EXITS("CMISSDataProjectionMaximumNumberOfIterationsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionMaximumNumberOfIterationsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of closest elements of data projection identified by a region user number.
  SUBROUTINE CMISSDataProjectionNumberOfClosestElementsGetNumber(regionUserNumber,numberOfClosestElements,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get number of closest elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfClosestElements !<On exit, the number of closest elements of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataProjectionNumberOfClosestElementsGetNumber",ERR,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION,ERR,error,*999)
      CALL DATA_PROJECTION_NUMBER_OF_CLOSEST_ELEMENTS_GET(DATA_PROJECTION,numberOfClosestElements,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataProjectionNumberOfClosestElementsGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjectionNumberOfClosestElementsGetNumber",err,error)
    CALL EXITS("CMISSDataProjectionNumberOfClosestElementsGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionNumberOfClosestElementsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of closest elements of data projection identified an object.
  SUBROUTINE CMISSDataProjectionNumberOfClosestElementsGetObj(dataProjection,numberOfClosestElements,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get number of closest elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfClosestElements !<On exit, the number of closest elements of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjectionNumberOfClosestElementsGetObj",err,error,*999)

    CALL DATA_PROJECTION_NUMBER_OF_CLOSEST_ELEMENTS_GET(dataProjection%DATA_PROJECTION,numberOfClosestElements,err,error,*999)

    CALL EXITS("CMISSDataProjectionNumberOfClosestElementsGetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjectionNumberOfClosestElementsGetObj",err,error)
    CALL EXITS("CMISSDataProjectionNumberOfClosestElementsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionNumberOfClosestElementsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of closest elements of data projection identified by a region user number.
  SUBROUTINE CMISSDataProjectionNumberOfClosestElementsSetNumber(regionUserNumber,numberOfClosestElements,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set number of closest elements for.
    INTEGER(INTG), INTENT(IN) :: numberOfClosestElements !<the number of closest elements to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataProjectionNumberOfClosestElementsSetNumber",ERR,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION,ERR,error,*999)
      CALL DATA_PROJECTION_NUMBER_OF_CLOSEST_ELEMENTS_SET(DATA_PROJECTION,numberOfClosestElements,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataProjectionNumberOfClosestElementsSetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjectionNumberOfClosestElementsSetNumber",err,error)
    CALL EXITS("CMISSDataProjectionNumberOfClosestElementsSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionNumberOfClosestElementsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of closest elements of data projection identified an object.
  SUBROUTINE CMISSDataProjectionNumberOfClosestElementsSetObj(dataProjection,numberOfClosestElements,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set number of closest elements for.
    INTEGER(INTG), INTENT(IN) :: numberOfClosestElements !<the number of closest elements to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjectionNumberOfClosestElementsSetObj",err,error,*999)

    CALL DATA_PROJECTION_NUMBER_OF_CLOSEST_ELEMENTS_SET(dataProjection%DATA_PROJECTION,numberOfClosestElements,err,error,*999)

    CALL EXITS("CMISSDataProjectionNumberOfClosestElementsSetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjectionNumberOfClosestElementsSetObj",err,error)
    CALL EXITS("CMISSDataProjectionNumberOfClosestElementsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionNumberOfClosestElementsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the projection type of data projection identified by a region user number.
  SUBROUTINE CMISSDataProjectionProjectionTypeGetNumber(regionUserNumber,projectionType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get projection type for.
    INTEGER(INTG), INTENT(OUT) :: projectionType !<On exit, the projection type of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataProjectionProjectionTypeGetNumber",ERR,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION,ERR,error,*999)
      CALL DATA_PROJECTION_PROJECTION_TYPE_GET(DATA_PROJECTION,projectionType,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataProjectionProjectionTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjectionProjectionTypeGetNumber",err,error)
    CALL EXITS("CMISSDataProjectionProjectionTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionProjectionTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection type of data projection identified an object.
  SUBROUTINE CMISSDataProjectionProjectionTypeGetObj(dataProjection,projectionType,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get projection type for.
    INTEGER(INTG), INTENT(OUT) :: projectionType !<On exit, the projection type of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjectionProjectionTypeGetObj",err,error,*999)

    CALL DATA_PROJECTION_PROJECTION_TYPE_GET(dataProjection%DATA_PROJECTION,projectionType,err,error,*999)

    CALL EXITS("CMISSDataProjectionProjectionTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjectionProjectionTypeGetObj",err,error)
    CALL EXITS("CMISSDataProjectionProjectionTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionProjectionTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the projection type of data projection identified by a region user number.
  SUBROUTINE CMISSDataProjectionProjectionTypeSetNumber(regionUserNumber,projectionType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set projection type for.
    INTEGER(INTG), INTENT(IN) :: projectionType !<the projection type to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataProjectionProjectionTypeSetNumber",ERR,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION,ERR,error,*999)
      CALL DATA_PROJECTION_PROJECTION_TYPE_SET(DATA_PROJECTION,projectionType,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataProjectionProjectionTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjectionProjectionTypeSetNumber",err,error)
    CALL EXITS("CMISSDataProjectionProjectionTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionProjectionTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the projection type of data projection identified an object.
  SUBROUTINE CMISSDataProjectionProjectionTypeSetObj(dataProjection,projectionType,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set projection type for.
    INTEGER(INTG), INTENT(IN) :: projectionType !<the projection type to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjectionProjectionTypeSetObj",err,error,*999)

    CALL DATA_PROJECTION_PROJECTION_TYPE_SET(dataProjection%DATA_PROJECTION,projectionType,err,error,*999)

    CALL EXITS("CMISSDataProjectionProjectionTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjectionProjectionTypeSetObj",err,error)
    CALL EXITS("CMISSDataProjectionProjectionTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionProjectionTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the relative tolerance of data projection identified by a region user number.
  SUBROUTINE CMISSDataProjectionRelativeToleranceGetNumber(regionUserNumber,relativeTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get relative tolerance for.
    REAL(DP), INTENT(OUT) :: relativeTolerance !<On exit, the absolute relative tolerance of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataProjectionRelativeToleranceGetNumber",ERR,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION,ERR,error,*999)
      CALL DATA_PROJECTION_RELATIVE_TOLERANCE_GET(DATA_PROJECTION,relativeTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataProjectionRelativeToleranceGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjectionRelativeToleranceGetNumber",err,error)
    CALL EXITS("CMISSDataProjectionRelativeToleranceGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionRelativeToleranceGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the relative tolerance of data projection identified an object.
  SUBROUTINE CMISSDataProjectionRelativeToleranceGetObj(dataProjection,relativeTolerance,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get relative tolerance for.
    REAL(DP), INTENT(OUT) :: relativeTolerance !<On exit, the absolute relative tolerance of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjectionRelativeToleranceGetObj",err,error,*999)

    CALL DATA_PROJECTION_RELATIVE_TOLERANCE_GET(dataProjection%DATA_PROJECTION,relativeTolerance,err,error,*999)

    CALL EXITS("CMISSDataProjectionRelativeToleranceGetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjectionRelativeToleranceGetObj",err,error)
    CALL EXITS("CMISSDataProjectionRelativeToleranceGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionRelativeToleranceGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance of data projection identified by a region user number.
  SUBROUTINE CMISSDataProjectionRelativeToleranceSetNumber(regionUserNumber,relativeTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<the absolute relative tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataProjectionRelativeToleranceSetNumber",ERR,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION,ERR,error,*999)
      CALL DATA_PROJECTION_RELATIVE_TOLERANCE_SET(DATA_PROJECTION,relativeTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataProjectionRelativeToleranceSetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjectionRelativeToleranceSetNumber",err,error)
    CALL EXITS("CMISSDataProjectionRelativeToleranceSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionRelativeToleranceSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance of data projection identified an object.
  SUBROUTINE CMISSDataProjectionRelativeToleranceSetObj(dataProjection,relativeTolerance,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<the absolute relative tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjectionRelativeToleranceSetObj",err,error,*999)

    CALL DATA_PROJECTION_RELATIVE_TOLERANCE_SET(dataProjection%DATA_PROJECTION,relativeTolerance,err,error,*999)

    CALL EXITS("CMISSDataProjectionRelativeToleranceSetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjectionRelativeToleranceSetObj",err,error)
    CALL EXITS("CMISSDataProjectionRelativeToleranceSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionRelativeToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Returns the starting xi of data projection identified by a region user number.
  SUBROUTINE CMISSDataProjectionStartingXiGetNumber(regionUserNumber,startingXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get starting xi for.
    REAL(DP), INTENT(OUT) :: startingXi(:) !<On exit, the absolute starting xi of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataProjectionStartingXiGetNumber",ERR,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION,ERR,error,*999)
      CALL DATA_PROJECTION_STARTING_XI_GET(DATA_PROJECTION,startingXi,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataProjectionStartingXiGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjectionStartingXiGetNumber",err,error)
    CALL EXITS("CMISSDataProjectionStartingXiGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionStartingXiGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the starting xi of data projection identified an object.
  SUBROUTINE CMISSDataProjectionStartingXiGetObj(dataProjection,startingXi,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get starting xi for.
    REAL(DP), INTENT(OUT) :: startingXi(:) !<On exit, the absolute starting xi of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjectionStartingXiGetObj",err,error,*999)

    CALL DATA_PROJECTION_STARTING_XI_GET(dataProjection%DATA_PROJECTION,startingXi,err,error,*999)

    CALL EXITS("CMISSDataProjectionStartingXiGetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjectionStartingXiGetObj",err,error)
    CALL EXITS("CMISSDataProjectionStartingXiGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionStartingXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the starting xi of data projection identified by a region user number.
  SUBROUTINE CMISSDataProjectionStartingXiSetNumber(regionUserNumber,startingXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set starting xi for.
    REAL(DP), INTENT(IN) :: startingXi(:) !<the absolute starting xi to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataProjectionStartingXiSetNumber",ERR,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION,ERR,error,*999)
      CALL DATA_PROJECTION_STARTING_XI_SET(DATA_PROJECTION,startingXi,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataProjectionStartingXiSetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjectionStartingXiSetNumber",err,error)
    CALL EXITS("CMISSDataProjectionStartingXiSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionStartingXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the starting xi of data projection identified an object.
  SUBROUTINE CMISSDataProjectionStartingXiSetObj(dataProjection,startingXi,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set starting xi for.
    REAL(DP), INTENT(IN) :: startingXi(:) !<the absolute starting xi to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjectionStartingXiSetObj",err,error,*999)

    CALL DATA_PROJECTION_STARTING_XI_SET(dataProjection%DATA_PROJECTION,startingXi,err,error,*999)

    CALL EXITS("CMISSDataProjectionStartingXiSetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjectionStartingXiSetObj",err,error)
    CALL EXITS("CMISSDataProjectionStartingXiSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjectionStartingXiSetObj

!!==================================================================================================================================
!!
!! EQUATIONS_ROUTINES
!!
!!==================================================================================================================================

  !>Destroys equations for equations identified by a user number.
  SUBROUTINE CMISSEquationsDestroyNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to destroy.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,error,*999)
        CALL EQUATIONS_DESTROY(EQUATIONS,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsDestroyNumber",err,error)
    CALL EXITS("CMISSEquationsDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy equations for equations identified by an object.
  SUBROUTINE CMISSEquationsDestroyObj(equations,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(INOUT) :: equations !<The equations to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsDestroyObj",err,error,*999)

    CALL EQUATIONS_DESTROY(equations%EQUATIONS,err,error,*999)

    CALL EXITS("CMISSEquationsDestroyObj")
    RETURN
999 CALL ERRORS("CMISSEquationsDestroyObj",err,error)
    CALL EXITS("CMISSEquationsDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsDestroyObj

  !
  !================================================================================================================================
  !

  !>Gets the linearity type for equations identified by a user number.
  SUBROUTINE CMISSEquationsLinearityTypeGetNumber(regionUserNumber,equationsSetUserNumber,linearityType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to get the linearity type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On return, the linearity type of the equations \see OPENCMISS_EquationsLinearityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsLinearityTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,error,*999)
        CALL EQUATIONS_LINEARITY_TYPE_GET(EQUATIONS,linearityType,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsLinearityTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsLinearityTypeGetNumber",err,error)
    CALL EXITS("CMISSEquationsLinearityTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsLinearityTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the linearity type for equations identified by an object.
  SUBROUTINE CMISSEquationsLinearityTypeGetObj(equations,linearityType,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(IN) :: equations !<The equations to get the linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On return, the linearity type of the equations \see OPENCMISS_EquationsLinearityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsLinearityTypeGetObj",err,error,*999)

    CALL EQUATIONS_LINEARITY_TYPE_GET(equations%EQUATIONS,linearityType,err,error,*999)

    CALL EXITS("CMISSEquationsLinearityTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsLinearityTypeGetObj",err,error)
    CALL EXITS("CMISSEquationsLinearityTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsLinearityTypeGetObj

  !
  !================================================================================================================================
  !

  !>Gets the lumping type for equations identified by a user number.
  SUBROUTINE CMISSEquationsLumpingTypeGetNumber(regionUserNumber,equationsSetUserNumber,lumpingType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to get the lumping type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the lumping type for.
    INTEGER(INTG), INTENT(OUT) :: lumpingType !<On return, the lumping type of the equations \see OPENCMISS_EquationsLumpingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsLumpingTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,error,*999)
        CALL EQUATIONS_LUMPING_TYPE_GET(EQUATIONS,lumpingType,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsLumpingTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsLumpingTypeGetNumber",err,error)
    CALL EXITS("CMISSEquationsLumpingTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsLumpingTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the lumping type for equations identified by an object.
  SUBROUTINE CMISSEquationsLumpingTypeGetObj(equations,lumpingType,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(IN) :: equations !<The equations to get the lumping type for.
    INTEGER(INTG), INTENT(OUT) :: lumpingType !<On return, the lumping type of the equations \see OPENCMISS_EquationsLumpingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsLumpingTypeGetObj",err,error,*999)

    CALL EQUATIONS_LUMPING_TYPE_GET(equations%EQUATIONS,lumpingType,err,error,*999)

    CALL EXITS("CMISSEquationsLumpingTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsLumpingTypeGetObj",err,error)
    CALL EXITS("CMISSEquationsLumpingTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsLumpingTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the lumping type for equations identified by a user number.
  SUBROUTINE CMISSEquationsLumpingTypeSetNumber(regionUserNumber,equationsSetUserNumber,lumpingType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to set the lumping type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the lumping type for.
    INTEGER(INTG), INTENT(IN) :: lumpingType !<The lumping type of the equations to set\see OPENCMISS_EquationsLumpingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsLumpingTypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,error,*999)
        CALL EQUATIONS_LUMPING_TYPE_SET(EQUATIONS,lumpingType,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsLumpingTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsLumpingTypeSetNumber",err,error)
    CALL EXITS("CMISSEquationsLumpingTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsLumpingTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the lumping type for equations identified by an object.
  SUBROUTINE CMISSEquationsLumpingTypeSetObj(equations,lumpingType,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(INOUT) :: equations !<The equations to set the lumping type for.
    INTEGER(INTG), INTENT(IN) :: lumpingType !<The lumping type of the equations to set\see OPENCMISS_EquationsLumpingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsLumpingTypeSetObj",err,error,*999)

    CALL EQUATIONS_LUMPING_TYPE_SET(equations%EQUATIONS,lumpingType,err,error,*999)

    CALL EXITS("CMISSEquationsLumpingTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsLumpingTypeSetObj",err,error)
    CALL EXITS("CMISSEquationsLumpingTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsLumpingTypeSetObj

  !
  !================================================================================================================================
  !

  !>Gets the output type for equations identified by a user number.
  SUBROUTINE CMISSEquationsOutputTypeGetNumber(regionUserNumber,equationsSetUserNumber,outputType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to get the output type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the equations \see OPENCMISS_EquationsOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsOutputTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,error,*999)
        CALL EQUATIONS_OUTPUT_TYPE_GET(EQUATIONS,outputType,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsOutputTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsOutputTypeGetNumber",err,error)
    CALL EXITS("CMISSEquationsOutputTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsOutputTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the output type for equations identified by an object.
  SUBROUTINE CMISSEquationsOutputTypeGetObj(equations,outputType,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(IN) :: equations !<The equations to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the equations \see OPENCMISS_EquationsOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsOutputTypeGetObj",err,error,*999)

    CALL EQUATIONS_OUTPUT_TYPE_GET(equations%EQUATIONS,outputType,err,error,*999)

    CALL EXITS("CMISSEquationsOutputTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsOutputTypeGetObj",err,error)
    CALL EXITS("CMISSEquationsOutputTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsOutputTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for equations identified by a user number.
  SUBROUTINE CMISSEquationsOutputTypeSetNumber(regionUserNumber,equationsSetUserNumber,outputType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to set the output type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type of the equations to set \see OPENCMISS_EquationsOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsOutputTypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,error,*999)
        CALL EQUATIONS_OUTPUT_TYPE_SET(EQUATIONS,outputType,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsOutputTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsOutputTypeSetNumber",err,error)
    CALL EXITS("CMISSEquationsOutputTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsOutputTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for equations identified by an object.
  SUBROUTINE CMISSEquationsOutputTypeSetObj(equations,outputType,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(INOUT) :: equations !<The equations to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type of the equations to set \see OPENCMISS_EquationsOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsOutputTypeSetObj",err,error,*999)

    CALL EQUATIONS_OUTPUT_TYPE_SET(equations%EQUATIONS,outputType,err,error,*999)

    CALL EXITS("CMISSEquationsOutputTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsOutputTypeSetObj",err,error)
    CALL EXITS("CMISSEquationsOutputTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsOutputTypeSetObj

  !
  !================================================================================================================================
  !

  !>Gets the sparsity type for equations identified by a user number.
  SUBROUTINE CMISSEquationsSparsityTypeGetNumber(regionUserNumber,equationsSetUserNumber,sparsityType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to get the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the sparsity type for.
    INTEGER(INTG), INTENT(OUT) :: sparsityType !<On return, the sparsity type of the equations \see OPENCMISS_EquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSparsityTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,error,*999)
        CALL EQUATIONS_SPARSITY_TYPE_GET(EQUATIONS,sparsityType,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSparsityTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSparsityTypeGetNumber",err,error)
    CALL EXITS("CMISSEquationsSparsityTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSparsityTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the sparsity type for equations identified by an object.
  SUBROUTINE CMISSEquationsSparsityTypeGetObj(equations,sparsityType,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(IN) :: equations !<The equations to get the sparsity type for.
    INTEGER(INTG), INTENT(OUT) :: sparsityType !<On return, the sparsity type of the equations \see OPENCMISS_EquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSparsityTypeGetObj",err,error,*999)

    CALL EQUATIONS_SPARSITY_TYPE_GET(equations%EQUATIONS,sparsityType,err,error,*999)

    CALL EXITS("CMISSEquationsSparsityTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSparsityTypeGetObj",err,error)
    CALL EXITS("CMISSEquationsSparsityTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSparsityTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for equations identified by a user number.
  SUBROUTINE CMISSEquationsSparsityTypeSetNumber(regionUserNumber,equationsSetUserNumber,sparsityType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type of the equations to set \see OPENCMISS_EquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSparsityTypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,error,*999)
        CALL EQUATIONS_SPARSITY_TYPE_SET(EQUATIONS,sparsityType,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSparsityTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSparsityTypeSetNumber",err,error)
    CALL EXITS("CMISSEquationsSparsityTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSparsityTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for equations identified by an object.
  SUBROUTINE CMISSEquationsSparsityTypeSetObj(equations,sparsityType,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(INOUT) :: equations !<The equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type of the equations to set \see OPENCMISS_EquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSparsityTypeSetObj",err,error,*999)

    CALL EQUATIONS_SPARSITY_TYPE_SET(equations%EQUATIONS,sparsityType,err,error,*999)

    CALL EXITS("CMISSEquationsSparsityTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSparsityTypeSetObj",err,error)
    CALL EXITS("CMISSEquationsSparsityTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSparsityTypeSetObj

  !
  !================================================================================================================================
  !

  !>Gets the time dependence type for equations identified by a user number.
  SUBROUTINE CMISSEquationsTimeDependenceTypeGetNumber(regionUserNumber,equationsSetUserNumber,timeDependenceType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to get the time dependence type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the time dependence type for.
    INTEGER(INTG), INTENT(OUT) :: timeDependenceType !<On return, the time dependence type of the equations \see OPENCMISS_EquationsTimeDependenceTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsTimeDependenceTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,error,*999)
        CALL EQUATIONS_TIME_DEPENDENCE_TYPE_GET(EQUATIONS,timeDependenceType,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsTimeDependenceTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsTimeDependenceTypeGetNumber",err,error)
    CALL EXITS("CMISSEquationsTimeDependenceTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsTimeDependenceTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the time dependence type for equations identified by an object.
  SUBROUTINE CMISSEquationsTimeDependenceTypeGetObj(equations,timeDependenceType,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(IN) :: equations !<The equations to get the time dependence type for.
    INTEGER(INTG), INTENT(OUT) :: timeDependenceType !<On return, the time dependence type of the equations \see OPENCMISS_EquationsTimeDependenceTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsTimeDependenceTypeGetObj",err,error,*999)

    CALL EQUATIONS_TIME_DEPENDENCE_TYPE_GET(equations%EQUATIONS,timeDependenceType,err,error,*999)

    CALL EXITS("CMISSEquationsTimeDependenceTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsTimeDependenceTypeGetObj",err,error)
    CALL EXITS("CMISSEquationsTimeDependenceTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsTimeDependenceTypeGetObj


!!==================================================================================================================================
!!
!! EQUATIONS_SET_ROUTINES
!!
!!==================================================================================================================================

  !>Finish the creation of a analytic solution for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetAnalyticCreateFinishNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetAnalyticCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_ANALYTIC_CREATE_FINISH(EQUATIONS_SET,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetAnalyticCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetAnalyticCreateFinishNumber",err,error)
    CALL EXITS("CMISSEquationsSetAnalyticCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetAnalyticCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of a analytic solution for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetAnalyticCreateFinishObj(equationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetAnalyticCreateFinishObj",err,error,*999)

    CALL EQUATIONS_SET_ANALYTIC_CREATE_FINISH(equationsSet%EQUATIONS_SET,err,error,*999)

    CALL EXITS("CMISSEquationsSetAnalyticCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetAnalyticCreateFinishObj",err,error)
    CALL EXITS("CMISSEquationsSetAnalyticCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetAnalyticCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of a analytic solution for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetAnalyticCreateStartNumber(regionUserNumber,equationsSetUserNumber,analyticFunctionType, &
    & analyticFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: analyticFunctionType !<The analytic function type to use. \see OPENCMISS_EquationsSetAnalyticFunctionTypes
    INTEGER(INTG), INTENT(IN) :: analyticFieldUserNumber !<The user number of the field for the analytic function
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(FIELD_TYPE), POINTER :: ANALYTIC_FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetAnalyticCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(ANALYTIC_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL FIELD_USER_NUMBER_FIND(analyticFieldUserNumber,REGION,ANALYTIC_FIELD,ERR,error,*999)
        CALL EQUATIONS_SET_ANALYTIC_CREATE_START(EQUATIONS_SET,analyticFunctionType,analyticFieldUserNumber,ANALYTIC_FIELD, &
          & err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetAnalyticCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetAnalyticCreateStartNumber",err,error)
    CALL EXITS("CMISSEquationsSetAnalyticCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetAnalyticCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of an analytic solution for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetAnalyticCreateStartObj(equationsSet,analyticFunctionType,analyticFieldUserNumber,analyticField,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the analytic creation on.
    INTEGER(INTG), INTENT(IN) :: analyticFunctionType !<The analytic function type to use. \see OPENCMISS_EquationsSetAnalyticFunctionTypes
    INTEGER(INTG), INTENT(IN) :: analyticFieldUserNumber !<The user number of the field for the analytic function
    TYPE(CMISSFieldType), INTENT(INOUT) :: analyticField !<If associated on entry, the user created analytic field which has the same user number as the specified analytic field user number. If not associated on entry, on return, the created analytic field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetAnalyticCreateStartObj",err,error,*999)

    CALL EQUATIONS_SET_ANALYTIC_CREATE_START(equationsSet%EQUATIONS_SET,analyticFunctionType,analyticFieldUserNumber, &
      & analyticField%FIELD,err,error,*999)

    CALL EXITS("CMISSEquationsSetAnalyticCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetAnalyticCreateStartObj",err,error)
    CALL EXITS("CMISSEquationsSetAnalyticCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetAnalyticCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the analytic solution for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetAnalyticDestroyNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destroy.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
     TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetAnalyticDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_ANALYTIC_DESTROY(EQUATIONS_SET,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetAnalyticDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetAnalyticDestroyNumber",err,error)
    CALL EXITS("CMISSEquationsSetAnalyticDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetAnalyticDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the analytic solution for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetAnalyticDestroyObj(equationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the analytic for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetAnalyticDestroyObj",err,error,*999)

    CALL EQUATIONS_SET_ANALYTIC_DESTROY(equationsSet%EQUATIONS_SET,err,error,*999)

    CALL EXITS("CMISSEquationsSetAnalyticDestroyObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetAnalyticDestroyObj",err,error)
    CALL EXITS("CMISSEquationsSetAnalyticDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetAnalyticDestroyObj


  !
  !================================================================================================================================
  !

  !>Evaluates the current analytic solution for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetAnalyticEvaluateNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to evaluate.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to evaluate.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
     TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetAnalyticEvaluateNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_ANALYTIC_EVALUATE(EQUATIONS_SET,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetAnalyticEvaluateNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetAnalyticEvaluateNumber",err,error)
    CALL EXITS("CMISSEquationsSetAnalyticEvaluateNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetAnalyticEvaluateNumber

  !
  !================================================================================================================================
  !

  !>Evaluates the current analytic solution for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetAnalyticEvaluateObj(equationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to evaluate the current analytic solution for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetAnalyticEvaluateObj",err,error,*999)

    CALL EQUATIONS_SET_ANALYTIC_EVALUATE(equationsSet%EQUATIONS_SET,err,error,*999)

    CALL EXITS("CMISSEquationsSetAnalyticEvaluateObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetAnalyticEvaluateObj",err,error)
    CALL EXITS("CMISSEquationsSetAnalyticEvaluateObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetAnalyticEvaluateObj

  !
  !================================================================================================================================
  !

  !>Returns the analytic time for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetAnalyticTimeGetNumber(regionUserNumber,equationsSetUserNumber,time,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set get the analytic time for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the analytic time get.
    REAL(DP), INTENT(OUT) :: time !<On return, the analytic time for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetAnalyticTimeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_ANALYTIC_TIME_GET(EQUATIONS_SET,time,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetAnalyticTimeGetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetAnalyticTimeGetNumber",err,error)
    CALL EXITS("CMISSEquationsSetAnalyticTimeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetAnalyticTimeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the analytic time for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetAnalyticTimeGetObj(equationsSet,time,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to get the analytic time for.
    REAL(DP), INTENT(OUT) :: time !<On return, the analytic time for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetAnalyticTimeGetObj",err,error,*999)

    CALL EQUATIONS_SET_ANALYTIC_TIME_GET(equationsSet%EQUATIONS_SET,time,err,error,*999)

    CALL EXITS("CMISSEquationsSetAnalyticTimeGetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetAnalyticTimeGetObj",err,error)
    CALL EXITS("CMISSEquationsSetAnalyticTimeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetAnalyticTimeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the analytic time for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetAnalyticTimeSetNumber(regionUserNumber,equationsSetUserNumber,time,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set get the analytic time for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the analytic time get.
    REAL(DP), INTENT(IN) :: time !<The analytic time to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetAnalyticTimeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_ANALYTIC_TIME_SET(EQUATIONS_SET,time,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetAnalyticTimeSetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetAnalyticTimeSetNumber",err,error)
    CALL EXITS("CMISSEquationsSetAnalyticTimeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetAnalyticTimeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the analytic time for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetAnalyticTimeSetObj(equationsSet,time,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to set the analytic time for.
    REAL(DP), INTENT(IN) :: time !<The analytic time to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetAnalyticTimeSetObj",err,error,*999)

    CALL EQUATIONS_SET_ANALYTIC_TIME_SET(equationsSet%EQUATIONS_SET,time,err,error,*999)

    CALL EXITS("CMISSEquationsSetAnalyticTimeSetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetAnalyticTimeSetObj",err,error)
    CALL EXITS("CMISSEquationsSetAnalyticTimeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetAnalyticTimeSetObj


  !
  !================================================================================================================================
  !

  !>Sets the analytic problem user parameter
  SUBROUTINE CMISSEquationsSetAnalyticUserParamSetNumber(regionUserNumber,equationsSetUserNumber,paramIdx,param,err)
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set
    INTEGER(INTG), INTENT(IN) :: paramIdx !<The index of the analytic user parameter to set
    REAL(DP), INTENT(IN) :: param !<Value of the parameter to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetAnalyticUserParamSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        IF(ASSOCIATED(EQUATIONS_SET%ANALYTIC)) THEN
          CALL EQUATIONS_SET_ANALYTIC_USER_PARAM_SET(EQUATIONS_SET,paramIdx,param,err,error,*999)
        ELSE
          LOCAL_ERROR="Equations set analytic is not associated for equations set with a user number of " &
            & //TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetAnalyticUserParamSetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetAnalyticUserParamSetNumber",err,error)
    CALL EXITS("CMISSEquationsSetAnalyticUserParamSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetAnalyticUserParamSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the analytic problem user parameter
  SUBROUTINE CMISSEquationsSetAnalyticUserParamSetObj(equationsSet,paramIdx,param,err)
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to set the analytic user parameter.
    INTEGER(INTG), INTENT(IN) :: paramIdx !<The index of the analytic user parameter to set
    REAL(DP), INTENT(IN) :: param !<Value of the parameter to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetAnalyticUserParamSetObj",err,error,*999)

    CALL EQUATIONS_SET_ANALYTIC_USER_PARAM_SET(equationsSet%EQUATIONS_SET,paramIdx,param,err,error,*999)

    CALL EXITS("CMISSEquationsSetAnalyticUserParamSetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetAnalyticUserParamSetObj",err,error)
    CALL EXITS("CMISSEquationsSetAnalyticUserParamSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetAnalyticUserParamSetObj

  !
  !================================================================================================================================
  !

  !>Sets the analytic problem user parameter
  SUBROUTINE CMISSEquationsSetAnalyticUserParamGetNumber(regionUserNumber,equationsSetUserNumber,paramIdx,param,err)
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set
    INTEGER(INTG), INTENT(IN) :: paramIdx !<The index of the analytic user parameter to set
    REAL(DP), INTENT(OUT) :: param !<Value of the parameter to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetAnalyticUserParamGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        IF(ASSOCIATED(EQUATIONS_SET%ANALYTIC)) THEN
          CALL EQUATIONS_SET_ANALYTIC_USER_PARAM_GET(EQUATIONS_SET,paramIdx,param,err,error,*999)
        ELSE
          LOCAL_ERROR="Equations set analytic is not associated for equations set with a user number of " &
            & //TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetAnalyticUserParamGetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetAnalyticUserParamGetNumber",err,error)
    CALL EXITS("CMISSEquationsSetAnalyticUserParamGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetAnalyticUserParamGetNumber

  !
  !================================================================================================================================
  !

  !>Sets the analytic problem user parameter
  SUBROUTINE CMISSEquationsSetAnalyticUserParamGetObj(equationsSet,paramIdx,param,err)
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to set the analytic user parameter.
    INTEGER(INTG), INTENT(IN) :: paramIdx !<The index of the analytic user parameter to set
    REAL(DP), INTENT(OUT) :: param !<Value of the parameter to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetAnalyticUserParamGetObj",err,error,*999)

    CALL EQUATIONS_SET_ANALYTIC_USER_PARAM_GET(equationsSet%EQUATIONS_SET,paramIdx,param,err,error,*999)

    CALL EXITS("CMISSEquationsSetAnalyticUserParamGetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetAnalyticUserParamGetObj",err,error)
    CALL EXITS("CMISSEquationsSetAnalyticUserParamGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetAnalyticUserParamGetObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetCreateFinishNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_CREATE_FINISH(EQUATIONS_SET,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Equations Set Create')
#endif

    CALL EXITS("CMISSEquationsSetCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetCreateFinishNumber",err,error)
    CALL EXITS("CMISSEquationsSetreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetCreateFinishObj(equationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetCreateFinishObj",err,error,*999)

    CALL EQUATIONS_SET_CREATE_FINISH(equationsSet%EQUATIONS_SET,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Equations Set Create')
#endif

    CALL EXITS("CMISSEquationsSetCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetCreateFinishObj",err,error)
    CALL EXITS("CMISSEquationsSetCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetCreateStartNumber(equationsSetUserNumber,regionUserNumber,geomFibreFieldUserNumber,&
               & equationsSetClass,equationsSetType,equationsSetSubtype,equationsSetFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to be created.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to start the creation of an equations set on.
    INTEGER(INTG), INTENT(IN) :: geomFibreFieldUserNumber !<The user number of the Geometric/Fibre field for the equations set.
    INTEGER(INTG), INTENT(IN) :: equationsSetFieldUserNumber !<The user number of the equations set field
    INTEGER(INTG), INTENT(IN) :: equationsSetClass !<The equations set class to set. \see OPENCMISS_EquationsSetClasses
    INTEGER(INTG), INTENT(IN) :: equationsSetType !<The equations set type to set. \see OPENCMISS_EquationsSetTypes
    INTEGER(INTG), INTENT(IN) :: equationsSetSubtype !<The equations set subtype to set. \see OPENCMISS_EquationsSetSubtypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: EQUATIONS_SET_FIELD_FIELD
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(FIELD_TYPE), POINTER :: GEOM_FIBRE_FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetCreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Equations Set Create')
#endif

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(GEOM_FIBRE_FIELD)
    NULLIFY(EQUATIONS_SET_FIELD_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(geomFibreFieldUserNumber,REGION,GEOM_FIBRE_FIELD,err,error,*999)

!!!!!!!!!!!!ALSO A FIELD USER NUMBER FIND FOR EQUATIONS SET FIELD?
      CALL FIELD_USER_NUMBER_FIND(equationsSetFieldUserNumber,REGION,EQUATIONS_SET_FIELD_FIELD,err,error,*999)

      IF(ASSOCIATED(GEOM_FIBRE_FIELD)) THEN
        CALL EQUATIONS_SET_CREATE_START(equationsSetUserNumber,REGION,GEOM_FIBRE_FIELD,&
          & equationsSetClass,equationsSetType,equationsSetSubtype,equationsSetFieldUserNumber,&
          & EQUATIONS_SET_FIELD_FIELD,EQUATIONS_SET,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(geomFibreFieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetCreateStartNumber",err,error)
    CALL EXITS("CMISSEquationsSetCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetCreateStartObj(equationsSetUserNumber,region,geomFibreField,&
              & equationsSetClass,equationsSetType,equationsSetSubtype,equationsSetFieldUserNumber,&
              & equationsSetFieldField,equationsSet,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to be created.
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region to create the equations set on.
    TYPE(CMISSFieldType), INTENT(IN) :: geomFibreField !<The Geometric/Fibre field for the creation of the equations set.
    INTEGER(INTG), INTENT(IN) :: equationsSetFieldUserNumber !<The user number of the equations set field
    TYPE(CMISSFieldType), INTENT(INOUT) :: equationsSetFieldField !<On return, a pointer to the equations set field
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<On return, the created equations set.
    INTEGER(INTG), INTENT(IN) :: equationsSetClass !<The equations set class to set. \see OPENCMISS_EquationsSetClasses
    INTEGER(INTG), INTENT(IN) :: equationsSetType !<The equations set type to set. \see OPENCMISS_EquationsSetTypes
    INTEGER(INTG), INTENT(IN) :: equationsSetSubtype !<The equations set subtype to set. \see OPENCMISS_EquationsSetSubtypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetCreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Equations Set Create')
#endif

    CALL EQUATIONS_SET_CREATE_START(equationsSetUserNumber,region%REGION,geomFibreField%FIELD, &
      & equationsSetClass,equationsSetType,equationsSetSubtype,&
      & equationsSetFieldUserNumber, equationsSetFieldField%FIELD, equationsSet%EQUATIONS_SET, &
      & err,error,*999)

    CALL EXITS("CMISSEquationsSetCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetCreateStartObj",err,error)
    CALL EXITS("CMISSEquationsSetCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetDestroyNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destory.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
     TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_DESTROY(EQUATIONS_SET,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetDestroyNumber",err,error)
    CALL EXITS("CMISSEquationsSetDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetDestroyObj(equationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetDestroyObj",err,error,*999)

    CALL EQUATIONS_SET_DESTROY(equationsSet%EQUATIONS_SET,err,error,*999)

    CALL EXITS("CMISSEquationsSetDestroyObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetDestroyObj",err,error)
    CALL EXITS("CMISSEquationsSetDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetDestroyObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of dependent variables for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetDependentCreateFinishNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish the creation of dependent variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of dependent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetDependentCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_DEPENDENT_CREATE_FINISH(EQUATIONS_SET,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetDependentCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetDependentCreateFinishNumber",err,error)
    CALL EXITS("CMISSEquationsSetDependentCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetDependentCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of dependent variables for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetDependentCreateFinishObj(equationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of dependent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetDependentCreateFinishObj",err,error,*999)

    CALL EQUATIONS_SET_DEPENDENT_CREATE_FINISH(equationsSet%EQUATIONS_SET,err,error,*999)

    CALL EXITS("CMISSEquationsSetDependentCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetDependentCreateFinishObj",err,error)
    CALL EXITS("CMISSEquationsSetDependentCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetDependentCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of dependent variables for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetDependentCreateStartNumber(regionUserNumber,equationsSetUserNumber,dependentFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to start the creation of dependent variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to start the creation of dependent variables for.
    INTEGER(INTG), INTENT(IN) :: dependentFieldUserNumber !<The user number of the dependent field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetDependentCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(DEPENDENT_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL FIELD_USER_NUMBER_FIND(dependentFieldUserNumber,REGION,DEPENDENT_FIELD,ERR,error,*999)
        CALL EQUATIONS_SET_DEPENDENT_CREATE_START(EQUATIONS_SET,dependentFieldUserNumber,DEPENDENT_FIELD,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetDependentCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetDependentCreateStartNumber",err,error)
    CALL EXITS("CMISSEquationsSetDependentCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetDependentCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of dependent variables for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetDependentCreateStartObj(equationsSet,dependentFieldUserNumber,dependentField,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the creation of dependent variables on.
    INTEGER(INTG), INTENT(IN) :: dependentFieldUserNumber !<The user number of the dependent field.
    TYPE(CMISSFieldType), INTENT(INOUT) :: dependentField !<If associated on entry, the user created dependent field which has the same user number as the specified dependent field user number. If not associated on entry, on return, the created dependent field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetDependentCreateStartObj",err,error,*999)

    CALL EQUATIONS_SET_DEPENDENT_CREATE_START(equationsSet%EQUATIONS_SET,dependentFieldUserNumber,dependentField%FIELD, &
      & err,error,*999)

    CALL EXITS("CMISSEquationsSetDependentCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetDependentCreateStartObj",err,error)
    CALL EXITS("CMISSEquationsSetDependentCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetDependentCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the dependent variables for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetDependentDestroyNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destroy the dependent variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the dependent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetDependentDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_DEPENDENT_DESTROY(EQUATIONS_SET,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetDependentDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetDependentDestroyNumber",err,error)
    CALL EXITS("CMISSEquationsSetDependentDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetDependentDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the dependent variables for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetDependentDestroyObj(equationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the dependent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetDependentDestroyObj",err,error,*999)

    CALL EQUATIONS_SET_DEPENDENT_DESTROY(equationsSet%EQUATIONS_SET,err,error,*999)

    CALL EXITS("CMISSEquationsSetDependentDestroyObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetDependentDestroyObj",err,error)
    CALL EXITS("CMISSEquationsSetDependentDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetDependentDestroyObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of equations for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetEquationsCreateFinishNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish the creation of equations for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetEquationsCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_CREATE_FINISH(EQUATIONS_SET,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetEquationsCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetEquationsCreateFinishNumber",err,error)
    CALL EXITS("CMISSEquationsSetEquationsCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetEquationsCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of equations for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetEquationsCreateFinishObj(equationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetEquationsCreateFinishObj",err,error,*999)

    CALL EQUATIONS_SET_EQUATIONS_CREATE_FINISH(equationsSet%EQUATIONS_SET,err,error,*999)

    CALL EXITS("CMISSEquationsSetEquationsCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetEquationsCreateFinishObj",err,error)
    CALL EXITS("CMISSEquationsSetEquationsCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetEquationsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of equations for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetEquationsCreateStartNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to start the creation of equations for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to start the creation of equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetEquationsCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_CREATE_START(EQUATIONS_SET,EQUATIONS,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetEquationsCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetEquationsCreateStartNumber",err,error)
    CALL EXITS("CMISSEquationsSetEquationsCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetEquationsCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of equations for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetEquationsCreateStartObj(equationsSet,equations,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the creation of equations on.
    TYPE(CMISSEquationsType), INTENT(INOUT) :: equations !<On return, the created equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetEquationsCreateStartObj",err,error,*999)

    CALL EQUATIONS_SET_EQUATIONS_CREATE_START(equationsSet%EQUATIONS_SET,equations%EQUATIONS,err,error,*999)

    CALL EXITS("CMISSEquationsSetEquationsCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetEquationsCreateStartObj",err,error)
    CALL EXITS("CMISSEquationsSetEquationsCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetEquationsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the equations for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetEquationsDestroyNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destroy the equations for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetEquationsDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_DESTROY(EQUATIONS_SET,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetEquationsDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetEquationsDestroyNumber",err,error)
    CALL EXITS("CMISSEquationsSetEquationsDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetEquationsDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the equations for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetEquationsDestroyObj(equationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetEquationsDestroyObj",err,error,*999)

    CALL EQUATIONS_SET_EQUATIONS_DESTROY(equationsSet%EQUATIONS_SET,err,error,*999)

    CALL EXITS("CMISSEquationsSetEquationsDestroyObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetEquationsDestroyObj",err,error)
    CALL EXITS("CMISSEquationsSetEquationsDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetEquationsDestroyObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of independent variables for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetIndependentCreateFinishNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish the creation of independent variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of independent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetIndependentCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_INDEPENDENT_CREATE_FINISH(EQUATIONS_SET,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetIndependentCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetIndependentCreateFinishNumber",err,error)
    CALL EXITS("CMISSEquationsSetIndependentCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetIndependentCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of independent variables for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetIndependentCreateFinishObj(equationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of independent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetIndependentCreateFinishObj",err,error,*999)

    CALL EQUATIONS_SET_INDEPENDENT_CREATE_FINISH(equationsSet%EQUATIONS_SET,err,error,*999)

    CALL EXITS("CMISSEquationsSetIndependentCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetIndependentCreateFinishObj",err,error)
    CALL EXITS("CMISSEquationsSetIndependentCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetIndependentCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of independent variables for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetIndependentCreateStartNumber(regionUserNumber,equationsSetUserNumber,independentFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to start the creation of independent variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to start the creation of independent variables for.
    INTEGER(INTG), INTENT(IN) :: independentFieldUserNumber !<The user number of the independent field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(FIELD_TYPE), POINTER :: INDEPENDENT_FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetDependentCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(INDEPENDENT_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL FIELD_USER_NUMBER_FIND(independentFieldUserNumber,REGION,INDEPENDENT_FIELD,ERR,error,*999)
        CALL EQUATIONS_SET_DEPENDENT_CREATE_START(EQUATIONS_SET,independentFieldUserNumber,INDEPENDENT_FIELD,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetIndependentCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetIndependentCreateStartNumber",err,error)
    CALL EXITS("CMISSEquationsSetIndependentCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetIndependentCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of independent variables for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetIndependentCreateStartObj(equationsSet,independentFieldUserNumber,independentField,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the creation of independent variables on.
    INTEGER(INTG), INTENT(IN) :: independentFieldUserNumber !<The user number of the dependent field.
    TYPE(CMISSFieldType), INTENT(INOUT) :: independentField !<If associated on entry, the user created independent field which has the same user number as the specified independent field user number. If not associated on entry, on return, the created independent field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetIndependentCreateStartObj",err,error,*999)

    CALL EQUATIONS_SET_INDEPENDENT_CREATE_START(equationsSet%EQUATIONS_SET,independentFieldUserNumber,independentField%FIELD, &
      & err,error,*999)

    CALL EXITS("CMISSEquationsSetIndependentCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetIndependentCreateStartObj",err,error)
    CALL EXITS("CMISSEquationsSetIndependentCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetIndependentCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the independent variables for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetIndependentDestroyNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destroy the independent variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the independent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetIndependentDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_INDEPENDENT_DESTROY(EQUATIONS_SET,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetIndependentDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetIndependentDestroyNumber",err,error)
    CALL EXITS("CMISSEquationsSetIndependentDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetIndependentDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the independent variables for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetIndependentDestroyObj(equationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the independent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetIndependentDestroyObj",err,error,*999)

    CALL EQUATIONS_SET_INDEPENDENT_DESTROY(equationsSet%EQUATIONS_SET,err,error,*999)

    CALL EXITS("CMISSEquationsSetIndependentDestroyObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetIndependentDestroyObj",err,error)
    CALL EXITS("CMISSEquationsSetIndependentDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetIndependentDestroyObj

  !
  !================================================================================================================================
  !

  !
  !================================================================================================================================
  !

  !>Finish the creation of materials for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetMaterialsCreateFinishNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish the creation of materials for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of materials for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetMaterialsCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_MATERIALS_CREATE_FINISH(EQUATIONS_SET,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetMaterialsCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetMaterialsCreateFinishNumber",err,error)
    CALL EXITS("CMISSEquationsSetMaterialsCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetMaterialsCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of materials for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetMaterialsCreateFinishObj(equationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of materials for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetMaterialsCreateFinishObj",err,error,*999)

    CALL EQUATIONS_SET_MATERIALS_CREATE_FINISH(equationsSet%EQUATIONS_SET,err,error,*999)

    CALL EXITS("CMISSEquationsSetMaterialsCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetMaterialsCreateFinishObj",err,error)
    CALL EXITS("CMISSEquationsSetMaterialsCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetMaterialsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of materials for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetMaterialsCreateStartNumber(regionUserNumber,equationsSetUserNumber,materialsFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to start the creation of materials for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to start the creation of materials for.
    INTEGER(INTG), INTENT(IN) :: materialsFieldUserNumber !<The user number of the materials field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(FIELD_TYPE), POINTER :: MATERIALS_FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetMaterialsCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(MATERIALS_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL FIELD_USER_NUMBER_FIND(materialsFieldUserNumber,REGION,MATERIALS_FIELD,ERR,error,*999)
        CALL EQUATIONS_SET_MATERIALS_CREATE_START(EQUATIONS_SET,materialsFieldUserNumber,MATERIALS_FIELD,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetMaterialsCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetMaterialsCreateStartNumber",err,error)
    CALL EXITS("CMISSEquationsSetMaterialsCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetMaterialsCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of materials for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetMaterialsCreateStartObj(equationsSet,materialsFieldUserNumber,materialsField,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the creation of materials on.
    INTEGER(INTG), INTENT(IN) :: materialsFieldUserNumber !<The user number of the materials field.
    TYPE(CMISSFieldType), INTENT(INOUT) :: materialsField !<If associated on entry, the user created materials field which has the same user number as the specified materials field user number. If not associated on entry, on return, the created materials field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetMaterialsCreateStartObj",err,error,*999)

    CALL EQUATIONS_SET_MATERIALS_CREATE_START(equationsSet%EQUATIONS_SET,materialsFieldUserNumber,materialsField%FIELD, &
      & err,error,*999)

    CALL EXITS("CMISSEquationsSetMaterialsCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetMaterialsCreateStartObj",err,error)
    CALL EXITS("CMISSEquationsSetMaterialsCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetMaterialsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the materials for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetMaterialsDestroyNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destroy the materials for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the materials for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetMaterialsDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_MATERIALS_DESTROY(EQUATIONS_SET,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetMaterialsDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetMaterialsDestroyNumber",err,error)
    CALL EXITS("CMISSEquationsSetMaterialsDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetMaterialsDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the materials for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetMaterialsDestroyObj(equationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the materials for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetMaterialsDestroyObj",err,error,*999)

    CALL EQUATIONS_SET_MATERIALS_DESTROY(equationsSet%EQUATIONS_SET,err,error,*999)

    CALL EXITS("CMISSEquationsSetMaterialsDestroyObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetMaterialsDestroyObj",err,error)
    CALL EXITS("CMISSEquationsSetMaterialsDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetMaterialsDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the solution method for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetSolutionMethodGetNumber(regionUserNumber,equationsSetUserNumber,solutionMethod,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to get the solution method for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the solution method for.
    INTEGER(INTG), INTENT(OUT) :: solutionMethod !<On return, the solution method. \see OPENCMISS_EquationsSetSolutionMethods
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetSolutionMethodGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_SOLUTION_METHOD_GET(EQUATIONS_SET,solutionMethod,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetSolutionMethodGetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetSolutionMethodGetNumber",err,error)
    CALL EXITS("CMISSEquationsSetSolutionMethodGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetSolutionMethodGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the solution method for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetSolutionMethodGetObj(equationsSet,solutionMethod,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to get the solution method for.
    INTEGER(INTG), INTENT(OUT) :: solutionMethod !<On Return, the solution method. \see OPENCMISS_EquationsSetSolutionMethods
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetSolutionMethodGetObj",err,error,*999)

    CALL EQUATIONS_SET_SOLUTION_METHOD_GET(equationsSet%EQUATIONS_SET,solutionMethod,err,error,*999)

    CALL EXITS("CMISSEquationsSetSolutionMethodGetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetSolutionMethodGetObj",err,error)
    CALL EXITS("CMISSEquationsSetSolutionMethodGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetSolutionMethodGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the solution method for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetSolutionMethodSetNumber(regionUserNumber,equationsSetUserNumber,solutionMethod,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to set the solution method for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the solution method for.
    INTEGER(INTG), INTENT(IN) :: solutionMethod !<The solution method to set. \see OPENCMISS_EquationsSetSolutionMethods
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetSolutionMethodSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_SOLUTION_METHOD_SET(EQUATIONS_SET,solutionMethod,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetSolutionMethodSetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetSolutionMethodSetNumber",err,error)
    CALL EXITS("CMISSEquationsSetSolutionMethodSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetSolutionMethodSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the solution method for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetSolutionMethodSetObj(equationsSet,solutionMethod,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to set the solution method for.
    INTEGER(INTG), INTENT(IN) :: solutionMethod !<The solution method to set. \see OPENCMISS_EquationsSetSolutionMethods
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetSolutionMethodSetObj",err,error,*999)

    CALL EQUATIONS_SET_SOLUTION_METHOD_SET(equationsSet%EQUATIONS_SET,solutionMethod,err,error,*999)

    CALL EXITS("CMISSEquationsSetSolutionMethodSetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetSolutionMethodSetObj",err,error)
    CALL EXITS("CMISSEquationsSetSolutionMethodSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetSolutionMethodSetObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of a source for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetSourceCreateFinishNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish the creation of a source for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of a source for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetSourceCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_SOURCE_CREATE_FINISH(EQUATIONS_SET,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetSourceCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetSourceCreateFinishNumber",err,error)
    CALL EXITS("CMISSEquationsSetSourceCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetSourceCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of a source for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetSourceCreateFinishObj(equationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of a source for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetSourceCreateFinishObj",err,error,*999)

    CALL EQUATIONS_SET_SOURCE_CREATE_FINISH(equationsSet%EQUATIONS_SET,err,error,*999)

    CALL EXITS("CMISSEquationsSetSourceCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetSourceCreateFinishObj",err,error)
    CALL EXITS("CMISSEquationsSetSourceCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetSourceCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of a source for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetSourceCreateStartNumber(regionUserNumber,equationsSetUserNumber,sourceFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to start the creation of a source for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to start the creation of a source for.
    INTEGER(INTG), INTENT(IN) :: sourceFieldUserNumber !<The user number of the source field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(FIELD_TYPE), POINTER :: SOURCE_FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetSourceCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(SOURCE_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL FIELD_USER_NUMBER_FIND(sourceFieldUserNumber,REGION,SOURCE_FIELD,ERR,error,*999)
        CALL EQUATIONS_SET_SOURCE_CREATE_START(EQUATIONS_SET,sourceFieldUserNumber,SOURCE_FIELD,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetSourceCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetSourceCreateStartNumber",err,error)
    CALL EXITS("CMISSEquationsSetSourceCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetSourceCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of a source for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetSourceCreateStartObj(equationsSet,sourceFieldUserNumber,sourceField,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the creation of a source on.
    INTEGER(INTG), INTENT(IN) :: sourceFieldUserNumber !<The user number of the source field.
    TYPE(CMISSFieldType), INTENT(INOUT) :: sourceField !<If associated on entry, the user created source field which has the same user number as the specified source field user number. If not associated on entry, on return, the created source field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetSourceCreateStartObj",err,error,*999)

    CALL EQUATIONS_SET_SOURCE_CREATE_START(equationsSet%EQUATIONS_SET,sourceFieldUserNumber,sourceField%FIELD,err,error,*999)

    CALL EXITS("CMISSEquationsSetSourceCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetSourceCreateStartObj",err,error)
    CALL EXITS("CMISSEquationsSetSourceCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetSourceCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the source for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetSourceDestroyNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destroy the source for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the source for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetSourceDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_SOURCE_DESTROY(EQUATIONS_SET,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetSourceDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetSourceDestroyNumber",err,error)
    CALL EXITS("CMISSEquationsSetSourceDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetSourceDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the source for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetSourceDestroyObj(equationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the source for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetSourceDestroyObj",err,error,*999)

    CALL EQUATIONS_SET_SOURCE_DESTROY(equationsSet%EQUATIONS_SET,err,error,*999)

    CALL EXITS("CMISSEquationsSetSourceDestroyObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetSourceDestroyObj",err,error)
    CALL EXITS("CMISSEquationsSetSourceDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetSourceDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the equations set specification i.e., equations set class, type and subtype for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetSpecificationGetNumber(regionUserNumber,equationsSetUserNumber,equationsSetClass, &
    & equationsSetType,equationsSetSubtype,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to get the specification for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the specification for.
    INTEGER(INTG), INTENT(OUT) :: equationsSetClass !<On return, the equations set class. \see OPENCMISS_EquationsSetClasses
    INTEGER(INTG), INTENT(OUT) :: equationsSetType !<On return, the equations set type. \see OPENCMISS_EquationsSetTypes
    INTEGER(INTG), INTENT(OUT) :: equationsSetSubtype !<On return, the equations set subtype. \see OPENCMISS_EquationsSetSubtypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetSpecificationGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_SPECIFICATION_GET(EQUATIONS_SET,equationsSetClass,equationsSetType,equationsSetSubtype,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetSpecificationGetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetSpecificationGetNumber",err,error)
    CALL EXITS("CMISSEquationsSetSpecificationGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetSpecificationGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the equations set specification i.e., equations set class, type and subtype for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetSpecificationGetObj(equationsSet,equationsSetClass,equationsSetType,equationsSetSubtype,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(IN) :: equationsSet !<The equations set to get the specification for.
    INTEGER(INTG), INTENT(OUT) :: equationsSetClass !<On return, the equations set class. \see OPENCMISS_EquationsSetClasses
    INTEGER(INTG), INTENT(OUT) :: equationsSetType !<On return, the equations set type. \see OPENCMISS_EquationsSetTypes
    INTEGER(INTG), INTENT(OUT) :: equationsSetSubtype !<On return, the equations set subtype. \see OPENCMISS_EquationsSetSubtypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetSpecificationGetObj",err,error,*999)

    CALL EQUATIONS_SET_SPECIFICATION_GET(equationsSet%EQUATIONS_SET,equationsSetClass,equationsSetType,equationsSetSubtype, &
      & err,error,*999)

    CALL EXITS("CMISSEquationsSetSpecificationGetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetSpecificationGetObj",err,error)
    CALL EXITS("CMISSEquationsSetSpecificationGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetSpecificationGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the equations set specification i.e., equations set class, type and subtype for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSetSpecificationSetNumber(regionUserNumber,equationsSetUserNumber,equationsSetClass, &
    & equationsSetType,equationsSetSubtype,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to set the specification for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the specification for.
    INTEGER(INTG), INTENT(IN) :: equationsSetClass !<The equations set class to set. \see OPENCMISS_EquationsSetClasses
    INTEGER(INTG), INTENT(IN) :: equationsSetType !<The equations set type to set. \see OPENCMISS_EquationsSetTypes
    INTEGER(INTG), INTENT(IN) :: equationsSetSubtype !<The equations set subtype to set. \see OPENCMISS_EquationsSetSubtypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSetSpecificationSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_SPECIFICATION_SET(EQUATIONS_SET,equationsSetClass,equationsSetType,equationsSetSubtype,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSEquationsSetSpecificationSetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSetSpecificationSetNumber",err,error)
    CALL EXITS("CMISSEquationsSetSpecificationSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetSpecificationSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the equations set specification i.e., equations set class, type and subtype for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSetSpecificationSetObj(equationsSet,equationsSetClass,equationsSetType,equationsSetSubtype,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to set the specification for.
    INTEGER(INTG), INTENT(IN) :: equationsSetClass !<The equations set class to set. \see OPENCMISS_EquationsSetClasses
    INTEGER(INTG), INTENT(IN) :: equationsSetType !<The equations set type to set. \see OPENCMISS_EquationsSetTypes
    INTEGER(INTG), INTENT(IN) :: equationsSetSubtype !<The equations set subtype to set. \see OPENCMISS_EquationsSetSubtypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSetSpecificationSetObj",err,error,*999)

    CALL EQUATIONS_SET_SPECIFICATION_SET(equationsSet%EQUATIONS_SET,equationsSetClass,equationsSetType,equationsSetSubtype, &
      & err,error,*999)

    CALL EXITS("CMISSEquationsSetSpecificationSetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSetSpecificationSetObj",err,error)
    CALL EXITS("CMISSEquationsSetSpecificationSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSetSpecificationSetObj

!!==================================================================================================================================
!!
!! FIELD_ROUTINES
!!
!!==================================================================================================================================

  !>Returns the interpolation type for a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldComponentInterpolationGetNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & interpolationType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the interpolation type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the interpolation type for.
    INTEGER(INTG), INTENT(OUT) :: interpolationType !<On return, the interpolation type. \see OPENCMISS_FieldInterpolationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldComponentInterpolationGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_INTERPOLATION_GET(FIELD,variableType,componentNumber,interpolationType,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldComponentInterpolationGetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldComponentInterpolationGetNumber",err,error)
    CALL EXITS("CMISSFieldComponentInterpolationGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldComponentInterpolationGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the interpolation type for a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldComponentInterpolationGetObj(field,variableType,componentNumber,interpolationType,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the interpolation type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the interpolation type for.
    INTEGER(INTG), INTENT(OUT) :: interpolationType !<On return, the interpolation type. \see OPENCMISS_FieldInterpolationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldComponentInterpolationGetObj",err,error,*999)

    CALL FIELD_COMPONENT_INTERPOLATION_GET(field%FIELD,variableType,componentNumber,interpolationType,err,error,*999)

    CALL EXITS("CMISSFieldComponentInterpolationGetObj")
    RETURN
999 CALL ERRORS("CMISSFieldComponentInterpolationGetObj",err,error)
    CALL EXITS("CMISSFieldComponentInterpolationGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldComponentInterpolationGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the interpolation type for a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldComponentInterpolationSetNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & interpolationType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the interpolation type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: interpolationType !<The interpolation type to set. \see OPENCMISS_FieldInterpolationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldComponentInterpolationSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_INTERPOLATION_SET(FIELD,variableType,componentNumber,interpolationType,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldComponentInterpolationSetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldComponentInterpolationSetNumber",err,error)
    CALL EXITS("CMISSFieldComponentInterpolationSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldComponentInterpolationSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the interpolation type for a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldComponentInterpolationSetObj(field,variableType,componentNumber,interpolationType,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the interpolation type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: interpolationType !<The interpolation type to set. \see OPENCMISS_FieldInterpolationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldComponentInterpolationSetObj",err,error,*999)

    CALL FIELD_COMPONENT_INTERPOLATION_SET(field%FIELD,variableType,componentNumber,interpolationType,err,error,*999)

    CALL EXITS("CMISSFieldComponentInterpolationSetObj")
    RETURN
999 CALL ERRORS("CMISSFieldComponentInterpolationSetObj",err,error)
    CALL EXITS("CMISSFieldComponentInterpolationSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldComponentInterpolationSetObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldComponentLabelGetCNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the label for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the field variable component label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldComponentLabelGetCNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_LABEL_GET(FIELD,variableType,componentNumber,label,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldComponentLabelGetCNumber")
    RETURN
999 CALL ERRORS("CMISSFieldComponentLabelGetCNumber",err,error)
    CALL EXITS("CMISSFieldComponentLabelGetCNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldComponentLabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldComponentLabelGetCObj(field,variableType,componentNumber,label,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the label for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the field variable component label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldComponentLabelGetCObj",err,error,*999)

    CALL FIELD_COMPONENT_LABEL_GET(field%FIELD,variableType,componentNumber,label,err,error,*999)

    CALL EXITS("CMISSFieldComponentLabelGetCObj")
    RETURN
999 CALL ERRORS("CMISSFieldComponentLabelGetCObj",err,error)
    CALL EXITS("CMISSFieldComponentLabelGetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldComponentLabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldComponentLabelGetVSNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the label for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the field variable component label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldComponentLabelGetVSNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_LABEL_GET(FIELD,variableType,componentNumber,label,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldComponentLabelGetVSNumber")
    RETURN
999 CALL ERRORS("CMISSFieldComponentLabelGetVSNumber",err,error)
    CALL EXITS("CMISSFieldComponentLabelGetVSNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldComponentLabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldComponentLabelGetVSObj(field,variableType,componentNumber,label,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the label for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the field variable component label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldComponentLabelGetVSObj",err,error,*999)

    CALL FIELD_COMPONENT_LABEL_GET(field%FIELD,variableType,componentNumber,label,err,error,*999)

    CALL EXITS("CMISSFieldComponentLabelGetVSObj")
    RETURN
999 CALL ERRORS("CMISSFieldComponentLabelGetVSObj",err,error)
    CALL EXITS("CMISSFieldComponentLabelGetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldComponentLabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldComponentLabelSetCNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the label for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The field variable component label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldComponentLabelSetCNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_LABEL_SET(FIELD,variableType,componentNumber,label,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldComponentLabelSetCNumber")
    RETURN
999 CALL ERRORS("CMISSFieldComponentLabelSetCNumber",err,error)
    CALL EXITS("CMISSFieldComponentLabelSetCNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldComponentLabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldComponentLabelSetCObj(field,variableType,componentNumber,label,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the label for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The field variable component label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldComponentLabelSetCObj",err,error,*999)

    CALL FIELD_COMPONENT_LABEL_SET(field%FIELD,variableType,componentNumber,label,err,error,*999)

    CALL EXITS("CMISSFieldComponentLabelSetCObj")
    RETURN
999 CALL ERRORS("CMISSFieldComponentLabelSetCObj",err,error)
    CALL EXITS("CMISSFieldComponentLabelSetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldComponentLabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldComponentLabelSetVSNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the label for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The field variable component label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldComponentLabelSetVSNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_LABEL_SET(FIELD,variableType,componentNumber,label,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldComponentLabelSetVSNumber")
    RETURN
999 CALL ERRORS("CMISSFieldComponentLabelSetVSNumber",err,error)
    CALL EXITS("CMISSFieldComponentLabelSetVSNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldComponentLabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldComponentLabelSetVSObj(field,variableType,componentNumber,label,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the label for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The field variable component label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldComponentLabelSetVSObj",err,error,*999)

    CALL FIELD_COMPONENT_LABEL_SET(field%FIELD,variableType,componentNumber,label,err,error,*999)

    CALL EXITS("CMISSFieldComponentLabelSetVSObj")
    RETURN
999 CALL ERRORS("CMISSFieldComponentLabelSetVSObj",err,error)
    CALL EXITS("CMISSFieldComponentLabelSetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldComponentLabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the mesh component number for a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldComponentMeshComponentGetNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & meshComponent,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the mesh component number for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the mesh component number for.
    INTEGER(INTG), INTENT(OUT) :: meshComponent !<On return, the mesh component number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldComponentMeshComponentGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_MESH_COMPONENT_GET(FIELD,variableType,componentNumber,meshComponent,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldComponentMeshComponentGetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldComponentMeshComponentGetNumber",err,error)
    CALL EXITS("CMISSFieldComponentMeshComponentGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldComponentMeshComponentGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the mesh component number for a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldComponentMeshComponentGetObj(field,variableType,componentNumber,meshComponent,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the mesh component number for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the mesh component number for.
    INTEGER(INTG), INTENT(OUT) :: meshComponent !<On return, the mesh component number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldComponentMeshComponentGetObj",err,error,*999)

    CALL FIELD_COMPONENT_MESH_COMPONENT_GET(field%FIELD,variableType,componentNumber,meshComponent,err,error,*999)

    CALL EXITS("CMISSFieldComponentMeshComponentGetObj")
    RETURN
999 CALL ERRORS("CMISSFieldComponentMeshComponentGetObj",err,error)
    CALL EXITS("CMISSFieldComponentMeshComponentGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldComponentMeshComponentGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh component number for a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldComponentMeshComponentSetNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & meshComponent,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the mesh component number for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: meshComponent !<The mesh component number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldComponentMeshComponentSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_MESH_COMPONENT_SET(FIELD,variableType,componentNumber,meshComponent,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldComponentMeshComponentSetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldComponentMeshComponentSetNumber",err,error)
    CALL EXITS("CMISSFieldComponentMeshComponentSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldComponentMeshComponentSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh component number for a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldComponentMeshComponentSetObj(field,variableType,componentNumber,meshComponent,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the mesh component number for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: meshComponent !<The mesh component number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldComponentMeshComponentSetObj",err,error,*999)

    CALL FIELD_COMPONENT_MESH_COMPONENT_SET(field%FIELD,variableType,componentNumber,meshComponent,err,error,*999)

    CALL EXITS("CMISSFieldComponentMeshComponentSetObj")
    RETURN
999 CALL ERRORS("CMISSFieldComponentMeshComponentSetObj",err,error)
    CALL EXITS("CMISSFieldComponentMeshComponentSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldComponentMeshComponentSetObj

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to an integer constant value for a field identified by a user number.
  SUBROUTINE CMISSFieldComponentValuesInitialiseIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to initialise the field variable component for for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldComponentValuesInitialiseIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_VALUES_INITIALISE(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldComponentValuesInitialiseIntgNumber")
    RETURN
999 CALL ERRORS("CMISSFieldComponentValuesInitialiseIntgNumber",err,error)
    CALL EXITS("CMISSFieldComponentValuesInitialiseIntgNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldComponentValuesInitialiseIntgNumber

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to an integer constant value for a field identified by an object.
  SUBROUTINE CMISSFieldComponentValuesInitialiseIntgObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldComponentValuesInitialiseIntgObj",err,error,*999)

    CALL FIELD_COMPONENT_VALUES_INITIALISE(field%FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)

    CALL EXITS("CMISSFieldComponentValuesInitialiseIntgObj")
    RETURN
999 CALL ERRORS("CMISSFieldComponentValuesInitialiseIntgObj",err,error)
    CALL EXITS("CMISSFieldComponentValuesInitialiseIntgObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldComponentValuesInitialiseIntgObj
  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a single precision constant value for a field identified by a user number.
  SUBROUTINE CMISSFieldComponentValuesInitialiseSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to initialise the field variable component for for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    REAL(SP), INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldComponentValuesInitialiseSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_VALUES_INITIALISE(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldComponentValuesInitialiseSPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldComponentValuesInitialiseSPNumber",err,error)
    CALL EXITS("CMISSFieldComponentValuesInitialiseSPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldComponentValuesInitialiseSPNumber

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a single precision constant value for a field identified by an object.
  SUBROUTINE CMISSFieldComponentValuesInitialiseSPObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    REAL(SP), INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldComponentValuesInitialiseSPObj",err,error,*999)

    CALL FIELD_COMPONENT_VALUES_INITIALISE(field%FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)

    CALL EXITS("CMISSFieldComponentValuesInitialiseSPObj")
    RETURN
999 CALL ERRORS("CMISSFieldComponentValuesInitialiseSPObj",err,error)
    CALL EXITS("CMISSFieldComponentValuesInitialiseSPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldComponentValuesInitialiseSPObj
  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a double precision constant value for a field identified by a user number.
  SUBROUTINE CMISSFieldComponentValuesInitialiseDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to initialise the field variable component for for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    REAL(DP), INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldComponentValuesInitialiseDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_VALUES_INITIALISE(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldComponentValuesInitialiseDPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldComponentValuesInitialiseDPNumber",err,error)
    CALL EXITS("CMISSFieldComponentValuesInitialiseDPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldComponentValuesInitialiseDPNumber

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a double precision constant value for a field identified by an object.
  SUBROUTINE CMISSFieldComponentValuesInitialiseDPObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    REAL(DP), INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldComponentValuesInitialiseDPObj",err,error,*999)

    CALL FIELD_COMPONENT_VALUES_INITIALISE(field%FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)

    CALL EXITS("CMISSFieldComponentValuesInitialiseDPObj")
    RETURN
999 CALL ERRORS("CMISSFieldComponentValuesInitialiseDPObj",err,error)
    CALL EXITS("CMISSFieldComponentValuesInitialiseDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldComponentValuesInitialiseDPObj
  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a logical constant value for a field identified by a user number.
  SUBROUTINE CMISSFieldComponentValuesInitialiseLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to initialise the field variable component for for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    LOGICAL, INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldComponentValuesInitialiseLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_VALUES_INITIALISE(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldComponentValuesInitialiseLNumber")
    RETURN
999 CALL ERRORS("CMISSFieldComponentValuesInitialiseLNumber",err,error)
    CALL EXITS("CMISSFieldComponentValuesInitialiseLNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldComponentValuesInitialiseLNumber

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a logical constant value for a field identified by an object.
  SUBROUTINE CMISSFieldComponentValuesInitialiseLObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    LOGICAL, INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldComponentValuesInitialiseLObj",err,error,*999)

    CALL FIELD_COMPONENT_VALUES_INITIALISE(field%FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)

    CALL EXITS("CMISSFieldComponentValuesInitialiseLObj")
    RETURN
999 CALL ERRORS("CMISSFieldComponentValuesInitialiseLObj",err,error)
    CALL EXITS("CMISSFieldComponentValuesInitialiseLObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldComponentValuesInitialiseLObj

  !
  !================================================================================================================================
  !

  !>Returns the data type for a field variable for a field identified by a user number.
  SUBROUTINE CMISSFieldDataTypeGetNumber(regionUserNumber,fieldUserNumber,variableType,dataType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the data type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: dataType !<On return, the field variable data type. \see OPENCMISS_FieldDataTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldDataTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DATA_TYPE_GET(FIELD,variableType,dataType,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldDataTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldDataTypeGetNumber",err,error)
    CALL EXITS("CMISSFieldDataTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldDataTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the data type for a field variable for a field identified by an object.
  SUBROUTINE CMISSFieldDataTypeGetObj(field,variableType,dataType,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the data type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: dataType !<On return, the field variable data type. \see OPENCMISS_FieldDataTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldDataTypeGetObj",err,error,*999)

    CALL FIELD_DATA_TYPE_GET(field%FIELD,variableType,dataType,err,error,*999)

    CALL EXITS("CMISSFieldDataTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSFieldDataTypeGetObj",err,error)
    CALL EXITS("CMISSFieldDataTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldDataTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the data type for a field variable for a field identified by a user number.
  SUBROUTINE CMISSFieldDataTypeSetNumber(regionUserNumber,fieldUserNumber,variableType,dataType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the data type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the data type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the data type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: dataType !<The field variable data type to set. \see OPENCMISS_FieldDataTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldDataTypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DATA_TYPE_SET(FIELD,variableType,dataType,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldDataTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldDataTypeSetNumber",err,error)
    CALL EXITS("CMISSFieldDataTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldDataTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the data type for a field variable for a field identified by an object.
  SUBROUTINE CMISSFieldDataTypeSetObj(field,variableType,dataType,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the data type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the data type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: dataType !<The field variable data type to set. \see OPENCMISS_FieldDataTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldDataTypeSetObj",err,error,*999)

    CALL FIELD_DATA_TYPE_SET(field%FIELD,variableType,dataType,err,error,*999)

    CALL EXITS("CMISSFieldDataTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSFieldDataTypeSetObj",err,error)
    CALL EXITS("CMISSFieldDataTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldDataTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the DOF order type for a field variable for a field identified by a user number.
  SUBROUTINE CMISSFieldDOFOrderTypeGetNumber(regionUserNumber,fieldUserNumber,variableType,dOFOrderType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the DOF Order type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the DOF Order type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the DOF Order type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: dOFOrderType !<On return, the field variable DOF Order type. \see OPENCMISS_FieldDOFOrderTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldDOFOrderTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DOF_ORDER_TYPE_GET(FIELD,variableType,dOFOrderType,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldDOFOrderTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldDOFOrderTypeGetNumber",err,error)
    CALL EXITS("CMISSFieldDOFOrderTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldDOFOrderTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the DOF Order type for a field variable for a field identified by an object.
  SUBROUTINE CMISSFieldDOFOrderTypeGetObj(field,variableType,dOFOrderType,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the DOF order type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the DOF order type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: dOFOrderType !<On return, the field variable DOF order type. \see OPENCMISS_FieldDOFOrderTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldDOFOrderTypeGetObj",err,error,*999)

    CALL FIELD_DOF_ORDER_TYPE_GET(field%FIELD,variableType,dOFOrderType,err,error,*999)

    CALL EXITS("CMISSFieldDOFOrderTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSFieldDOFOrderTypeGetObj",err,error)
    CALL EXITS("CMISSFieldDOFOrderTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldDOFOrderTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the DOF order type for a field variable for a field identified by a user number.
  SUBROUTINE CMISSFieldDOFOrderTypeSetNumber(regionUserNumber,fieldUserNumber,variableType,dOFOrderType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the DOF Order type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the DOF Order type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the DOF Order type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: dOFOrderType !<The field variable DOF Order type to set. \see OPENCMISS_FieldDOFOrderTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldDOFOrderTypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DOF_ORDER_TYPE_SET(FIELD,variableType,dOFOrderType,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldDOFOrderTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldDOFOrderTypeSetNumber",err,error)
    CALL EXITS("CMISSFieldDOFOrderTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldDOFOrderTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the DOF Order type for a field variable for a field identified by an object.
  SUBROUTINE CMISSFieldDOFOrderTypeSetObj(field,variableType,dOFOrderType,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the DOF order type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the DOF order type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: dOFOrderType !<The field variable DOF order type to set. \see OPENCMISS_FieldDOFOrderTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldDOFOrderTypeSetObj",err,error,*999)

    CALL FIELD_DOF_ORDER_TYPE_SET(field%FIELD,variableType,dOFOrderType,err,error,*999)

    CALL EXITS("CMISSFieldDOFOrderTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSFieldDOFOrderTypeSetObj",err,error)
    CALL EXITS("CMISSFieldDOFOrderTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldDOFOrderTypeSetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a field identified by a user number.
  SUBROUTINE CMISSFieldCreateFinishNumber(regionUserNumber,fieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_CREATE_FINISH(FIELD,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Field Create')
#endif

    CALL EXITS("CMISSFieldCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSFieldCreateFinishNumber",err,error)
    CALL EXITS("CMISSFieldCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a field identified by an object.
  SUBROUTINE CMISSFieldCreateFinishObj(field,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(INOUT) :: field !<The field to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldCreateFinishObj",err,error,*999)

    CALL FIELD_CREATE_FINISH(field%FIELD,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('field Create')
#endif

    CALL EXITS("CMISSFieldCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSFieldCreateFinishObj",err,error)
    CALL EXITS("CMISSFieldCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a field identified by a user number.
  SUBROUTINE CMISSFieldCreateStartNumber(fieldUserNumber,regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to start the creation of.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to start the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldCreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Field Create')
#endif

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_CREATE_START(fieldUserNumber,REGION,FIELD,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSFieldCreateStartNumber",err,error)
    CALL EXITS("CMISSFieldCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a field on an interface identified by an object.
  SUBROUTINE CMISSFieldCreateStartInterfaceObj(fieldUserNumber,iNTERFACE,field,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to start the creation of.
    TYPE(CMISSInterfaceType), INTENT(IN) :: Interface !<The interface to create the field on.
    TYPE(CMISSFieldType), INTENT(INOUT) :: field !<On return, the created field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldCreateStartInterfaceObj",err,error,*999)

    CALL FIELD_CREATE_START(fieldUserNumber,Interface%iNTERFACE,field%FIELD,err,error,*999)

    CALL EXITS("CMISSFieldCreateStartInterfaceObj")
    RETURN
999 CALL ERRORS("CMISSFieldCreateStartInterfaceObj",err,error)
    CALL EXITS("CMISSFieldCreateStartInterfaceObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldCreateStartInterfaceObj

  !
  !================================================================================================================================
  !

   !>Starts the creation of a field on a region identified by an object.
  SUBROUTINE CMISSFieldCreateStartRegionObj(fieldUserNumber,region,field,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to start the creation of.
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region to create the field on.
    TYPE(CMISSFieldType), INTENT(INOUT) :: field !<On return, the created field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldCreateStartRegionObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('field Create')
#endif

    CALL FIELD_CREATE_START(fieldUserNumber,region%REGION,field%FIELD,err,error,*999)

    CALL EXITS("CMISSFieldCreateStartRegionObj")
    RETURN
999 CALL ERRORS("CMISSFieldCreateStartRegionObj",err,error)
    CALL EXITS("CMISSFieldCreateStartRegionObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldCreateStartRegionObj

  !
  !================================================================================================================================
  !

  !>Returns the dependent type for a field identified by a user number.
  SUBROUTINE CMISSFieldDependentTypeGetNumber(regionUserNumber,fieldUserNumber,dependentType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the dependent type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the dependent type for.
    INTEGER(INTG), INTENT(OUT) :: dependentType !<On return, the field dependent type. \see OPENCMISS_FieldDependentTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldDependentTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DEPENDENT_TYPE_GET(FIELD,dependentType,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldDependentTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldDependentTypeGetNumber",err,error)
    CALL EXITS("CMISSFieldDependentTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldDependentTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the dependent type for a field identified by an object.
  SUBROUTINE CMISSFieldDependentTypeGetObj(field,dependentType,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the dependent type for.
    INTEGER(INTG), INTENT(OUT) :: dependentType !<On return, the field dependent type. \see OPENCMISS_FieldDependentTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldDependentTypeGetObj",err,error,*999)

    CALL FIELD_DEPENDENT_TYPE_GET(field%FIELD,dependentType,err,error,*999)

    CALL EXITS("CMISSFieldDependentTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSFieldDependentTypeGetObj",err,error)
    CALL EXITS("CMISSFieldDependentTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldDependentTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the dependent type for a field identified by a user number.
  SUBROUTINE CMISSFieldDependentTypeSetNumber(regionUserNumber,fieldUserNumber,dependentType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the dependent type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the dependent type for.
    INTEGER(INTG), INTENT(IN) :: dependentType !<The field dependent type to set. \see OPENCMISS_FieldDependentTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldDependentTypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DEPENDENT_TYPE_SET(FIELD,dependentType,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldDependentTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldDependentTypeSetNumber",err,error)
    CALL EXITS("CMISSFieldDependentTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldDependentTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the dependent type for a field identified by an object.
  SUBROUTINE CMISSFieldDependentTypeSetObj(field,dependentType,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the dependent type for.
    INTEGER(INTG), INTENT(IN) :: dependentType !<The field dependent type to set. \see OPENCMISS_FieldDependentTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldDependentTypeSetObj",err,error,*999)

    CALL FIELD_DEPENDENT_TYPE_SET(field%FIELD,dependentType,err,error,*999)

    CALL EXITS("CMISSFieldDependentTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSFieldDependentTypeSetObj",err,error)
    CALL EXITS("CMISSFieldDependentTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldDependentTypeSetObj

  !
  !================================================================================================================================
  !

  !>Destroys a field identified by a user number.
  SUBROUTINE CMISSFieldDestroyNumber(regionUserNumber,fieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to destroy.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DESTROY(FIELD,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSFieldDestroyNumber",err,error)
    CALL EXITS("CMISSFieldDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a field identified by an object.
  SUBROUTINE CMISSFieldDestroyObj(field,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldDestroyObj",err,error,*999)

    CALL FIELD_DESTROY(field%FIELD,err,error,*999)

    CALL EXITS("CMISSFieldDestroyObj")
    RETURN
999 CALL ERRORS("CMISSFieldDestroyObj",err,error)
    CALL EXITS("CMISSFieldDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the dimension for a field identified by a user number.
  SUBROUTINE CMISSFieldDimensionGetNumber(regionUserNumber,fieldUserNumber,variableType,dIMENSION,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the dimension for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the dimension for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the dimension for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: Dimension !<On return, the field dimension. \see OPENCMISS_FieldDimensionTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldDimensionGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DIMENSION_GET(FIELD,variableType,dIMENSION,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldDimensionGetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldDimensionGetNumber",err,error)
    CALL EXITS("CMISSFieldDimensionGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldDimensionGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the dimension for a field identified by an object.
  SUBROUTINE CMISSFieldDimensionGetObj(field,variableType,dIMENSION,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the dimension for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the dimension for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: Dimension !<On return, the field dimension. \see OPENCMISS_FieldDimension
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldDimensionGetObj",err,error,*999)

    CALL FIELD_DIMENSION_GET(field%FIELD,variableType,dIMENSION,err,error,*999)

    CALL EXITS("CMISSFieldDimensionGetObj")
    RETURN
999 CALL ERRORS("CMISSFieldDimensionGetObj",err,error)
    CALL EXITS("CMISSFieldDimensionGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldDimensionGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the dimension for a field identified by a user number.
  SUBROUTINE CMISSFieldDimensionSetNumber(regionUserNumber,fieldUserNumber,variableType,dIMENSION,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the dimension for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the dimension for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the dimension for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: Dimension !<The field dimension to set. \see OPENCMISS_FieldDimensionTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldDimensionSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DIMENSION_SET(FIELD,variableType,dIMENSION,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldDimensionSetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldDimensionSetNumber",err,error)
    CALL EXITS("CMISSFieldDimensionSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldDimensionSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the dimension for a field identified by an object.
  SUBROUTINE CMISSFieldDimensionSetObj(field,variableType,dimension,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the dimension for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the dimension for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: dimension !<The field dimension to set. \see OPENCMISS_FieldDimension
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldDimensionSetObj",err,error,*999)

    CALL FIELD_DIMENSION_SET(field%FIELD,variableType,DIMENSION,err,error,*999)

    CALL EXITS("CMISSFieldDimensionSetObj")
    RETURN
999 CALL ERRORS("CMISSFieldDimensionSetObj",err,error)
    CALL EXITS("CMISSFieldDimensionSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldDimensionSetObj

  !
  !================================================================================================================================
  !

  !>Returns the geometric field for a field identified by a user number.
  SUBROUTINE CMISSFieldGeometricFieldGetNumber(regionUserNumber,fieldUserNumber,geometricFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the geometric field for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the geometric field for.
    INTEGER(INTG), INTENT(OUT) :: geometricFieldUserNumber !<On return, the field geometric field user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD,GEOMETRIC_FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldGeometricFieldGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    NULLIFY(GEOMETRIC_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_GEOMETRIC_FIELD_GET(FIELD,GEOMETRIC_FIELD,err,error,*999)
        geometricFieldUserNumber=GEOMETRIC_FIELD%USER_NUMBER
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldGeometricFieldGetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldGeometricFieldGetNumber",err,error)
    CALL EXITS("CMISSFieldGeometricFieldGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldGeometricFieldGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the geometric field for a field identified by an object.
  SUBROUTINE CMISSFieldGeometricFieldGetObj(field,geometricField,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the geometric field for.
    TYPE(CMISSFieldType), INTENT(INOUT) :: geometricField !<On return, the geometric field for the field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldGeometricFieldGetObj",err,error,*999)

    CALL FIELD_GEOMETRIC_FIELD_GET(field%FIELD,geometricField%FIELD,err,error,*999)

    CALL EXITS("CMISSFieldGeometricFieldGetObj")
    RETURN
999 CALL ERRORS("CMISSFieldGeometricFieldGetObj",err,error)
    CALL EXITS("CMISSFieldGeometricFieldGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldGeometricFieldGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the geometric field for a field identified by a user number.
  SUBROUTINE CMISSFieldGeometricFieldSetNumber(regionUserNumber,fieldUserNumber,geometricFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the geometric field for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the geometric field for.
    INTEGER(INTG), INTENT(OUT) :: geometricFieldUserNumber !<The field geometric field user number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD,GEOMETRIC_FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldGeometricFieldSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    NULLIFY(GEOMETRIC_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_USER_NUMBER_FIND(geometricFieldUserNumber,REGION,GEOMETRIC_FIELD,err,error,*999)
        IF(ASSOCIATED(GEOMETRIC_FIELD)) THEN
          CALL FIELD_GEOMETRIC_FIELD_SET(FIELD,GEOMETRIC_FIELD,err,error,*999)
        ELSE
          LOCAL_ERROR="A geometric field with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(geometricFieldUserNumber,"*",err,error))// &
            & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldGeometricFieldSetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldGeometricFieldSetNumber",err,error)
    CALL EXITS("CMISSFieldGeometricFieldSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldGeometricFieldSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the geometric field for a field identified by an object.
  SUBROUTINE CMISSFieldGeometricFieldSetObj(field,geometricField,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the geometric field for.
    TYPE(CMISSFieldType), INTENT(IN) :: geometricField !<The geometric field for the field to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldGeometricFieldSetObj",err,error,*999)

    CALL FIELD_GEOMETRIC_FIELD_SET(field%FIELD,geometricField%FIELD,err,error,*999)

    CALL EXITS("CMISSFieldGeometricFieldSetObj")
    RETURN
999 CALL ERRORS("CMISSFieldGeometricFieldSetObj",err,error)
    CALL EXITS("CMISSFieldGeometricFieldSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldGeometricFieldSetObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a field identified by a user number.
  SUBROUTINE CMISSFieldLabelGetCNumber(regionUserNumber,fieldUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the field label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldLabelGetCNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_LABEL_GET(FIELD,label,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldLabelGetCNumber")
    RETURN
999 CALL ERRORS("CMISSFieldLabelGetCNumber",err,error)
    CALL EXITS("CMISSFieldLabelGetCNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldLabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a field identified by an object.
  SUBROUTINE CMISSFieldLabelGetCObj(field,label,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the field label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldLabelGetCObj",err,error,*999)

    CALL FIELD_LABEL_GET(field%FIELD,label,err,error,*999)

    CALL EXITS("CMISSFieldLabelGetCObj")
    RETURN
999 CALL ERRORS("CMISSFieldLabelGetCObj",err,error)
    CALL EXITS("CMISSFieldLabelGetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldLabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a field identified by a user number.
  SUBROUTINE CMISSFieldLabelGetVSNumber(regionUserNumber,fieldUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the field label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldLabelGetVSNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_LABEL_GET(FIELD,label,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldLabelGetVSNumber")
    RETURN
999 CALL ERRORS("CMISSFieldLabelGetVSNumber",err,error)
    CALL EXITS("CMISSFieldLabelGetVSNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldLabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a field identified by an object.
  SUBROUTINE CMISSFieldLabelGetVSObj(field,label,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the field label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldLabelGetVSObj",err,error,*999)

    CALL FIELD_LABEL_GET(field%FIELD,label,err,error,*999)

    CALL EXITS("CMISSFieldLabelGetVSObj")
    RETURN
999 CALL ERRORS("CMISSFieldLabelGetVSObj",err,error)
    CALL EXITS("CMISSFieldLabelGetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldLabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a field identified by a user number.
  SUBROUTINE CMISSFieldLabelSetCNumber(regionUserNumber,fieldUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The field label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldLabelSetCNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_LABEL_SET(FIELD,label,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldLabelSetCNumber")
    RETURN
999 CALL ERRORS("CMISSFieldLabelSetCNumber",err,error)
    CALL EXITS("CMISSFieldLabelSetCNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldLabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a field identified by an object.
  SUBROUTINE CMISSFieldLabelSetCObj(field,label,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The field label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldLabelSetCObj",err,error,*999)

    CALL FIELD_LABEL_SET(field%FIELD,label,err,error,*999)

    CALL EXITS("CMISSFieldLabelSetCObj")
    RETURN
999 CALL ERRORS("CMISSFieldLabelSetCObj",err,error)
    CALL EXITS("CMISSFieldLabelSetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldLabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a field identified by a user number.
  SUBROUTINE CMISSFieldLabelSetVSNumber(regionUserNumber,fieldUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The field label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldLabelSetVSNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_LABEL_SET(FIELD,label,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldLabelSetVSNumber")
    RETURN
999 CALL ERRORS("CMISSFieldLabelSetVSNumber",err,error)
    CALL EXITS("CMISSFieldLabelSetVSNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldLabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a field identified by an object.
  SUBROUTINE CMISSFieldLabelSetVSObj(field,label,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The field label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldLabelSetVSObj",err,error,*999)

    CALL FIELD_LABEL_SET(field%FIELD,label,err,error,*999)

    CALL EXITS("CMISSFieldLabelSetVSObj")
    RETURN
999 CALL ERRORS("CMISSFieldLabelSetVSObj",err,error)
    CALL EXITS("CMISSFieldLabelSetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldLabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the interpolation type for a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldPositionNormalTangentCalculateNodeNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & localNodeNumber,position,normal,tangents,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the interpolation type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number of the field variable to get the data type for.
    REAL(DP), INTENT(OUT) :: position(:),normal(:),tangents(:,:) !<Actual useful outputs
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldPositionNormalTangentCalculateNodeNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_POSITION_NORMAL_TANGENTS_CALCULATE_NODE(FIELD,variableType,componentNumber,localNodeNumber, &
          & position,normal,tangents,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldPositionNormalTangentCalculateNodeNumber")
    RETURN
999 CALL ERRORS("CMISSFieldPositionNormalTangentCalculateNodeNumber",err,error)
    CALL EXITS("CMISSFieldPositionNormalTangentCalculateNodeNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldPositionNormalTangentCalculateNodeNumber

  !
  !================================================================================================================================
  !

  !>Returns the position, normal and tangents for a field node for a field identified by an object.
  SUBROUTINE CMISSFieldPositionNormalTangentCalculateNodeObj(field,variableType,componentNumber,localNodeNumber, &
    & position,normal,tangents,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the interpolation type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data type for.
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number of the field variable to get the data type for.
    REAL(DP), INTENT(OUT) :: position(:),normal(:),tangents(:,:) !<Actual useful outputs
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldPositionNormalTangentCalculateNodeObj",err,error,*999)

    CALL FIELD_POSITION_NORMAL_TANGENTS_CALCULATE_NODE(field%FIELD,variableType,componentNumber,localNodeNumber, &
    & position,normal,tangents,err,error,*999)

    CALL EXITS("CMISSFieldPositionNormalTangentCalculateNodeObj")
    RETURN
999 CALL ERRORS("CMISSFieldPositionNormalTangentCalculateNodeObj",err,error)
    CALL EXITS("CMISSFieldPositionNormalTangentCalculateNodeObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldPositionNormalTangentCalculateNodeObj



  !
  !================================================================================================================================
  !

  !>Returns the mesh decomposition for a field identified by a user number.
  SUBROUTINE CMISSFieldMeshDecompositionGetNumber(regionUserNumber,fieldUserNumber,decompositionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the mesh decomposition for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the mesh decomposition for.
    INTEGER(INTG), INTENT(OUT) :: decompositionUserNumber !<On return, the field decomposition user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldMeshDecompositionGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_MESH_DECOMPOSITION_GET(FIELD,DECOMPOSITION,err,error,*999)
        decompositionUserNumber=DECOMPOSITION%USER_NUMBER
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldMeshDecompositionGetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldMeshDecompositionGetNumber",err,error)
    CALL EXITS("CMISSFieldMeshDecompositionGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMeshDecompositionGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the mesh decomposition for a field identified by an object.
  SUBROUTINE CMISSFieldMeshDecompositionGetObj(field,meshDecomposition,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the mesh decomposition for.
    TYPE(CMISSDecompositionType), INTENT(INOUT) :: meshDecomposition !<On return, the mesh decomposition for the field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldMeshDecompositionGetObj",err,error,*999)

    CALL FIELD_MESH_DECOMPOSITION_GET(field%FIELD,meshDecomposition%DECOMPOSITION,err,error,*999)

    CALL EXITS("CMISSFieldMeshDecompositionGetObj")
    RETURN
999 CALL ERRORS("CMISSFieldMeshDecompositionGetObj",err,error)
    CALL EXITS("CMISSFieldMeshDecompositionGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMeshDecompositionGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh decomposition for a field identified by a user number.
  SUBROUTINE CMISSFieldMeshDecompositionSetNumber(regionUserNumber,fieldUserNumber,meshUserNumber,decompositionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the mesh decomposition for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the mesh decomposition for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the mesh decomposition for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The field mesh decomposition user number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldMeshDecompositionSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    NULLIFY(DECOMPOSITION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
        IF(ASSOCIATED(MESH)) THEN
          CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
          IF(ASSOCIATED(DECOMPOSITION)) THEN
            CALL FIELD_MESH_DECOMPOSITION_SET(FIELD,DECOMPOSITION,err,error,*999)
          ELSE
            LOCAL_ERROR="A decomposition with a user number of "//TRIM(NUMBER_TO_VSTRING(decompositionUserNumber,"*",err,error))// &
              & " does not exist on mesh number "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
            & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldMeshDecompositionSetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldMeshDecompositionSetNumber",err,error)
    CALL EXITS("CMISSFieldMeshDecompositionSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMeshDecompositionSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh decomposition for a field identified by an object.
  SUBROUTINE CMISSFieldMeshDecompositionSetObj(field,meshDecomposition,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the mesh decomposition for.
    TYPE(CMISSDecompositionType), INTENT(IN) :: meshDecomposition !<The mesh decomposition for the field to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldMeshDecompositionSetObj",err,error,*999)

    CALL FIELD_MESH_DECOMPOSITION_SET(field%FIELD,meshDecomposition%DECOMPOSITION,err,error,*999)

    CALL EXITS("CMISSFieldMeshDecompositionSetObj")
    RETURN
999 CALL ERRORS("CMISSFieldMeshDecompositionSetObj",err,error)
    CALL EXITS("CMISSFieldMeshDecompositionSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMeshDecompositionSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of componenets for a field variable for a field identified by a user number.
  SUBROUTINE CMISSFieldNumberOfComponentsGetNumber(regionUserNumber,fieldUserNumber,variableType,numberOfComponents,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the number of components for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the number of components for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to get the number of components for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: numberOfComponents !<On return, the number of components in the field variable.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldNumberOfComponentsGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_NUMBER_OF_COMPONENTS_GET(FIELD,variableType,numberOfComponents,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldNumberOfComponentsGetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldNumberOfComponentsGetNumber",err,error)
    CALL EXITS("CMISSFieldNumberOfComponentsGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldNumberOfComponentsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of components for a field variable for a field identified by an object.
  SUBROUTINE CMISSFieldNumberOfComponentsGetObj(field,variableType,numberOfComponents,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the number of components for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to get the number of components for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: numberOfComponents !<On return, the number of components in the field variable.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldNumberOfComponentsGetObj",err,error,*999)

    CALL FIELD_NUMBER_OF_COMPONENTS_GET(field%FIELD,variableType,numberOfComponents,err,error,*999)

    CALL EXITS("CMISSFieldNumberOfComponentsGetObj")
    RETURN
999 CALL ERRORS("CMISSFieldNumberOfComponentsGetObj",err,error)
    CALL EXITS("CMISSFieldNumberOfComponentsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldNumberOfComponentsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of componenets for a field variable for a field identified by a user number.
  SUBROUTINE CMISSFieldNumberOfComponentsSetNumber(regionUserNumber,fieldUserNumber,variableType,numberOfComponents,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the number of components for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: numberOfComponents !<The number of components in the field variable to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldNumberOfComponentsSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_NUMBER_OF_COMPONENTS_SET(FIELD,variableType,numberOfComponents,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldNumberOfComponentsSetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldNumberOfComponentsSetNumber",err,error)
    CALL EXITS("CMISSFieldNumberOfComponentsSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldNumberOfComponentsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of components for a field variable for a field identified by an object.
  SUBROUTINE CMISSFieldNumberOfComponentsSetObj(field,variableType,numberOfComponents,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the number of components for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: numberOfComponents !<The number of components in the field variable to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldNumberOfComponentsSetObj",err,error,*999)

    CALL FIELD_NUMBER_OF_COMPONENTS_SET(field%FIELD,variableType,numberOfComponents,err,error,*999)

    CALL EXITS("CMISSFieldNumberOfComponentsSetObj")
    RETURN
999 CALL ERRORS("CMISSFieldNumberOfComponentsSetObj",err,error)
    CALL EXITS("CMISSFieldNumberOfComponentsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldNumberOfComponentsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of variables for a field identified by a user number.
  SUBROUTINE CMISSFieldNumberOfVariablesGetNumber(regionUserNumber,fieldUserNumber,numberOfVariables,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the number of variables for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the number of variables for.
    INTEGER(INTG), INTENT(OUT) :: numberOfVariables !<On return, the number of variables in the field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldNumberOfVariablesGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_NUMBER_OF_VARIABLES_GET(FIELD,numberOfVariables,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldNumberOfVariablesGetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldNumberOfVariablesGetNumber",err,error)
    CALL EXITS("CMISSFieldNumberOfVariablesGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldNumberOfVariablesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of variables for a field identified by an object.
  SUBROUTINE CMISSFieldNumberOfVariablesGetObj(field,numberOfVariables,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the number of variables for.
    INTEGER(INTG), INTENT(OUT) :: numberOfVariables !<On return, the number of variables in the field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldNumberOfVariablesGetObj",err,error,*999)

    CALL FIELD_NUMBER_OF_VARIABLES_GET(field%FIELD,numberOfVariables,err,error,*999)

    CALL EXITS("CMISSFieldNumberOfVariablesGetObj")
    RETURN
999 CALL ERRORS("CMISSFieldNumberOfVariablesGetObj",err,error)
    CALL EXITS("CMISSFieldNumberOfVariablesGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldNumberOfVariablesGetObj

  !
  !================================================================================================================================
  !

  !>Sets/chnages the number of variables for a field identified by a user number.
  SUBROUTINE CMISSFieldNumberOfVariablesSetNumber(regionUserNumber,fieldUserNumber,numberOfVariables,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the number of variables for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the number of variables for.
    INTEGER(INTG), INTENT(IN) :: numberOfVariables !<The number of variables in the field to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldNumberOfVariablesSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_NUMBER_OF_VARIABLES_SET(FIELD,numberOfVariables,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldNumberOfVariablesSetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldNumberOfVariablesSetNumber",err,error)
    CALL EXITS("CMISSFieldNumberOfVariablesSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldNumberOfVariablesSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of variables for a field identified by an object.
  SUBROUTINE CMISSFieldNumberOfVariablesSetObj(field,numberOfVariables,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the number of variables for.
    INTEGER(INTG), INTENT(IN) :: numberOfVariables !<The number of variables in the field to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldNumberOfVariablesSetObj",err,error,*999)

    CALL FIELD_NUMBER_OF_VARIABLES_SET(field%FIELD,numberOfVariables,err,error,*999)

    CALL EXITS("CMISSFieldNumberOfVariablesSetObj")
    RETURN
999 CALL ERRORS("CMISSFieldNumberOfVariablesSetObj",err,error)
    CALL EXITS("CMISSFieldNumberOfVariablesSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldNumberOfVariablesSetObj

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetAddConstantIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetAddConstantIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetAddConstantIntgNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddConstantIntgNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetAddConstantIntgNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetAddConstantIntgNumber

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for the constant of the field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetAddConstantIntgObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the field parameter set.
     INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetAddConstantIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_CONSTANT(field%FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetAddConstantIntgObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddConstantIntgObj",err,error)
    CALL EXITS("CMISSFieldParameterSetAddConstantIntgObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetAddConstantIntgObj

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetAddConstantSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    REAL(SP), INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetAddConstantSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetAddConstantSPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddConstantSPNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetAddConstantSPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetAddConstantSPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for the constant of the field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetAddConstantSPObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    REAL(SP), INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetAddConstantSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_CONSTANT(field%FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetAddConstantSPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddConstantSPObj",err,error)
    CALL EXITS("CMISSFieldParameterSetAddConstantSPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetAddConstantSPObj

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetAddConstantDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    REAL(DP), INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetAddConstantDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetAddConstantDPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddConstantDPNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetAddConstantDPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetAddConstantDPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for the constant of the field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetAddConstantDPObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    REAL(DP), INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetAddConstantDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_CONSTANT(field%FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetAddConstantDPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddConstantDPObj",err,error)
    CALL EXITS("CMISSFieldParameterSetAddConstantDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetAddConstantDPObj

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetAddConstantLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    LOGICAL, INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetAddConstantLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetAddConstantLNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddConstantLNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetAddConstantLNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetAddConstantLNumber

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for the constant of the field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetAddConstantLObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    LOGICAL, INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetAddConstantLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_CONSTANT(field%FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetAddConstantLbj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddConstantLObj",err,error)
    CALL EXITS("CMISSFieldParameterSetAddConstantLObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetAddConstantLObj

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to an element in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetAddElementIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetAddElementIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetAddElementIntgNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddElementIntgNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetAddElementIntgNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetAddElementIntgNumber

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to an element in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetAddElementIntgObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: UserElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetAddElementIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_ELEMENT(field%FIELD,variableType,fieldSetType,UserElementNumber,componentNumber,value, &
      & err,error,*999)

    CALL EXITS("CMISSFieldParameterSetAddElementIntgObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddElementIntgObj",err,error)
    CALL EXITS("CMISSFieldParameterSetAddElementIntgObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetAddElementIntgObj

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to an element in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetAddElementSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetAddElementSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetAddElementSPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddElementSPNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetAddElementSPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetAddElementSPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to an element in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetAddElementSPObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetAddElementSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_ELEMENT(field%FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    CALL EXITS("CMISSFieldParameterSetAddElementSPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddElementSPObj",err,error)
    CALL EXITS("CMISSFieldParameterSetAddElementSPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetAddElementSPObj

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to an element in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetAddElementDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetAddElementDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetAddElementDPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddElementDPNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetAddElementDPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetAddElementDPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to an element in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetAddElementDPObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetAddElementDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_ELEMENT(field%FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    CALL EXITS("CMISSFieldParameterSetAddElementDPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddElementDPObj",err,error)
    CALL EXITS("CMISSFieldParameterSetAddElementDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetAddElementDPObj

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to an element in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetAddElementLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetAddElementLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetAddElementLNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddElementLNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetAddElementLNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetAddElementLNumber

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to an element in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetAddElementLObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetAddElementLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_ELEMENT(field%FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    CALL EXITS("CMISSFieldParameterSetAddElementLObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddElementLObj",err,error)
    CALL EXITS("CMISSFieldParameterSetAddElementLObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetAddElementLObj

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to an node in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetAddNodeIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,versionNumber, &
    & derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetAddNodeIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
          & componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetAddNodeIntgNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddNodeIntgNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetAddNodeIntgNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetAddNodeIntgNumber

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to an node in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetAddNodeIntgObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetAddNodeIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_NODE(field%FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetAddNodeIntgObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddNodeIntgObj",err,error)
    CALL EXITS("CMISSFieldParameterSetAddNodeIntgObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetAddNodeIntgObj

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to an node in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetAddNodeSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,versionNumber, &
    & derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetAddNodeSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
          & componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetAddNodeSPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddNodeSPNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetAddNodeSPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetAddNodeSPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to an node in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetAddNodeSPObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetAddNodeSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_NODE(field%FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetAddNodeSPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddNodeSPObj",err,error)
    CALL EXITS("CMISSFieldParameterSetAddNodeSPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetAddNodeSPObj

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to an node in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetAddNodeDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,versionNumber, &
    & derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetAddNodeDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
          & componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetAddNodeDPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddNodeDPNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetAddNodeDPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetAddNodeDPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to an node in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetAddNodeDPObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetAddNodeDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_NODE(field%FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetAddNodeDPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddNodeDPObj",err,error)
    CALL EXITS("CMISSFieldParameterSetAddNodeDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetAddNodeDPObj

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to an node in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetAddNodeLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,versionNumber, &
    & derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetAddNodeLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
          & componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetAddNodeLNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddNodeLNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetAddNodeLNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetAddNodeLNumber

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to an node in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetAddNodeLObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber, value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetAddNodeLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_NODE(field%FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber, value,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetAddNodeLObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetAddNodeLObj",err,error)
    CALL EXITS("CMISSFieldParameterSetAddNodeLObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetAddNodeLObj

  !
  !================================================================================================================================
  !

  !>Creates a new parameter set of type set type for a field variable for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetCreateNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to create the parameter set on.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to create the parameter set on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to create the parameter set on. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to create. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetCreateNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_CREATE(FIELD,variableType,fieldSetType,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetCreateNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetCreateNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetCreateNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetCreateNumber

  !
  !================================================================================================================================
  !

  !>Creates a new parameter set of type set type for a field variable for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetCreateObj(field,variableType,fieldSetType,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to create the field parameter set on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to create the parameter set on. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to create. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetCreateObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_CREATE(field%FIELD,variableType,fieldSetType,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetCreateObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetCreateObj",err,error)
    CALL EXITS("CMISSFieldParameterSetCreateObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetCreateObj

  !
  !================================================================================================================================
  !

  !>Destroys the specified parameter set type for a field variable for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetDestroyNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to destroy the parameter set for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to destroy the parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to destroy the parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to destroy. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DESTROY(FIELD,variableType,fieldSetType,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDestroyNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the specified parameter set type for a field variable for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetDestroyObj(field,variableType,fieldSetType,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to destroy the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to destroy the parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to destroy. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetDestroyObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_DESTROY(field%FIELD,variableType,fieldSetType,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetDestroyObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDestroyObj",err,error)
    CALL EXITS("CMISSFieldParameterSetDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local integer data array for a field identified by an user number. The pointer must be restored with a call to OPENCMISS::CMISSFieldParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE CMISSFieldParameterSetDataGetIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,parameters,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetDataGetIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DATA_GET(FIELD,variableType,fieldSetType,parameters,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetDataGetIntgNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDataGetIntgNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetDataGetIntgNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetDataGetIntgNumber

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local integer data array for a field identified by an object. The pointer must be restored with a call to OPENCMISS::CMISSFieldParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE CMISSFieldParameterSetDataGetIntgObj(field,variableType,fieldSetType,parameters,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetDataGetIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_DATA_GET(field%FIELD,variableType,fieldSetType,parameters,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetDataGetIntgObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDataGetIntgObj",err,error)
    CALL EXITS("CMISSFieldParameterSetDataGetIntgObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetDataGetIntgObj

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local single precision data array for a field identified by an user number. The pointer must be restored with a call to OPENCMISS::CMISSFieldParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE CMISSFieldParameterSetDataGetSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,parameters,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OPENCMISS_FieldParameterSetTypes
    REAL(SP), INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetDataGetSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DATA_GET(FIELD,variableType,fieldSetType,parameters,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetDataGetSPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDataGetSPNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetDataGetSPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetDataGetSPNumber

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local single precision data array for a field identified by an object. The pointer must be restored with a call to OPENCMISS::CMISSFieldParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE CMISSFieldParameterSetDataGetSPObj(field,variableType,fieldSetType,parameters,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OPENCMISS_FieldParameterSetTypes
    REAL(SP), INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetDataGetSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_DATA_GET(field%FIELD,variableType,fieldSetType,parameters,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetDataGetSPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDataGetSPObj",err,error)
    CALL EXITS("CMISSFieldParameterSetDataGetSPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetDataGetSPObj

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local double precision data array for a field identified by an user number. The pointer must be restored with a call to OPENCMISS::CMISSFieldParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE CMISSFieldParameterSetDataGetDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,parameters,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OPENCMISS_FieldParameterSetTypes
    REAL(DP), INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetDataGetDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DATA_GET(FIELD,variableType,fieldSetType,parameters,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetDataGetDPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDataGetDPNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetDataGetDPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetDataGetDPNumber

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local double precision data array for a field identified by an object. The pointer must be restored with a call to OPENCMISS::CMISSFieldParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE CMISSFieldParameterSetDataGetDPObj(field,variableType,fieldSetType,parameters,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OPENCMISS_FieldParameterSetTypes
    REAL(DP), INTENT(INOUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetDataGetDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_DATA_GET(field%FIELD,variableType,fieldSetType,parameters,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetDataGetDPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDataGetDPObj",err,error)
    CALL EXITS("CMISSFieldParameterSetDataGetDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetDataGetDPObj

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local logical data array for a field identified by an user number. The pointer must be restored with a call to OPENCMISS::CMISSFieldParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE CMISSFieldParameterSetDataGetLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,parameters,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OPENCMISS_FieldParameterSetTypes
    LOGICAL, INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetDataGetLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DATA_GET(FIELD,variableType,fieldSetType,parameters,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetDataGetLNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDataGetLNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetDataGetLNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetDataGetLNumber

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local logical data array for a field identified by an object. The pointer must be restored with a call to OPENCMISS::CMISSFieldParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE CMISSFieldParameterSetDataGetLObj(field,variableType,fieldSetType,parameters,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OPENCMISS_FieldParameterSetTypes
    LOGICAL, INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetDataGetLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_DATA_GET(field%FIELD,variableType,fieldSetType,parameters,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetDataGetLObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDataGetLObj",err,error)
    CALL EXITS("CMISSFieldParameterSetDataGetLObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetDataGetLObj

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local integer array that was obtained with an OPENCMISS::CMISSFieldParameterSetDataGet call for a field that is specified with an user number.
  SUBROUTINE CMISSFieldParameterSetDataRestoreIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,parameters,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT), POINTER :: parameters(:) !<A pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetDataRestoreIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FIELD,variableType,fieldSetType,parameters,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetDataRestoreIntgNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDataRestoreIntgNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetDataRestoreIntgNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetDataRestoreIntgNumber

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local integer array that was obtained with an OPENCMISS::CMISSFieldParameterSetDataGet call for a field that is specified with an object.
  SUBROUTINE CMISSFieldParameterSetDataRestoreIntgObj(field,variableType,fieldSetType,parameters,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to restore the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data to restore.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetDataRestoreIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_DATA_RESTORE(field%FIELD,variableType,fieldSetType,parameters,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetDataRestoreIntgObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDataRestoreIntgObj",err,error)
    CALL EXITS("CMISSFieldParameterSetDataRestoreIntgObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetDataRestoreIntgObj

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local single precision array that was obtained with an OPENCMISS::CMISSFieldParameterSetDataGet call for a field that is specified with an user number.
  SUBROUTINE CMISSFieldParameterSetDataRestoreSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,parameters,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OPENCMISS_FieldParameterSetTypes
    REAL(SP), INTENT(OUT), POINTER :: parameters(:) !<A pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetDataRestoreSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FIELD,variableType,fieldSetType,parameters,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetDataRestoreSPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDataRestoreSPNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetDataRestoreSPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetDataRestoreSPNumber

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local single precision array that was obtained with an OPENCMISS::CMISSFieldParameterSetDataGet call for a field that is specified with an object.
  SUBROUTINE CMISSFieldParameterSetDataRestoreSPObj(field,variableType,fieldSetType,parameters,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to restore the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OPENCMISS_FieldParameterSetTypes
    REAL(SP), INTENT(OUT), POINTER :: parameters(:) !<A pointer to the parameter set data to restore.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetDataRestoreSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_DATA_RESTORE(field%FIELD,variableType,fieldSetType,parameters,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetDataRestoreSPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDataRestoreSPObj",err,error)
    CALL EXITS("CMISSFieldParameterSetDataRestoreSPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetDataRestoreSPObj

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local double precision array that was obtained with an OPENCMISS::CMISSFieldParameterSetDataGet call for a field that is specified with an user number.
  SUBROUTINE CMISSFieldParameterSetDataRestoreDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,parameters,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OPENCMISS_FieldParameterSetTypes
    REAL(DP), INTENT(OUT), POINTER :: parameters(:) !<A pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetDataRestoreDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FIELD,variableType,fieldSetType,parameters,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetDataRestoreDPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDataRestoreDPNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetDataRestoreDPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetDataRestoreDPNumber

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local double precision array that was obtained with an OPENCMISS::CMISSFieldParameterSetDataGet call for a field that is specified with an object.
  SUBROUTINE CMISSFieldParameterSetDataRestoreDPObj(field,variableType,fieldSetType,parameters,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to restore the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OPENCMISS_FieldParameterSetTypes
    REAL(DP), INTENT(OUT), POINTER :: parameters(:) !<A pointer to the parameter set data to restore.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetDataRestoreDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_DATA_RESTORE(field%FIELD,variableType,fieldSetType,parameters,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetDataRestoreDPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDataRestoreDPObj",err,error)
    CALL EXITS("CMISSFieldParameterSetDataRestoreDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetDataRestoreDPObj

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local logical array that was obtained with an OPENCMISS::CMISSFieldParameterSetDataGet call for a field that is specified with an user number.
  SUBROUTINE CMISSFieldParameterSetDataRestoreLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,parameters,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OPENCMISS_FieldParameterSetTypes
    LOGICAL, INTENT(OUT), POINTER :: parameters(:) !<A pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetDataRestoreLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FIELD,variableType,fieldSetType,parameters,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetDataRestoreLNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDataRestoreLNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetDataRestoreLNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetDataRestoreLNumber

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local logical array that was obtained with an OPENCMISS::CMISSFieldParameterSetDataGet call for a field that is specified with an object.
  SUBROUTINE CMISSFieldParameterSetDataRestoreLObj(field,variableType,fieldSetType,parameters,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to restore the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OPENCMISS_FieldParameterSetTypes
    LOGICAL, INTENT(OUT), POINTER :: parameters(:) !<A pointer to the parameter set data to restore.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetDataRestoreLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_DATA_RESTORE(field%FIELD,variableType,fieldSetType,parameters,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetDataRestoreLObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetDataRestoreLObj",err,error)
    CALL EXITS("CMISSFieldParameterSetDataRestoreLObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetDataRestoreLObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified constant of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetGetConstantIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,vALUE,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetGetConstantIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,Value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetGetConstantIntgNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetConstantIntgNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetGetConstantIntgNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetGetConstantIntgNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetGetConstantIntgObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetGetConstantIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_CONSTANT(field%FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetGetConstantIntgObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetConstantIntgObj",err,error)
    CALL EXITS("CMISSFieldParameterSetGetConstantIntgObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetGetConstantIntgObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified constant of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetGetConstantSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetGetConstantSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetGetConstantSPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetConstantSPNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetGetConstantSPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetGetConstantSPNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetGetConstantSPObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetGetConstantSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_CONSTANT(field%FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetGetConstantSPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetConstantSPObj",err,error)
    CALL EXITS("CMISSFieldParameterSetGetConstantSPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetGetConstantSPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified constant of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetGetConstantDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetGetConstantDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetGetConstantDPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetConstantDPNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetGetConstantDPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetGetConstantDPNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetGetConstantDPObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetGetConstantDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_CONSTANT(field%FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetGetConstantDPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetConstantDPObj",err,error)
    CALL EXITS("CMISSFieldParameterSetGetConstantDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetGetConstantDPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified constant of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetGetConstantLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetGetConstantLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetGetConstantLNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetConstantLNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetGetConstantLNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetGetConstantLNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetGetConstantLObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetGetConstantLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_CONSTANT(field%FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetGetConstantLObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetConstantLObj",err,error)
    CALL EXITS("CMISSFieldParameterSetGetConstantLObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetGetConstantLObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified element of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetGetElementIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetGetElementIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetGetElementIntgNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetElementIntgNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetGetElementIntgNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetGetElementIntgNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified element of a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetGetElementIntgObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetGetElementIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_ELEMENT(field%FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    CALL EXITS("CMISSFieldParameterSetGetElementIntgObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetElementIntgObj",err,error)
    CALL EXITS("CMISSFieldParameterSetGetElementIntgObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetGetElementIntgObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified element of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetGetElementSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetGetElementSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetGetElementSPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetElementSPNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetGetElementSPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetGetElementSPNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified element of a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetGetElementSPObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetGetElementSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_ELEMENT(field%FIELD,variableType,fieldSetType,userElementNumber,componentNumber,VALUE, &
      & err,error,*999)

    CALL EXITS("CMISSFieldParameterSetGetElementSPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetElementSPObj",err,error)
    CALL EXITS("CMISSFieldParameterSetGetElementSPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetGetElementSPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified element of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetGetElementDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetGetElementDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetGetElementDPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetElementDPNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetGetElementDPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetGetElementDPNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified element of a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetGetElementDPObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetGetElementDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_ELEMENT(field%FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    CALL EXITS("CMISSFieldParameterSetGetElementDPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetElementDPObj",err,error)
    CALL EXITS("CMISSFieldParameterSetGetElementDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetGetElementDPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified element of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetGetElementLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetGetElementLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetGetElementLNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetElementLNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetGetElementLNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetGetElementLNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified element of a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetGetElementLObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetGetElementLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_ELEMENT(field%FIELD,variableType,fieldSetType,userElementNumber,componentNumber,VALUE, &
      & err,error,*999)

    CALL EXITS("CMISSFieldParameterSetGetElementLObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetElementLObj",err,error)
    CALL EXITS("CMISSFieldParameterSetGetElementLObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetGetElementLObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified node and derivative of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetGetNodeIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetGetNodeIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
          & componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetGetNodeIntgNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetNodeIntgNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetGetNodeIntgNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetGetNodeIntgNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified node and derivative of a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetGetNodeIntgObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,vALUE,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: Value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetGetNodeIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_NODE(field%FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber, Value,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetGetNodeIntgObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetNodeIntgObj",err,error)
    CALL EXITS("CMISSFieldParameterSetGetNodeIntgObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetGetNodeIntgObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified node and derivative of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetGetNodeSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetGetNodeSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
          & componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetGetNodeSPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetNodeSPNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetGetNodeSPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetGetNodeSPNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified node and derivative of a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetGetNodeSPObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetGetNodeSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_NODE(field%FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetGetNodeSPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetNodeSPObj",err,error)
    CALL EXITS("CMISSFieldParameterSetGetNodeSPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetGetNodeSPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified node and derivative of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetGetNodeDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetGetNodeDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
          & componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetGetNodeDPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetNodeDPNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetGetNodeDPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetGetNodeDPNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified node and derivative of a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetGetNodeDPObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetGetNodeDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_NODE(field%FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber, value,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetGetNodeDPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetNodeDPObj",err,error)
    CALL EXITS("CMISSFieldParameterSetGetNodeDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetGetNodeDPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified node and derivative of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetGetNodeLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetGetNodeLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
          & componentNumber, value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetGetNodeLNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetNodeLNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetGetNodeLNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetGetNodeLNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified node and derivative of a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetGetNodeLObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetGetNodeLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_NODE(field%FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetGetNodeLObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetNodeLObj",err,error)
    CALL EXITS("CMISSFieldParameterSetGetNodeLObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetGetNodeLObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified element of a field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetGetGaussPointDPObj(field,variableType,fieldSetType,&
    & userElementNumber,gaussPointNumber,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetGetGaussPointDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_GAUSS_POINT(field%FIELD,variableType,fieldSetType,userElementNumber,gaussPointNumber,&
    & componentNumber,value, err,error,*999)

    CALL EXITS("CMISSFieldParameterSetGetGaussPointDPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetGetGaussPointDPObj",err,error)
    CALL EXITS("CMISSFieldParameterSetGetGaussPointDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetGetGaussPointDPObj
  !
  !================================================================================================================================
  !


  !>Updates the given parameter set with the given integer value for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetUpdateConstantIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetUpdateConstantIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetUpdateConstantIntgNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateConstantIntgNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetUpdateConstantIntgNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetUpdateConstantIntgNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the constant of the field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetUpdateConstantIntgObj(field,variableType,fieldSetType,componentNumber,vALUE,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: Value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetUpdateConstantIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(field%FIELD,variableType,fieldSetType,componentNumber,Value,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetUpdateConstantIntgObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateConstantIntgObj",err,error)
    CALL EXITS("CMISSFieldParameterSetUpdateConstantIntgObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetUpdateConstantIntgObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetUpdateConstantSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetUpdateConstantSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetUpdateConstantSPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateConstantSPNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetUpdateConstantSPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetUpdateConstantSPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the constant of the field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetUpdateConstantSPObj(field,variableType,fieldSetType,componentNumber,vALUE,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(SP), INTENT(IN) :: Value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetUpdateConstantSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(field%FIELD,variableType,fieldSetType,componentNumber,Value,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetUpdateConstantSPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateConstantSPObj",err,error)
    CALL EXITS("CMISSFieldParameterSetUpdateConstantSPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetUpdateConstantSPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetUpdateConstantDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetUpdateConstantDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetUpdateConstantDPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateConstantDPNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetUpdateConstantDPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetUpdateConstantDPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the constant of the field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetUpdateConstantDPObj(field,variableType,fieldSetType,componentNumber,vALUE,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(DP), INTENT(IN) :: Value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetUpdateConstantDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(field%FIELD,variableType,fieldSetType,componentNumber,Value,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetUpdateConstantDPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateConstantDPObj",err,error)
    CALL EXITS("CMISSFieldParameterSetUpdateConstantDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetUpdateConstantDPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetUpdateConstantLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetUpdateConstantLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetUpdateConstantLNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateConstantLNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetUpdateConstantLNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetUpdateConstantLNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the constant of the field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetUpdateConstantLObj(field,variableType,fieldSetType,componentNumber,vALUE,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    LOGICAL, INTENT(IN) :: Value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetUpdateConstantLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(field%FIELD,variableType,fieldSetType,componentNumber,Value,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetUpdateConstantLObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateConstantLObj",err,error)
    CALL EXITS("CMISSFieldParameterSetUpdateConstantLObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetUpdateConstantLObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the element of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetUpdateElementIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,vALUE,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the element value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the element value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: Value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetUpdateElementIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,Value, &
          & err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetUpdateElementIntgNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateElementIntgNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetUpdateElementIntgNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetUpdateElementIntgNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the element of the field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetUpdateElementIntgObj(field,variableType,fieldSetType,userElementNumber,componentNumber, &
    & value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetUpdateElementIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_ELEMENT(field%FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    CALL EXITS("CMISSFieldParameterSetUpdateElementIntgObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateElementIntgObj",err,error)
    CALL EXITS("CMISSFieldParameterSetUpdateElementIntgObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetUpdateElementIntgObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the element of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetUpdateElementSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,vALUE,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the element value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the element value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the element value for the field parameter set.
    REAL(SP), INTENT(IN) :: Value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetUpdateElementSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,Value, &
          & err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetUpdateElementSPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateElementSPNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetUpdateElementSPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetUpdateElementSPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the element of the field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetUpdateElementSPObj(field,variableType,fieldSetType,userElementNumber,componentNumber, &
    & value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetUpdateElementSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_ELEMENT(field%FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    CALL EXITS("CMISSFieldParameterSetUpdateElementSPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateElementSPObj",err,error)
    CALL EXITS("CMISSFieldParameterSetUpdateElementSPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetUpdateElementSPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the element of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetUpdateElementDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,vALUE,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the element value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the element value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the element value for the field parameter set.
    REAL(DP), INTENT(IN) :: Value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetUpdateElementDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,Value, &
          & err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetUpdateElementDPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateElementDPNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetUpdateElementDPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetUpdateElementDPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the element of the field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetUpdateElementDPObj(field,variableType,fieldSetType,userElementNumber,componentNumber, &
    & value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(DP), INTENT(IN) :: VALUE !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetUpdateElementDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_ELEMENT(field%FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    CALL EXITS("CMISSFieldParameterSetUpdateElementDPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateElementDPObj",err,error)
    CALL EXITS("CMISSFieldParameterSetUpdateElementDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetUpdateElementDPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the element of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetUpdateElementLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,vALUE,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the element value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the element value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the element value for the field parameter set.
    LOGICAL, INTENT(IN) :: Value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetUpdateElementLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,Value, &
          & err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetUpdateElementLNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateElementLNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetUpdateElementLNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetUpdateElementLNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the element of the field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetUpdateElementLObj(field,variableType,fieldSetType,userElementNumber,componentNumber, &
    & value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetUpdateElementLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_ELEMENT(field%FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    CALL EXITS("CMISSFieldParameterSetUpdateElementLObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateElementLObj",err,error)
    CALL EXITS("CMISSFieldParameterSetUpdateElementLObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetUpdateElementLObj

  !
  !================================================================================================================================
  !

  !>Finishes the parameter set update for a field variable for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetUpdateFinishNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to finish the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to finish the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to finish the parameter set update for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type to finish the update for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetUpdateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_FINISH(FIELD,variableType,fieldSetType,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetUpdateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateFinishNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetUpdateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetUpdateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the parameter set update for a field variable for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetUpdateFinishObj(field,variableType,fieldSetType,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to finishe the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to finish the parameter set update for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type to finish the update for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetUpdateFinishObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_FINISH(field%FIELD,variableType,fieldSetType,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetUpdateFinishObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateFinishObj",err,error)
    CALL EXITS("CMISSFieldParameterSetUpdateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetUpdateFinishObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the node and derivative of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetUpdateNodeIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetUpdateNodeIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
          & componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetUpdateNodeIntgNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateNodeIntgNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetUpdateNodeIntgNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetUpdateNodeIntgNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the node and derivative of the field variable component for a field identified by an object.

  SUBROUTINE CMISSFieldParameterSetUpdateNodeIntgObj(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetUpdateNodeIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_NODE(field%FIELD,variableType,fieldSetType,versionNumber,derivativeNumber, &
      & userNodeNumber,componentNumber, value,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetUpdateNodeIntgObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateNodeIntgObj",err,error)
    CALL EXITS("CMISSFieldParameterSetUpdateNodeIntgObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetUpdateNodeIntgObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the node and derivative of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetUpdateNodeSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetUpdateNodeSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
          & componentNumber, value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetUpdateNodeSPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateNodeSPNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetUpdateNodeSPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetUpdateNodeSPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the node and derivative of the field variable component for a field identified by an object.

  SUBROUTINE CMISSFieldParameterSetUpdateNodeSPObj(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber, componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetUpdateNodeSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_NODE(field%FIELD,variableType,fieldSetType,versionNumber,derivativeNumber, &
      & userNodeNumber,componentNumber, value,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetUpdateNodeSPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateNodeSPObj",err,error)
    CALL EXITS("CMISSFieldParameterSetUpdateNodeSPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetUpdateNodeSPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the node and derivative of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetUpdateNodeDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetUpdateNodeDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber, &
          & userNodeNumber,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetUpdateNodeDPNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateNodeDPNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetUpdateNodeDPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetUpdateNodeDPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the node and derivative of the field variable component for a field identified by an object.

  SUBROUTINE CMISSFieldParameterSetUpdateNodeDPObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetUpdateNodeDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_NODE(field%FIELD,variableType,fieldSetType,versionNumber,derivativeNumber, &
      & userNodeNumber,componentNumber,value,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetUpdateNodeDPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateNodeDPObj",err,error)
    CALL EXITS("CMISSFieldParameterSetUpdateNodeDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetUpdateNodeDPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the node and derivative of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetUpdateNodeLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetUpdateNodeLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber, &
          & userNodeNumber,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetUpdateNodeLNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateNodeLNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetUpdateNodeLNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetUpdateNodeLNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the node and derivative of the field variable component for a field identified by an object.

  SUBROUTINE CMISSFieldParameterSetUpdateNodeLObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetUpdateNodeLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_NODE(field%FIELD,variableType,fieldSetType,versionNumber,derivativeNumber, &
      & userNodeNumber,componentNumber, value,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetUpdateNodeLObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateNodeLObj",err,error)
    CALL EXITS("CMISSFieldParameterSetUpdateNodeLObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetUpdateNodeLObj

  !
  !================================================================================================================================
  !
  !>Updates the given parameter set with the given double precision value for the element gauss point of the field variable component for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetUpdateGaussPointDPObj(field,variableType,fieldSetType,userElementNumber,gaussPointNumber, &
  & componentNumber, value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(DP), INTENT(IN) :: VALUE !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetUpdateGaussPointDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_GAUSS_POINT(field%FIELD,variableType,fieldSetType,userElementNumber,gaussPointNumber,&
    & componentNumber,value,  err,error,*999)

    CALL EXITS("CMISSFieldParameterSetUpdateGaussPointDPObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateGaussPointDPObj",err,error)
    CALL EXITS("CMISSFieldParameterSetUpdateGaussPointDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetUpdateGaussPointDPObj

  !
  !================================================================================================================================
  !

  !>Starts the parameter set update for a field variable for a field identified by a user number.
  SUBROUTINE CMISSFieldParameterSetUpdateStartNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to start the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to start the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to start the parameter set update for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type to start the update for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParameterSetUpdateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_START(FIELD,variableType,fieldSetType,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldParameterSetUpdateStartNumber")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateStartNumber",err,error)
    CALL EXITS("CMISSFieldParameterSetUpdateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetUpdateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the parameter set update for a field variable for a field identified by an object.
  SUBROUTINE CMISSFieldParameterSetUpdateStartObj(field,variableType,fieldSetType,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to start the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to start the parameter set update for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type to start the update for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetUpdateStartObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_START(field%FIELD,variableType,fieldSetType,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetUpdateStartObj")
    RETURN
999 CALL ERRORS("CMISSFieldParameterSetUpdateStartObj",err,error)
    CALL EXITS("CMISSFieldParameterSetUpdateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParameterSetUpdateStartObj

  !
  !================================================================================================================================
  !

  !>Copy the parameters from the parameter set of a component of a field variable to the paramters of a parameter set of
  !>a component of another field variable, where both fields are identified by user numbers.
  SUBROUTINE CMISSFieldParametersToFieldParametersComponentCopyNumber(fromRegionUserNumber,fromFieldUserNumber,fromVariableType, &
      & fromParameterSetType, fromComponentNumber,toRegionUserNumber,toFieldUserNumber,toVariableType,toParameterSetType, &
      & toComponentNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: fromRegionUserNumber !<The user number of the region containing the field to copy from
    INTEGER(INTG), INTENT(IN) :: fromFieldUserNumber !<The field to copy from
    INTEGER(INTG), INTENT(IN) :: fromVariableType !<The field variable type to copy from
    INTEGER(INTG), INTENT(IN) :: fromParameterSetType !<The field parameter set type to copy from
    INTEGER(INTG), INTENT(IN) :: fromComponentNumber !<The field variable component number to copy from
    INTEGER(INTG), INTENT(IN) :: toRegionUserNumber !<The user number of the region containing the field to copy to
    INTEGER(INTG), INTENT(IN) :: toFieldUserNumber !<The field to copy to
    INTEGER(INTG), INTENT(IN) :: toVariableType !<The field variable type to copy to
    INTEGER(INTG), INTENT(IN) :: toParameterSetType !<The parameter set type to copy to
    INTEGER(INTG), INTENT(IN) :: toComponentNumber !<The field variable component to copy to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(REGION_TYPE), POINTER :: FROM_REGION
    TYPE(FIELD_TYPE), POINTER :: FROM_FIELD
    TYPE(REGION_TYPE), POINTER :: TO_REGION
    TYPE(FIELD_TYPE), POINTER :: TO_FIELD
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldParametersToFieldParametersComponentCopyNumber",err,error,*999)

    NULLIFY(FROM_REGION)
    NULLIFY(FROM_FIELD)
    NULLIFY(TO_REGION)
    NULLIFY(TO_FIELD)
    CALL REGION_USER_NUMBER_FIND(fromRegionUserNumber,FROM_REGION,err,error,*999)
    IF(ASSOCIATED(FROM_REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fromFieldUserNumber,FROM_REGION,FROM_FIELD,err,error,*999)
      IF(ASSOCIATED(FROM_FIELD)) THEN
        CALL REGION_USER_NUMBER_FIND(toRegionUserNumber,TO_REGION,err,error,*999)
        IF(ASSOCIATED(TO_REGION)) THEN
          CALL FIELD_USER_NUMBER_FIND(toFieldUserNumber,TO_REGION,TO_FIELD,err,error,*999)
          IF(ASSOCIATED(TO_FIELD)) THEN
            CALL FIELD_PARAMETERS_TO_FIELD_PARAMETERS_COMPONENT_COPY(FROM_FIELD,fromVariableType,fromParameterSetType, &
              & fromComponentNumber,TO_FIELD,toVariableType,toParameterSetType,toComponentNumber,err,error,*999)
          ELSE
            LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(toFieldUserNumber,"*",err,error))// &
              & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(toRegionUserNumber,"*",err,error))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(toRegionUserNumber,"*",err,error))// &
            & " does not exist."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fromFieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(fromRegionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(fromRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    RETURN
999 CALL ERRORS("CMISSFieldParametersToFieldParametersComponentCopyNumber",err,error)
    CALL EXITS("CMISSFieldParametersToFieldParametersComponentCopyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParametersToFieldParametersComponentCopyNumber

  !
  !================================================================================================================================
  !

  !>Copy the parameters from the parameter set of a component of a field variable to the paramters of a parameter set of
  !>a component of another field variable, where both fields are objects.
  SUBROUTINE CMISSFieldParametersToFieldParametersComponentCopyObj(fromField,fromVariableType,fromParameterSetType, &
    & fromComponentNumber,toField,toVariableType,toParameterSetType,toComponentNumber,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: fromField !<The field to copy from
    INTEGER(INTG), INTENT(IN) :: fromVariableType !<The field variable type to copy from
    INTEGER(INTG), INTENT(IN) :: fromParameterSetType !<The field parameter set type to copy from
    INTEGER(INTG), INTENT(IN) :: fromComponentNumber !<The field variable component number to copy from
    TYPE(CMISSFieldType), INTENT(IN) :: toField !<The field to copy to
    INTEGER(INTG), INTENT(IN) :: toVariableType !<The field variable type to copy to
    INTEGER(INTG), INTENT(IN) :: toParameterSetType !<The parameter set type to copy to
    INTEGER(INTG), INTENT(IN) :: toComponentNumber !<The field variable component to copy to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    CALL ENTERS("CMISSFieldParametersToFieldParametersComponentCopyObj",err,error,*999)

    CALL FIELD_PARAMETERS_TO_FIELD_PARAMETERS_COMPONENT_COPY(fromField%FIELD,fromVariableType,fromParameterSetType, &
      & fromComponentNumber,toField%FIELD,toVariableType,toParameterSetType,toComponentNumber,err,error,*999)

    RETURN
999 CALL ERRORS("CMISSFieldParametersToFieldParametersComponentCopyObj",err,error)
    CALL EXITS("CMISSFieldParametersToFieldParametersComponentCopyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldParametersToFieldParametersComponentCopyObj

  !
  !================================================================================================================================
  !

  !>Returns the scaling type for a field identified by a user number.
  SUBROUTINE CMISSFieldScalingTypeGetNumber(regionUserNumber,fieldUserNumber,scalingType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the scaling type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the scaling type for.
    INTEGER(INTG), INTENT(OUT) :: scalingType !<On return, the field scaling type. \see OPENCMISS_FieldScalingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldScalingTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_SCALING_TYPE_GET(FIELD,scalingType,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldScalingTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldScalingTypeGetNumber",err,error)
    CALL EXITS("CMISSFieldScalingTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldScalingTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the scaling type for a field identified by an object.
  SUBROUTINE CMISSFieldScalingTypeGetObj(field,scalingType,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the scaling type for.
    INTEGER(INTG), INTENT(OUT) :: scalingType !<On return, the field scaling type. \see OPENCMISS_FieldScalingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldScalingTypeGetObj",err,error,*999)

    CALL FIELD_SCALING_TYPE_GET(field%FIELD,scalingType,err,error,*999)

    CALL EXITS("CMISSFieldScalingTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSFieldScalingTypeGetObj",err,error)
    CALL EXITS("CMISSFieldScalingTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldScalingTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the scaling type for a field identified by a user number.
  SUBROUTINE CMISSFieldScalingTypeSetNumber(regionUserNumber,fieldUserNumber,scalingType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the scaling type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the scaling type for.
    INTEGER(INTG), INTENT(IN) :: scalingType !<The field scaling type to set. \see OPENCMISS_FieldScalingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldScalingTypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_SCALING_TYPE_SET(FIELD,scalingType,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldScalingTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldScalingTypeSetNumber",err,error)
    CALL EXITS("CMISSFieldScalingTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldScalingTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the scaling type for a field identified by an object.
  SUBROUTINE CMISSFieldScalingTypeSetObj(field,scalingType,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the scaling type for.
    INTEGER(INTG), INTENT(IN) :: scalingType !<The field scaling type to set. \see OPENCMISS_FieldScalingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldScalingTypeSetObj",err,error,*999)

    CALL FIELD_SCALING_TYPE_SET(field%FIELD,scalingType,err,error,*999)

    CALL EXITS("CMISSFieldScalingTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSFieldScalingTypeSetObj",err,error)
    CALL EXITS("CMISSFieldScalingTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldScalingTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the field type for a field identified by a user number.
  SUBROUTINE CMISSFieldTypeGetNumber(regionUserNumber,fieldUserNumber,fieldType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the field type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the field type for.
    INTEGER(INTG), INTENT(OUT) :: fieldType !<On return, the field type. \see OPENCMISS_FieldTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_TYPE_GET(FIELD,fieldType,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldTypeGetNumber",err,error)
    CALL EXITS("CMISSFieldTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the type for a field identified by an object.
  SUBROUTINE CMISSFieldTypeGetObj(field,fieldType,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the field type for.
    INTEGER(INTG), INTENT(OUT) :: fieldType !<On return, the field type. \see OPENCMISS_FieldTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldTypeGetObj",err,error,*999)

    CALL FIELD_TYPE_GET(field%FIELD,fieldType,err,error,*999)

    CALL EXITS("CMISSFieldTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSFieldTypeGetObj",err,error)
    CALL EXITS("CMISSFieldTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the field type for a field identified by a user number.
  SUBROUTINE CMISSFieldTypeSetNumber(regionUserNumber,fieldUserNumber,fieldType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the field type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the field type for.
    INTEGER(INTG), INTENT(IN) :: fieldType !<The field type to set. \see OPENCMISS_FieldTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldTypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_TYPE_SET(FIELD,fieldType,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldTypeSetNumber",err,error)
    CALL EXITS("CMISSFieldTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the type for a field identified by an object.
  SUBROUTINE CMISSFieldTypeSetObj(field,fieldType,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the field type for.
    INTEGER(INTG), INTENT(IN) :: fieldType !<The field type to set. \see OPENCMISS_FieldTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldTypeSetObj",err,error,*999)

    CALL FIELD_TYPE_SET(field%FIELD,fieldType,err,error,*999)

    CALL EXITS("CMISSFieldTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSFieldTypeSetObj",err,error)
    CALL EXITS("CMISSFieldTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a field variable for a field identified by a user number.
  SUBROUTINE CMISSFieldVariableLabelGetCNumber(regionUserNumber,fieldUserNumber,variableType,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the field variable label \see OPENCMISS_FieldVariableTypes
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the field variable label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldVariableLabelGetCNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_VARIABLE_LABEL_GET(FIELD,variableType,label,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldVariableLabelGetCNumber")
    RETURN
999 CALL ERRORS("CMISSFieldVariableLabelGetCNumber",err,error)
    CALL EXITS("CMISSFieldVariableLabelGetCNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldVariableLabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a field variable for a field identified by an object.
  SUBROUTINE CMISSFieldVariableLabelGetCObj(field,variableType,label,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the field variable label \see OPENCMISS_FieldVariableTypes
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the field variable label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldVariableLabelGetCObj",err,error,*999)

    CALL FIELD_VARIABLE_LABEL_GET(field%FIELD,variableType,label,err,error,*999)

    CALL EXITS("CMISSFieldVariableLabelGetCObj")
    RETURN
999 CALL ERRORS("CMISSFieldVariableLabelGetCObj",err,error)
    CALL EXITS("CMISSFieldVariableLabelGetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldVariableLabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a field variable for a field identified by a user number.
  SUBROUTINE CMISSFieldVariableLabelGetVSNumber(regionUserNumber,fieldUserNumber,variableType,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the field variable label \see OPENCMISS_FieldVariableTypes
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the field variable label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldVariableLabelGetVSNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_VARIABLE_LABEL_GET(FIELD,variableType,label,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldVariableLabelGetVSNumber")
    RETURN
999 CALL ERRORS("CMISSFieldVariableLabelGetVSNumber",err,error)
    CALL EXITS("CMISSFieldVariableLabelGetVSNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldVariableLabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a field variable for a field identified by an object.
  SUBROUTINE CMISSFieldVariableLabelGetVSObj(field,variableType,label,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the field variable label \see OPENCMISS_FieldVariableTypes
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the field variable label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldVariableLabelGetVSObj",err,error,*999)

    CALL FIELD_VARIABLE_LABEL_GET(field%FIELD,variableType,label,err,error,*999)

    CALL EXITS("CMISSFieldVariableLabelGetVSObj")
    RETURN
999 CALL ERRORS("CMISSFieldVariableLabelGetVSObj",err,error)
    CALL EXITS("CMISSFieldVariableLabelGetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldVariableLabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a field variable for a field identified by a user number.
  SUBROUTINE CMISSFieldVariableLabelSetCNumber(regionUserNumber,fieldUserNumber,variableType,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the field variable label \see OPENCMISS_FieldVariableTypes
    CHARACTER(LEN=*), INTENT(IN) :: label !<The field variable label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldVariableLabelSetCNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_VARIABLE_LABEL_SET(FIELD,variableType,label,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldVariableLabelSetCNumber")
    RETURN
999 CALL ERRORS("CMISSFieldVariableLabelSetCNumber",err,error)
    CALL EXITS("CMISSFieldVariableLabelSetCNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldVariableLabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a field variable for a field identified by an object.
  SUBROUTINE CMISSFieldVariableLabelSetCObj(field,variableType,label,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the field variable label \see OPENCMISS_FieldVariableTypes
    CHARACTER(LEN=*), INTENT(IN) :: label !<The field variable label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldVariableLabelSetCObj",err,error,*999)

    CALL FIELD_VARIABLE_LABEL_SET(field%FIELD,variableType,label,err,error,*999)

    CALL EXITS("CMISSFieldVariableLabelSetCObj")
    RETURN
999 CALL ERRORS("CMISSFieldVariableLabelSetCObj",err,error)
    CALL EXITS("CMISSFieldVariableLabelSetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldVariableLabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a field variable for a field identified by a user number.
  SUBROUTINE CMISSFieldVariableLabelSetVSNumber(regionUserNumber,fieldUserNumber,variableType,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the field variable label \see OPENCMISS_FieldVariableTypes
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The field variable label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldVariableLabelSetVSNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_VARIABLE_LABEL_SET(FIELD,variableType,label,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldVariableLabelSetVSNumber")
    RETURN
999 CALL ERRORS("CMISSFieldVariableLabelSetVSNumber",err,error)
    CALL EXITS("CMISSFieldVariableLabelSetVSNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldVariableLabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a field variable for a field identified by an object.
  SUBROUTINE CMISSFieldVariableLabelSetVSObj(field,variableType,label,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the field variable label \see OPENCMISS_FieldVariableTypes
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The field variable label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldVariableLabelSetVSObj",err,error,*999)

    CALL FIELD_VARIABLE_LABEL_SET(field%FIELD,variableType,label,err,error,*999)

    CALL EXITS("CMISSFieldVariableLabelSetVSObj")
    RETURN
999 CALL ERRORS("CMISSFieldVariableLabelSetVSObj",err,error)
    CALL EXITS("CMISSFieldVariableLabelSetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldVariableLabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the field variable types for a field identified by a user number.
  SUBROUTINE CMISSFieldVariableTypesGetNumber(regionUserNumber,fieldUserNumber,variableTypes,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the field variable types for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the field variable types for.
    INTEGER(INTG), INTENT(OUT) :: variableTypes(:) !<variableTypes(variable_idx). On return, the field variable types for the variable_idx'th field variable. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldVariableTypesGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_VARIABLE_TYPES_GET(FIELD,variableTypes,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldVariableTypesGetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldVariableTypesGetNumber",err,error)
    CALL EXITS("CMISSFieldVariableTypesGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldVariableTypesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the variable types for a field identified by an object.
  SUBROUTINE CMISSFieldVariableTypesGetObj(field,variableTypes,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the field variable types for.
    INTEGER(INTG), INTENT(OUT) :: variableTypes(:) !<variableTypes(variable_idx). On return, the field variable types for the variable_idx'th field variable. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldVariableTypesGetObj",err,error,*999)

    CALL FIELD_VARIABLE_TYPES_GET(field%FIELD,variableTypes,err,error,*999)

    CALL EXITS("CMISSFieldVariableTypesGetObj")
    RETURN
999 CALL ERRORS("CMISSFieldVariableTypesGetObj",err,error)
    CALL EXITS("CMISSFieldVariableTypesGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldVariableTypesGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the field variable types for a field identified by a user number.
  SUBROUTINE CMISSFieldVariableTypesSetNumber(regionUserNumber,fieldUserNumber,variableTypes,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the field variable types for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the field variable types for.
    INTEGER(INTG), INTENT(IN) :: variableTypes(:) !<variableTypes(variable_idx). The field variable types for the variable_idx'th field variable to set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldVariableTypesSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_VARIABLE_TYPES_SET(FIELD,variableTypes,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSFieldVariableTypesSetNumber")
    RETURN
999 CALL ERRORS("CMISSFieldVariableTypesSetNumber",err,error)
    CALL EXITS("CMISSFieldVariableTypesSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldVariableTypesSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the variable types for a field identified by an object.
  SUBROUTINE CMISSFieldVariableTypesSetObj(field,variableTypes,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the field variable types for.
    INTEGER(INTG), INTENT(IN) :: variableTypes(:) !<variableTypes(variable_idx). The field variable types for the variable_idx'th field variable to set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldVariableTypesSetObj",err,error,*999)

    CALL FIELD_VARIABLE_TYPES_SET(field%FIELD,variableTypes,err,error,*999)

    CALL EXITS("CMISSFieldVariableTypesSetObj")
    RETURN
999 CALL ERRORS("CMISSFieldVariableTypesSetObj",err,error)
    CALL EXITS("CMISSFieldVariableTypesSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldVariableTypesSetObj

!!==================================================================================================================================
!!
!! FIELD_IO_ROUTINES
!!
!!==================================================================================================================================

  !>Export element information for fields set identified by an object. \todo number method
  SUBROUTINE CMISSFieldIOElementsExportCCObj(fields,fileName,method,err)

    !Argument variables
    TYPE(CMISSFieldsType), INTENT(INOUT) :: fields !<The fields to export the elements for.
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<The file name to export the elements to
    CHARACTER(LEN=*), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: VFileName
    TYPE(VARYING_STRING) :: VMethod
    INTEGER(INTG) :: FileNameLength
    INTEGER(INTG) :: MethodLength

    CALL ENTERS("CMISSFieldIOElementsExportCCObj",err,error,*999)

    FileNameLength = LEN_TRIM(fileName)
    VFileName = fileName(1:FileNameLength)
    MethodLength = LEN_TRIM(method)
    VMethod = method(1:MethodLength)

    CALL FIELD_IO_ELEMENTS_EXPORT(fields%FIELDS,VFileName,VMethod,err,error,*999)

    CALL EXITS("CMISSFieldIOElementsExportCCObj")
    RETURN
999 CALL ERRORS("CMISSFieldIOElementsExportCCObj",err,error)
    CALL EXITS("CMISSFieldIOElementsExportCCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldIOElementsExportCCObj

  !
  !================================================================================================================================
  !


  !>Export element information for fields set identified by an object. \todo number method
  SUBROUTINE CMISSFieldIOElementsExportVSCObj(fields,fileName,method,err)

    !Argument variables
    TYPE(CMISSFieldsType), INTENT(INOUT) :: fields !<The fields to export the elements for.
    TYPE(VARYING_STRING), INTENT(IN) :: fileName !<The file name to export the elements to
    CHARACTER(LEN=*), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: VMethod
    INTEGER(INTG) :: MethodLength

    CALL ENTERS("CMISSFieldIOElementsExportVSCObj",err,error,*999)

    MethodLength = LEN_TRIM(method)
    VMethod = method(1:MethodLength)

    CALL FIELD_IO_ELEMENTS_EXPORT(fields%FIELDS,fileName,VMethod,err,error,*999)

    CALL EXITS("CMISSFieldIOElementsExportVSCObj")
    RETURN
999 CALL ERRORS("CMISSFieldIOElementsExportVSCObj",err,error)
    CALL EXITS("CMISSFieldIOElementsExportVSCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldIOElementsExportVSCObj

  !
  !================================================================================================================================
  !


  !>Export element information for fields set identified by an object. \todo number method
  SUBROUTINE CMISSFieldIOElementsExportCVSObj(fields,fileName,method,err)

    !Argument variables
    TYPE(CMISSFieldsType), INTENT(INOUT) :: fields !<The fields to export the elements for.
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<The file name to export the elements to
    TYPE(VARYING_STRING), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: VFileName
    INTEGER(INTG) :: FileNameLength

    CALL ENTERS("CMISSFieldIOElementsExportCVSObj",err,error,*999)

    FileNameLength = LEN_TRIM(fileName)
    VFileName = fileName(1:FileNameLength)

    CALL FIELD_IO_ELEMENTS_EXPORT(fields%FIELDS,VFileName,method,err,error,*999)

    CALL EXITS("CMISSFieldIOElementsExportCVSObj")
    RETURN
999 CALL ERRORS("CMISSFieldIOElementsExportCVSObj",err,error)
    CALL EXITS("CMISSFieldIOElementsExportCVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldIOElementsExportCVSObj

  !
  !================================================================================================================================
  !

  !>Export element information for fields set identified by an object. \todo number method
  SUBROUTINE CMISSFieldIOElementsExportVSVSObj(fields,fileName,method,err)

    !Argument variables
    TYPE(CMISSFieldsType), INTENT(INOUT) :: fields !<The fields to export the elements for.
    TYPE(VARYING_STRING), INTENT(IN) :: fileName !<The file name to export the elements to
    TYPE(VARYING_STRING), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldIOElementsExportVSVSObj",err,error,*999)

    CALL FIELD_IO_ELEMENTS_EXPORT(fields%FIELDS,fileName,method,err,error,*999)

    CALL EXITS("CMISSFieldIOElementsExportVSVSObj")
    RETURN
999 CALL ERRORS("CMISSFieldIOElementsExportVSObj",err,error)
    CALL EXITS("CMISSFieldIOElementsExportVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldIOElementsExportVSVSObj

  !
  !================================================================================================================================
  !

  !>Export nodal information for fields set identified by an object. \todo number method
  SUBROUTINE CMISSFieldIONodesExportCCObj(fields,fileName,method,err)

    !Argument variables
    TYPE(CMISSFieldsType), INTENT(INOUT) :: fields !<The fields to export the nodes for.
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<The file name to export the nodes to
    CHARACTER(LEN=*), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: VFileName
    TYPE(VARYING_STRING) :: VMethod
    INTEGER(INTG) :: FileNameLength
    INTEGER(INTG) :: MethodLength

    CALL ENTERS("CMISSFieldIONodesExportCCObj",err,error,*999)

    FileNameLength = LEN_TRIM(fileName)
    VFileName = fileName(1:FileNameLength)
    MethodLength = LEN_TRIM(method)
    VMethod = method(1:MethodLength)

    CALL FIELD_IO_NODES_EXPORT(fields%FIELDS,VFileName,VMethod,err,error,*999)

    CALL EXITS("CMISSFieldIONodesExportCCObj")
    RETURN
999 CALL ERRORS("CMISSFieldIONodesExportCCObj",err,error)
    CALL EXITS("CMISSFieldIONodesExportCCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldIONodesExportCCObj

  !
  !================================================================================================================================
  !

  !>Export nodal information for fields set identified by an object. \todo number method
  SUBROUTINE CMISSFieldIONodesExportVSCObj(fields,fileName,method,err)

    !Argument variables
    TYPE(CMISSFieldsType), INTENT(INOUT) :: fields !<The fields to export the nodes for.
    TYPE(VARYING_STRING), INTENT(IN) :: fileName !<The file name to export the nodes to
    CHARACTER(LEN=*), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: VMethod
    INTEGER(INTG) :: MethodLength

    CALL ENTERS("CMISSFieldIONodesExportVSCObj",err,error,*999)

    MethodLength = LEN_TRIM(method)
    VMethod = method(1:MethodLength)

    CALL FIELD_IO_NODES_EXPORT(fields%FIELDS,fileName,VMethod,err,error,*999)

    CALL EXITS("CMISSFieldIONodesExportVSCObj")
    RETURN
999 CALL ERRORS("CMISSFieldIONodesExportVSCObj",err,error)
    CALL EXITS("CMISSFieldIONodesExportVSCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldIONodesExportVSCObj

  !
  !================================================================================================================================
  !

  !>Export nodal information for fields set identified by an object. \todo number method
  SUBROUTINE CMISSFieldIONodesExportCVSObj(fields,fileName,method,err)

    !Argument variables
    TYPE(CMISSFieldsType), INTENT(INOUT) :: fields !<The fields to export the nodes for.
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<The file name to export the nodes to
    TYPE(VARYING_STRING), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: VFileName
    INTEGER(INTG) :: FileNameLength

    CALL ENTERS("CMISSFieldIONodesExportCVSObj",err,error,*999)

    FileNameLength = LEN_TRIM(fileName)
    VFileName = fileName(1:FileNameLength)

    CALL FIELD_IO_NODES_EXPORT(fields%FIELDS,VFileName,method,err,error,*999)

    CALL EXITS("CMISSFieldIONodesExportCVSObj")
    RETURN
999 CALL ERRORS("CMISSFieldIONodesExportCVSObj",err,error)
    CALL EXITS("CMISSFieldIONodesExportCVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldIONodesExportCVSObj

  !
  !================================================================================================================================
  !

  !>Export nodal information for fields set identified by an object. \todo number method
  SUBROUTINE CMISSFieldIONodesExportVSVSObj(fields,fileName,method,err)

    !Argument variables
    TYPE(CMISSFieldsType), INTENT(INOUT) :: fields !<The fields to export the nodes for.
    TYPE(VARYING_STRING), INTENT(IN) :: fileName !<The file name to export the nodes to
    TYPE(VARYING_STRING), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFieldIONodesExportVSVSObj",err,error,*999)

    CALL FIELD_IO_NODES_EXPORT(fields%FIELDS,fileName,method,err,error,*999)

    CALL EXITS("CMISSFieldIONodesExportVSVSObj")
    RETURN
999 CALL ERRORS("CMISSFieldIONodesExportVSVSObj",err,error)
    CALL EXITS("CMISSFieldIONodesExportVSVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldIONodesExportVSVSObj

!!==================================================================================================================================
!!
!! GENERATED_MESH_ROUTINES
!!
!!==================================================================================================================================

  !>Returns the basis for a generated mesh on a region identified by a user number.
  SUBROUTINE CMISSGeneratedMeshBasisGetNumber(regionUserNumber,generatedMeshUserNumber,basisUserNumbers,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to get the basis for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to get the basis for.
    INTEGER(INTG), INTENT(INOUT) :: basisUserNumbers(:) !<On return, the user numbers of the bases.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_PTR_TYPE), POINTER :: BASES(:)
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    INTEGER(INTG) :: basis_idx,NumBases

    CALL ENTERS("CMISSGeneratedMeshBasisGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    NULLIFY(BASES)

    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_BASIS_GET(GENERATED_MESH,BASES,err,error,*999)
        IF(ASSOCIATED(BASES)) THEN
          NumBases=SIZE(BASES)
          IF(SIZE(basisUserNumbers)<NumBases) THEN
            LOCAL_ERROR="The basis user numbers array must have a size of at least "// &
                & TRIM(NUMBER_TO_VSTRING(NumBases,"*",err,error))// &
                & ". However, it has a size of " &
                & //TRIM(NUMBER_TO_VSTRING(SIZE(basisUserNumbers),"*",err,error))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
          ENDIF
          DO basis_idx=1,NumBases
            IF(ASSOCIATED(BASES(basis_idx)%PTR)) THEN
              basisUserNumbers(basis_idx)=BASES(basis_idx)%PTR%USER_NUMBER
            ELSE
              LOCAL_ERROR="The basis with index "//TRIM(NUMBER_TO_VSTRING(basis_idx,"*",err,error))// &
                & " is not associated for the generated mesh with a user number of "// &
                & TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
            ENDIF
          ENDDO
        ELSE
          LOCAL_ERROR="The bases are not associated for the generated mesh with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSGeneratedMeshBasisGetNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshBasisGetNumber",err,error)
    CALL EXITS("CMISSGeneratedMeshBasisGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshBasisGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the basis for a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshBasisGetObj(generatedMesh,bases,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to get the basis for.
    TYPE(CMISSBasisType), INTENT(INOUT) :: bases(:) !<On return, the array of bases.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_PTR_TYPE), POINTER :: BASIS_PTRS(:)
    INTEGER(INTG) :: basis_idx,NumBases
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMeshBasisGetObj",err,error,*999)

    NULLIFY(BASIS_PTRS)

    CALL GENERATED_MESH_BASIS_GET(generatedMesh%GENERATED_MESH,BASIS_PTRS,err,error,*999)
    IF(ASSOCIATED(BASIS_PTRS)) THEN
      NumBases=SIZE(BASIS_PTRS)
      IF(SIZE(bases)<NumBases) THEN
        LOCAL_ERROR="The bases array must have a size of at least "// &
            & TRIM(NUMBER_TO_VSTRING(NumBases,"*",err,error))// &
            & ". However, it has a size of " &
            & //TRIM(NUMBER_TO_VSTRING(SIZE(bases),"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
      DO basis_idx=1,NumBases
        bases(basis_idx)%BASIS=>BASIS_PTRS(basis_idx)%PTR
      ENDDO
    ELSE
      LOCAL_ERROR="The bases are not associated for the generated mesh."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSGeneratedMeshBasisGetObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshBasisGetObj",err,error)
    CALL EXITS("CMISSGeneratedMeshBasisGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshBasisGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the basis for a generated mesh on a region identified by a user number.
  SUBROUTINE CMISSGeneratedMeshBasisSetNumber0(regionUserNumber,generatedMeshUserNumber,basisUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_PTR_TYPE), POINTER :: BASES(:)
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMeshBasisSetNumber0",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    NULLIFY(BASIS)

    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL BASIS_USER_NUMBER_FIND(basisUserNumber,BASIS,err,error,*999)
        IF(ASSOCIATED(BASIS)) THEN
          ALLOCATE(BASES(1),STAT=err)
          IF(err/=0) CALL FLAG_ERROR("Could not allocate bases.",err,error,*999)
          BASES(1)%PTR=>BASIS
          CALL GENERATED_MESH_BASIS_SET(GENERATED_MESH,BASES,err,error,*999)
        ELSE
          LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(basisUserNumber,"*",err,error))// &
            & " does not exist."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSGeneratedMeshBasisSetNumber0")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshBasisSetNumber0",err,error)
    CALL EXITS("CMISSGeneratedMeshBasisSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshBasisSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the basis for a generated mesh on a region identified by a user number.
  SUBROUTINE CMISSGeneratedMeshBasisSetNumber1(regionUserNumber,generatedMeshUserNumber,basisUserNumbers,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: basisUserNumbers(:) !<The user numbers of the bases to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_PTR_TYPE), POINTER :: BASES(:)
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    INTEGER(INTG) :: basis_idx,NumBases

    CALL ENTERS("CMISSGeneratedMeshBasisSetNumber1",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    NULLIFY(BASES)

    NumBases=SIZE(basisUserNumbers)
    ALLOCATE(BASES(NumBases),STAT=err)
    IF(err/=0) CALL FLAG_ERROR("Could not allocate bases.",err,error,*999)

    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        DO basis_idx=1,NumBases
          NULLIFY(BASIS)
          CALL BASIS_USER_NUMBER_FIND(basisUserNumbers(basis_idx),BASIS,err,error,*999)
          IF(ASSOCIATED(BASIS)) THEN
            BASES(basis_idx)%PTR=>BASIS
          ELSE
            LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(basisUserNumbers(basis_idx),"*",err,error))// &
              & " does not exist."
            CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
          ENDIF
        ENDDO
        CALL GENERATED_MESH_BASIS_SET(GENERATED_MESH,BASES,err,error,*999)
      ELSE
        LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSGeneratedMeshBasisSetNumber1")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshBasisSetNumber1",err,error)
    CALL EXITS("CMISSGeneratedMeshBasisSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshBasisSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the basis for a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshBasisSetObj0(generatedMesh,basis,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the basis for.
    TYPE(CMISSBasisType), INTENT(IN) :: basis !<The basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMeshBasisSetObj0",err,error,*999)

    CALL CMISSGeneratedMeshBasisSetObj1(generatedMesh,[basis],err)

    CALL EXITS("CMISSGeneratedMeshBasisSetObj0")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshBasisSetObj0",err,error)
    CALL EXITS("CMISSGeneratedMeshBasisSetObj0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshBasisSetObj0

  !
  !================================================================================================================================
  !

  !>Sets/changes the basis for a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshBasisSetObj1(generatedMesh,bases,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the basis for.
    TYPE(CMISSBasisType), INTENT(IN) :: bases(:) !<The bases to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: basis_idx
    TYPE(BASIS_PTR_TYPE), ALLOCATABLE :: BASIS_PTRS(:)
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMeshBasisSetObj1",err,error,*999)

    ALLOCATE(BASIS_PTRS(SIZE(bases,1)),STAT=err)
    IF(err/=0) CALL FLAG_ERROR("Could not allocate bases.",err,error,*999)
    DO basis_idx=1,SIZE(bases,1)
      IF(ASSOCIATED(bases(basis_idx)%BASIS)) THEN
        BASIS_PTRS(basis_idx)%PTR=>bases(basis_idx)%BASIS
      ELSE
        LOCAL_ERROR="The basis for index "//TRIM(NUMBER_TO_VSTRING(basis_idx,"*",err,error))//" is not associated."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ENDDO

    CALL GENERATED_MESH_BASIS_SET(generatedMesh%GENERATED_MESH,BASIS_PTRS,err,error,*999)

    CALL EXITS("CMISSGeneratedMeshBasisSetObj1")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshBasisSetObj1",err,error)
    CALL EXITS("CMISSGeneratedMeshBasisSetObj1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshBasisSetObj1

  !
  !================================================================================================================================
  !

  !>Sets/changes the base vectors for a generated mesh on a region identified by a user number.
  SUBROUTINE CMISSGeneratedMeshBaseVectorsSetNumber(regionUserNumber,generatedMeshUserNumber,baseVectors,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the base vectors for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the base vectors for.
    REAL(DP), INTENT(IN) :: baseVectors(:,:) !<baseVectors(coordinate_idx,xi_idx). The base vectors to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMeshBaseVectorsSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_BASE_VECTORS_SET(GENERATED_MESH,baseVectors,err,error,*999)
      ELSE
        LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSGeneratedMeshBaseVectorsSetNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshBaseVectorsSetNumber",err,error)
    CALL EXITS("CMISSGeneratedMeshBaseVectorsSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshBaseVectorsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the base vectors for a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshBaseVectorsSetObj(generatedMesh,baseVectors,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the base vectors for.
    REAL(DP), INTENT(IN) :: baseVectors(:,:) !<baseVectors(coordinate_idx,xi_idx). The base vectors to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMeshBaseVectorsSetObj",err,error,*999)

    CALL GENERATED_MESH_BASE_VECTORS_SET(generatedMesh%GENERATED_MESH,baseVectors,err,error,*999)

    CALL EXITS("CMISSGeneratedMeshBaseVectorsSetObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshBaseVectorsSetObj",err,error)
    CALL EXITS("CMISSGeneratedMeshBaseVectorsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshBaseVectorsSetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a generated mesh on a region identified by a user number.
  SUBROUTINE CMISSGeneratedMeshCreateFinishNumber(regionUserNumber,generatedMeshUserNumber,meshUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to generate.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMeshCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_CREATE_FINISH(GENERATED_MESH,meshUserNumber,MESH,err,error,*999)
      ELSE
        LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Generated Mesh Create')
#endif

    CALL EXITS("CMISSGeneratedMeshCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshCreateFinishNumber",err,error)
    CALL EXITS("CMISSGeneratedMeshCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshCreateFinishObj(generatedMesh,meshUserNumber,mesh,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to generate.
    TYPE(CMISSMeshType), INTENT(INOUT) :: mesh !<On return, the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMeshCreateFinishObj",err,error,*999)

    CALL GENERATED_MESH_CREATE_FINISH(generatedMesh%GENERATED_MESH,meshUserNumber,mesh%MESH,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Generated mesh Create')
#endif

    CALL EXITS("CMISSGeneratedMeshCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshCreateFinishObj",err,error)
    CALL EXITS("CMISSGeneratedMeshCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a generated mesh on a region identified by a user number.
  SUBROUTINE CMISSGeneratedMeshCreateStartNumber(generatedMeshUserNumber,regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to create.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to create the generated mesh in.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMeshCreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Generated Mesh Create')
#endif

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_CREATE_START(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSGeneratedMeshCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshCreateStartNumber",err,error)
    CALL EXITS("CMISSGeneratedMeshCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a generated mesh on an interface identified by an object.
  SUBROUTINE CMISSGeneratedMeshCreateStartInterfaceObj(generatedMeshUserNumber,iNTERFACE,generatedMesh,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to create.
    TYPE(CMISSInterfaceType), INTENT(INOUT) :: Interface !<The interface to created generated mesh in.
    TYPE(CMISSGeneratedMeshType), INTENT(INOUT) :: generatedMesh !<On return, the created generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMeshCreateStartInterfaceObj",err,error,*999)

    CALL GENERATED_MESH_CREATE_START(generatedMeshUserNumber,Interface%iNTERFACE,generatedMesh%GENERATED_MESH,err,error,*999)

    CALL EXITS("CMISSGeneratedMeshCreateStartInterfaceObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshCreateStartInterfaceObj",err,error)
    CALL EXITS("CMISSGeneratedMeshCreateStartInterfaceObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshCreateStartInterfaceObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a generated mesh on a region identified by an object.
  SUBROUTINE CMISSGeneratedMeshCreateStartRegionObj(generatedMeshUserNumber,region,generatedMesh,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to create.
    TYPE(CMISSRegionType), INTENT(INOUT) :: region !<The region to created generated mesh in.
    TYPE(CMISSGeneratedMeshType), INTENT(INOUT) :: generatedMesh !<On return, the created generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMeshCreateStartRegionObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Generated Mesh Create')
#endif

    CALL GENERATED_MESH_CREATE_START(generatedMeshUserNumber,REGION%region,generatedMesh%GENERATED_MESH,err,error,*999)

    CALL EXITS("CMISSGeneratedMeshCreateStartRegionObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshCreateStartRegionObj",err,error)
    CALL EXITS("CMISSGeneratedMeshCreateStartRegionObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshCreateStartRegionObj

  !
  !================================================================================================================================
  !

  !>Destroys a generated mesh on a region identified by a user number.
  SUBROUTINE CMISSGeneratedMeshDestroyNumber(regionUserNumber,generatedMeshUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to destroy.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMeshDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_DESTROY(GENERATED_MESH,err,error,*999)
      ELSE
        LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSGeneratedMeshDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshDestroyNumber",err,error)
    CALL EXITS("CMISSGeneratedMeshDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshDestroyObj(generatedMesh,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(INOUT) :: generatedMesh !<The generated mesh to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMeshDestroyObj",err,error,*999)

    CALL GENERATED_MESH_DESTROY(generatedMesh%GENERATED_MESH,err,error,*999)

    CALL EXITS("CMISSGeneratedMeshDestroyObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshDestroyObj",err,error)
    CALL EXITS("CMISSGeneratedMeshDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshDestroyObj
  !
  !================================================================================================================================
  !

  !>Returns the extent for a generated mesh on a region identified by a user number.
  SUBROUTINE CMISSGeneratedMeshExtentGetNumber(regionUserNumber,generatedMeshUserNumber,extent,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to get the extent for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to get the extent for.
    REAL(DP), INTENT(OUT) :: extent(:) !<extent(i). On return, the extent for the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMeshExtentGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_EXTENT_GET(GENERATED_MESH,extent,err,error,*999)
      ELSE
        LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NUMBER_TO_VSTRING(rEGIONUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(rEGIONUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSGeneratedMeshExtentGetNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshExtentGetNumber",err,error)
    CALL EXITS("CMISSGeneratedMeshExtentGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshExtentGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the extent for a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshExtentGetObj(generatedMesh,extent,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to get the extent for.
    REAL(DP), INTENT(OUT) :: extent(:) !<extent(i). On return, the extent for the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMeshExtentGetObj",err,error,*999)

    CALL GENERATED_MESH_EXTENT_GET(generatedMesh%GENERATED_MESH,extent,err,error,*999)

    CALL EXITS("CMISSGeneratedMeshExtentGetObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshExtentGetObj",err,error)
    CALL EXITS("CMISSGeneratedMeshExtentGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshExtentGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the extent for a generated mesh on a region identified by a user number.
  SUBROUTINE CMISSGeneratedMeshExtentSetNumber(regionUserNumber,generatedMeshUserNumber,extent,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the extent for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the extent for.
    REAL(DP), INTENT(IN) :: extent(:) !<extent(i). The extent for the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMeshExtentSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_EXTENT_SET(GENERATED_MESH,extent,err,error,*999)
      ELSE
        LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSGeneratedMeshExtentSetNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshExtentSetNumber",err,error)
    CALL EXITS("CMISSGeneratedMeshExtentSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshExtentSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the extent for a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshExtentSetObj(generatedMesh,extent,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the extent for.
    REAL(DP), INTENT(IN) :: extent(:) !<extent(i). the extent for the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMeshExtentSetObj",err,error,*999)

    CALL GENERATED_MESH_EXTENT_SET(generatedMesh%GENERATED_MESH,extent,err,error,*999)

    CALL EXITS("CMISSGeneratedMeshExtentSetObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshExtentSetObj",err,error)
    CALL EXITS("CMISSGeneratedMeshExtentSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshExtentSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of elements for a generated mesh on a region identified by a user number.
  SUBROUTINE CMISSGeneratedMeshNumberOfElementsGetNumber(regionUserNumber,generatedMeshUserNumber,numberOfElements,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to get the number of elements for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to get the number of elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfElements(:) !<numberOfElements(i). On return, the number of elements in the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMeshNumberOfElementsGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_NUMBER_OF_ELEMENTS_GET(GENERATED_MESH,numberOfElements,err,error,*999)
      ELSE
        LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSGeneratedMeshNumberOfElementsGetNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshNumberOfElementsGetNumber",err,error)
    CALL EXITS("CMISSGeneratedMeshNumberOfElementsGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshNumberOfElementsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of elements for a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshNumberOfElementsGetObj(generatedMesh,numberOfElements,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to get the number of elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfElements(:) !<numberOfElements(i). On return, the number of elements in the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMeshNumberOfElementsGetObj",err,error,*999)

    CALL GENERATED_MESH_NUMBER_OF_ELEMENTS_GET(generatedMesh%GENERATED_MESH,numberOfElements,err,error,*999)

    CALL EXITS("CMISSGeneratedMeshNumberOfElementsGetObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshNumberOfElementsGetObj",err,error)
    CALL EXITS("CMISSGeneratedMeshNumberOfElementsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshNumberOfElementsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of elements for a generated mesh on a region identified by a user number.
  SUBROUTINE CMISSGeneratedMeshNumberOfElementsSetNumber(regionUserNumber,generatedMeshUserNumber,numberOfElements,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: numberOfElements(:) !<numberOfElements(i). The number of elements in the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMeshNumberOfElementsSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_NUMBER_OF_ELEMENTS_SET(GENERATED_MESH,numberOfElements,err,error,*999)
      ELSE
        LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSGeneratedMeshNumberOfElementsSetNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshNumberOfElementsSetNumber",err,error)
    CALL EXITS("CMISSGeneratedMeshNumberOfElementsSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshNumberOfElementsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of elements for a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshNumberOfElementsSetObj(generatedMesh,numberOfElements,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: numberOfElements(:) !<numberOfElements(i). The number of elements in the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMeshNumberOfElementsSetObj",err,error,*999)

    CALL GENERATED_MESH_NUMBER_OF_ELEMENTS_SET(generatedMesh%GENERATED_MESH,numberOfElements,err,error,*999)

    CALL EXITS("CMISSGeneratedMeshNumberOfElementsSetObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshNumberOfElementsSetObj",err,error)
    CALL EXITS("CMISSGeneratedMeshNumberOfElementsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshNumberOfElementsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the origin of a generated mesh on a region identified by a user number.
  SUBROUTINE CMISSGeneratedMeshOriginGetNumber(regionUserNumber,generatedMeshUserNumber,origin,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to get the origin for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to get the origin for.
    REAL(DP), INTENT(OUT) :: origin(:) !<origin(i). On return, the origin of the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMeshOriginGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_ORIGIN_GET(GENERATED_MESH,origin,err,error,*999)
      ELSE
        LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSGeneratedMeshOriginGetNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshOriginGetNumber",err,error)
    CALL EXITS("CMISSGeneratedMeshOriginGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshOriginGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the origin of a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshOriginGetObj(generatedMesh,origin,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to get the origin for.
    REAL(DP), INTENT(OUT) :: origin(:) !<origin(i). On return, the origin of the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMeshOriginGetObj",err,error,*999)

    CALL GENERATED_MESH_ORIGIN_GET(generatedMesh%GENERATED_MESH,origin,err,error,*999)

    CALL EXITS("CMISSGeneratedMeshOriginGetObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshOriginGetObj",err,error)
    CALL EXITS("CMISSGeneratedMeshOriginGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshOriginGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the origin of a generated mesh on a region identified by a user number.
  SUBROUTINE CMISSGeneratedMeshOriginSetNumber(regionUserNumber,generatedMeshUserNumber,origin,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the origin for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the origin for.
    REAL(DP), INTENT(IN) :: origin(:) !<origin(i). The origin of the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMeshOriginSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_ORIGIN_SET(GENERATED_MESH,origin,err,error,*999)
      ELSE
        LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSGeneratedMeshOriginSetNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshOriginSetNumber",err,error)
    CALL EXITS("CMISSGeneratedMeshOriginSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshOriginSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the origin of a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshOriginSetObj(generatedMesh,origin,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the origin for.
    REAL(DP), INTENT(IN) :: origin(:) !<origin(i). The origin of the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMeshOriginSetObj",err,error,*999)

    CALL GENERATED_MESH_ORIGIN_SET(generatedMesh%GENERATED_MESH,origin,err,error,*999)

    CALL EXITS("CMISSGeneratedMeshOriginSetObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshOriginSetObj",err,error)
    CALL EXITS("CMISSGeneratedMeshOriginSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshOriginSetObj

  !
  !================================================================================================================================
  !

  !>Returns the type of a generated mesh on a region identified by a user number.
  SUBROUTINE CMISSGeneratedMeshTypeGetNumber(regionUserNumber,generatedMeshUserNumber,generatedMeshType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to get the type for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to get the type for.
    INTEGER(INTG), INTENT(OUT) :: generatedMeshType !<On return, the type of the generated mesh. \see OPENCMISS_GeneratedMeshTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMeshTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_TYPE_GET(GENERATED_MESH,generatedMeshType,err,error,*999)
      ELSE
        LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSGeneratedMeshTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshTypeGetNumber",err,error)
    CALL EXITS("CMISSGeneratedMeshTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the type of a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshTypeGetObj(generatedMesh,generatedMeshType,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to get the generated mesh type for.
    INTEGER(INTG), INTENT(OUT) :: generatedMeshType !<On return, the type of the generated mesh. \see OPENCMISS_GeneratedMeshTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMeshTypeGetObj",err,error,*999)

    CALL GENERATED_MESH_TYPE_GET(generatedMesh%GENERATED_MESH,generatedMeshType,err,error,*999)

    CALL EXITS("CMISSGeneratedMeshTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshTypeGetObj",err,error)
    CALL EXITS("CMISSGeneratedMeshTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a generated mesh on a region identified by a user number.
  SUBROUTINE CMISSGeneratedMeshTypeSetNumber(regionUserNumber,generatedMeshUserNumber,generatedMeshType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the type for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the type for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshType !<The type of the generated mesh to set. \see OPENCMISS_GeneratedMeshTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMeshTypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_TYPE_SET(GENERATED_MESH,generatedMeshType,err,error,*999)
      ELSE
        LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on a region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSGeneratedMeshTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshTypeSetNumber",err,error)
    CALL EXITS("CMISSGeneratedMeshTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshTypeSetObj(generatedMesh,generatedMeshType,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the generated mesh type for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshType !<The type of the generated mesh to set. \see OPENCMISS_GeneratedMeshTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMeshTypeSetObj",err,error,*999)

    CALL GENERATED_MESH_TYPE_SET(generatedMesh%GENERATED_MESH,generatedMeshType,err,error,*999)

    CALL EXITS("CMISSGeneratedMeshTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshTypeSetObj",err,error)
    CALL EXITS("CMISSGeneratedMeshTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshTypeSetObj

  !
  !================================================================================================================================
  !

  !>Calculates and sets the geometric field parameters for a generated mesh identified by a user number.
  SUBROUTINE CMISSGeneratedMeshGeometricParametersCalculateNumber(regionUserNumber,fieldUserNumber, &
      & generatedMeshUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to calculate the geometric parameters for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the geometric parameters for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to calculate the geometric parameters for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMeshGeometricParametersCalculateNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
        IF(ASSOCIATED(GENERATED_MESH)) THEN
          CALL GENERATED_MESH_GEOMETRIC_PARAMETERS_CALCULATE(FIELD,GENERATED_MESH,err,error,*999)
        ELSE
          LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
            & " does not exist."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSGeneratedMeshGeometricParametersCalculateNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshGeometricParametersCalculateNumber",err,error)
    CALL EXITS("CMISSGeneratedMeshGeometricParametersCalculateNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshGeometricParametersCalculateNumber

  !
  !================================================================================================================================
  !

  !>Calculates and sets the geometric field parameters for a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshGeometricParametersCalculateObj(field,generatedMesh,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(INOUT) :: field !<The field to calculate the geometric parameters for
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to calculate the geometric parameters for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMeshGeometricParametersCalculateObj",err,error,*999)

    CALL GENERATED_MESH_GEOMETRIC_PARAMETERS_CALCULATE(field%FIELD,generatedMesh%GENERATED_MESH,err,error,*999)

    CALL EXITS("CMISSGeneratedMeshGeometricParametersCalculateObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshGeometricParametersCalculateObj",err,error)
    CALL EXITS("CMISSGeneratedMeshGeometricParametersCalculateObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMeshGeometricParametersCalculateObj

  !
  !================================================================================================================================
  !

  !>Returns a list of the nodes belonging to a surface, and their normal xi direction, of a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshSurfaceGetNumber0(regionUserNumber,generatedMeshUserNumber,surfaceType,surfaceNodes,normalXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber  !<Guess what this is.
    INTEGER(INTG), INTENT(IN) :: surfaceType !<The type of surface to be extracted.
    INTEGER(INTG), INTENT(OUT), ALLOCATABLE :: surfaceNodes(:) !<The list of nodes on the surface to be returned.
    INTEGER(INTG), INTENT(OUT) :: normalXi !<index of the xi direction that is normal to the surface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMeshSurfaceGetNumber0",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)

    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
          CALL GENERATED_MESH_SURFACE_GET(GENERATED_MESH,1,surfaceType,surfaceNodes,normalXi,err,error,*999)
      ELSE
        LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
            & " does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSGeneratedMeshSurfaceGetNumber0")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshSurfaceGetNumber0",err,error)
    CALL EXITS("CMISSGeneratedMeshSurfaceGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN
  END SUBROUTINE CMISSGeneratedMeshSurfaceGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns a list of the nodes belonging to a surface, and their normal xi direction, of a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshSurfaceGetNumber1(regionUserNumber,meshComponent,generatedMeshUserNumber,surfaceType, &
      & surfaceNodes,normalXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh.
    INTEGER(INTG), INTENT(IN) :: meshComponent !<The mesh component/basis number to use
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber  !<Guess what this is.
    INTEGER(INTG), INTENT(IN) :: surfaceType !<The type of surface to be extracted.
    INTEGER(INTG), INTENT(OUT), ALLOCATABLE :: surfaceNodes(:) !<The list of nodes on the surface to be returned.
    INTEGER(INTG), INTENT(OUT) :: normalXi !<index of the xi direction that is normal to the surface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMeshSurfaceGetNumber1",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)

    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
          CALL GENERATED_MESH_SURFACE_GET(GENERATED_MESH,meshComponent,surfaceType,surfaceNodes,normalXi,err,error,*999)
      ELSE
        LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
            & " does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSGeneratedMeshSurfaceGetNumber1")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshSurfaceGetNumber1",err,error)
    CALL EXITS("CMISSGeneratedMeshSurfaceGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN
  END SUBROUTINE CMISSGeneratedMeshSurfaceGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns a list of the nodes belonging to a surface, and their normal xi direction, of a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshSurfaceGetObj0(generatedMesh,surfaceType,surfaceNodes,normalXi,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh from which to extract surface nodes.
    INTEGER(INTG), INTENT(IN) :: surfaceType !<The type of surface to be extracted .
    INTEGER(INTG), INTENT(OUT), ALLOCATABLE :: surfaceNodes(:) !<The list of nodes on the surface to be returned.
    INTEGER(INTG), INTENT(OUT) :: normalXi !<index of the xi direction that is normal to the surface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL ENTERS("CMISSGeneratedMeshSurfaceGetObj0",err,error,*999)

    CALL GENERATED_MESH_SURFACE_GET(generatedMesh%GENERATED_MESH,1,surfaceType,surfaceNodes,normalXi,err,error,*999)

    CALL EXITS("CMISSGeneratedMeshSurfaceGetObj0")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshSurfaceGetObj0",err,error)
    CALL EXITS("CMISSGeneratedMeshSurfaceGetObj0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN
  END SUBROUTINE CMISSGeneratedMeshSurfaceGetObj0

  !
  !================================================================================================================================
  !

  !>Returns a list of the nodes belonging to a surface, and their normal xi direction, of a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMeshSurfaceGetObj1(generatedMesh,meshComponent,surfaceType,surfaceNodes,normalXi,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh from which to extract surface nodes.
    INTEGER(INTG), INTENT(IN) :: meshComponent !<The mesh component/basis number to use
    INTEGER(INTG), INTENT(IN) :: surfaceType !<The type of surface to be extracted .
    INTEGER(INTG), INTENT(OUT), ALLOCATABLE :: surfaceNodes(:) !<The list of nodes on the surface to be returned.
    INTEGER(INTG), INTENT(OUT) :: normalXi !<index of the xi direction that is normal to the surface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL ENTERS("CMISSGeneratedMeshSurfaceGetObj1",err,error,*999)

    CALL GENERATED_MESH_SURFACE_GET(generatedMesh%GENERATED_MESH,meshComponent,surfaceType,surfaceNodes,normalXi,err,error,*999)

    CALL EXITS("CMISSGeneratedMeshSurfaceGetObj1")
    RETURN
999 CALL ERRORS("CMISSGeneratedMeshSurfaceGetObj1",err,error)
    CALL EXITS("CMISSGeneratedMeshSurfaceGetObj1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN
  END SUBROUTINE CMISSGeneratedMeshSurfaceGetObj1


!!==================================================================================================================================
!!
!! MESH EMBEDDING ROUTINES
!!
!!==================================================================================================================================
  !
  !================================================================================================================================
  !

  !>Initialises a EmbeddedMeshType object.
  SUBROUTINE CMISSMeshEmbeddingTypeInitialise(meshEmbedding,err)
    !Argument variables
    TYPE(CMISSMeshEmbeddingType), INTENT(OUT) ::  meshEmbedding !<The  MeshEmbeddingType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshEmbeddingTypeInitialise",err,error,*999)

    NULLIFY(meshEmbedding%MESH_EMBEDDING)

    CALL EXITS("CMISSMeshEmbeddingTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSMeshEmbeddingTypeInitialise",err,error)
    CALL EXITS("CMISSMeshEmbeddingTypeInitialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshEmbeddingTypeInitialise

  !
  !================================================================================================================================
  !
!>Creates a mesh embedding
  SUBROUTINE CMISSMeshEmbeddingCreateNumber(regionOneUserNumber,regionTwoUserNumber,meshEmbedding,parentMeshUserNumber, &
    & childMeshUserNumber,err)

    TYPE(CMISSMeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
    TYPE(REGION_TYPE), POINTER :: REGION1, REGION2
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    TYPE(MESH_TYPE), POINTER :: PARENTMESH,CHILDMESH
    INTEGER(INTG), INTENT(IN) :: parentMeshUserNumber, childMeshUserNumber  !<The user number of the mesh.
    INTEGER(INTG), INTENT(IN) :: regionOneUserNumber, regionTwoUserNumber !<The user number of the region containing the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.


    CALL ENTERS("CMISSMeshEmbeddingCreateNumber",err,error,*999)

    NULLIFY(REGION1)
    NULLIFY(REGION2)
    NULLIFY(PARENTMESH)
    NULLIFY(CHILDMESH)

    CALL REGION_USER_NUMBER_FIND(regionOneUserNumber,REGION1,err,error,*999)
    CALL REGION_USER_NUMBER_FIND(regionTwoUserNumber,REGION2,err,error,*999)
    IF(ASSOCIATED(REGION1)) THEN
      CALL MESH_USER_NUMBER_FIND(parentMeshUserNumber,REGION1,PARENTMESH,err,error,*999)
      IF(ASSOCIATED(REGION2)) THEN
        CALL MESH_USER_NUMBER_FIND(childMeshUserNumber,REGION2,CHILDMESH,err,error,*999)
        IF(ASSOCIATED(PARENTMESH).AND.ASSOCIATED(CHILDMESH)) THEN
          CALL MESH_EMBEDDING_CREATE(meshEmbedding%MESH_EMBEDDING,PARENTMESH,CHILDMESH,err,error,*999)
        ELSE
          LOCAL_ERROR="Meshes with user number of "//TRIM(NUMBER_TO_VSTRING(parentMeshUserNumber,"*",err,error))// &
              & " and "//TRIM(NUMBER_TO_VSTRING(childMeshUserNumber,"*",err,error))//  " do not exist."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionTwoUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionOneUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSMeshEmbeddingCreateNumber")
    RETURN
999 CALL ERRORS("CMISSMeshEmbeddingCreateNumber",err,error)
    CALL EXITS("CMISSMeshEmbeddingCreateNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshEmbeddingCreateNumber

  !
  !================================================================================================================================
  !

  !>Creates a mesh embedding
  SUBROUTINE CMISSMeshEmbeddingCreateObj(meshEmbedding, parentMesh, childMesh, err)
    TYPE(CMISSMeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
    TYPE(CMISSMeshType), INTENT(IN) :: parentMesh, childMesh   !<The parent and child meshes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    CALL MESH_EMBEDDING_CREATE(meshEmbedding%MESH_EMBEDDING,parentMesh%MESH,childMesh%MESH,err,error,*999)
999 RETURN
  END SUBROUTINE CMISSMeshEmbeddingCreateObj

  !
  !================================================================================================================================
  !

  !>Sets the embedded nodes for one parent element
  SUBROUTINE CMISSMeshEmbeddingSetChildNodePositionObj(meshEmbedding, elementNumber, nodeNumbers, xiCoords, err)
    TYPE(CMISSMeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
    INTEGER(INTG), INTENT(IN) :: elementNumber   !<Parent element number
    INTEGER(INTG), INTENT(IN) :: nodeNumbers(:)  !<Node numbers in child mesh
    REAL(DP), INTENT(IN)      :: xiCoords(:,:)   !<Xi coordinates of embedded nodes wrt parent element
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    CALL MESH_EMBEDDING_SET_CHILD_NODE_POSITION(meshEmbedding%MESH_EMBEDDING,elementNumber, nodeNumbers, xiCoords, err, error, *999)
999 RETURN
  END SUBROUTINE CMISSMeshEmbeddingSetChildNodePositionObj

  !
  !================================================================================================================================
  !

  !>Pushes data to embedded mesh. Will generally be used at library and not API level. /TODO: Parameter set etc, function name?
  SUBROUTINE CMISSMeshEmbeddingPushDataObj(meshEmbedding, parentField, parentComponent, childField, childComponent, err)
    TYPE(CMISSMeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
    TYPE(CMISSFieldType), INTENT(IN) :: parentField, childField  !<Fields associated with parent and child mesh to get/set data from
!    TYPE(CMISSFieldType), POINTER, INTENT(IN) :: parentField, childField  !<Fields associated with parent and child mesh to get/set data from

    INTEGER(INTG), INTENT(IN) :: parentComponent, childComponent  !<Component numbers in respective fields
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    CALL MESH_EMBEDDING_PUSH_DATA(meshEmbedding%MESH_EMBEDDING,parentField%FIELD, parentComponent, childField%FIELD, &
      & childComponent, err, error, *999)
999 RETURN
  END SUBROUTINE CMISSMeshEmbeddingPushDataObj

!
  !================================================================================================================================
  !
!   !>Sets the positions of a Gauss point of the parent mesh in terms of element/xi coordinated in the child mesh
    SUBROUTINE CMISSMeshEmbeddingSetGaussPointDataObj(meshEmbedding, parentElementNumber,gaussPointNumber, &
       & parentXiCoords,childElementNumber,childXiCoords, err)
     TYPE(CMISSMeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
     INTEGER(INTG), INTENT(IN) :: parentElementNumber   !<Parent element number
     INTEGER(INTG), INTENT(IN) :: childElementNumber   !<Child element number
     INTEGER(INTG), INTENT(IN) :: gaussPointNumber  !<Gauss point number in this element
     REAL(DP), INTENT(IN)      :: parentXiCoords(:)   !<Xi coordinates of embedded nodes wrt parent element
     REAL(DP), INTENT(IN)      :: childXiCoords(:)   !<Xi coordinates of embedded nodes wrt Child element
     INTEGER(INTG), INTENT(OUT) :: err           !<The error code
!
     CALL MESH_EMBEDDING_SET_GAUSS_POINT_DATA(meshEmbedding%MESH_EMBEDDING, parentElementNumber, gaussPointNumber,&
     & parentXiCoords, childElementNumber, childXiCoords,err,error,*999)
 999 RETURN
    END SUBROUTINE CMISSMeshEmbeddingSetGaussPointDataObj
! !
  !================================================================================================================================
  !
!   !>Sets the positions of a Gauss point of the parent mesh in terms of element/xi coordinated in the child mesh
    SUBROUTINE CMISSMeshEmbeddingPullGaussPointDataObj(meshEmbedding, parentField, parentComponent, childField, childComponent, err)
    TYPE(CMISSMeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
    TYPE(CMISSFieldType), INTENT(IN) :: parentField, childField  !<Fields associated with parent and child mesh to get/set data from
    INTEGER(INTG), INTENT(IN) :: parentComponent, childComponent  !<Component numbers in respective fields
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL MESH_EMBEDDING_PULL_GAUSS_POINT_DATA(meshEmbedding%MESH_EMBEDDING,parentField%FIELD, parentComponent, &
      &  childField%FIELD,childComponent, err, error, *999)
999 RETURN
    END SUBROUTINE CMISSMeshEmbeddingPullGaussPointDataObj
! !
  !================================================================================================================================
  !
   SUBROUTINE CMISSFieldParameterSetGetGaussPointCoordObj(meshEmbedding,componentNumber,numberOfGaussPoints, &
     & coords,err)

    !Argument variables
    TYPE(CMISSMeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
    INTEGER(INTG), INTENT(IN) :: componentNumber
    INTEGER(INTG), INTENT(OUT) :: numberOfGaussPoints
    REAL(DP), INTENT(OUT)      :: coords(:)   !<Xi coordinates of embedded nodes wrt Child element
    INTEGER(INTG), INTENT(OUT) :: err           !<The error code
    !Local variables

    CALL ENTERS("CMISSFieldParameterSetGetGaussPointCoordObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_GAUSS_POINT_COORD(meshEmbedding%MESH_EMBEDDING,componentNumber, &
      & NumberofGaussPoints,COORDS,ERR,error,*999)

    CALL EXITS("CMISSFieldParameterSetGetGaussPointCoordObj")

999 RETURN

  END SUBROUTINE CMISSFieldParameterSetGetGaussPointCoordObj
!!==================================================================================================================================
!!
!! INTERFACE_ROUTINES
!!
!!==================================================================================================================================

  !
  !================================================================================================================================
  !

  !>Finishes the creation of an interface identified by a user number.
  SUBROUTINE CMISSInterfaceCreateFinishNumber(regionUserNumber,interfaceUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to finish the interface for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CREATE_FINISH(INTERFACE,err,error,*999)
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceCreateFinishNumber",err,error)
    CALL EXITS("CMISSInterfaceCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of an interface identified by an object.
  SUBROUTINE CMISSInterfaceCreateFinishObj(iNTERFACE,err)

    !Argument variables
    TYPE(CMISSInterfaceType), INTENT(IN) :: Interface !<The interface to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceCreateFinishObj",err,error,*999)

    CALL INTERFACE_CREATE_FINISH(Interface%iNTERFACE,err,error,*999)

    CALL EXITS("CMISSInterfaceCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceCreateFinishObj",err,error)
    CALL EXITS("CMISSInterfaceCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface identified by a user number.
  SUBROUTINE CMISSInterfaceCreateStartNumber(interfaceUserNumber,regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to start the creation of.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to start the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_CREATE_START(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceCreateStartNumber",err,error)
    CALL EXITS("CMISSInterfaceCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface identified by an object.
  SUBROUTINE CMISSInterfaceCreateStartObj(interfaceUserNumber,region,interface,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the field to start the creation of.
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region to create the interface on.
    TYPE(CMISSInterfaceType), INTENT(IN) :: interface !<On return, the created interface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceCreateStartObj",err,error,*999)

    CALL INTERFACE_CREATE_START(interfaceUserNumber,region%REGION,interface%INTERFACE,err,error,*999)

    CALL EXITS("CMISSInterfaceCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceCreateStartObj",err,error)
    CALL EXITS("CMISSInterfaceCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys an interface identified by a user number.
  SUBROUTINE CMISSInterfaceDestroyNumber(regionUserNumber,interfaceUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to destroy.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFInterfaceDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_DESTROY(INTERFACE,err,error,*999)
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceDestroyNumber",err,error)
    CALL EXITS("CMISSInterfaceDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys an interface identified by an object.
  SUBROUTINE CMISSInterfaceDestroyObj(iNTERFACE,err)

    !Argument variables
    TYPE(CMISSInterfaceType), INTENT(IN) :: Interface !<The interface to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceDestroyObj",err,error,*999)

    CALL INTERFACE_DESTROY(Interface%iNTERFACE,err,error,*999)

    CALL EXITS("CMISSInterfaceDestroyObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceDestroyObj",err,error)
    CALL EXITS("CMISSInterfaceDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for an interface identified by an user number.
  SUBROUTINE CMISSInterfaceLabelGetCNumber(parentRegionUserNumber,interfaceUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region containing the interface to get the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: PARENT_REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceLabelGetCNumber",err,error,*999)

    NULLIFY(PARENT_REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,PARENT_REGION,err,error,*999)
    IF(ASSOCIATED(PARENT_REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,PARENT_REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_LABEL_GET(INTERFACE,label,err,error,*999)
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on a parent region with a user number of "// &
          & TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceLabelGetCNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceLabelGetCNumber",err,error)
    CALL EXITS("CMISSInterfaceLabelGetCNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceLabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character string label for an interface identified by an object.
  SUBROUTINE CMISSInterfaceLabelGetCObj(interface,label,err)

    !Argument variables
    TYPE(CMISSInterfaceType), INTENT(IN) :: interface !<The interface to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceLabelGetCObj",err,error,*999)

    CALL INTERFACE_LABEL_GET(interface%INTERFACE,label,err,error,*999)

    CALL EXITS("CMISSInterfaceLabelGetCObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceLabelGetCObj",err,error)
    CALL EXITS("CMISSInterfaceLabelGetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceLabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for an interface identified by an user number.
  SUBROUTINE CMISSInterfaceLabelGetVSNumber(parentRegionUserNumber,interfaceUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region containing the interface to get the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: PARENT_REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceLabelGetVSNumber",err,error,*999)

    NULLIFY(PARENT_REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,PARENT_REGION,err,error,*999)
    IF(ASSOCIATED(PARENT_REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,PARENT_REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_LABEL_GET(INTERFACE,label,err,error,*999)
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on a parent region with a user number of "// &
          & TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceLabelGetVSNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceLabelGetVSNumber",err,error)
    CALL EXITS("CMISSInterfaceLabelGetVSNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceLabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for an interface identified by an object.
  SUBROUTINE CMISSInterfaceLabelGetVSObj(iNTERFACE,label,err)

    !Argument variables
    TYPE(CMISSInterfaceType), INTENT(IN) :: Interface !<The interface to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the interface label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceLabelGetVSObj",err,error,*999)

    CALL INTERFACE_LABEL_GET(Interface%iNTERFACE,label,err,error,*999)

    CALL EXITS("CMISSInterfaceLabelGetVSObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceLabelGetVSObj",err,error)
    CALL EXITS("CMISSInterfaceLabelGetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceLabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for an interface identified by an user number.
  SUBROUTINE CMISSInterfaceLabelSetCNumber(parentRegionUserNumber,interfaceUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region containing the interface to set the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The interface label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: PARENT_REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceLabelSetCNumber",err,error,*999)

    NULLIFY(PARENT_REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,PARENT_REGION,err,error,*999)
    IF(ASSOCIATED(PARENT_REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,PARENT_REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_LABEL_SET(INTERFACE,label,err,error,*999)
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on a parent region with a user number of "// &
          & TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceLabelSetCNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceLabelSetCNumber",err,error)
    CALL EXITS("CMISSInterfaceLabelSetCNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceLabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for an interface identified by an object.
  SUBROUTINE CMISSInterfaceLabelSetCObj(iNTERFACE,label,err)

    !Argument variables
    TYPE(CMISSInterfaceType), INTENT(IN) :: Interface !<The interface to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The interface label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceLabelSetCObj",err,error,*999)

    CALL INTERFACE_LABEL_SET(Interface%iNTERFACE,label,err,error,*999)

    CALL EXITS("CMISSInterfaceLabelSetCObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceLabelSetCObj",err,error)
    CALL EXITS("CMISSInterfaceLabelSetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceLabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for an interface identified by an user number.
  SUBROUTINE CMISSInterfaceLabelSetVSNumber(parentRegionUserNumber,interfaceUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region containing the interface to set the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The interface label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: PARENT_REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceLabelSetVSNumber",err,error,*999)

    NULLIFY(PARENT_REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,PARENT_REGION,err,error,*999)
    IF(ASSOCIATED(PARENT_REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,PARENT_REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_LABEL_SET(INTERFACE,CHAR(label),err,error,*999)
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on a parent region with a user number of "// &
          & TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceLabelStVSNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceLabelSetVSNumber",err,error)
    CALL EXITS("CMISSInterfaceLabelSetVSNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceLabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes string label for an interface identified by an object.
  SUBROUTINE CMISSInterfaceLabelSetVSObj(iNTERFACE,label,err)

    !Argument variables
    TYPE(CMISSInterfaceType), INTENT(IN) :: Interface !<The interface to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The interface label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceLabelSetVSObj",err,error,*999)

    CALL INTERFACE_LABEL_SET(Interface%iNTERFACE,CHAR(label),err,error,*999)

    CALL EXITS("CMISSInterfaceLabelSetVSObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceLabelSetVSObj",err,error)
    CALL EXITS("CMISSInterfaceLabelSetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceLabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Adds a mesh to be coupled in an interface identified by a user number.
  SUBROUTINE CMISSInterfaceMeshAddNumber(interfaceRegionUserNumber,interfaceUserNumber,meshRegionUserNumber, &
    & meshUserNumber,meshIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: interfaceRegionUserNumber !<The user number of the parent region containing the interface to add a coupled mesh to.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to add a coupled mesh to.
    INTEGER(INTG), INTENT(IN) :: meshRegionUserNumber !<The user number of the region containing the mesh to add to the interface.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to add to the interface.
    INTEGER(INTG), INTENT(OUT) :: meshIndex !<On return, the mesh index of the mesh in the list of coupled meshes in the interface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: MESH_REGION,PARENT_REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceMeshAddNumber",err,error,*999)

    NULLIFY(PARENT_REGION)
    NULLIFY(INTERFACE)
    NULLIFY(MESH_REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(interfaceRegionUserNumber,PARENT_REGION,err,error,*999)
    IF(ASSOCIATED(PARENT_REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,PARENT_REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL REGION_USER_NUMBER_FIND(meshRegionUserNumber,MESH_REGION,err,error,*999)
        IF(ASSOCIATED(MESH_REGION)) THEN
          CALL MESH_USER_NUMBER_FIND(meshUserNumber,MESH_REGION,MESH,err,error,*999)
          IF(ASSOCIATED(MESH)) THEN
            CALL INTERFACE_MESH_ADD(INTERFACE,MESH,meshIndex,err,error,*999)
          ELSE
            LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
              & " does not exist on the region with an user number of "// &
              & TRIM(NUMBER_TO_VSTRING(meshRegionUserNumber,"*",err,error))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The mesh region with an user number of "//TRIM(NUMBER_TO_VSTRING(meshRegionUserNumber,"*",err,error))// &
            & " does not exist."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "// &
          & TRIM(NUMBER_TO_VSTRING(interfaceRegionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="The interface parent region with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(interfaceRegionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceMeshAddNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceMeshAddNumber",err,error)
    CALL EXITS("CMISSInterfaceMeshAddNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceMeshAddNumber

  !
  !================================================================================================================================
  !

  !>Adds a mesh to be coupled in an interface identified by an object.
  SUBROUTINE CMISSInterfaceMeshAddObj(interface,mesh,meshIndex,err)

    !Argument variables
    TYPE(CMISSInterfaceType), INTENT(IN) :: interface !<The interface to finish creating.
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !<The mesh to add to the interface.
    INTEGER(INTG), INTENT(OUT) :: meshIndex !<On return, the mesh index of the mesh in the list of coupled meshes in the interface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceMeshAddObj",err,error,*999)

    CALL INTERFACE_MESH_ADD(interface%INTERFACE,mesh%MESH,meshIndex,err,error,*999)

    CALL EXITS("CMISSInterfaceMeshAddObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceMeshAddObj",err,error)
    CALL EXITS("CMISSInterfaceMeshAddObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceMeshAddObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of an interface coupled mesh connectivity identified by a user number.
  SUBROUTINE CMISSInterfaceMeshConnectivityCreateFinishNumber(regionUserNumber,interfaceUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to finish the interface meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to finish creating the meshes connectivity.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceMeshConnectivityCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_MESH_CONNECTIVITY_CREATE_FINISH(INTERFACE%MESH_CONNECTIVITY,err,error,*999)
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceMeshConnectivityCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceMeshConnectivityCreateFinishNumber",err,error)
    CALL EXITS("CMISSInterfaceMeshConnectivityCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceMeshConnectivityCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of an interface meshes connectivity identified by an object.
  SUBROUTINE CMISSInterfaceMeshConnectivityCreateFinishObj(interfaceMeshConnectivity,err)

    !Argument variables
    TYPE(CMISSInterfaceMeshConnectivityType), INTENT(IN) :: interfaceMeshConnectivity !<The interface meshes connectivity to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceMeshConnectivityCreateFinishObj",err,error,*999)

    CALL INTERFACE_MESH_CONNECTIVITY_CREATE_FINISH(interfaceMeshConnectivity%MESH_CONNECTIVITY,err,error,*999)

    CALL EXITS("CMISSInterfaceMeshConnectivityCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceMeshConnectivityCreateFinishObj",err,error)
    CALL EXITS("CMISSInterfaceMeshConnectivityCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceMeshConnectivityCreateFinishObj



  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface meshes connectivity identified by a user number.
  SUBROUTINE CMISSInterfaceMeshConnectivityCreateStartNumber(regionUserNumber,interfaceUserNumber,meshNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to start the creation of the meshes connectivity.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to start the creation of the meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: meshNumber !<The user number of the interface mesh
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: INTERFACE_MESH_CONNECTIVITY
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceMeshConnectivityCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_MESH_CONNECTIVITY)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL MESH_USER_NUMBER_FIND(meshNumber,INTERFACE,MESH,ERR,error,*999)
        IF(ASSOCIATED(MESH)) THEN
          CALL INTERFACE_MESH_CONNECTIVITY_CREATE_START(INTERFACE,MESH,INTERFACE_MESH_CONNECTIVITY,err,error,*999)
        ELSE
          LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
           & " does not exist on the interface with user number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceMeshConnectivityCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceMeshConnectivityCreateStartNumber",err,error)
    CALL EXITS("CMISSInterfaceMeshConnectivityCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceMeshConnectivityCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface meshes connectivity identified by an object.
  SUBROUTINE CMISSInterfaceMeshConnectivityCreateStartObj(iNTERFACE,iNTERFACE_MESH,interfaceMeshConnectivity,err)

    !Argument variables
    TYPE(CMISSInterfaceType), INTENT(IN) :: Interface !<The interface to start the creation of the meshes connectivity for
    TYPE(CMISSMeshType), INTENT(IN) :: iNTERFACE_MESH
    TYPE(CMISSInterfaceMeshConnectivityType), INTENT(INOUT) :: interfaceMeshConnectivity !<On return, the created meshes connectivity
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceMeshConnectivityCreateStartObj",err,error,*999)

    CALL INTERFACE_MESH_CONNECTIVITY_CREATE_START(iNTERFACE%iNTERFACE,iNTERFACE_MESH%MESH, &
      & interfaceMeshConnectivity%MESH_CONNECTIVITY,err,error,*999)

    CALL EXITS("CMISSInterfaceMeshConnectivityCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceMeshConnectivityCreateStartObj",err,error)
    CALL EXITS("CMISSInterfaceMeshConnectivityCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceMeshConnectivityCreateStartObj


  !
  !================================================================================================================================
  !

  !>Sets the number of coupled mesh elements which are linked to a specific interface element.
  SUBROUTINE CMISSInterfaceMeshConnectivityElementNumberSetNumber(regionUserNumber,interfaceUserNumber, &
     &  interfaceElementNumber,coupledMeshIndexNumber,numberOfElements,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to start the creation of the meshes connectivity.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to start the creation of the meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceElementNumber !<The element number of the interface mesh
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number to the coupled mesh
    INTEGER(INTG), INTENT(IN) :: numberOfElements !<The number of elements
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceMeshConnectivityElementNumberSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_MESH_CONNECTIVITY_ELEMENT_NUMBER_SET(INTERFACE%MESH_CONNECTIVITY,interfaceElementNumber, &
         & coupledMeshIndexNumber,numberOfElements,err,error,*999)
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceMeshConnectivityElementNumberSetNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceMeshConnectivityElementNumberSetNumber",err,error)
    CALL EXITS("CMISSInterfaceMeshConnectivityElementNumberSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceMeshConnectivityElementNumberSetNumber

  !
  !================================================================================================================================
  !


  !>Sets the xi coordinate mapping between the interface and xi coordinates in a coupled region mesh
  SUBROUTINE CMISSInterfaceMeshConnectivityElementXiSetNumber(regionUserNumber,interfaceUserNumber,interfaceElementNumber, &
     &  coupledMeshIndexNumber,coupledMeshElementNumber,localNodeNumber,componentNumber,xi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to start the creation of the meshes connectivity.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to start the creation of the meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceElementNumber !<The element number of the interface mesh
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number to the coupled mesh
    INTEGER(INTG), INTENT(IN) :: coupledMeshElementNumber !<The number of elements
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The number of elements
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The number of elements
    REAL(DP), INTENT(IN) :: xi(:)
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceMeshConnectivityElementXiSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_MESH_CONNECTIVITY_ELEMENT_XI_SET(INTERFACE%MESH_CONNECTIVITY,interfaceElementNumber, &
         & coupledMeshIndexNumber,coupledMeshElementNumber,localNodeNumber,componentNumber,xi,err,error,*999)
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceMeshConnectivityElementXiSetNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceMeshConnectivityElementXiSetNumber",err,error)
    CALL EXITS("CMISSInterfaceMeshConnectivityElementXiSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceMeshConnectivityElementXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the xi coordinate mapping between the interface and xi coordinates in a coupled region mesh
  SUBROUTINE CMISSInterfaceMeshConnectivityElementXiSetObj(interfaceMeshConnectivity,interfaceElementNumber, &
     &  coupledMeshIndexNumber,coupledMeshElementNumber,localNodeNumber,componentNumber,xi,err)

    !Argument variables
    TYPE(CMISSInterfaceMeshConnectivityType), INTENT(IN) :: interfaceMeshConnectivity !<The interface to start the creation of the meshes connectivity for
    INTEGER(INTG), INTENT(IN) :: interfaceElementNumber !<The element number of the interface mesh
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number to the coupled mesh
    INTEGER(INTG), INTENT(IN) :: coupledMeshElementNumber !<The number of elements
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The number of elements
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The number of elements
    REAL(DP), INTENT(IN) :: xi(:)
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceMeshConnectivityElementXiSetObj",err,error,*999)

    CALL INTERFACE_MESH_CONNECTIVITY_ELEMENT_XI_SET(interfaceMeshConnectivity%MESH_CONNECTIVITY,interfaceElementNumber, &
         & coupledMeshIndexNumber,coupledMeshElementNumber,localNodeNumber,componentNumber,xi,err,error,*999)

    CALL EXITS("CMISSInterfaceMeshConnectivityElementXiSetObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceMeshConnectivityElementXiSetObj",err,error)
    CALL EXITS("CMISSInterfaceMeshConnectivityElementXiSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceMeshConnectivityElementXiSetObj

  !
  !================================================================================================================================
  !

  !>Sets the number of coupled mesh elements which are linked to a specific interface element.
  SUBROUTINE CMISSInterfaceMeshConnectivityElementNumberSetObj(interfaceMeshConnectivity,interfaceElementNumber, &
     &  coupledMeshIndexNumber,numberOfElements,err)

    !Argument variables
    TYPE(CMISSInterfaceMeshConnectivityType), INTENT(IN) :: interfaceMeshConnectivity !<The interface to start the creation of the meshes connectivity for
    INTEGER(INTG), INTENT(IN) :: interfaceElementNumber !<The element number of the interface mesh
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number to the coupled mesh
    INTEGER(INTG), INTENT(IN) :: numberOfElements !<The number of elements

    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceMeshConnectivityElementNumberSetObj",err,error,*999)

    CALL INTERFACE_MESH_CONNECTIVITY_ELEMENT_NUMBER_SET(interfaceMeshConnectivity%MESH_CONNECTIVITY, &
         & interfaceElementNumber,coupledMeshIndexNumber,numberOfElements,err,error,*999)

    CALL EXITS("CMISSInterfaceMeshConnectivityElementNumberSetObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceMeshConnectivityElementNumberSetObj",err,error)
    CALL EXITS("CMISSInterfaceMeshConnectivityElementNumberSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceMeshConnectivityElementNumberSetObj

  !
  !================================================================================================================================
  !

  !>Sets the basis for the mesh connectivity
  SUBROUTINE CMISSInterfaceMeshConnectivitySetBasisObj(interfaceMeshConnectivity,interfaceMappingBasis,err)

    !Argument variables
    TYPE(CMISSInterfaceMeshConnectivityType), INTENT(IN) :: interfaceMeshConnectivity !<The interface to start the creation of the meshes connectivity for
    TYPE(CMISSBasisType), INTENT(INOUT) :: interfaceMappingBasis !<The interface mesh connectivity basis
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceMeshConnectivitySetBasisObj",err,error,*999)

    CALL INTERFACE_MESH_CONNECTIVITY_SET_BASIS(interfaceMeshConnectivity%MESH_CONNECTIVITY,interfaceMappingBasis%BASIS,err, &
      & error,*999)

    CALL EXITS("CMISSInterfaceMeshConnectivitySetBasisObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceMeshConnectivitySetBasisObj",err,error)
    CALL EXITS("CMISSInterfaceMeshConnectivitySetBasisObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceMeshConnectivitySetBasisObj

  !
  !================================================================================================================================
  !

  !>Destroys an interface meshes connectivity identified by a user number.
  SUBROUTINE CMISSInterfaceMeshConnectivityDestroyNumber(regionUserNumber,interfaceUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to destroy the meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to destroy the meshes connectivity for.
   INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFInterfaceMeshConnectivityDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_MESH_CONNECTIVITY_DESTROY(INTERFACE%MESH_CONNECTIVITY,err,error,*999)
     ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceMeshConnectivityDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceMeshConnectivityDestroyNumber",err,error)
    CALL EXITS("CMISSInterfaceMeshConnectivityDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceMeshConnectivityDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys an interface meshes connectivity identified by an object.
  SUBROUTINE CMISSInterfaceMeshConnectivityDestroyObj(interfaceMeshConnectivity,err)

    !Argument variables
    TYPE(CMISSInterfaceMeshConnectivityType), INTENT(IN) :: interfaceMeshConnectivity !<The interface meshes connectivity to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceMeshConnectivityDestroyObj",err,error,*999)

    IF(ASSOCIATED(interfaceMeshConnectivity%MESH_CONNECTIVITY)) &
      &  CALL INTERFACE_MESH_CONNECTIVITY_DESTROY(interfaceMeshConnectivity%MESH_CONNECTIVITY,err,error,*999)

    CALL EXITS("CMISSInterfaceMeshConnectivityDestroyObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceMeshConnectivityDestroyObj",err,error)
    CALL EXITS("CMISSInterfaceMeshConnectivityDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceMeshConnectivityDestroyObj


  !
  !================================================================================================================================
  !


  SUBROUTINE CMISSInterfaceMeshConnectivitySetBasisNumber(regionUserNumber,interfaceUserNumber,interfaceBasisNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to destroy the meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to destroy the meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceBasisNumber !<The user number of the basis to denote the interface mesh connectivity basis
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceMeshConnectivitySetBasisNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(BASIS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL BASIS_USER_NUMBER_FIND(interfaceBasisNumber,BASIS,err,error,*999)
        IF (ASSOCIATED(BASIS)) THEN
          CALL INTERFACE_MESH_CONNECTIVITY_SET_BASIS(INTERFACE%MESH_CONNECTIVITY,BASIS,err,error,*999)
        ELSE
          LOCAL_ERROR="A basis with the user number "//TRIM(NUMBER_TO_VSTRING(interfaceBasisNumber,"*",err,error))// &
            & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
     ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceMeshConnectivitySetBasisNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceMeshConnectivitySetBasisNumber",err,error)
    CALL EXITS("CMISSInterfaceMeshConnectivitySetBasisNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceMeshConnectivitySetBasisNumber


!!==================================================================================================================================
!!
!! INTERFACE_CONDITIONS_ROUTINES
!!
!!==================================================================================================================================

  !>Finishes the creation of an interface condition identified by an user number.
  SUBROUTINE CMISSInterfaceConditionCreateFinishNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to finish the interface condition for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containg the interface condition to finish creating for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceConditionCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_CREATE_FINISH(INTERFACE_CONDITION,err,error,*999)
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceConditionCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceConditionCreateFinishNumber",err,error)
    CALL EXITS("CMISSInterfaceConditionCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceConditionCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of an interface condition identified by an object.
  SUBROUTINE CMISSInterfaceConditionCreateFinishObj(interfaceCondition,err)

    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceConditionCreateFinishObj",err,error,*999)

    CALL INTERFACE_CONDITION_CREATE_FINISH(interfaceCondition%INTERFACE_CONDITION,err,error,*999)

    CALL EXITS("CMISSInterfaceConditionCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceConditionCreateFinishObj",err,error)
    CALL EXITS("CMISSInterfaceConditionCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceConditionCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface condition identified by a user number.
  SUBROUTINE CMISSInterfaceConditionCreateStartNumber(interfaceConditionUserNumber,regionUserNumber,interfaceUserNumber, &
    & geometricFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to start the creation of.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to start the creation of the interface condition for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to start the creation of.
    INTEGER(INTG), INTENT(IN) :: geometricFieldUserNumber !<The user number of the geometric field on the interface for the interface condition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: GEOMETRIC_FIELD
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceConditionCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(GEOMETRIC_FIELD)
    NULLIFY(INTERFACE_CONDITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL FIELD_USER_NUMBER_FIND(geometricFieldUserNumber,INTERFACE,GEOMETRIC_FIELD,err,error,*999)
        IF(ASSOCIATED(GEOMETRIC_FIELD)) THEN
          CALL INTERFACE_CONDITION_CREATE_START(interfaceConditionUserNumber,INTERFACE,GEOMETRIC_FIELD,INTERFACE_CONDITION, &
            & err,error,*999)
        ELSE
          LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(geometricFieldUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " in the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceConditionCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceConditionCreateStartNumber",err,error)
    CALL EXITS("CMISSInterfaceConditionCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceConditionCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface condition identified by an object.
  SUBROUTINE CMISSInterfaceConditionCreateStartObj(interfaceConditionUserNumber,interface,geometricField,interfaceCondition,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface conditon to start the creation of.
    TYPE(CMISSInterfaceType), INTENT(IN) :: interface !<The interface to create the interface on.
    TYPE(CMISSFieldType), INTENT(IN) :: geometricField !<The geometric field for the interface condition.
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: interfaceCondition !<On return, the created interface condition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceConditionCreateStartObj",err,error,*999)

    CALL INTERFACE_CONDITION_CREATE_START(interfaceConditionUserNumber,interface%INTERFACE,geometricField%FIELD, &
      & interfaceCondition%INTERFACE_CONDITION,err,error,*999)

    CALL EXITS("CMISSInterfaceConditionCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceConditionCreateStartObj",err,error)
    CALL EXITS("CMISSInterfaceConditionCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceConditionCreateStartObj

  !
  !================================================================================================================================
  !

  !>Adds a dependent variable to an interface condition identified by a user number.
  SUBROUTINE CMISSInterfaceConditionDependentVariableAddNumber(interfaceRegionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,meshIndex,equationsSetRegionUserNumber,equationsSetUserNumber,variableType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: interfaceRegionUserNumber !<The user number of the region containing the interface containing the interface condition to add the dependent variable for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to add the dependent variable for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to add the dependent variable for.
    INTEGER(INTG), INTENT(IN) :: meshIndex !<The mesh index of the interface condition interface for which the dependent variable is added.
    INTEGER(INTG), INTENT(IN) :: equationsSetRegionUserNumber !<The user number of the region containing the equations set containing the dependent field varible to add.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set containing the dependent field to add the variable for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent variable to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: EQUATIONS_SET_REGION,INTERFACE_REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceConditionDependentVariableAddNumber",err,error,*999)

    NULLIFY(INTERFACE_REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    NULLIFY(EQUATIONS_SET_REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(interfaceRegionUserNumber,INTERFACE_REGION,err,error,*999)
    IF(ASSOCIATED(INTERFACE_REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,INTERFACE_REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL REGION_USER_NUMBER_FIND(EquationsSetRegionuserNumber,EQUATIONS_SET_REGION,err,error,*999)
          IF(ASSOCIATED(EQUATIONS_SET_REGION)) THEN
            CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,EQUATIONS_SET_REGION,EQUATIONS_SET,err,error,*999)
            IF(ASSOCIATED(EQUATIONS_SET)) THEN
              CALL INTERFACE_CONDITION_DEPENDENT_VARIABLE_ADD(INTERFACE_CONDITION,meshIndex,EQUATIONS_SET,variableType, &
                & err,error,*999)
            ELSE
              LOCAL_ERROR="An equations set with an user number of "// &
                & TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
                & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(equationsSetRegionUserNumber,"*",err,error))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The equations set region with an user number of "// &
              & TRIM(NUMBER_TO_VSTRING(equationsSetRegionUserNumber,"*",err,error))//" does not exist."
            CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(interfaceRegionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(interfaceRegionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="The interface region with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(interfaceRegionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceConditionDependentVariableAddNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceConditionDependentVariableAddNumber",err,error)
    CALL EXITS("CMISSInterfaceConditionDependentVariableAddNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceConditionDependentVariableAddNumber

  !
  !================================================================================================================================
  !

  !>Adds a dependent field variable to an interface condition identified by an object.
  SUBROUTINE CMISSInterfaceConditionDependentVariableAddObj(interfaceCondition,meshIndex,equationsSet,variableType,err)

    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to add the dependent variable to.
    INTEGER(INTG), INTENT(IN) :: meshIndex !<The mesh index of the interface condition interface for which the dependent variable is added.
    TYPE(CMISSEquationsSetType), INTENT(IN) :: equationsSet !<The equations set containg the dependent variable to add.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent variable to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceConditionDependentVariableAddObj",err,error,*999)

    CALL INTERFACE_CONDITION_DEPENDENT_VARIABLE_ADD(interfaceCondition%INTERFACE_CONDITION,meshIndex,equationsSet%EQUATIONS_SET, &
      & variableType,err,error,*999)

    CALL EXITS("CMISSInterfaceConditionDependentVariableAddObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceConditionDependentVariableAddObj",err,error)
    CALL EXITS("CMISSInterfaceConditionDependentVariableAddObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceConditionDependentVariableAddObj

  !
  !================================================================================================================================
  !

  !>Destroys an interface condition identified by a user number.
  SUBROUTINE CMISSInterfaceConditionDestroyNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to destroy.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to destroy.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFInterfaceConditionDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_DESTROY(INTERFACE_CONDITION,err,error,*999)
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceConditionDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceConditionDestroyNumber",err,error)
    CALL EXITS("CMISSInterfaceConditionDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceConditionDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys an interface condition identified by an object.
  SUBROUTINE CMISSInterfaceConditionDestroyObj(interfaceCondition,err)

    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceConditionDestroyObj",err,error,*999)

    CALL INTERFACE_CONDITION_DESTROY(interfaceCondition%INTERFACE_CONDITION,err,error,*999)

    CALL EXITS("CMISSInterfaceConditionDestroyObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceConditionDestroyObj",err,error)
    CALL EXITS("CMISSInterfaceConditionDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceConditionDestroyObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of equations for an interface condition identified by an user number.
  SUBROUTINE CMISSInterfaceConditionEquationsCreateFinishNumber(regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to finish the interface equations for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containg the interface condition to finish the interface equations for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to finish creating the interface equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceConditionEquationsCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_EQUATIONS_CREATE_FINISH(INTERFACE_CONDITION,err,error,*999)
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceConditionEquationsCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceConditionEquationsCreateFinishNumber",err,error)
    CALL EXITS("CMISSInterfaceConditionEquationsCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceConditionEquationsCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of interface equations for an interface condition identified by an object.
  SUBROUTINE CMISSInterfaceConditionEquationsCreateFinishObj(interfaceCondition,err)

    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to finish creating the interface equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceConditionEquationsCreateFinishObj",err,error,*999)

    CALL INTERFACE_CONDITION_EQUATIONS_CREATE_FINISH(interfaceCondition%INTERFACE_CONDITION,err,error,*999)

    CALL EXITS("CMISSInterfaceConditionEquationsCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceConditionEquationsCreateFinishObj",err,error)
    CALL EXITS("CMISSInterfaceConditionEquationsCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceConditionEquationsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of interface equations for an interface condition identified by a user number.
  SUBROUTINE CMISSInterfaceConditionEquationsCreateStartNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber, &
    & err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to start the creation of the interface equations for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to start the creation of the interface equations for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to start the creation of the interface equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: INTERFACE_EQUATIONS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceConditionEquationsCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    NULLIFY(INTERFACE_EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_EQUATIONS_CREATE_START(INTERFACE_CONDITION,INTERFACE_EQUATIONS,err,error,*999)
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceConditionEquationsCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceConditionEquationsCreateStartNumber",err,error)
    CALL EXITS("CMISSInterfaceConditionEquationsCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceConditionEquationsCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of interface equations for an interface condition identified by an object.
  SUBROUTINE CMISSInterfaceConditionEquationsCreateStartObj(interfaceCondition,interfaceEquations,err)

    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to start the creation of interface equations for
    TYPE(CMISSInterfaceEquationsType), INTENT(IN) :: interfaceEquations !<On return, the created interface equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceConditionEquationsCreateStartObj",err,error,*999)

    CALL INTERFACE_CONDITION_EQUATIONS_CREATE_START(interfaceCondition%INTERFACE_CONDITION,interfaceEquations% &
      & INTERFACE_EQUATIONS,err,error,*999)

    CALL EXITS("CMISSInterfaceConditionEquationsCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceConditionEquationsCreateStartObj",err,error)
    CALL EXITS("CMISSInterfaceConditionEquationsCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceConditionEquationsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys interface equations for an interface condition identified by a user number.
  SUBROUTINE CMISSInterfaceConditionEquationsDestroyNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to destroy the interface equations for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to destroy the interface equations for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to destroy the interface equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFInterfaceConditionEquationsDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_EQUATIONS_DESTROY(INTERFACE_CONDITION,err,error,*999)
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceConditionEquationsDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceConditionEquationsDestroyNumber",err,error)
    CALL EXITS("CMISSInterfaceConditionEquationsDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceConditionEquationsDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the interface equations for an interface condition identified by an object.
  SUBROUTINE CMISSInterfaceConditionEquationsDestroyObj(interfaceCondition,err)

    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to destroy the interface equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceConditionEquationsDestroyObj",err,error,*999)

    CALL INTERFACE_CONDITION_EQUATIONS_DESTROY(interfaceCondition%INTERFACE_CONDITION,err,error,*999)

    CALL EXITS("CMISSInterfaceConditionEquationsDestroyObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceConditionEquationsDestroyObj",err,error)
    CALL EXITS("CMISSInterfaceConditionEquationsDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceConditionEquationsDestroyObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a Lagrange Multiplier Field for an interface condition identified by an user number.
  SUBROUTINE CMISSInterfaceConditionLagrangeFieldCreateFinishNumber(regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to finish the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containg the interface condition to finish the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to finish creating the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceConditionLagrangeFieldCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_LAGRANGE_FIELD_CREATE_FINISH(INTERFACE_CONDITION,err,error,*999)
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceConditionLagrangeFieldCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceConditionLagrangeFieldCreateFinishNumber",err,error)
    CALL EXITS("CMISSInterfaceConditionLagrangeFieldCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceConditionLagrangeFieldCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a Lagrange multiplier field for an interface condition identified by an object.
  SUBROUTINE CMISSInterfaceConditionLagrangeFieldCreateFinishObj(interfaceCondition,err)

    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to finish creating the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceConditionLagrangeFieldCreateFinishObj",err,error,*999)

    CALL INTERFACE_CONDITION_LAGRANGE_FIELD_CREATE_FINISH(interfaceCondition%INTERFACE_CONDITION,err,error,*999)

    CALL EXITS("CMISSInterfaceConditionLagrangeFieldCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceConditionLagrangeFieldCreateFinishObj",err,error)
    CALL EXITS("CMISSInterfaceConditionLagrangeFieldCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceConditionLagrangeFieldCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a Lagrange multiplier field for an interface condition identified by a user number.
  SUBROUTINE CMISSInterfaceConditionLagrangeFieldCreateStartNumber(regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,lagrangeFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to start the creation of the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to start the creation of the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to start the creation of the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(IN) :: lagrangeFieldUserNumber !<The user number of the Lagrange field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: LAGRANGE_FIELD
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceConditionLagrangeFieldCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    NULLIFY(LAGRANGE_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_LAGRANGE_FIELD_CREATE_START(INTERFACE_CONDITION,lagrangeFieldUserNumber,LAGRANGE_FIELD, &
            & err,error,*999)
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceConditionLagrangeFieldCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceConditionLagrangeFieldCreateStartNumber",err,error)
    CALL EXITS("CMISSInterfaceConditionLagrangeFieldCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceConditionLagrangeFieldCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a Lagrange multiplier field for an interface condition identified by an object.
  SUBROUTINE CMISSInterfaceConditionLagrangeFieldCreateStartObj(interfaceCondition,lagrangeFieldUserNumber,lagrangeField,err)

    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to start the creation of the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(IN) :: lagrangeFieldUserNumber !<The user number of the Lagrange field.
    TYPE(CMISSFieldType), INTENT(INOUT) :: lagrangeField !<If associated on entry, the user created Lagrange field which has the same user number as the specified Lagrange field user number. If not associated on entry, on return, the created Lagrange field for the interface condition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceConditionLagrangeFieldCreateStartObj",err,error,*999)

    CALL INTERFACE_CONDITION_LAGRANGE_FIELD_CREATE_START(interfaceCondition%INTERFACE_CONDITION,lagrangeFieldUserNumber, &
      & lagrangeField%FIELD,err,error,*999)

    CALL EXITS("CMISSInterfaceConditionLagrangeFieldCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceConditionLagrangeFieldCreateStartObj",err,error)
    CALL EXITS("CMISSInterfaceConditionLagrangeFieldCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceConditionLagrangeFieldCreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the method for an interface condition identified by a user number.
  SUBROUTINE CMISSInterfaceConditionMethodGetNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber, &
    & interfaceConditionMethod,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to get the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to get the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to get the method for.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionMethod !<On return, the interface condition method. \see OPENCMISS_InterfaceConditionMethods,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceConditionMethodGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_METHOD_GET(INTERFACE_CONDITION,interfaceConditionMethod,err,error,*999)
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceConditionMethodGetNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceConditionMethodGetNumber",err,error)
    CALL EXITS("CMISSInterfaceConditionMethodGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceConditionMethodGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the method for an interface condition identified by an object.
  SUBROUTINE CMISSInterfaceConditionMethodGetObj(interfaceCondition,interfaceConditionMethod,err)

    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to get the method for.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionMethod !<On return, the interface condition method. \see OPENCMISS_InterfaceConditionMethods,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceConditionMethodGetObj",err,error,*999)

    CALL INTERFACE_CONDITION_METHOD_GET(interfaceCondition%INTERFACE_CONDITION,interfaceConditionMethod,err,error,*999)

    CALL EXITS("CMISSInterfaceConditionMethodGetObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceConditionMethodGetObj",err,error)
    CALL EXITS("CMISSInterfaceConditionMethodGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceConditionMethodGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the method for an interface condition identified by a user number.
  SUBROUTINE CMISSInterfaceConditionMethodSetNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber, &
    & interfaceConditionMethod,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionMethod !<The interface condition method to set. \see OPENCMISS_InterfaceConditionMethods,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceConditionMethodSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_METHOD_SET(INTERFACE_CONDITION,interfaceConditionMethod,err,error,*999)
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceConditionMethodSetNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceConditionMethodSetNumber",err,error)
    CALL EXITS("CMISSInterfaceConditionMethodSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceConditionMethodSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the method for an interface condition identified by an object.
  SUBROUTINE CMISSInterfaceConditionMethodSetObj(interfaceCondition,interfaceConditionMethod,err)

    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionMethod !<The interface condition method to set. \see OPENCMISS_InterfaceConditionMethods,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceConditionMethodSetObj",err,error,*999)

    CALL INTERFACE_CONDITION_METHOD_SET(interfaceCondition%INTERFACE_CONDITION,interfaceConditionMethod,err,error,*999)

    CALL EXITS("CMISSInterfaceConditionMethodSetObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceConditionMethodSetObj",err,error)
    CALL EXITS("CMISSInterfaceConditionMethodSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceConditionMethodSetObj

  !
  !================================================================================================================================
  !

  !>Returns the operator for an interface condition identified by a user number.
  SUBROUTINE CMISSInterfaceConditionOperatorGetNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber, &
    & interfaceConditionOperator,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to get the operator for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to get the operator for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to get the operator for.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionOperator !<On return, the interface condition operator. \see OPENCMISS_InterfaceConditionOperators,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceConditionOperatorGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_OPERATOR_GET(INTERFACE_CONDITION,interfaceConditionOperator,err,error,*999)
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceConditionOperatorGetNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceConditionOperatorGetNumber",err,error)
    CALL EXITS("CMISSInterfaceConditionOperatorGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceConditionOperatorGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the operator for an interface condition identified by an object.
  SUBROUTINE CMISSInterfaceConditionOperatorGetObj(interfaceCondition,interfaceConditionOperator,err)

    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to get the operator for.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionOperator !<On return, the interface condition operator. \see OPENCMISS_InterfaceConditionOperator,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceConditionOperatorGetObj",err,error,*999)

    CALL INTERFACE_CONDITION_OPERATOR_GET(interfaceCondition%INTERFACE_CONDITION,interfaceConditionOperator, &
      & err,error,*999)

    CALL EXITS("CMISSInterfaceConditionOperatorGetObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceConditionOperatorGetObj",err,error)
    CALL EXITS("CMISSInterfaceConditionOperatorGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceConditionOperatorGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the operator for an interface condition identified by a user number.
  SUBROUTINE CMISSInterfaceConditionOperatorSetNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber, &
    & interfaceConditionOperator,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to set the operator for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to set the operator for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to set the operator for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionOperator !<The interface condition operator to set. \see OPENCMISS_InterfaceConditionOperators,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceConditionOperatorSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_OPERATOR_SET(INTERFACE_CONDITION,interfaceConditionOperator,err,error,*999)
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceConditionOperatorSetNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceConditionOperatorSetNumber",err,error)
    CALL EXITS("CMISSInterfaceConditionOperatorSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceConditionOperatorSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the operator for an interface condition identified by an object.
  SUBROUTINE CMISSInterfaceConditionOperatorSetObj(interfaceCondition,interfaceConditionOperator,err)

    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to set the operator for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionOperator !<The interface condition operator to set. \see OPENCMISS_InterfaceConditionOperator,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceConditionOperatorSetObj",err,error,*999)

    CALL INTERFACE_CONDITION_OPERATOR_SET(interfaceCondition%INTERFACE_CONDITION,interfaceConditionOperator, &
      & err,error,*999)

    CALL EXITS("CMISSInterfaceConditionOperatorSetObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceConditionOperatorSetObj",err,error)
    CALL EXITS("CMISSInterfaceConditionOperatorSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceConditionOperatorSetObj

  !
  !================================================================================================================================
  !

  !>Returns the output type for an interface equations identified by a user number.
  SUBROUTINE CMISSInterfaceEquationsOutputTypeGetNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber, &
    & outputType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface, interface condition and interface equations to get the output type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface, interface condition and interface equations to get the ouput type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition and interface equation to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the interface equations output type. \see OPENCMISS_EquationsOutputType,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: INTERFACE_EQUATIONS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceEquationsOutputTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    NULLIFY(INTERFACE_EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_EQUATIONS_GET(INTERFACE_CONDITION,INTERFACE_EQUATIONS,err,error,*999)
          CALL INTERFACE_EQUATIONS_OUTPUT_TYPE_GET(INTERFACE_EQUATIONS,outputType,err,error,*999)
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceEquationsOutputTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceEquationsOutputTypeGetNumber",err,error)
    CALL EXITS("CMISSInterfaceEquationsOutputTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceEquationsOutputTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the output type for an interface equations identified by an object.
  SUBROUTINE CMISSInterfaceEquationsOutputTypeGetObj(interfaceEquations,outputType,err)

    !Argument variables
    TYPE(CMISSInterfaceEquationsType), INTENT(IN) :: interfaceEquations !<The interface equations to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the interface equations output type. \see OPENCMISS_EquationsOutputType,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceEquationsOutputTypeGetObj",err,error,*999)

    CALL INTERFACE_EQUATIONS_OUTPUT_TYPE_GET(interfaceEquations%INTERFACE_EQUATIONS,outputType,err,error,*999)

    CALL EXITS("CMISSInterfaceEquationsOutputTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceEquationsOutputTypeGetObj",err,error)
    CALL EXITS("CMISSInterfaceEquationsOutputTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceEquationsOutputTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for an interface equations identified by a user number.
  SUBROUTINE CMISSInterfaceEquationsOutputTypeSetNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber, &
    & outputType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface, interface condition and interface equations to set the output type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface, interface condition and interface equations to set the output type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition and interface equations to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The interface equations output type to set. \see OPENCMISS_EquationsOutputTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: INTERFACE_EQUATIONS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceEquationsOutputTypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    NULLIFY(INTERFACE_EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_EQUATIONS_GET(INTERFACE_CONDITION,INTERFACE_EQUATIONS,err,error,*999)
          CALL INTERFACE_EQUATIONS_OUTPUT_TYPE_SET(INTERFACE_EQUATIONS,outputType,err,error,*999)
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceEquationsOutputTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceEquationsOutputTypeSetNumber",err,error)
    CALL EXITS("CMISSInterfaceEquationsOutputTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceEquationsOutputTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for an interface equations identified by an object.
  SUBROUTINE CMISSInterfaceEquationsOutputTypeSetObj(interfaceEquations,outputType,err)

    !Argument variables
    TYPE(CMISSInterfaceEquationsType), INTENT(IN) :: interfaceEquations !<The interface equations to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The interface equations output type to set. \see OPENCMISS_EquationsOutputTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceEquationsOutputTypeSetObj",err,error,*999)

    CALL INTERFACE_EQUATIONS_OUTPUT_TYPE_SET(interfaceEquations%INTERFACE_EQUATIONS,outputType,err,error,*999)

    CALL EXITS("CMISSInterfaceEquationsOutputTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceEquationsOutputTypeSetObj",err,error)
    CALL EXITS("CMISSInterfaceEquationsOutputTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceEquationsOutputTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the sparsity type for an interface equations identified by a user number.
  SUBROUTINE CMISSInterfaceEquationsSparsityGetNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber, &
    & sparsityType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface, interface condition and interface equations to get the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface, interface condition and interface equations to get the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition and interface equation to get the sparsity type for.
    INTEGER(INTG), INTENT(OUT) :: sparsityType !<On return, the interface equations sparsity type. \see OPENCMISS_EquationsSparsityType,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: INTERFACE_EQUATIONS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceEquationsSparsityGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    NULLIFY(INTERFACE_EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_EQUATIONS_GET(INTERFACE_CONDITION,INTERFACE_EQUATIONS,err,error,*999)
          CALL INTERFACE_EQUATIONS_SPARSITY_TYPE_GET(INTERFACE_EQUATIONS,sparsityType,err,error,*999)
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceEquationsSparsityGetNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceEquationsSparsityGetNumber",err,error)
    CALL EXITS("CMISSInterfaceEquationsSparsityGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceEquationsSparsityGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the sparsity type for an interface equations identified by an object.
  SUBROUTINE CMISSInterfaceEquationsSparsityGetObj(interfaceEquations,sparsityType,err)

    !Argument variables
    TYPE(CMISSInterfaceEquationsType), INTENT(IN) :: interfaceEquations !<The interface equations to get the sparsity type for.
    INTEGER(INTG), INTENT(OUT) :: sparsityType !<On return, the interface equations sparsity type. \see OPENCMISS_EquationsSparsityType,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceEquationsSparsityGetObj",err,error,*999)

    CALL INTERFACE_EQUATIONS_SPARSITY_TYPE_GET(interfaceEquations%INTERFACE_EQUATIONS,sparsityType,err,error,*999)

    CALL EXITS("CMISSInterfaceEquationsSparsityGetObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceEquationsSparsityGetObj",err,error)
    CALL EXITS("CMISSInterfaceEquationsSparsityGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceEquationsSparsityGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for an interface equations identified by a user number.
  SUBROUTINE CMISSInterfaceEquationsSparsitySetNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber, &
    & sparsityType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface, interface condition and interface equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface, interface condition and interface equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition and interface equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The interface equations sparsity type to set. \see OPENCMISS_EquationsSparsityTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: INTERFACE_EQUATIONS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceEquationsSparsitySetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    NULLIFY(INTERFACE_EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_EQUATIONS_GET(INTERFACE_CONDITION,INTERFACE_EQUATIONS,err,error,*999)
          CALL INTERFACE_EQUATIONS_SPARSITY_TYPE_SET(INTERFACE_EQUATIONS,sparsityType,err,error,*999)
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceEquationsSparsitySetNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceEquationsSparsitySetNumber",err,error)
    CALL EXITS("CMISSInterfaceEquationsSparsitySetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceEquationsSparsitySetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for an interface equations identified by an object.
  SUBROUTINE CMISSInterfaceEquationsSparsitySetObj(interfaceEquations,sparsityType,err)

    !Argument variables
    TYPE(CMISSInterfaceEquationsType), INTENT(IN) :: interfaceEquations !<The interface equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The interface equations sparsity type to set. \see OPENCMISS_EquationsSparsityTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceEquationsSparsitySetObj",err,error,*999)

    CALL INTERFACE_EQUATIONS_SPARSITY_TYPE_SET(interfaceEquations%INTERFACE_EQUATIONS,sparsityType,err,error,*999)

    CALL EXITS("CMISSInterfaceEquationsSparsitySetObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceEquationsSparsitySetObj",err,error)
    CALL EXITS("CMISSInterfaceEquationsSparsitySetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceEquationsSparsitySetObj

!!==================================================================================================================================
!!
!! MESH_ROUTINES
!!
!!==================================================================================================================================

  !>Finishes the creation of a domain decomposition for a decomposition identified by a user number.
  SUBROUTINE CMISSDecompositionCreateFinishNumber(regionUserNumber,meshUserNumber,decompositionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to finish the decomposition for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to finish the decomposition for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to finish.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDecompositionCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_CREATE_FINISH(DECOMPOSITION,err,error,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Decomposition Create')
#endif

    CALL EXITS("CMISSDecompositionCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSDecompositionCreateFinishNumber",err,error)
    CALL EXITS("CMISSDecompositionCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a domain decomposition for a decomposition identified by an object.
  SUBROUTINE CMISSDecompositionCreateFinishObj(decomposition,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !<The decomposition to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecompositionCreateFinishObj",err,error,*999)

    CALL DECOMPOSITION_CREATE_FINISH(decomposition%DECOMPOSITION,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('decomposition Create')
#endif

    CALL EXITS("CMISSDecompositionCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSDecompositionCreateFinishObj",err,error)
    CALL EXITS("CMISSDecompositionCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a domain decomposition for a decomposition identified by a user number.
  SUBROUTINE CMISSDecompositionCreateStartNumber(decompositionUserNumber,regionUserNumber,meshUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to create.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to create the decomposition for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to create the decomposition for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDecompositionCreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Decomposition Create')
#endif

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_CREATE_START(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDecompositionCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSDecompositionCreateStartNumber",err,error)
    CALL EXITS("CMISSDecompositionCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a domain decomposition for a decomposition identified by an object.
  SUBROUTINE CMISSDecompositionCreateStartObj(decompositionUserNumber,mesh,decomposition,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to create.
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !<The mesh to create the decomposition for.
    TYPE(CMISSDecompositionType), INTENT(INOUT) :: decomposition !<On return, the created decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecompositionCreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('decomposition Create')
#endif

    CALL DECOMPOSITION_CREATE_START(decompositionUserNumber,mesh%MESH,decomposition%DECOMPOSITION,err,error,*999)

    CALL EXITS("CMISSDecompositionCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSDecompositionCreateStartObj",err,error)
    CALL EXITS("CMISSDecompositionCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys a decomposition identified by a user number.
  SUBROUTINE CMISSDecompositionDestroyNumber(regionUserNumber,meshUserNumber,decompositionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to destroy the decomposition for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to destroy the decomposition for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDecompositionDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_DESTROY(DECOMPOSITION,err,error,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDecompositionDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSDecompositionDestroyNumber",err,error)
    CALL EXITS("CMISSDecompositionDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a decomposition identified by an object.
  SUBROUTINE CMISSDecompositionDestroyObj(decomposition,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !<The decomposition to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecompositionDestroyObj",err,error,*999)

    CALL DECOMPOSITION_DESTROY(decomposition%DECOMPOSITION,err,error,*999)

    CALL EXITS("CMISSDecompositionDestroyObj")
    RETURN
999 CALL ERRORS("CMISSDecompositionDestroyObj",err,error)
    CALL EXITS("CMISSDecompositionDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionDestroyObj

  !
  !================================================================================================================================
  !

  !>Calculates the element domains for a decomposition identified by a user number.
  SUBROUTINE CMISSDecompositionElementDomainCalculateNumber(regionUserNumber,meshUserNumber,decompositionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to calculate the element domains for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to calculate the element domains for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to calculate the element domains for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDecompositionElementDomainCalculateNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_ELEMENT_DOMAIN_CALCULATE(DECOMPOSITION,err,error,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDecompositionElementDomainCalculateNumber")
    RETURN
999 CALL ERRORS("CMISSDecompositionElementDomainCalculateNumber",err,error)
    CALL EXITS("CMISSDecompositionElementDomainCalculateNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionElementDomainCalculateNumber

  !
  !================================================================================================================================
  !

  !>Calculates the element domains for a decomposition identified by an object.
  SUBROUTINE CMISSDecompositionElementDomainCalculateObj(decomposition,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !<The decomposition to calcualte the element domains for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecompositionElementDomainCalculateObj",err,error,*999)

    CALL DECOMPOSITION_ELEMENT_DOMAIN_CALCULATE(decomposition%DECOMPOSITION,err,error,*999)

    CALL EXITS("CMISSDecompositionElementDomainCalculateObj")
    RETURN
999 CALL ERRORS("CMISSDecompositionElementDomainCalculateObj",err,error)
    CALL EXITS("CMISSDecompositionElementDomainCalculateObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionElementDomainCalculateObj

  !
  !================================================================================================================================
  !

  !>Returns the domain for a given element in a decomposition identified by a user number.
  SUBROUTINE CMISSDecompositionElementDomainGetNumber(regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & elementUserNumber,domain,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the element domain for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the element domain for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the element domain for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to get the domain for.
    INTEGER(INTG), INTENT(OUT) :: domain !<On return, the computational domain of the element.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDecompositionElementDomainGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_ELEMENT_DOMAIN_GET(DECOMPOSITION,elementUserNumber,domain,err,error,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDecompositionElementDomainGetNumber")
    RETURN
999 CALL ERRORS("CMISSDecompositionElementDomainGetNumber",err,error)
    CALL EXITS("CMISSDecompositionElementDomainGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionElementDomainGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the domain for a given element in a decomposition identified by an object.
  SUBROUTINE CMISSDecompositionElementDomainGetObj(decomposition,elementUserNumber,domain,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the domain for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to get the domain for.
    INTEGER(INTG), INTENT(OUT) :: domain !<On return, the computational domain of the element.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecompositionElementDomainGetObj",err,error,*999)

    CALL DECOMPOSITION_ELEMENT_DOMAIN_GET(decomposition%DECOMPOSITION,elementUserNumber,domain,err,error,*999)

    CALL EXITS("CMISSDecompositionElementDomainGetObj")
    RETURN
999 CALL ERRORS("CMISSDecompositionElementDomainGetObj",err,error)
    CALL EXITS("CMISSDecompositionElementDomainGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionElementDomainGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the domain for a given element in a decomposition identified by a user number.
  SUBROUTINE CMISSDecompositionElementDomainSetNumber(regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & elementUserNumber,domain,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the element domain for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the element domain for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to set the element domain for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to set the domain for.
    INTEGER(INTG), INTENT(IN) :: domain !<The computational domain of the element to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDecompositionElementDomainSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_ELEMENT_DOMAIN_SET(DECOMPOSITION,elementUserNumber,domain,err,error,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDecompositionElementDomainSetNumber")
    RETURN
999 CALL ERRORS("CMISSDecompositionElementDomainSetNumber",err,error)
    CALL EXITS("CMISSDecompositionElementDomainSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionElementDomainSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the domain for a given element in a decomposition identified by an object.
  SUBROUTINE CMISSDecompositionElementDomainSetObj(decomposition,elementUserNumber,domain,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !<The decomposition to set the element domain for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to set the domain for.
    INTEGER(INTG), INTENT(IN) :: domain !<The computational domain of the element to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecompositionElementDomainSetObj",err,error,*999)

    CALL DECOMPOSITION_ELEMENT_DOMAIN_SET(decomposition%DECOMPOSITION,elementUserNumber,domain,err,error,*999)

    CALL EXITS("CMISSDecompositionElementDomainSetObj")
    RETURN
999 CALL ERRORS("CMISSDecompositionElementDomainSetObj",err,error)
    CALL EXITS("CMISSDecompositionElementDomainSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionElementDomainSetObj

  !
  !================================================================================================================================
  !

  !>Returns the mesh component number used for the decomposition of a mesh for a decomposition identified by a user number.
  SUBROUTINE CMISSDecompositionMeshComponentGetNumber(regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & meshComponentNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the decomposition mesh component for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the decomposition mesh component for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the mesh component for.
    INTEGER(INTG), INTENT(OUT) :: meshComponentNumber !<On return, the mesh component number for the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDecompositionMeshComponentGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_MESH_COMPONENT_NUMBER_GET(DECOMPOSITION,meshComponentNumber,err,error,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDecompositionMeshComponentGetNumber")
    RETURN
999 CALL ERRORS("CMISSDecompositionMeshComponentGetNumber",err,error)
    CALL EXITS("CMISSDecompositionMeshComponentGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionMeshComponentGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the mesh component number used for the decomposition of a mesh for a decomposition identified by an object.
  SUBROUTINE CMISSDecompositionMeshComponentGetObj(decomposition,meshComponentNumber,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the mesh component for.
    INTEGER(INTG), INTENT(OUT) :: meshComponentNumber !<On return, the mesh component number for the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecompositionMeshComponentGetObj",err,error,*999)

    CALL DECOMPOSITION_MESH_COMPONENT_NUMBER_GET(decomposition%DECOMPOSITION,meshComponentNumber,err,error,*999)

    CALL EXITS("CMISSDecompositionMeshComponentGetObj")
    RETURN
999 CALL ERRORS("CMISSDecompositionMeshComponentGetObj",err,error)
    CALL EXITS("CMISSDecompositionMeshComponentGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionMeshComponentGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh component number used for the decomposition of a mesh for a decomposition identified by a user number.
  SUBROUTINE CMISSDecompositionMeshComponentSetNumber(regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & meshComponentNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the decomposition mesh component for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the decomposition mesh component for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to set the mesh component for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number for the decomposition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDecompositionMeshComponentSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_MESH_COMPONENT_NUMBER_SET(DECOMPOSITION,meshComponentNumber,err,error,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDecompositionMeshComponentSetNumber")
    RETURN
999 CALL ERRORS("CMISSDecompositionMeshComponentSetNumber",err,error)
    CALL EXITS("CMISSDecompositionMeshComponentSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionMeshComponentSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh component number used for the decomposition of a mesh for a decomposition identified by an object.
  SUBROUTINE CMISSDecompositionMeshComponentSetObj(decomposition,meshComponentNumber,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !<The decomposition to Set the mesh component for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number for the decomposition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecompositionMeshComponentSetObj",err,error,*999)

    CALL DECOMPOSITION_MESH_COMPONENT_NUMBER_SET(decomposition%DECOMPOSITION,meshComponentNumber,err,error,*999)

    CALL EXITS("CMISSDecompositionMeshComponentSetObj")
    RETURN
999 CALL ERRORS("CMISSDecompositionMeshComponentSetObj",err,error)
    CALL EXITS("CMISSDecompositionMeshComponentSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionMeshComponentSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of domains for a decomposition identified by a user number.
  SUBROUTINE CMISSDecompositionNumberOfDomainsGetNumber(regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & numberOfDomains,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the number of domains for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the number of domains for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the number of domains for.
    INTEGER(INTG), INTENT(OUT) :: numberOfDomains !<On return, the number of domains in the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDecompositionNumberOfDomainsGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_NUMBER_OF_DOMAINS_GET(DECOMPOSITION,numberOfDomains,err,error,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDecompositionNumberOfDomainsGetNumber")
    RETURN
999 CALL ERRORS("CMISSDecompositionNumberOfDomainsGetNumber",err,error)
    CALL EXITS("CMISSDecompositionNumberOfDomainsGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionNumberOfDomainsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of domains for a decomposition identified by an object.
  SUBROUTINE CMISSDecompositionNumberOfDomainsGetObj(decomposition,numberOfDomains,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the number of domains for.
    INTEGER(INTG), INTENT(OUT) :: numberOfDomains !<On return, the number of domains in the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecompositionNumberOfDomainsGetObj",err,error,*999)

    CALL DECOMPOSITION_NUMBER_OF_DOMAINS_GET(decomposition%DECOMPOSITION,numberOfDomains,err,error,*999)

    CALL EXITS("CMISSDecompositionNumberOfDomainsGetObj")
    RETURN
999 CALL ERRORS("CMISSDecompositionNumberOfDomainsGetObj",err,error)
    CALL EXITS("CMISSDecompositionNumberOfDomainsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionNumberOfDomainsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of domains for a decomposition identified by a user number.
  SUBROUTINE CMISSDecompositionNumberOfDomainsSetNumber(regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & numberOfDomains,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the number of domains for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the number of domains for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to set the number of domains for.
    INTEGER(INTG), INTENT(IN) :: numberOfDomains !<The number of domains in the decomposition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDecompositionNumberOfDomainsSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_NUMBER_OF_DOMAINS_SET(DECOMPOSITION,numberOfDomains,err,error,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDecompositionNumberOfDomainsSetNumber")
    RETURN
999 CALL ERRORS("CMISSDecompositionNumberOfDomainsSetNumber",err,error)
    CALL EXITS("CMISSDecompositionNumberOfDomainsSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionNumberOfDomainsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of domains for a decomposition identified by an object.
  SUBROUTINE CMISSDecompositionNumberOfDomainsSetObj(decomposition,numberOfDomains,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !<The decomposition to set the number of domains for.
    INTEGER(INTG), INTENT(IN) :: numberOfDomains !<The number of domains in the decomposition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecompositionNumberOfDomainsSetObj",err,error,*999)

    CALL DECOMPOSITION_NUMBER_OF_DOMAINS_SET(decomposition%DECOMPOSITION,numberOfDomains,err,error,*999)

    CALL EXITS("CMISSDecompositionNumberOfDomainsSetObj")
    RETURN
999 CALL ERRORS("CMISSDecompositionNumberOfDomainsSetObj",err,error)
    CALL EXITS("CMISSDecompositionNumberOfDomainsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionNumberOfDomainsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the type of a decomposition identified by a user number.
  SUBROUTINE CMISSDecompositionTypeGetNumber(regionUserNumber,meshUserNumber,decompositionUserNumber,decompositionType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the decomposition type for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the decomposition type for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the decomposition type for.
    INTEGER(INTG), INTENT(OUT) :: decompositionType !<On return, the type of the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDecompositionTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_TYPE_GET(DECOMPOSITION,decompositionType,err,error,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDecompositionTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSDecompositionTypeGetNumber",err,error)
    CALL EXITS("CMISSDecompositionTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the type of a decomposition identified by an object.
  SUBROUTINE CMISSDecompositionTypeGetObj(decomposition,decompositionType,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the type for.
    INTEGER(INTG), INTENT(OUT) :: decompositionType !<On return, the type of the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecompositionTypeGetObj",err,error,*999)

    CALL DECOMPOSITION_TYPE_GET(decomposition%DECOMPOSITION,decompositionType,err,error,*999)

    CALL EXITS("CMISSDecompositionTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSDecompositionTypeGetObj",err,error)
    CALL EXITS("CMISSDecompositionTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a decomposition identified by a user number.
  SUBROUTINE CMISSDecompositionTypeSetNumber(regionUserNumber,meshUserNumber,decompositionUserNumber,decompositionType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the decomposition type for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the decomposition type for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to set the decomposition type for.
    INTEGER(INTG), INTENT(IN) :: decompositionType !<The type of the decomposition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDecompositionTypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_TYPE_SET(DECOMPOSITION,decompositionType,err,error,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDecompositionTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSDecompositionTypeSetNumber",err,error)
    CALL EXITS("CMISSDecompositionTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a decomposition identified by an object.
  SUBROUTINE CMISSDecompositionTypeSetObj(decomposition,decompositionType,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !<The decomposition to Set the type for.
    INTEGER(INTG), INTENT(IN) :: decompositionType !<The type of the decomposition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecompositionTypeSetObj",err,error,*999)

    CALL DECOMPOSITION_TYPE_SET(decomposition%DECOMPOSITION,decompositionType,err,error,*999)

    CALL EXITS("CMISSDecompositionTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSDecompositionTypeSetObj",err,error)
    CALL EXITS("CMISSDecompositionTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets whether lines should be calculated
  SUBROUTINE CMISSDecompositionCalculateLinesSetNumber(regionUserNumber,meshUserNumber,&
                                                     & decompositionUserNumber,calculateLinesFlag,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to set the calculate lines flag for.
    LOGICAL, INTENT(IN) :: calculateLinesFlag !<Boolean to determine whether to set lines to be calculated.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDecompositionCalculateLinesSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_CALCULATE_LINES_SET(DECOMPOSITION,calculateLinesFlag,err,error,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDecompositionCalculateLinesSetNumber")
    RETURN
999 CALL ERRORS("CMISSDecompositionCalculateLinesSetNumber",err,error)
    CALL EXITS("CMISSDecompositionCalculateLinesSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionCalculateLinesSetNumber

  !
  !================================================================================================================================
  !

  !>Sets whether lines should be calculated
  SUBROUTINE CMISSDecompositionCalculateLinesSetObj(decomposition,calculateLinesFlag,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !<The decomposition to set the calculate lines flag for.
    LOGICAL, INTENT(IN) :: calculateLinesFlag !<Boolean to determine whether to set lines to be calculated.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecompositionCalculateLinesSetObj",err,error,*999)

    CALL DECOMPOSITION_CALCULATE_LINES_SET(decomposition%DECOMPOSITION,calculateLinesFlag,err,error,*999)

    CALL EXITS("CMISSDecompositionCalculateLinesSetObj")
    RETURN
999 CALL ERRORS("CMISSDecompositionCalculateLinesSetObj",err,error)
    CALL EXITS("CMISSDecompositionCalculateLinesSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionCalculateLinesSetObj

  !
  !================================================================================================================================
  !

  !>Sets whether faces should be calculated
  SUBROUTINE CMISSDecompositionCalculateFacesSetNumber(regionUserNumber,meshUserNumber, &
                                                     & decompositionUserNumber,calculateFacesFlag,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to set the decomposition type for.
    LOGICAL, INTENT(IN) :: calculateFacesFlag !<Boolean to determine whether to set faces to be calculated.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDecompositionCalculateFacesSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_CALCULATE_FACES_SET(DECOMPOSITION,calculateFacesFlag,err,error,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDecompositionCalculateFacesSetNumber")
    RETURN
999 CALL ERRORS("CMISSDecompositionCalculateFacesSetNumber",err,error)
    CALL EXITS("CMISSDecompositionCalculateFacesSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionCalculateFacesSetNumber

  !
  !================================================================================================================================
  !

  !>Sets whether faces should be calculated
  SUBROUTINE CMISSDecompositionCalculateFacesSetObj(decomposition,calculateFacesFlag,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !<The decomposition to set the calculate faces flag for.
    LOGICAL, INTENT(IN) :: calculateFacesFlag !<Boolean to determine whether to set faces to be calculated.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecompositionCalculateFacesSetObj",err,error,*999)

    CALL DECOMPOSITION_CALCULATE_FACES_SET(decomposition%DECOMPOSITION,calculateFacesFlag,err,error,*999)

    CALL EXITS("CMISSDecompositionCalculateFacesSetObj")
    RETURN
999 CALL ERRORS("CMISSDecompositionCalculateFacesSetObj",err,error)
    CALL EXITS("CMISSDecompositionCalculateFacesSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionCalculateFacesSetObj

  !
  !================================================================================================================================
  !

  !>Returns the domain for a given node in a decomposition identified by a user number.
  SUBROUTINE CMISSDecompositionNodeDomainGetNumber(regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & nodeUserNumber,meshComponentNumber,domain,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the node domain for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the node domain for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the node domain for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the domain for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The user number of the mesh component to get the domain for.
    INTEGER(INTG), INTENT(OUT) :: domain !<On return, the computational domain of the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDecompositionNodeDomainGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_NODE_DOMAIN_GET(DECOMPOSITION,nodeUserNumber,meshComponentNumber,domain,err,error,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDecompositionNodeDomainGetNumber")
    RETURN
999 CALL ERRORS("CMISSDecompositionNodeDomainGetNumber",err,error)
    CALL EXITS("CMISSDecompositionNodeDomainGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionNodeDomainGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the domain for a given node in a decomposition identified by an object. \todo Maybe swap Node and MeshComponent?
  SUBROUTINE CMISSDecompositionNodeDomainGetObj(decomposition,nodeUserNumber,meshComponentNumber,domain,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the domain for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the domain for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The user number of the mesh component to get the domain for.
    INTEGER(INTG), INTENT(OUT) :: domain !<On return, the computational domain of the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecompositionNodeDomainGetObj",err,error,*999)

    CALL DECOMPOSITION_NODE_DOMAIN_GET(decomposition%DECOMPOSITION,nodeUserNumber,meshComponentNumber,domain,err,error,*999)

    CALL EXITS("CMISSDecompositionNodeDomainGetObj")
    RETURN
999 CALL ERRORS("CMISSDecompositionNodeDomainGetObj",err,error)
    CALL EXITS("CMISSDecompositionNodeDomainGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecompositionNodeDomainGetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a mesh for a mesh identified by a user number.
  SUBROUTINE CMISSMeshCreateFinishNumber(regionUserNumber,meshUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMeshCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_CREATE_FINISH(MESH,err,error,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Mesh Create')
#endif

    CALL EXITS("CMISSMeshCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSMeshCreateFinishNumber",err,error)
    CALL EXITS("CMISSMeshCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a mesh for a mesh identified by an object.
  SUBROUTINE CMISSMeshCreateFinishObj(mesh,err)

    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !<The mesh to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshCreateFinishObj",err,error,*999)

    CALL MESH_CREATE_FINISH(mesh%MESH,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('mesh Create')
#endif

    CALL EXITS("CMISSMeshCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSMeshCreateFinishObj",err,error)
    CALL EXITS("CMISSMeshCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a mesh for a mesh identified by a user number.
  SUBROUTINE CMISSMeshCreateStartNumber(meshUserNumber,regionUserNumber,numberOfDimensions,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to start the creation of.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to start the creation of.
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions for the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMeshCreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Mesh Create')
#endif

    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_CREATE_START(meshUserNumber,REGION,numberOfDimensions,MESH,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSMeshCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSMeshCreateStartNumber",err,error)
    CALL EXITS("CMISSMeshCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a mesh for a mesh identified by an object.
  SUBROUTINE CMISSMeshCreateStartObj(meshUserNumber,region,numberOfDimensions,mesh,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to start the creation of.
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region containing the mesh to start the creation of.
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions for the mesh.
    TYPE(CMISSMeshType), INTENT(INOUT) :: mesh !<On return, the created mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshCreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('mesh Create')
#endif

    CALL MESH_CREATE_START(meshUserNumber,region%REGION,numberOfDimensions,mesh%MESH,err,error,*999)

    CALL EXITS("CMISSMeshCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSMeshCreateStartObj",err,error)
    CALL EXITS("CMISSMeshCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshCreateStartObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a mesh for a mesh identified by an object.
  SUBROUTINE CMISSMeshCreateStartInterfaceObj(meshUserNumber,iNTERFACE,numberOfDimensions,mesh,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to start the creation of.
    TYPE(CMISSInterfaceType), INTENT(IN) :: iNTERFACE !<The interface containing the mesh to start the creation of.
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions for the mesh.
    TYPE(CMISSMeshType), INTENT(OUT) :: mesh !<On return, the created mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshCreateStartInterfaceObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('mesh Create')
#endif

    CALL MESH_CREATE_START(meshUserNumber,Interface%iNTERFACE,numberOfDimensions,mesh%MESH,err,error,*999)

    CALL EXITS("CMISSMeshCreateStartInterfaceObj")
    RETURN
999 CALL ERRORS("CMISSMeshCreateStartInterfaceObj",err,error)
    CALL EXITS("CMISSMeshCreateStartInterfaceObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshCreateStartInterfaceObj

  !
  !================================================================================================================================
  !

  !>Destroys a mesh identified by a user number.
  SUBROUTINE CMISSMeshDestroyNumber(regionUserNumber,meshUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to destroy.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMeshDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_DESTROY(MESH,err,error,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSMeshDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSMeshDestroyNumber",err,error)
    CALL EXITS("CMISSMeshDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a mesh identified by an object.
  SUBROUTINE CMISSMeshDestroyObj(mesh,err)

    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !<The mesh to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshDestroyObj",err,error,*999)

    CALL MESH_DESTROY(mesh%MESH,err,error,*999)

    CALL EXITS("CMISSMeshDestroyObj")
    RETURN
999 CALL ERRORS("CMISSMeshDestroyObj",err,error)
    CALL EXITS("CMISSMeshDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the number of components in a mesh identified by a user number.
  SUBROUTINE CMISSMeshNumberOfComponentsGetNumber(regionUserNumber,meshUserNumber,numberOfComponents,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the number of components for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the number of components for.
    INTEGER(INTG), INTENT(OUT) :: numberOfComponents !<On return, the number of components in the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMeshNumberOfComponentsGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_NUMBER_OF_COMPONENTS_GET(MESH,numberOfComponents,err,error,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSMeshNumberOfComponentsGetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshNumberOfComponentsGetNumber",err,error)
    CALL EXITS("CMISSMeshNumberOfComponentsGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshNumberOfComponentsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of components in a mesh identified by an object.
  SUBROUTINE CMISSMeshNumberOfComponentsGetObj(mesh,numberOfComponents,err)

    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !<The mesh to get the number of components for.
    INTEGER(INTG), INTENT(OUT) :: numberOfComponents !<On return, the number of components in the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshNumberOfComponentsGetObj",err,error,*999)

    CALL MESH_NUMBER_OF_COMPONENTS_GET(mesh%MESH,numberOfComponents,err,error,*999)

    CALL EXITS("CMISSMeshNumberOfComponentsGetObj")
    RETURN
999 CALL ERRORS("CMISSMeshNumberOfComponentsGetObj",err,error)
    CALL EXITS("CMISSMeshNumberOfComponentsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshNumberOfComponentsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of components in a mesh identified by a user number.
  SUBROUTINE CMISSMeshNumberOfComponentsSetNumber(regionUserNumber,meshUserNumber,numberOfComponents,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: numberOfComponents !<The number of components in the mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMeshNumberOfComponentsSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_NUMBER_OF_COMPONENTS_SET(MESH,numberOfComponents,err,error,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSMeshNumberOfComponentsSetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshNumberOfComponentsSetNumber",err,error)
    CALL EXITS("CMISSMeshNumberOfComponentsSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshNumberOfComponentsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of components in a mesh identified by an object.
  SUBROUTINE CMISSMeshNumberOfComponentsSetObj(mesh,numberOfComponents,err)

    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !<The mesh to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: numberOfComponents !<The number of components in the mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshNumberOfComponentsSetObj",err,error,*999)

    CALL MESH_NUMBER_OF_COMPONENTS_SET(mesh%MESH,numberOfComponents,err,error,*999)

    CALL EXITS("CMISSMeshNumberOfComponentsSetObj")
    RETURN
999 CALL ERRORS("CMISSMeshNumberOfComponentsSetObj",err,error)
    CALL EXITS("CMISSMeshNumberOfComponentsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshNumberOfComponentsSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the surrounding elements calculate flag.
  SUBROUTINE CMISSMeshSurroundingElementsCalculateSetNumber(regionUserNumber,meshUserNumber,surroundingElementsCalculateFlag,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the surrounding elements calculate flag for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the surrounding elements calculate flag for.
    LOGICAL, INTENT(IN) :: surroundingElementsCalculateFlag !<Boolean flag to determine whether to calculate surrounding elements.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMeshSurroundingElementsCalculateSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_SURROUNDING_ELEMENTS_CALCULATE_SET(MESH,surroundingElementsCalculateFlag,err,error,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSMeshSurroundingElementsCalculateSetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshSurroundingElementsCalculateSetNumber",err,error)
    CALL EXITS("CMISSMeshSurroundingElementsCalculateSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshSurroundingElementsCalculateSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the surrounding elements calculate flag.
  SUBROUTINE CMISSMeshSurroundingElementsCalculateSetObj(mesh,surroundingElementsCalculateFlag,err)

    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !<The mesh to set the surrounding elements calculate flag for.
    LOGICAL, INTENT(IN) :: surroundingElementsCalculateFlag !<Boolean flag to determine whether to calculate surrounding elements.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshSurroundingElementsCalculateSetObj",err,error,*999)

    CALL MESH_SURROUNDING_ELEMENTS_CALCULATE_SET(mesh%MESH,surroundingElementsCalculateFlag,err,error,*999)

    CALL EXITS("CMISSMeshSurroundingElementsCalculateSetObj")
    RETURN
999 CALL ERRORS("CMISSMeshSurroundingElementsCalculateSetObj",err,error)
    CALL EXITS("CMISSMeshSurroundingElementsCalculateSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshSurroundingElementsCalculateSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of elements in a mesh identified by a user number.
  SUBROUTINE CMISSMeshNumberOfElementsGetNumber(regionUserNumber,meshUserNumber,numberOfElements,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the number of elements for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the number of elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfElements !<On return, the number of elements in the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMeshNumberOfElementsGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_NUMBER_OF_ELEMENTS_GET(MESH,numberOfElements,err,error,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSMeshNumberOfElementsGetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshNumberOfElementsGetNumber",err,error)
    CALL EXITS("CMISSMeshNumberOfElementsGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshNumberOfElementsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of elements in a mesh identified by an object.
  SUBROUTINE CMISSMeshNumberOfElementsGetObj(mesh,numberOfElements,err)

    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !<The mesh to get the number of elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfElements !<On return, the number of elements in the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshNumberOfElementsGetObj",err,error,*999)

    CALL MESH_NUMBER_OF_ELEMENTS_GET(mesh%MESH,numberOfElements,err,error,*999)

    CALL EXITS("CMISSMeshNumberOfElementsGetObj")
    RETURN
999 CALL ERRORS("CMISSMeshNumberOfElementsGetObj",err,error)
    CALL EXITS("CMISSMeshNumberOfElementsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshNumberOfElementsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of elements in a mesh identified by a user number.
  SUBROUTINE CMISSMeshNumberOfElementsSetNumber(regionUserNumber,meshUserNumber,numberOfElements,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: numberOfElements !<The number of elements in the mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMeshNumberOfElementsSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_NUMBER_OF_ELEMENTS_SET(MESH,numberOfElements,err,error,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSMeshNumberOfElementsSetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshNumberOfElementsSetNumber",err,error)
    CALL EXITS("CMISSMeshNumberOfElementsSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshNumberOfElementsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of elements in a mesh identified by an object.
  SUBROUTINE CMISSMeshNumberOfElementsSetObj(mesh,numberOfElements,err)

    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !<The mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: numberOfElements !<The number of elements in the mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshNumberOfElementsSetObj",err,error,*999)

    CALL MESH_NUMBER_OF_ELEMENTS_SET(mesh%MESH,numberOfElements,err,error,*999)

    CALL EXITS("CMISSMeshNumberOfElementsSetObj")
    RETURN
999 CALL ERRORS("CMISSMeshNumberOfElementsSetObj",err,error)
    CALL EXITS("CMISSMeshNumberOfElementsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshNumberOfElementsSetObj

  !
  !================================================================================================================================
  !

  !>Finishes creating elements for a mesh component of a mesh identified by a user number.
  SUBROUTINE CMISSMeshElementsCreateFinishNumber(regionUserNumber,meshUserNumber,meshComponentNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to finish creating the elements for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to finish creating the elements for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the mesh to finish creating the elements for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MESH_ELEMENTS_TYPE), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMeshElementsCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,MESH_ELEMENTS,err,error,*999)
        CALL MESH_TOPOLOGY_ELEMENTS_CREATE_FINISH(MESH_ELEMENTS,err,error,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSMeshElementsCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSMeshElementsCreateFinishNumber",err,error)
    CALL EXITS("CMISSMeshElementsCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElementsCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes creating elements for a mesh component of a mesh identified by an object.
  SUBROUTINE CMISSMeshElementsCreateFinishObj(meshElements,err)

    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshElementsCreateFinishObj",err,error,*999)

    CALL MESH_TOPOLOGY_ELEMENTS_CREATE_FINISH(meshElements%MESH_ELEMENTS,err,error,*999)

    CALL EXITS("CMISSMeshElementsCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSMeshElementsCreateFinishObj",err,error)
    CALL EXITS("CMISSMeshElementsCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElementsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts creating elements for a mesh component of a mesh identified by a user number.
  SUBROUTINE CMISSMeshElementsCreateStartNumber(regionUserNumber,meshUserNumber,meshComponentNumber,basisUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to start creating the elements for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to start creating the elements for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the mesh to start creating the elements for.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the default basis to use for the elements.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MESH_ELEMENTS_TYPE), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMeshElementsCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(BASIS)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL BASIS_USER_NUMBER_FIND(basisUserNumber,BASIS,err,error,*999)
        IF(ASSOCIATED(BASIS)) THEN
          CALL MESH_TOPOLOGY_ELEMENTS_CREATE_START(MESH,meshComponentNumber,BASIS,MESH_ELEMENTS,err,error,*999)
        ELSE
          LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(basisUserNumber,"*",err,error))// &
            & " does not exist."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSMeshElementsCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSMeshElementsCreateStartNumber",err,error)
    CALL EXITS("CMISSMeshElementsCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElementsCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts creating elements for a mesh component of a mesh identified by an object.
  SUBROUTINE CMISSMeshElementsCreateStartObj(mesh,meshComponentNumber,basis,meshElements,err)

    !Argument variables
    TYPE(CMISSMeshType), INTENT(INOUT) :: mesh !<The mesh to start the creation of elements for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the mesh to start creating the elements for.
    TYPE(CMISSBasisType), INTENT(IN) :: basis !<The default basis to use for the elements.
    TYPE(CMISSMeshElementsType), INTENT(INOUT) :: meshElements !<On return, the created mesh elements.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshElementsCreateStartObj",err,error,*999)

    CALL MESH_TOPOLOGY_ELEMENTS_CREATE_START(mesh%MESH,meshComponentNumber,basis%BASIS,meshElements%MESH_ELEMENTS,err,error,*999)

    CALL EXITS("CMISSMeshElementsCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSMeshElementsCreateStartObj",err,error)
    CALL EXITS("CMISSMeshElementsCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElementsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the mesh elements for a mesh component on a mesh identified by an
  !user number.
  SUBROUTINE CMISSMeshElementsGetNumber(regionUserNumber,meshUserNumber,meshComponentNumber,meshElements,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the elements for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the elements for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the elements for.
    TYPE(CMISSMeshElementsType), INTENT(INOUT) :: meshElements !<The mesh elements.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMeshElementsGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,meshElements%MESH_ELEMENTS,err,error,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSMeshElementsGetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshElementsGetNumber",err,error)
    CALL EXITS("CMISSMeshElementsGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElementsGetNumber


  !
  !================================================================================================================================
  !

  !>Returns the mesh elements for a mesh component on a mesh identified by an
  !user number.
  SUBROUTINE CMISSMeshElementsGetObj(mesh,meshComponentNumber,meshElements,err)

    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !<The mesh to get the elements for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the elements for.
    TYPE(CMISSMeshElementsType), INTENT(INOUT) :: meshElements !<The mesh elements.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    !Local variables

    CALL ENTERS("CMISSMeshElementsGetObj",err,error,*999)

    CALL MESH_TOPOLOGY_ELEMENTS_GET(mesh%MESH,meshComponentNumber,meshElements%MESH_ELEMENTS,err,error,*999)

    CALL EXITS("CMISSMeshElementsGetObj")
    RETURN
999 CALL ERRORS("CMISSMeshElementsGetObj",err,error)
    CALL EXITS("CMISSMeshElementsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElementsGetObj

  !
  !================================================================================================================================
  !

  !>Returns the basis for an element in a mesh identified by an user number. \todo should the global element number be a user number?
  SUBROUTINE CMISSMeshElementsBasisGetNumber(regionUserNumber,meshUserNumber,meshComponentNumber,globalElementNumber, &
    & basisUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the basis for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the basis for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the basis for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to get the basis for.
    INTEGER(INTG), INTENT(OUT) :: basisUserNumber !<On return, the user number of the basis for the element.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MESH_ELEMENTS_TYPE), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMeshElementsBasisGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    NULLIFY(BASIS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,MESH_ELEMENTS,err,error,*999)
        CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_BASIS_GET(globalElementNumber,MESH_ELEMENTS,BASIS,err,error,*999)
        IF(ASSOCIATED(BASIS)) THEN
          basisUserNumber = BASIS%USER_NUMBER
        ELSE
          LOCAL_ERROR="The basis is not associated for global element number "// &
            & TRIM(NUMBER_TO_VSTRING(globalElementNumber,"*",err,error))//" of mesh component number "// &
            & TRIM(NUMBER_TO_VSTRING(meshComponentNumber,"*",err,error))//" from the mesh with a user number of "//&
            & TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))//" in the region with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSMeshElementsBasisGetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshElementsBasisGetNumber",err,error)
    CALL EXITS("CMISSMeshElementsBasisGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElementsBasisGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the basis for an element in a mesh identified by an object. \todo should the global element number be a user number?
  SUBROUTINE CMISSMeshElementsBasisGetObj(meshElements,globalElementNumber,basis,err)

    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to get the basis for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to get the basis for.
    TYPE(CMISSBasisType), INTENT(INOUT) :: basis !<On return, the basis for the element.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshElementsBasisGetObj",err,error,*999)

    CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_BASIS_GET(globalElementNumber,meshElements%MESH_ELEMENTS,basis%BASIS,err,error,*999)

    CALL EXITS("CMISSMeshElementsBasisGetObj")
    RETURN
999 CALL ERRORS("CMISSMeshElementsBasisGetObj",err,error)
    CALL EXITS("CMISSMeshElementsBasisGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElementsBasisGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the basis for an element in a mesh identified by an user number. \todo should the global element number be a user number?
  SUBROUTINE CMISSMeshElementsBasisSetNumber(regionUserNumber,meshUserNumber,meshComponentNumber,globalElementNumber, &
    & basisUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the basis for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to set the basis for.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis for the element to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MESH_ELEMENTS_TYPE), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMeshElementsBasisSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    NULLIFY(BASIS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,MESH_ELEMENTS,err,error,*999)
        CALL BASIS_USER_NUMBER_FIND(basisUserNumber,BASIS,err,error,*999)
        IF(ASSOCIATED(BASIS)) THEN
          CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_BASIS_SET(globalElementNumber,MESH_ELEMENTS,BASIS,err,error,*999)
        ELSE
          LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(basisUserNumber,"*",err,error))// &
            & " does not exist."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSMeshElementsBasisSetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshElementsBasisSetNumber",err,error)
    CALL EXITS("CMISSMeshElementsBasisSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElementsBasisSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the basis for an element in a mesh identified by an object. \todo should the global element number be a user number?
  SUBROUTINE CMISSMeshElementsBasisSetObj(meshElements,globalElementNumber,basis,err)

    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to set the basis for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to set the basis for.
    TYPE(CMISSBasisType), INTENT(IN) :: basis !<The basis for the element to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshElementsBasisSetObj",err,error,*999)

    CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_BASIS_SET(globalElementNumber,meshElements%MESH_ELEMENTS,basis%BASIS,err,error,*999)

    CALL EXITS("CMISSMeshElementsBasisSetObj")
    RETURN
999 CALL ERRORS("CMISSMeshElementsBasisSetObj",err,error)
    CALL EXITS("CMISSMeshElementsBasisSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElementsBasisSetObj

  !
  !================================================================================================================================
  !

  !>Returns the element nodes for an element in a mesh identified by an user number. \todo should the global element number be a user number?
  SUBROUTINE CMISSMeshElementsNodesGetNumber(regionUserNumber,meshUserNumber,meshComponentNumber,globalElementNumber, &
    & elementUserNodes,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the element nodes for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the element nodes for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the element nodes for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to get the element nodes for.
    INTEGER(INTG), INTENT(OUT) :: elementUserNodes(:) !<elementUserNodes(i). On return, the user node number number of the i'th element node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MESH_ELEMENTS_TYPE), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMeshElementsNodesGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,MESH_ELEMENTS,err,error,*999)
        CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_NODES_GET(globalElementNumber,MESH_ELEMENTS,elementUserNodes,err,error,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSMeshElementsNodesGetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshElementsNodesGetNumber",err,error)
    CALL EXITS("CMISSMeshElementsNodesGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElementsNodesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the element nodes for an element in a mesh identified by an object. \todo should the global element number be a user number?
  SUBROUTINE CMISSMeshElementsNodesGetObj(meshElements,globalElementNumber,elementUserNodes,err)

    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to get the element nodes for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to get the element nodes for.
    INTEGER(INTG), INTENT(OUT) :: elementUserNodes(:) !<elementUserNodes(i). On return, the user node number number of the i'th element node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshElementsNodesGetObj",err,error,*999)

    CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_NODES_GET(globalElementNumber,meshElements%MESH_ELEMENTS,elementUserNodes,err,error,*999)

    CALL EXITS("CMISSMeshElementsNodesGetObj")
    RETURN
999 CALL ERRORS("CMISSMeshElementsNodesGetObj",err,error)
    CALL EXITS("CMISSMeshElementsNodesGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElementsNodesGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the element nodes for an element in a mesh identified by an user number. \todo should the global element number be a user number?
  SUBROUTINE CMISSMeshElementsNodesSetNumber(regionUserNumber,meshUserNumber,meshComponentNumber,globalElementNumber, &
    & elementUserNodes,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: elementUserNodes(:) !<elementUserNodes(i). The user node number number of the i'th element node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MESH_ELEMENTS_TYPE), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMeshElementsNodesSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,MESH_ELEMENTS,err,error,*999)
        CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_NODES_SET(globalElementNumber,MESH_ELEMENTS,elementUserNodes,err,error,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSMeshElementsNodesSetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshElementsNodesSetNumber",err,error)
    CALL EXITS("CMISSMeshElementsNodesSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElementsNodesSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the element nodes for an element in a mesh identified by an object. \todo should the global element number be a user number?
  SUBROUTINE CMISSMeshElementsNodesSetObj(meshElements,globalElementNumber,elementUserNodes,err)

    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: elementUserNodes(:) !<elementUserNodes(i). The user node number number of the i'th element node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshElementsNodesSetObj",err,error,*999)

    CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_NODES_SET(globalElementNumber,meshElements%MESH_ELEMENTS,elementUserNodes,err,error,*999)

    CALL EXITS("CMISSMeshElementsNodesSetObj")
    RETURN
999 CALL ERRORS("CMISSMeshElementsNodesSetObj",err,error)
    CALL EXITS("CMISSMeshElementsNodesSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElementsNodesSetObj


  !
  !================================================================================================================================
  !

  !>Sets/changes the element nodes for an element in a mesh identified by an user number. \todo should the global element number be a user number?
  SUBROUTINE CMISSMeshElementsUserNodeVersionSetNumber(regionUserNumber,meshUserNumber,globalElementNumber,versionNumber, &
    & derivativeNumber,userNodeNumber,meshComponentNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The version number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to set a version for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the element nodes for.

    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MESH_ELEMENTS_TYPE), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    INTEGER(INTG) :: localelementnode
    LOGICAL :: FOUND

    CALL ENTERS("CMISSMeshElementsUserNodeVersionSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,MESH_ELEMENTS,err,error,*999)
        FOUND=.FALSE.
        DO localelementnode=1,MESH_ELEMENTS%ELEMENTS(globalElementNumber)%BASIS%NUMBER_OF_NODES
          IF(MESH_ELEMENTS%ELEMENTS(globalElementNumber)%USER_ELEMENT_NODES(localelementnode)==userNodeNumber) THEN
            FOUND=.TRUE.
            EXIT
          ENDIF
        ENDDO !localelementnode
        IF(FOUND) THEN
          CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_NODE_VERSION_SET(globalElementNumber,MESH_ELEMENTS,versionNumber,derivativeNumber, &
            & userNodeNumber,err,error,*999)
        ELSE
          LOCAL_ERROR="User node number "//TRIM(NUMBER_TO_VSTRING(userNodeNumber,"*",err,error))// &
            & " does not exist in element number "//TRIM(NUMBER_TO_VSTRING(globalElementNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSMeshElementsUserNodeVersionSetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshElementsUserNodeVersionSetNumber",err,error)
    CALL EXITS("CMISSMeshElementsUserNodeVersionSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElementsUserNodeVersionSetNumber

  !
  !================================================================================================================================
   !

  !>Sets/changes the element nodes for an element in a mesh identified by an object. \todo should the global element number be a user number?
  SUBROUTINE CMISSMeshElementsUserNodeVersionSetObj(meshElements,globalElementNumber,versionNumber,derivativeNumber, &
    & userNodeNumber,err)

    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The version number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to set a version for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    INTEGER(INTG) :: localelementnode
    LOGICAL :: FOUND

    CALL ENTERS("CMISSMeshElementsUserNodeVersionSetObj",err,error,*999)

    FOUND=.FALSE.
    DO localelementnode=1,meshElements%MESH_ELEMENTS%ELEMENTS(globalElementNumber)%BASIS%NUMBER_OF_NODES
      IF(meshElements%MESH_ELEMENTS%ELEMENTS(globalElementNumber)%USER_ELEMENT_NODES(localelementnode)==userNodeNumber) THEN
        FOUND=.TRUE.
        EXIT
      ENDIF
    ENDDO !localelementnode
    IF(FOUND) THEN
      CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_NODE_VERSION_SET(globalElementNumber,meshElements%MESH_ELEMENTS,versionNumber, &
         & derivativeNumber,userNodeNumber,err,error,*999)
    ELSE
      LOCAL_ERROR="User node number "//TRIM(NUMBER_TO_VSTRING(userNodeNumber,"*",err,error))// &
        & " does not exist in element number "//TRIM(NUMBER_TO_VSTRING(globalElementNumber,"*",err,error))//"."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSMeshElementsUserNodeVersionSetObj")
    RETURN
999 CALL ERRORS("CMISSMeshElementsUserNodeVersionSetObj",err,error)
    CALL EXITS("CMISSMeshElementsUserNodeVersionSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElementsUserNodeVersionSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the element nodes for an element in a mesh identified by an user number. \todo should the global element number be a user number?
  SUBROUTINE CMISSMeshElementsLocalElementNodeVersionSetNumber(regionUserNumber,meshUserNumber,globalElementNumber,versionNumber, &
    & derivativeNumber,localElementNodeNumber,meshComponentNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The version number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: localElementNodeNumber !<The local element node to set a version for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the element nodes for.

    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MESH_ELEMENTS_TYPE), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMeshElementsLocalElementNodeVersionSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,MESH_ELEMENTS,err,error,*999)
        CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_NODE_VERSION_SET(globalElementNumber,MESH_ELEMENTS,versionNumber,derivativeNumber, &
          & localElementNodeNumber,err,error,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSMeshElementsLocalElementNodeVersionSetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshElementsLocalElementNodeVersionSetNumber",err,error)
    CALL EXITS("CMISSMeshElementsLocalElementNodeVersionSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElementsLocalElementNodeVersionSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the element nodes for an element in a mesh identified by an object. \todo should the global element number be a user number?
  SUBROUTINE CMISSMeshElementsLocalElementNodeVersionSetObj(meshElements,globalElementNumber,versionNumber,derivativeNumber, &
    & localElementNodeNumber,err)

    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The version number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: localElementNodeNumber !<The local element node to set a version for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshElementsLocalElementNodeVersionSetObj",err,error,*999)

    CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_NODE_VERSION_SET(globalElementNumber,meshElements%MESH_ELEMENTS,versionNumber, &
       & derivativeNumber,localElementNodeNumber,err,error,*999)

    CALL EXITS("CMISSMeshElementsLocalElementNodeVersionSetObj")
    RETURN
999 CALL ERRORS("CMISSMeshElementsLocalElementNodeVersionSetObj",err,error)
    CALL EXITS("CMISSMeshElementsLocalElementNodeVersionSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElementsLocalElementNodeVersionSetObj

  !
  !================================================================================================================================
  !

  !
  !================================================================================================================================
  !

  !>Returns the user number for an element in a mesh identified by an user number.
  SUBROUTINE CMISSMeshElementsUserNumberGetNumber(regionUserNumber,meshUserNumber,meshComponentNumber,elementGlobalNumber, &
    & elementUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the element user number for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the element user number for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the element user number for.
    INTEGER(INTG), INTENT(IN) :: elementGlobalNumber !<The global element number to get the element user number for.
    INTEGER(INTG), INTENT(OUT) :: elementUserNumber !<On return, the element user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MESH_ELEMENTS_TYPE), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMeshElementsUserNumberGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,MESH_ELEMENTS,err,error,*999)
        CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_USER_NUMBER_GET(elementGlobalNumber,elementUserNumber,MESH_ELEMENTS,err,error,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSMeshElementsUserNumberGetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshElementsUserNumberGetNumber",err,error)
    CALL EXITS("CMISSMeshElementsUserNumberGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElementsUserNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the element user number for an element in a mesh identified by an object.
  SUBROUTINE CMISSMeshElementsUserNumberGetObj(meshElements,elementGlobalNumber,elementUserNumber,err)

    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to get the element nodes for.
    INTEGER(INTG), INTENT(IN) :: elementGlobalNumber !<The global element number to get the element user number for.
    INTEGER(INTG), INTENT(OUT) :: elementUserNumber !<On return, the element user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshElementsUserNumberGetObj",err,error,*999)

    CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_USER_NUMBER_GET(elementGlobalNumber,elementUserNumber,meshElements%MESH_ELEMENTS, &
      & err,error,*999)

    CALL EXITS("CMISSMeshElementsUserNumberGetObj")
    RETURN
999 CALL ERRORS("CMISSMeshElementsUserNumberGetObj",err,error)
    CALL EXITS("CMISSMeshElementsUserNumberGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElementsUserNumberGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the user number for an element in a mesh identified by an user number.
  SUBROUTINE CMISSMeshElementsUserNumberSetNumber(regionUserNumber,meshUserNumber,meshComponentNumber,elementGlobalNumber, &
    & elementUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the element user number for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the element user number for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the element user number for.
    INTEGER(INTG), INTENT(IN) :: elementGlobalNumber !<The global element number to set the element user number for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The element user number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MESH_ELEMENTS_TYPE), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMeshElementsUserNumberSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,MESH_ELEMENTS,err,error,*999)
        CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_USER_NUMBER_SET(elementGlobalNumber,elementUserNumber,MESH_ELEMENTS,err,error,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSMeshElementsUserNumberSetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshElementsUserNumberSetNumber",err,error)
    CALL EXITS("CMISSMeshElementsUserNumberSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElementsUserNumberSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the element user number for an element in a mesh identified by an object.
  SUBROUTINE CMISSMeshElementsUserNumberSetObj(meshElements,elementGlobalNumber,elementUserNumber,err)

    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: elementGlobalNumber !<The global element number to set the element user number for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The element user number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshElementsUserNumberSetObj",err,error,*999)

    CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_USER_NUMBER_SET(elementGlobalNumber,elementUserNumber,meshElements%MESH_ELEMENTS, &
      & err,error,*999)

    CALL EXITS("CMISSMeshElementsUserNumberSetObj")
    RETURN
999 CALL ERRORS("CMISSMeshElementsUserNumberSetObj",err,error)
    CALL EXITS("CMISSMeshElementsUserNumberSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElementsUserNumberSetObj

  !
  !================================================================================================================================
  !


  !>Checks if the given node exists on the given mesh component.
  SUBROUTINE CMISSMeshNodeExistsNumber( regionUserNumber, meshUserNumber, meshComponentNumber, nodeUserNumber, nodeExists, err )

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to check the node for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh tocheck the node for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to check the node for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to check.
    LOGICAL, INTENT(OUT) :: nodeExists !<True if the node exists, false otherwise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    !Local variables
    TYPE(MESH_TYPE), POINTER :: Mesh
    TYPE(REGION_TYPE), POINTER :: Region
    INTEGER(INTG) :: GlobalNodeNumber
    TYPE(VARYING_STRING) :: LocalError

    CALL ENTERS("CMISSMeshNodeExistsNumber",err,error,*999)

    nodeExists = .FALSE.

    NULLIFY( Region )
    NULLIFY( Mesh )
    CALL REGION_USER_NUMBER_FIND( regionUserNumber, Region, err, error, *999 )
    IF( ASSOCIATED( REGION ) ) THEN
      CALL MESH_USER_NUMBER_FIND( meshUserNumber, Region, Mesh, err, error, *999 )
      IF( ASSOCIATED( MESH ) ) THEN
        CALL MESH_TOPOLOGY_NODE_CHECK_EXISTS(Mesh,meshComponentNumber,nodeUserNumber,nodeExists,GlobalNodeNumber,err,error,*999)
      ELSE
        LocalError="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LocalError,err,error,*999)
      ENDIF
    ELSE
      LocalError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LocalError,err,error,*999)
    ENDIF

    CALL EXITS("CMISSMeshNodeExistsNumber")
    RETURN
999 CALL ERRORS("CMISSMeshNodeExistsNumber",err,error)
    CALL EXITS("CMISSMeshNodeExistsNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshNodeExistsNumber

  !
  !================================================================================================================================
  !

  !>Checks if the given node exists on the given mesh component.
  SUBROUTINE CMISSMeshNodeExistsObj( mesh, meshComponentNumber, nodeUserNumber, nodeExists, err )

    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !<The mesh to check the node for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to check the node for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to check.
    LOGICAL, INTENT(OUT) :: nodeExists !<True if the node exists, false otherwise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    !Local variables
    INTEGER(INTG) :: GlobalNodeNumber

    nodeExists = .FALSE.

    CALL ENTERS("CMISSMeshNodeExistsObj",err,error,*999)

    CALL MESH_TOPOLOGY_NODE_CHECK_EXISTS(mesh%MESH,meshComponentNumber,nodeUserNumber,nodeExists,GlobalNodeNumber,err,error,*999)

    CALL EXITS("CMISSMeshNodeExistsObj")
    RETURN
999 CALL ERRORS("CMISSMeshNodeExistsObj",err,error)
    CALL EXITS("CMISSMeshNodeExistsObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshNodeExistsObj

  !
  !================================================================================================================================
  !

  !>Checks if the given element exists on the given mesh component.
  SUBROUTINE CMISSMeshElementExistsNumber( regionUserNumber, meshUserNumber, meshComponentNumber, &
    & elementUserNumber, elementExists, err )

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to check the element for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to check the element for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to check the element for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to check.
    LOGICAL, INTENT(OUT) :: elementExists !<True if the element exists, false otherwise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    !Local variables
    TYPE(MESH_TYPE), POINTER :: Mesh
    TYPE(REGION_TYPE), POINTER :: Region
    INTEGER(INTG) :: GlobalElementNumber
    TYPE(VARYING_STRING) :: LocalError

    CALL ENTERS("CMISSMeshElementExistsNumber",err,error,*999)

    elementExists = .FALSE.

    NULLIFY( Region )
    NULLIFY( Mesh )
    CALL REGION_USER_NUMBER_FIND( regionUserNumber, Region, err, error, *999 )
    IF( ASSOCIATED( REGION ) ) THEN
      CALL MESH_USER_NUMBER_FIND( meshUserNumber, Region, Mesh, err, error, *999 )
      IF( ASSOCIATED( MESH ) ) THEN
        CALL MESH_TOPOLOGY_ELEMENT_CHECK_EXISTS(Mesh,meshComponentNumber,elementUserNumber,elementExists, &
          & GlobalElementNumber,err,error,*999)
      ELSE
        LocalError="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LocalError,err,error,*999)
      ENDIF
    ELSE
      LocalError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LocalError,err,error,*999)
    ENDIF

    CALL EXITS("CMISSMeshElementExistsNumber")
    RETURN
999 CALL ERRORS("CMISSMeshElementExistsNumber",err,error)
    CALL EXITS("CMISSMeshElementExistsNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElementExistsNumber

  !
  !================================================================================================================================
  !

  !>Checks if the given element exists on the given mesh component.
  SUBROUTINE CMISSMeshElementExistsObj( mesh, meshComponentNumber, elementUserNumber, elementExists, err )

    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !<The mesh to check the node for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to check the element for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to check.
    LOGICAL, INTENT(OUT) :: elementExists !<True if the element exists, false otherwise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    !Local variables
    INTEGER(INTG) :: GlobalElementNumber

    CALL ENTERS("CMISSMeshElementExistsObj",err,error,*999)

    elementExists = .FALSE.

    CALL MESH_TOPOLOGY_ELEMENT_CHECK_EXISTS(mesh%MESH,meshComponentNumber,elementUserNumber,elementExists, GlobalElementNumber, &
      & err,error,*999)

    CALL EXITS("CMISSMeshElementExistsObj")
    RETURN
999 CALL ERRORS("CMISSMeshElementExistsObj",err,error)
    CALL EXITS("CMISSMeshElementExistsObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElementExistsObj

!!==================================================================================================================================
!!
!! NODE_ROUTINES
!!
!!==================================================================================================================================

  !>Finishes the process of creating nodes in a region for nodes identified by user number.
  SUBROUTINE CMISSNodesCreateFinishNumber(regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSNodesCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,err,error,*999)
      CALL NODES_CREATE_FINISH(NODES,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Nodes Create')
#endif

    CALL EXITS("CMISSNodesCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSNodesCreateFinishNumber",err,error)
    CALL EXITS("CMISSNodesCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodesCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a nodes in a region for nodes identified by an object.
  SUBROUTINE CMISSNodesCreateFinishObj(nodes,err)

    !Argument variables
    TYPE(CMISSNodesType), INTENT(IN) :: nodes !<The nodes to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSNodesCreateFinishObj",err,error,*999)

    CALL NODES_CREATE_FINISH(nodes%NODES,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('nodes Create')
#endif

    CALL EXITS("CMISSNodesCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSNodesCreateFinishObj",err,error)
    CALL EXITS("CMISSNodesCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodesCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of creating nodes in a region for nodes identified by user number.
  SUBROUTINE CMISSNodesCreateStartNumber(regionUserNumber,numberOfNodes,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to start the creation of.
    INTEGER(INTG), INTENT(IN) :: numberOfNodes !<The number of nodes to create.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSNodesCreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Nodes Create')
#endif

    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL NODES_CREATE_START(REGION,numberOfNodes,NODES,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSNodesCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSNodesCreateStartNumber",err,error)
    CALL EXITS("CMISSNodesCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodesCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a nodes in a region for nodes identified by an object.
  SUBROUTINE CMISSNodesCreateStartObj(region,numberOfNodes,nodes,err)

    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region to start the creation of nodes on.
    INTEGER(INTG), INTENT(IN) :: numberOfNodes !<The number of nodes to create.
    TYPE(CMISSNodesType), INTENT(IN) :: nodes !<On return, the created nodes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSNodesCreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('nodes Create')
#endif

    CALL NODES_CREATE_START(region%REGION,numberOfNodes,nodes%NODES,err,error,*999)

    CALL EXITS("CMISSNodesCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSNodesCreateStartObj",err,error)
    CALL EXITS("CMISSNodesCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodesCreateStartObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a nodes in a region for nodes identified by an object.
  SUBROUTINE CMISSNodesCreateStartInterfaceObj(iNTERFACE,numberOfNodes,nodes,err)

    !Argument variables
    TYPE(CMISSInterfaceType), INTENT(IN) :: iNTERFACE !<The interface to start the creation of nodes on.
    INTEGER(INTG), INTENT(IN) :: numberOfNodes !<The number of nodes to create.
    TYPE(CMISSNodesType), INTENT(IN) :: nodes !<On return, the created nodes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSNodesCreateStartInterfaceObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('nodes Create')
#endif

    CALL NODES_CREATE_START(Interface%iNTERFACE,numberOfNodes,nodes%NODES,err,error,*999)

    CALL EXITS("CMISSNodesCreateStartInterfaceObj")
    RETURN
999 CALL ERRORS("CMISSNodesCreateStartInterfaceObj",err,error)
    CALL EXITS("CMISSNodesCreateStartInterfaceObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodesCreateStartInterfaceObj

  !
  !================================================================================================================================
  !

  !>Destroys the nodes in a region for nodes identified by user number.
  SUBROUTINE CMISSNodesDestroyNumber(regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSNodesDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,err,error,*999)
      CALL NODES_DESTROY(NODES,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSNodesDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSNodesDestroyNumber",err,error)
    CALL EXITS("CMISSNodesDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodesDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the nodes in a region for nodes identified by an object.
  SUBROUTINE CMISSNodesDestroyObj(nodes,err)

    !Argument variables
    TYPE(CMISSNodesType), INTENT(IN) :: nodes !<The nodes to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSNodeDestroyObj",err,error,*999)

    CALL NODES_DESTROY(nodes%NODES,err,error,*999)

    CALL EXITS("CMISSNodesDestroyObj")
    RETURN
999 CALL ERRORS("CMISSNodesDestroyObj",err,error)
    CALL EXITS("CMISSNodesDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodesDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the number of nodes
  SUBROUTINE CMISSNodesNumberOfNodesGetNumber(regionUserNumber,numberOfNodes,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to get node count for.
    INTEGER(INTG), INTENT(OUT) :: numberOfNodes !<On return, the number of nodes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSNodesNumberOfNodesGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,err,error,*999)
      CALL NODES_NUMBER_OF_NODES_GET(NODES,numberOfNodes,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSNodesNumberOfNodesGetNumber")
    RETURN
999 CALL ERRORS("CMISSNodesNumberOfNodesGetNumber",err,error)
    CALL EXITS("CMISSNodesNumberOfNodesGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodesNumberOfNodesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of nodes
  SUBROUTINE CMISSNodesNumberOfNodesGetObj(nodes,numberOfNodes,err)

    !Argument variables
    TYPE(CMISSNodesType), INTENT(IN) :: nodes !<The nodes get node count for.
    INTEGER(INTG), INTENT(OUT) :: numberOfNodes !<The number of nodes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSNodesNumberOfNodesGetObj",err,error,*999)

    CALL NODES_NUMBER_OF_NODES_GET(nodes%NODES,numberOfNodes,err,error,*999)

    CALL EXITS("CMISSNodesNumberOfNodesGetObj")
    RETURN
999 CALL ERRORS("CMISSNodesNumberOfNodesGetObj",err,error)
    CALL EXITS("CMISSNodesNumberOfNodesGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodesNumberOfNodesGetObj

  !
  !================================================================================================================================
  !

  !>Returns the character label for a node in a set of nodes identified by user number. \todo should this be user number??
  SUBROUTINE CMISSNodesLabelGetCNumber(regionUserNumber,nodeGlobalNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to get the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the label for the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSNodesLabelGetCNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,err,error,*999)
      CALL NODES_LABEL_GET(NODES,nodeGlobalNumber,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSNodesLabelGetCNumber")
    RETURN
999 CALL ERRORS("CMISSNodesLabelGetCNumber",err,error)
    CALL EXITS("CMISSNodesLabelGetCNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodesLabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character label for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE CMISSNodesLabelGetCObj(nodes,nodeGlobalNumber,label,err)

    !Argument variables
    TYPE(CMISSNodesType), INTENT(IN) :: nodes !<The nodes to get the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the label for the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSNodesLabelGetCObj",err,error,*999)

    CALL NODES_LABEL_GET(nodes%NODES,nodeGlobalNumber,label,err,error,*999)

    CALL EXITS("CMISSNodesLabelGetCObj")
    RETURN
999 CALL ERRORS("CMISSNodesLabelGetCObj",err,error)
    CALL EXITS("CMISSNodesLabelGetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodesLabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a node in a set of nodes identified by user number. \todo should this be user number??
  SUBROUTINE CMISSNodesLabelGetVSNumber(regionUserNumber,nodeGlobalNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to get the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the label for the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSNodesLabelGetVSNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,err,error,*999)
      CALL NODES_LABEL_GET(NODES,nodeGlobalNumber,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSNodesLabelGetVSNumber")
    RETURN
999 CALL ERRORS("CMISSNodesLabelGetVSNumber",err,error)
    CALL EXITS("CMISSNodesLabelGetVSNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodesLabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE CMISSNodesLabelGetVSObj(nodes,nodeGlobalNumber,label,err)

    !Argument variables
    TYPE(CMISSNodesType), INTENT(IN) :: nodes !<The nodes to get the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the label for the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSNodesLabelGetVSObj",err,error,*999)

    CALL NODES_LABEL_GET(nodes%NODES,nodeGlobalNumber,label,err,error,*999)

    CALL EXITS("CMISSNodesLabelGetVSObj")
    RETURN
999 CALL ERRORS("CMISSNodesLabelGetVSObj",err,error)
    CALL EXITS("CMISSNodesLabelGetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodesLabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character label for a node in a set of nodes identified by user number. \todo should this be user number??
  SUBROUTINE CMISSNodesLabelSetCNumber(regionUserNumber,nodeGlobalNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to set the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The label for the node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSNodesLabelSetCNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,err,error,*999)
      CALL NODES_LABEL_SET(NODES,nodeGlobalNumber,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSNodesLabelSetCNumber")
    RETURN
999 CALL ERRORS("CMISSNodesLabelSetCNumber",err,error)
    CALL EXITS("CMISSNodesLabelSetCNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodesLabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character label for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE CMISSNodesLabelSetCObj(nodes,nodeGlobalNumber,label,err)

    !Argument variables
    TYPE(CMISSNodesType), INTENT(IN) :: nodes !<The nodes to set the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The label for the node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSNodesLabelSetCObj",err,error,*999)

    CALL NODES_LABEL_SET(nodes%NODES,nodeGlobalNumber,label,err,error,*999)

    CALL EXITS("CMISSNodesLabelSetCObj")
    RETURN
999 CALL ERRORS("CMISSNodesLabelSetCObj",err,error)
    CALL EXITS("CMISSNodesLabelSetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodesLabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a node in a set of nodes identified by user number. \todo should this be user number??
  SUBROUTINE CMISSNodesLabelSetVSNumber(regionUserNumber,nodeGlobalNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to set the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The label for the node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSNodesLabelSetVSNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,err,error,*999)
      CALL NODES_LABEL_SET(NODES,nodeGlobalNumber,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSNodesLabelSetVSNumber")
    RETURN
999 CALL ERRORS("CMISSNodesLabelSetVSNumber",err,error)
    CALL EXITS("CMISSNodesLabelSetVSNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodesLabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE CMISSNodesLabelSetVSObj(nodes,nodeGlobalNumber,label,err)

    !Argument variables
    TYPE(CMISSNodesType), INTENT(IN) :: nodes !<The nodes to set the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The label for the node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSNodesLabelSetVSObj",err,error,*999)

    CALL NODES_LABEL_SET(nodes%NODES,nodeGlobalNumber,label,err,error,*999)

    CALL EXITS("CMISSNodesLabelSetVSObj")
    RETURN
999 CALL ERRORS("CMISSNodesLabelSetVSObj",err,error)
    CALL EXITS("CMISSNodesLabelSetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodesLabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the user number for a node in a set of nodes identified by user number.
  SUBROUTINE CMISSNodesUserNumberGetNumber(regionUserNumber,nodeGlobalNumber,nodeUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to get the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to get the node user number for.
    INTEGER(INTG), INTENT(OUT) :: nodeUserNumber !<On return, the user number for the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSNodesUserNumberGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,err,error,*999)
      CALL NODES_USER_NUMBER_GET(NODES,nodeGlobalNumber,nodeUserNumber,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSNodesUserNumberGetNumber")
    RETURN
999 CALL ERRORS("CMISSNodesUserNumberGetNumber",err,error)
    CALL EXITS("CMISSNodesUserNumberGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodesUserNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the user number for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE CMISSNodesUserNumberGetObj(nodes,nodeGlobalNumber,nodeUserNumber,err)

    !Argument variables
    TYPE(CMISSNodesType), INTENT(IN) :: nodes !<The nodes to get the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to get the node user number for.
    INTEGER(INTG), INTENT(OUT) :: nodeUserNumber !<On return, the user number for the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSNodesUserNumberGetObj",err,error,*999)

    CALL NODES_USER_NUMBER_GET(nodes%NODES,nodeGlobalNumber,nodeUserNumber,err,error,*999)

    CALL EXITS("CMISSNodesUserNumberGetObj")
    RETURN
999 CALL ERRORS("CMISSNodesUserNumberGetObj",err,error)
    CALL EXITS("CMISSNodesUserNumberGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodesUserNumberGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the user number for a node in a set of nodes identified by user number.
  SUBROUTINE CMISSNodesUserNumberSetNumber(regionUserNumber,nodeGlobalNumber,nodeUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to set the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to set the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number for the node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSNodesUserNumberSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,err,error,*999)
      CALL NODES_USER_NUMBER_SET(NODES,nodeGlobalNumber,nodeUserNumber,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSNodesUserNumberSetNumber")
    RETURN
999 CALL ERRORS("CMISSNodesUserNumberSetNumber",err,error)
    CALL EXITS("CMISSNodesUserNumberSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodesUserNumberSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the user number for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE CMISSNodesUserNumberSetObj(nodes,nodeGlobalNumber,nodeUserNumber,err)

    !Argument variables
    TYPE(CMISSNodesType), INTENT(IN) :: nodes !<The nodes to set the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to set the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number for the node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSNodesUserNumberSetObj",err,error,*999)

    CALL NODES_USER_NUMBER_SET(nodes%NODES,nodeGlobalNumber,nodeUserNumber,err,error,*999)

    CALL EXITS("CMISSNodesUserNumberSetObj")
    RETURN
999 CALL ERRORS("CMISSNodesUserNumberSetObj",err,error)
    CALL EXITS("CMISSNodesUserNumberSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodesUserNumberSetObj

!!==================================================================================================================================
!!
!! PROBLEM_ROUTINES
!!
!!==================================================================================================================================

  !>Finishes the process of creating CellML equations for a problem identified by user number.
  SUBROUTINE CMISSProblemCellMLEquationsCreateFinishNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to finish the creation of CellML equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblemCellMLEquationsCreateFinishNumber",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CELLML_EQUATIONS_CREATE_FINISH(PROBLEM,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('CellML Equations Create')
#endif

    CALL EXITS("CMISSProblemCellMLEquationsCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSProblemCellMLEquationsCreateFinishNumber",err,error)
    CALL EXITS("CMISSProblemCellMLEquationsCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemCellMLEquationsCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of CellML equations for problem identified by an object.
  SUBROUTINE CMISSProblemCellMLEquationsCreateFinishObj(problem,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to finish creating the CellML equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemCellMLEquationsCreateFinishObj",err,error,*999)

    CALL PROBLEM_CELLML_EQUATIONS_CREATE_FINISH(problem%PROBLEM,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('CellML Equations Create')
#endif

    CALL EXITS("CMISSProblemCellMLEquationsCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSProblemCellMLEquationsCreateFinishObj",err,error)
    CALL EXITS("CMISSProblemCellMLEquationsCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemCellMLEquationsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of creating CellML equations for a problem identified by user number.
  SUBROUTINE CMISSProblemCellMLEquationsCreateStartNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to start the creation of CellML equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblemCellMLEquationsCreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Equations Create')
#endif

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CELLML_EQUATIONS_CREATE_START(PROBLEM,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSProblemCellMLEquationsCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSProblemCellMLEquationsCreateStartNumber",err,error)
    CALL EXITS("CMISSProblemCellMLEquationsCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemCellMLEquationsCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of CellML equations for problem identified by an object.
  SUBROUTINE CMISSProblemCellMLEquationsCreateStartObj(problem,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to start creating the CellML equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemCellMLEquationsCreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Equations Create')
#endif

    CALL PROBLEM_CELLML_EQUATIONS_CREATE_START(problem%PROBLEM,err,error,*999)

    CALL EXITS("CMISSProblemCellMLEquationsCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSProblemCellMLEquationsCreateStartObj",err,error)
    CALL EXITS("CMISSProblemCellMLEquationsCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemCellMLEquationsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML equations from a problem identified by an user number.
  SUBROUTINE CMISSProblemCellMLEquationsGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,CellMLEquations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(CMISSCellMLEquationsType), INTENT(INOUT) :: CellMLEquations !<On return, the specified CellML equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblemCellMLEquationsGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CELLML_EQUATIONS_GET(PROBLEM,controlLoopIdentifier,solverIndex,CellMLEquations%CELLML_EQUATIONS,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSProblemCellMLEquationsGetNumber0")
    RETURN
999 CALL ERRORS("CMISSProblemCellMLEquationsGetNumber0",err,error)
    CALL EXITS("CMISSProblemCellMLEquationsGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemCellMLEquationsGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the CellML equations from a problem identified by an user number.
  SUBROUTINE CMISSProblemCellMLEquationsGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,CellMLEquations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the CellML equations for.
    TYPE(CMISSCellMLEquationsType), INTENT(INOUT) :: CellMLEquations !<On return, the specified CellML equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
     TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblemCellMLEquationsGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CELLML_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,CellMLEquations%CELLML_EQUATIONS,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSProblemCellMLEquationsGetNumber1")
    RETURN
999 CALL ERRORS("CMISSProblemCellMLEquationsGetNumber1",err,error)
    CALL EXITS("CMISSProblemCellMLEquationsGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemCellMLEquationsGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the CellML equations from a problem identified by an object.
  SUBROUTINE CMISSProblemCellMLEquationsGetObj0(problem,controlLoopIdentifier,solverIndex,CellMLEquations,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the CellML equations for.
    TYPE(CMISSCellMLEquationsType), INTENT(INOUT) :: CellMLEquations !<On return, the specified CellML equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemCellMLEquationsGetObj0",err,error,*999)

    CALL PROBLEM_CELLML_EQUATIONS_GET(problem%PROBLEM,controlLoopIdentifier,solverIndex,CellMLEquations%CELLML_EQUATIONS, &
      & err,error,*999)

    CALL EXITS("CMISSProblemCellMLEquationsGetObj0")
    RETURN
999 CALL ERRORS("CMISSProblemCellMLEquationsGetObj0",err,error)
    CALL EXITS("CMISSProblemCellMLEquationsGetObj0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemCellMLEquationsGetObj0

  !
  !================================================================================================================================
  !

  !>Returns the CellML equations from a problem identified by an object.
  SUBROUTINE CMISSProblemCellMLEquationsGetObj1(problem,controlLoopIdentifiers,solverIndex,CellMLEquations,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the CellML equations for.
    TYPE(CMISSCellMLEquationsType), INTENT(INOUT) :: CellMLEquations !<On return, the specified CellML equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemCellMLEquationsGetObj1",err,error,*999)

    CALL PROBLEM_CELLML_EQUATIONS_GET(problem%PROBLEM,controlLoopIdentifiers,solverIndex,CellMLEquations%CELLML_EQUATIONS, &
      & err,error,*999)

    CALL EXITS("CMISSProblemCellMLEquationsGetObj1")
    RETURN
999 CALL ERRORS("CMISSProblemCellMLEquationsGetObj1",err,error)
    CALL EXITS("CMISSProblemCellMLEquationsGetObj1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemCellMLEquationsGetObj1

   !
  !================================================================================================================================
  !

  !>Finishes the process of a problem identified by user number.
  SUBROUTINE CMISSProblemCreateFinishNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblemCreateFinishNumber",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CREATE_FINISH(PROBLEM,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Problem Create')
#endif

    CALL EXITS("CMISSProblemCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSProblemCreateFinishNumber",err,error)
    CALL EXITS("CMISSProblemCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a problem identified by an object.
  SUBROUTINE CMISSProblemCreateFinishObj(problem,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemCreateFinishObj",err,error,*999)

    CALL PROBLEM_CREATE_FINISH(problem%PROBLEM,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('problem Create')
#endif

    CALL EXITS("CMISSProblemCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSProblemCreateFinishObj",err,error)
    CALL EXITS("CMISSProblemCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of a problem identified by user number.
  SUBROUTINE CMISSProblemCreateStartNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to start the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM

    CALL ENTERS("CMISSProblemCreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Problem Create')
#endif

    NULLIFY(PROBLEM)
    CALL PROBLEM_CREATE_START(problemUserNumber,PROBLEM,err,error,*999)

    CALL EXITS("CMISSProblemCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSProblemCreateStartNumber",err,error)
    CALL EXITS("CMISSProblemCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a problem identified by an object.
  SUBROUTINE CMISSProblemCreateStartObj(problemUserNumber,problem,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to start the creation of.
    TYPE(CMISSProblemType), INTENT(INOUT) :: problem !<On return, the created problem.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemCreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('problem Create')
#endif

    CALL PROBLEM_CREATE_START(problemUserNumber,problem%PROBLEM,err,error,*999)

    CALL EXITS("CMISSProblemCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSProblemCreateStartObj",err,error)
    CALL EXITS("CMISSProblemCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemCreateStartObj

  !
  !================================================================================================================================
  !

  !>Finishes the process of creating a control loop for a problem identified by user number.
  SUBROUTINE CMISSProblemControlLoopCreateFinishNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to finish creating the control loop for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblemControlLoopCreateFinishNumber",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_CREATE_FINISH(PROBLEM,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Problem Control Loop Create')
#endif

    CALL EXITS("CMISSProblemControlLoopCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSProblemControlLoopCreateFinishNumber",err,error)
    CALL EXITS("CMISSProblemControlLoopCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemControlLoopCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a control loop on a problem identified by an object.
  SUBROUTINE CMISSProblemControlLoopCreateFinishObj(problem,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to finish creating the control loop for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemControlLoopCreateFinishObj",err,error,*999)

    CALL PROBLEM_CONTROL_LOOP_CREATE_FINISH(problem%PROBLEM,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('problem Control Loop Create')
#endif

    CALL EXITS("CMISSProblemControlLoopCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSProblemControlLoopCreateFinishObj",err,error)
    CALL EXITS("CMISSProblemControlLoopCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemControlLoopCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of creating a control loop for a problem identified by user number.
  SUBROUTINE CMISSProblemControlLoopCreateStartNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to start creating the control loop for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblemControlLoopCreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Problem Control Loop Create')
#endif

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_CREATE_START(PROBLEM,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSProblemControlLoopCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSProblemControlLoopCreateStartNumber",err,error)
    CALL EXITS("CMISSProblemControlLoopCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemControlLoopCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a control loop on a problem identified by an object.
  SUBROUTINE CMISSProblemControlLoopCreateStartObj(problem,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to start creating the control loop for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemControlLoopCreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('problem Control Loop Create')
#endif

    CALL PROBLEM_CONTROL_LOOP_CREATE_START(problem%PROBLEM,err,error,*999)

    CALL EXITS("CMISSProblemControlLoopCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSProblemControlLoopCreateStartObj",err,error)
    CALL EXITS("CMISSProblemControlLoopCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemControlLoopCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys the control loops for a problem identified by user number.
  SUBROUTINE CMISSProblemControlLoopDestroyNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to destroy the control loops for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblemControlLoopDestroyNumber",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_DESTROY(PROBLEM,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSProblemControlLoopDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSProblemControlLoopDestroyNumber",err,error)
    CALL EXITS("CMISSProblemControlLoopDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemControlLoopDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the control loops on a problem identified by an object.
  SUBROUTINE CMISSProblemControlLoopDestroyObj(problem,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to destroy the control loops for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemControlLoopDestroyObj",err,error,*999)

    CALL PROBLEM_CONTROL_LOOP_DESTROY(problem%PROBLEM,err,error,*999)

    CALL EXITS("CMISSProblemControlLoopDestroyObj")
    RETURN
999 CALL ERRORS("CMISSProblemControlLoopDestroyObj",err,error)
    CALL EXITS("CMISSProblemControlLoopDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemControlLoopDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns a control loop from a problem identified by an user number.
  SUBROUTINE CMISSProblemControlLoopGetNumber0(problemUserNumber,controlLoopIdentifier,controlLoop,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified problem control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblemControlLoopGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,controlLoop%CONTROL_LOOP,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSProblemControlLoopGetNumber0")
    RETURN
999 CALL ERRORS("CMISSProblemControlLoopGetNumber0",err,error)
    CALL EXITS("CMISSProblemControlLoopGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemControlLoopGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns a control loop from a problem identified by an user number.
  SUBROUTINE CMISSProblemControlLoopGetNumber1(problemUserNumber,controlLoopIdentifiers,controlLoop,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the control loop for.
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified problem control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
     TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblemControlLoopGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,controlLoop%CONTROL_LOOP,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSProblemControlLoopGetNumber1")
    RETURN
999 CALL ERRORS("CMISSProblemControlLoopGetNumber1",err,error)
    CALL EXITS("CMISSProblemControlLoopGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemControlLoopGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns a control loop from a problem identified by an object.
  SUBROUTINE CMISSProblemControlLoopGetObj0(problem,controlLoopIdentifier,controlLoop,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified problem control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemControlLoopGetObj0",err,error,*999)

    CALL PROBLEM_CONTROL_LOOP_GET(problem%PROBLEM,controlLoopIdentifier,controlLoop%CONTROL_LOOP,err,error,*999)

    CALL EXITS("CMISSProblemControlLoopGetObj0")
    RETURN
999 CALL ERRORS("CMISSProblemControlLoopGetObj0",err,error)
    CALL EXITS("CMISSProblemControlLoopGetObj0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemControlLoopGetObj0

  !
  !================================================================================================================================
  !

  !>Returns a control loop from a problem identified by an object.
  SUBROUTINE CMISSProblemControlLoopGetObj1(problem,controlLoopIdentifiers,controlLoop,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the control loop for.
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified problem control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemControlLoopGetObj1",err,error,*999)

    CALL PROBLEM_CONTROL_LOOP_GET(problem%PROBLEM,controlLoopIdentifiers,controlLoop%CONTROL_LOOP,err,error,*999)

    CALL EXITS("CMISSProblemControlLoopGetObj1")
    RETURN
999 CALL ERRORS("CMISSProblemControlLoopGetObj1",err,error)
    CALL EXITS("CMISSProblemControlLoopGetObj1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemControlLoopGetObj1

  !
  !================================================================================================================================
  !

  !>Destroys a problem identified by an user number.
  SUBROUTINE CMISSProblemDestroyNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblemDestroyNumber",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_DESTROY(PROBLEM,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSProblemDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSProblemDestroyNumber",err,error)
    CALL EXITS("CMISSProblemDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a problem identified by an object.
  SUBROUTINE CMISSProblemDestroyObj(problem,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemDestroyObj",err,error,*999)

    CALL PROBLEM_DESTROY(problem%PROBLEM,err,error,*999)

    CALL EXITS("CMISSProblemDestroyObj")
    RETURN
999 CALL ERRORS("CMISSProblemDestroyObj",err,error)
    CALL EXITS("CMISSProblemDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemDestroyObj

  !
  !================================================================================================================================
  !

  !>Solves a problem identified by an user number.
  SUBROUTINE CMISSProblemSolveNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to solve.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblemSolveNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Problem Solve')
#endif

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVE(PROBLEM,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Problem Solve')
#endif

    CALL EXITS("CMISSProblemSolveNumber")
    RETURN
999 CALL ERRORS("CMISSProblemSolveNumber",err,error)
    CALL EXITS("CMISSProblemSolveNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemSolveNumber

  !
  !================================================================================================================================
  !

  !>Solves a problem identified by an object.
  SUBROUTINE CMISSProblemSolveObj(problem,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to solve.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemSolveObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('problem Solve')
#endif

    CALL PROBLEM_SOLVE(problem%PROBLEM,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('problem Solve')
#endif

    CALL EXITS("CMISSProblemSolveObj")
    RETURN
999 CALL ERRORS("CMISSProblemSolveObj",err,error)
    CALL EXITS("CMISSProblemSolveObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemSolveObj

  !
  !================================================================================================================================
  !

  !>Returns a solver from a problem identified by an user number.
  SUBROUTINE CMISSProblemSolverGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,solver,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver for.
    TYPE(CMISSSolverType), INTENT(INOUT) :: solver !<On return, the specified solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblemSolverGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,solver%SOLVER,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSProblemSolverGetNumber0")
    RETURN
999 CALL ERRORS("CMISSProblemSolverGetNumber0",err,error)
    CALL EXITS("CMISSProblemSolverGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemSolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns a solver from a problem identified by an user number.
  SUBROUTINE CMISSProblemSolverGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,solver,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver for.
    TYPE(CMISSSolverType), INTENT(INOUT) :: solver !<On return, the specified solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
     TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblemSolverGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,solver%SOLVER,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSProblemSolverGetNumber1")
    RETURN
999 CALL ERRORS("CMISSProblemSolverGetNumber1",err,error)
    CALL EXITS("CMISSProblemSolverGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemSolverGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns a solver from a problem identified by an object.
  SUBROUTINE CMISSProblemSolverGetObj0(problem,controlLoopIdentifier,solverIndex,solver,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to get the solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver for.
    TYPE(CMISSSolverType), INTENT(INOUT) :: solver !<On return, the specified solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemSolverGetObj0",err,error,*999)

    CALL PROBLEM_SOLVER_GET(problem%PROBLEM,controlLoopIdentifier,solverIndex,solver%SOLVER,err,error,*999)

    CALL EXITS("CMISSProblemSolverGetObj0")
    RETURN
999 CALL ERRORS("CMISSProblemSolverGetObj0",err,error)
    CALL EXITS("CMISSProblemSolverGetObj0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemSolverGetObj0

  !
  !================================================================================================================================
  !

  !>Returns a solver from a problem identified by an object.
  SUBROUTINE CMISSProblemSolverGetObj1(problem,controlLoopIdentifiers,solverIndex,solver,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to get the solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver for.
    TYPE(CMISSSolverType), INTENT(INOUT) :: solver !<On return, the specified solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemSolverGetObj1",err,error,*999)

    CALL PROBLEM_SOLVER_GET(problem%PROBLEM,controlLoopIdentifiers,solverIndex,solver%SOLVER,err,error,*999)

    CALL EXITS("CMISSProblemSolverGetObj1")
    RETURN
999 CALL ERRORS("CMISSProblemSolverGetObj1",err,error)
    CALL EXITS("CMISSProblemSolverGetObj1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemSolverGetObj1

  !
  !================================================================================================================================
  !

  !>Set boundary conditions for solver equations according to the analytic equations for solver equations identified by user numbers.
  SUBROUTINE CMISSProblemSolverEquationsBoundaryConditionsAnalyticNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to calculate the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to calculate the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to calculate the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblemSolverEquationsBoundaryConditionsAnalyticNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER_EQUATIONS,err,error,*999)
      IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
        CALL PROBLEM_SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_ANALYTIC(SOLVER_EQUATIONS,err,error,*999)
      ELSE
        LOCAL_ERROR="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A problem with a user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSProblemSolverEquationsBoundaryConditionsAnalyticNumber0")
    RETURN
999 CALL ERRORS("CMISSProblemSolverEquationsBoundaryConditionsAnalyticNumber0",err,error)
    CALL EXITS("CMISSProblemSolverEquationsBoundaryConditionsAnalyticNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemSolverEquationsBoundaryConditionsAnalyticNumber0

  !
  !================================================================================================================================
  !

  !>Set boundary conditions for solver equations according to the analytic equations for solver equations identified by user numbers.
  SUBROUTINE CMISSProblemSolverEquationsBoundaryConditionsAnalyticNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to calculate the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to calculate the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to calculate the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblemSolverEquationsBoundaryConditionsAnalyticNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
      IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
        CALL PROBLEM_SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_ANALYTIC(SOLVER_EQUATIONS,err,error,*999)
      ELSE
        LOCAL_ERROR="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A problem with a user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSProblemSolverEquationsBoundaryConditionsAnalyticNumber1")
    RETURN
999 CALL ERRORS("CMISSProblemSolverEquationsBoundaryConditionsAnalyticNumber1",err,error)
    CALL EXITS("CMISSProblemSolverEquationsBoundaryConditionsAnalyticNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemSolverEquationsBoundaryConditionsAnalyticNumber1

  !
  !================================================================================================================================
  !

  !>Set boundary conditions for solver equations according to the analytic equations.
  SUBROUTINE CMISSProblemSolverEquationsBoundaryConditionsAnalyticObj(solverEquations,err)

    !Argument variables
    TYPE(CMISSSolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL ENTERS("CMISSProblemSolverEquationsBoundaryConditionsAnalyticObj",err,error,*999)

    CALL PROBLEM_SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_ANALYTIC(solverEquations%SOLVER_EQUATIONS,err,error,*999)

    CALL EXITS("CMISSProblemSolverEquationsBoundaryConditionsAnalyticObj")
    RETURN
999 CALL ERRORS("CMISSProblemSolverEquationsBoundaryConditionsAnalyticObj",err,error)
    CALL EXITS("CMISSProblemSolverEquationsBoundaryConditionsAnalyticObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemSolverEquationsBoundaryConditionsAnalyticObj

  !
  !================================================================================================================================
  !

  !>Finishes the process of creating solver equations for a problem identified by user number.
  SUBROUTINE CMISSProblemSolverEquationsCreateFinishNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to finish the creation of solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblemSolverEquationsCreateFinishNumber",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_CREATE_FINISH(PROBLEM,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Solver Equations Create')
#endif

    CALL EXITS("CMISSProblemSolverEquationsCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSProblemSolverEquationsCreateFinishNumber",err,error)
    CALL EXITS("CMISSProblemSolverEquationsCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemSolverEquationsCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of solver equations for problem identified by an object.
  SUBROUTINE CMISSProblemSolverEquationsCreateFinishObj(problem,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to finish creating the solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemSolverEquationsCreateFinishObj",err,error,*999)

    CALL PROBLEM_SOLVER_EQUATIONS_CREATE_FINISH(problem%PROBLEM,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Solver Equations Create')
#endif

    CALL EXITS("CMISSProblemSolverEquationsCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSProblemSolverEquationsCreateFinishObj",err,error)
    CALL EXITS("CMISSProblemSolverEquationsCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemSolverEquationsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of creating solver equations for a problem identified by user number.
  SUBROUTINE CMISSProblemSolverEquationsCreateStartNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to start the creation of solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblemSolverEquationsCreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Solver Equations Create')
#endif

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_CREATE_START(PROBLEM,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSProblemSolverEquationsCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSProblemSolverEquationsCreateStartNumber",err,error)
    CALL EXITS("CMISSProblemSolverEquationsCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemSolverEquationsCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of solver equations for problem identified by an object.
  SUBROUTINE CMISSProblemSolverEquationsCreateStartObj(problem,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to start creating the solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemSolverEquationsCreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Solver Equations Create')
#endif

    CALL PROBLEM_SOLVER_EQUATIONS_CREATE_START(problem%PROBLEM,err,error,*999)

    CALL EXITS("CMISSProblemSolverEquationsCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSProblemSolverEquationsCreateStartObj",err,error)
    CALL EXITS("CMISSProblemSolverEquationsCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemSolverEquationsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys the solver equations for a problem identified by an user number.
  SUBROUTINE CMISSProblemSolverEquationsDestroyNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to destroy solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblemSolverEquationsDestroyNumber",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_DESTROY(PROBLEM,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSProblemSolverEquationsDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSProblemSolverEquationsDestroyNumber",err,error)
    CALL EXITS("CMISSProblemSolverEquationsDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemSolverEquationsDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the solver equations for problem identified by an object.
  SUBROUTINE CMISSProblemSolverEquationsDestroyObj(problem,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to destroy the solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemSolverEquationsDestroyObj",err,error,*999)

    CALL PROBLEM_SOLVER_EQUATIONS_DESTROY(problem%PROBLEM,err,error,*999)

    CALL EXITS("CMISSProblemSolverEquationsDestroyObj")
    RETURN
999 CALL ERRORS("CMISSProblemSolverEquationsDestroyObj",err,error)
    CALL EXITS("CMISSProblemSolverEquationsDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemSolverEquationsDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the solver equations from a problem identified by an user number.
  SUBROUTINE CMISSProblemSolverEquationsGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,solverEquations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(CMISSSolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblemSolverEquationsGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifier,solverIndex,solverEquations%SOLVER_EQUATIONS,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSProblemSolverEquationsGetNumber0")
    RETURN
999 CALL ERRORS("CMISSProblemSolverEquationsGetNumber0",err,error)
    CALL EXITS("CMISSProblemSolverEquationsGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemSolverEquationsGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the solver equations from a problem identified by an user number.
  SUBROUTINE CMISSProblemSolverEquationsGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,solverEquations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(CMISSSolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
     TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblemSolverEquationsGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,solverEquations%SOLVER_EQUATIONS,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSProblemSolverEquationsGetNumber1")
    RETURN
999 CALL ERRORS("CMISSProblemSolverEquationsGetNumber1",err,error)
    CALL EXITS("CMISSProblemSolverEquationsGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemSolverEquationsGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the solver equations from a problem identified by an object.
  SUBROUTINE CMISSProblemSolverEquationsGetObj0(problem,controlLoopIdentifier,solverIndex,solverEquations,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(CMISSSolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemSolverEquationsGetObj0",err,error,*999)

    CALL PROBLEM_SOLVER_EQUATIONS_GET(problem%PROBLEM,controlLoopIdentifier,solverIndex,solverEquations%SOLVER_EQUATIONS, &
      & err,error,*999)

    CALL EXITS("CMISSProblemSolverEquationsGetObj0")
    RETURN
999 CALL ERRORS("CMISSProblemSolverEquationsGetObj0",err,error)
    CALL EXITS("CMISSProblemSolverEquationsGetObj0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemSolverEquationsGetObj0

  !
  !================================================================================================================================
  !

  !>Returns the solver equations from a problem identified by an object.
  SUBROUTINE CMISSProblemSolverEquationsGetObj1(problem,controlLoopIdentifiers,solverIndex,solverEquations,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(CMISSSolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemSolverEquationsGetObj1",err,error,*999)

    CALL PROBLEM_SOLVER_EQUATIONS_GET(problem%PROBLEM,controlLoopIdentifiers,solverIndex,solverEquations%SOLVER_EQUATIONS, &
      & err,error,*999)

    CALL EXITS("CMISSProblemSolverEquationsGetObj1")
    RETURN
999 CALL ERRORS("CMISSProblemSolverEquationsGetObj1",err,error)
    CALL EXITS("CMISSProblemSolverEquationsGetObj1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemSolverEquationsGetObj1

  !
  !================================================================================================================================
  !

  !>Finishes the process of creating solvers for a problem identified by user number.
  SUBROUTINE CMISSProblemSolversCreateFinishNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to finish the creation of solvers for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblemSolversCreateFinishNumber",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVERS_CREATE_FINISH(PROBLEM,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Problem Solvers Create')
#endif

    CALL EXITS("CMISSProblemSolversCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSProblemSolversCreateFinishNumber",err,error)
    CALL EXITS("CMISSProblemSolversCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemSolversCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of solvers for problem identified by an object.
  SUBROUTINE CMISSProblemSolversCreateFinishObj(problem,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to finish creating the solvers for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemSolversCreateFinishObj",err,error,*999)

    CALL PROBLEM_SOLVERS_CREATE_FINISH(problem%PROBLEM,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('problem Solvers Create')
#endif

    CALL EXITS("CMISSProblemSolversCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSProblemSolversCreateFinishObj",err,error)
    CALL EXITS("CMISSProblemSolversCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemSolversCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of creating solvers for a problem identified by user number.
  SUBROUTINE CMISSProblemSolversCreateStartNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to start the creation of solvers for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblemSolversCreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Problem Solvers Create')
#endif

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVERS_CREATE_START(PROBLEM,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSProblemSolversCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSProblemSolversCreateStartNumber",err,error)
    CALL EXITS("CMISSProblemSolversCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemSolversCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of solvers for problem identified by an object.
  SUBROUTINE CMISSProblemSolversCreateStartObj(problem,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to start creating the solvers for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemSolversCreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('problem Solvers Create')
#endif

    CALL PROBLEM_SOLVERS_CREATE_START(problem%PROBLEM,err,error,*999)

    CALL EXITS("CMISSProblemSolversCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSProblemSolversCreateStartObj",err,error)
    CALL EXITS("CMISSProblemSolversCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemSolversCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys the solvers for a problem identified by an user number.
  SUBROUTINE CMISSProblemSolversDestroyNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to destroy the solvers for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblemSolversDestroyNumber",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVERS_DESTROY(PROBLEM,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSProblemSolversDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSProblemSolversDestroyNumber",err,error)
    CALL EXITS("CMISSProblemSolversDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemSolversDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the solvers for problem identified by an object.
  SUBROUTINE CMISSProblemSolversDestroyObj(problem,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to destroy the solvers for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemSolversDestroyObj",err,error,*999)

    CALL PROBLEM_SOLVERS_DESTROY(problem%PROBLEM,err,error,*999)

    CALL EXITS("CMISSProblemSolversDestroyObj")
    RETURN
999 CALL ERRORS("CMISSProblemSolversDestroyObj",err,error)
    CALL EXITS("CMISSProblemSolversDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemSolversDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the specification i.e., problem class, type and subtype for a problem identified by an user number.
  SUBROUTINE CMISSProblemSpecificationGetNumber(problemUserNumber,problemClass,problemType,problemSubtype,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the specification for.
    INTEGER(INTG), INTENT(OUT) :: problemClass !<On return, the problem class. \see OPENCMISS_ProblemClasses
    INTEGER(INTG), INTENT(OUT) :: problemType !<On return, the problem type. \see OPENCMISS_ProblemTypes
    INTEGER(INTG), INTENT(OUT) :: problemSubtype !<On return, the problem subtype. \see OPENCMISS_ProblemSubTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblemSpecificationGetNumber",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SPECIFICATION_GET(PROBLEM,problemClass,problemType,problemSubtype,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSProblemSpecificationGetNumber")
    RETURN
999 CALL ERRORS("CMISSProblemSpecificationGetNumber",err,error)
    CALL EXITS("CMISSProblemSpecificationGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemSpecificationGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the specification i.e., problem class, type and subtype for a problem identified by an object.
  SUBROUTINE CMISSProblemSpecificationGetObj(problem,problemClass,problemType,problemSubtype,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to get the specification for.
    INTEGER(INTG), INTENT(OUT) :: problemClass !<On return, the problem class. \see OPENCMISS_ProblemClasses
    INTEGER(INTG), INTENT(OUT) :: problemType !<On return, the problem type. \see OPENCMISS_ProblemTypes
    INTEGER(INTG), INTENT(OUT) :: problemSubtype !<On return, the problem subtype. \see OPENCMISS_ProblemSubTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemSpecificationGetObj",err,error,*999)

    CALL PROBLEM_SPECIFICATION_GET(problem%PROBLEM,problemClass,problemType,problemSubtype,err,error,*999)

    CALL EXITS("CMISSProblemSpecificationGetObj")
    RETURN
999 CALL ERRORS("CMISSProblemSpecificationGetObj",err,error)
    CALL EXITS("CMISSProblemSpecificationGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemSpecificationGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the specification i.e., problem class, type and subtype for a problem identified by an user number.
  SUBROUTINE CMISSProblemSpecificationSetNumber(problemUserNumber,problemClass,problemType,problemSubtype,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the specification for.
    INTEGER(INTG), INTENT(IN) :: problemClass !<The problem class to set. \see OPENCMISS_ProblemClasses
    INTEGER(INTG), INTENT(IN) :: problemType !<The problem type to set. \see OPENCMISS_ProblemTypes
    INTEGER(INTG), INTENT(IN) :: problemSubtype !<The problem subtype to set. \see OPENCMISS_ProblemSubTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblemSpecificationSetNumber",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SPECIFICATION_SET(PROBLEM,problemClass,problemType,problemSubtype,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSProblemSpecificationSetNumber")
    RETURN
999 CALL ERRORS("CMISSProblemSpecificationSetNumber",err,error)
    CALL EXITS("CMISSProblemSpecificationSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemSpecificationSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the specification i.e., problem class, type and subtype for a problem identified by an object.
  SUBROUTINE CMISSProblemSpecificationSetObj(problem,problemClass,problemType,problemSubtype,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to get the specification for.
    INTEGER(INTG), INTENT(IN) :: problemClass !<The problem class to set. \see OPENCMISS_ProblemClasses
    INTEGER(INTG), INTENT(IN) :: problemType !<The problem type to set. \see OPENCMISS_ProblemTypes
    INTEGER(INTG), INTENT(IN) :: problemSubtype !<The problem subtype to set. \see OPENCMISS_ProblemSubTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblemSpecificationSetObj",err,error,*999)

    CALL PROBLEM_SPECIFICATION_SET(problem%PROBLEM,problemClass,problemType,problemSubtype,err,error,*999)

    CALL EXITS("CMISSProblemSpecificationSetObj")
    RETURN
999 CALL ERRORS("CMISSProblemSpecificationSetObj",err,error)
    CALL EXITS("CMISSProblemSpecificationSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblemSpecificationSetObj

!!==================================================================================================================================
!!
!! REGION_ROUTINES
!!
!!==================================================================================================================================

  !>Returns the coordinate system for a region identified by an user number.
  SUBROUTINE CMISSRegionCoordinateSystemGetNumber(regionUserNumber,coordinateSystemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to get the coordinate system for.
    INTEGER(INTG), INTENT(OUT) :: coordinateSystemUserNumber !<On return, the coordinate system user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSRegionCoordinateSystemGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(COORDINATE_SYSTEM)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_COORDINATE_SYSTEM_GET(REGION,COORDINATE_SYSTEM,err,error,*999)
      IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
        coordinateSystemUserNumber = COORDINATE_SYSTEM%USER_NUMBER
      ELSE
        LOCAL_ERROR="The coordinate system is not associated for region number "// &
          & TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSRegionCoordinateSystemGetNumber")
    RETURN
999 CALL ERRORS("CMISSRegionCoordinateSystemGetNumber",err,error)
    CALL EXITS("CMISSRegionCoordinateSystemGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegionCoordinateSystemGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the coordinate system for a region identified by an object.
  SUBROUTINE CMISSRegionCoordinateSystemGetObj(region,coordinateSystem,err)

    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region to get the coordinate system for.
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<On return, the regions coordinate system.
   INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRegionCoordinateSystemGetObj",err,error,*999)

    CALL REGION_COORDINATE_SYSTEM_GET(region%REGION,coordinateSystem%COORDINATE_SYSTEM,err,error,*999)

    CALL EXITS("CMISSRegionCoordinateSystemGetObj")
    RETURN
999 CALL ERRORS("CMISSRegionCoordinateSystemGetObj",err,error)
    CALL EXITS("CMISSRegionCoordinateSystemGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegionCoordinateSystemGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the coordinate system for a region identified by an user number.
  SUBROUTINE CMISSRegionCoordinateSystemSetNumber(regionUserNumber,coordinateSystemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to set the coordinate system for.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSRegionCoordinateSystemSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(COORDINATE_SYSTEM)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
      IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
        CALL REGION_COORDINATE_SYSTEM_SET(REGION,COORDINATE_SYSTEM,err,error,*999)
      ELSE
        LOCAL_ERROR="A coordinate system with an user number of "// &
          & TRIM(NUMBER_TO_VSTRING(coordinateSystemUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSRegionCoordinateSystemSetNumber")
    RETURN
999 CALL ERRORS("CMISSRegionCoordinateSystemSetNumber",err,error)
    CALL EXITS("CMISSRegionCoordinateSystemSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegionCoordinateSystemSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the coordinate system for a region identified by an object.
  SUBROUTINE CMISSRegionCoordinateSystemSetObj(region,coordinateSystem,err)

    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region to set the coordinate system for.
    TYPE(CMISSCoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRegionCoordinateSystemSetObj",err,error,*999)

    CALL REGION_COORDINATE_SYSTEM_SET(region%REGION,coordinateSystem%COORDINATE_SYSTEM,err,error,*999)

    CALL EXITS("CMISSRegionCoordinateSystemSetObj")
    RETURN
999 CALL ERRORS("CMISSRegionCoordinateSystemSetObj",err,error)
    CALL EXITS("CMISSRegionCoordinateSystemSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegionCoordinateSystemSetObj

  !
  !================================================================================================================================
  !

  !>Finishes the process of creating a region identified by user number.
  SUBROUTINE CMISSRegionCreateFinishNumber(regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSRegionCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_CREATE_FINISH(REGION,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Region Create')
#endif

    CALL EXITS("CMISSRegionCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSRegionCreateFinishNumber",err,error)
    CALL EXITS("CMISSRegionCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegionCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a region identified by an object.
  SUBROUTINE CMISSRegionCreateFinishObj(region,err)

    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRegionCreateFinishObj",err,error,*999)

    CALL REGION_CREATE_FINISH(region%REGION,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('region Create')
#endif

    CALL EXITS("CMISSRegionCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSRegionCreateFinishObj",err,error)
    CALL EXITS("CMISSRegionCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegionCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process creating a region identified by user number.
  SUBROUTINE CMISSRegionCreateStartNumber(regionUserNumber,parentRegionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to start the creation of.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region to start the creation of the region in.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: PARENT_REGION,REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSRegionCreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Region Create')
#endif

    NULLIFY(PARENT_REGION)
    NULLIFY(REGION)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,PARENT_REGION,err,error,*999)
    IF(ASSOCIATED(PARENT_REGION)) THEN
      CALL REGION_CREATE_START(regionUserNumber,PARENT_REGION,REGION,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSRegionCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSRegionCreateStartNumber",err,error)
    CALL EXITS("CMISSRegionCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegionCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a region identified by an object.
  SUBROUTINE CMISSRegionCreateStartObj(regionUserNumber,parentRegion,region,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to start the creation of.
    TYPE(CMISSRegionType), INTENT(IN) :: parentRegion !<The parent region to  to start the creation of the region in.
    TYPE(CMISSRegionType), INTENT(INOUT) :: region !<On return, the created region.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRegionCreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('region Create')
#endif

    CALL REGION_CREATE_START(regionUserNumber,parentRegion%REGION,region%REGION,err,error,*999)

    CALL EXITS("CMISSRegionCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSRegionCreateStartObj",err,error)
    CALL EXITS("CMISSRegionCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegionCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys a region identified by an user number.
  SUBROUTINE CMISSRegionDestroyNumber(regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSRegionDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DESTROY(REGION,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSRegionDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSRegionDestroyNumber",err,error)
    CALL EXITS("CMISSRegionDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegionDestroyNumber

  !
  !================================================================================================================================
  !

  !>Returns the data points for a region identified by an object.
  SUBROUTINE CMISSRegionDataPointsGetObj(region,dataPoints,err)

    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region to get the data points for.
    TYPE(CMISSDataPointsType), INTENT(INOUT) :: dataPoints !<On return, the regions data points.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRegionDataPointsGetObj",err,error,*999)

    CALL REGION_DATA_POINTS_GET(region%REGION,dataPoints%DATA_POINTS,err,error,*999)

    CALL EXITS("CMISSRegionDataPointsGetObj")
    RETURN
999 CALL ERRORS("CMISSRegionDataPointsGetObj",err,error)
    CALL EXITS("CMISSRegionDataPointsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegionDataPointsGetObj

  !
  !================================================================================================================================
  !

  !>Destroys a region identified by an object.
  SUBROUTINE CMISSRegionDestroyObj(region,err)

    !Argument variables
    TYPE(CMISSRegionType), INTENT(INOUT) :: region !<The region to destroy
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRegionDestroyObj",err,error,*999)

    CALL REGION_DESTROY(region%REGION,err,error,*999)

    CALL EXITS("CMISSRegionDestroyObj")
    RETURN
999 CALL ERRORS("CMISSRegionDestroyObj",err,error)
    CALL EXITS("CMISSRegionDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegionDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a region identified by an user number.
  SUBROUTINE CMISSRegionLabelGetCNumber(regionUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSRegionLabelGetCNumber",err,error,*999)

    NULLIFY(REGION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_LABEL_GET(REGION,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSRegionLabelGetCNumber")
    RETURN
999 CALL ERRORS("CMISSRegionLabelGetCNumber",err,error)
    CALL EXITS("CMISSRegionLabelGetCNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegionLabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a region identified by an object.
  SUBROUTINE CMISSRegionLabelGetCObj(region,label,err)

    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRegionLabelGetCObj",err,error,*999)

    CALL REGION_LABEL_GET(region%REGION,label,err,error,*999)

    CALL EXITS("CMISSRegionLabelGetCObj")
    RETURN
999 CALL ERRORS("CMISSRegionLabelGetCObj",err,error)
    CALL EXITS("CMISSRegionLabelGetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegionLabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a region identified by an user number.
  SUBROUTINE CMISSRegionLabelGetVSNumber(regionUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSRegionLabelGetVSNumber",err,error,*999)

    NULLIFY(REGION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_LABEL_GET(REGION,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSRegionLabelGetVSNumber")
    RETURN
999 CALL ERRORS("CMISSRegionLabelGetVSNumber",err,error)
    CALL EXITS("CMISSRegionLabelGetVSNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegionLabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a region identified by an object.
  SUBROUTINE CMISSRegionLabelGetVSObj(region,label,err)

    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRegionLabelGetVSObj",err,error,*999)

    CALL REGION_LABEL_GET(region%REGION,label,err,error,*999)

    CALL EXITS("CMISSRegionLabelGetVSObj")
    RETURN
999 CALL ERRORS("CMISSRegionLabelGetVSObj",err,error)
    CALL EXITS("CMISSRegionLabelGetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegionLabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a region identified by an user number.
  SUBROUTINE CMISSRegionLabelSetCNumber(regionUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSRegionLabelSetCNumber",err,error,*999)

    NULLIFY(REGION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_LABEL_SET(REGION,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSRegionLabelSetCNumber")
    RETURN
999 CALL ERRORS("CMISSRegionLabelSetCNumber",err,error)
    CALL EXITS("CMISSRegionLabelSetCNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegionLabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a region identified by an object.
  SUBROUTINE CMISSRegionLabelSetCObj(region,label,err)

    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRegionLabelSetCObj",err,error,*999)

    CALL REGION_LABEL_SET(region%REGION,label,err,error,*999)

    CALL EXITS("CMISSRegionLabelSetCObj")
    RETURN
999 CALL ERRORS("CMISSRegionLabelSetCObj",err,error)
    CALL EXITS("CMISSRegionLabelSetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegionLabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a region identified by an user number.
  SUBROUTINE CMISSRegionLabelSetVSNumber(regionUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSRegionLabelSetVSNumber",err,error,*999)

    NULLIFY(REGION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_LABEL_SET(REGION,CHAR(label),err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSRegionLabelStVSNumber")
    RETURN
999 CALL ERRORS("CMISSRegionLabelSetVSNumber",err,error)
    CALL EXITS("CMISSRegionLabelSetVSNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegionLabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes string label for a region identified by an object.
  SUBROUTINE CMISSRegionLabelSetVSObj(region,label,err)

    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRegionLabelSetVSObj",err,error,*999)

    CALL REGION_LABEL_SET(region%REGION,CHAR(label),err,error,*999)

    CALL EXITS("CMISSRegionLabelSetVSObj")
    RETURN
999 CALL ERRORS("CMISSRegionLabelSetVSObj",err,error)
    CALL EXITS("CMISSRegionLabelSetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegionLabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the nodes for a region identified by an object.
  SUBROUTINE CMISSRegionNodesGetObj(region,nodes,err)

    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region to get the nodes for.
    TYPE(CMISSNodesType), INTENT(INOUT) :: nodes !<On return, the regions nodes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRegionNodesGetObj",err,error,*999)

    CALL REGION_NODES_GET(region%REGION,nodes%NODES,err,error,*999)

    CALL EXITS("CMISSRegionNodesGetObj")
    RETURN
999 CALL ERRORS("CMISSRegionNodesGetObj",err,error)
    CALL EXITS("CMISSRegionNodesGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegionNodesGetObj

!!==================================================================================================================================
!!
!! SOLVER_ROUTINES
!!
!!==================================================================================================================================

  !
  !================================================================================================================================
  !

  !>Adds a CellML environment to CellML equations identified by an user number.
  SUBROUTINE CMISSCellMLEquationsCellMLAddNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & regionUserNumber,CellMLUserNumber,CellMLIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem with the solver to add the CellML environment for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to add the CellML environment for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to add the CellML environment for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML environment to add.
    INTEGER(INTG), INTENT(OUT) :: CellMLIndex !<On return, the index of the added CellML environment.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: CELLML_EQUATIONS
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLEquationsCellMLAddNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(CELLML_EQUATIONS)
    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_CELLML_EQUATIONS_GET(SOLVER,CELLML_EQUATIONS,err,error,*999)
      CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
      IF(ASSOCIATED(REGION)) THEN
        CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
        IF(ASSOCIATED(CELLML)) THEN
          CALL CELLML_EQUATIONS_CELLML_ADD(CELLML_EQUATIONS,CELLML,CellMLIndex,err,error,*999)
        ELSE
          LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
            & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
          & " does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCellMLEquationsCellMLAddNumber0")
    RETURN
999 CALL ERRORS("CMISSCellMLEquationsCellMLAddNumber0",err,error)
    CALL EXITS("CMISSCellMLEquationsCellMLAddNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLEquationsCellMLAddNumber0

  !
  !================================================================================================================================
  !

  !>Adds a CellML environment to CellML equations identified by an user number.
  SUBROUTINE CMISSCellMLEquationsCellMLAddNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & regionUserNumber,CellMLUserNumber,CellMLIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to add the CellML environment for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to add the CellML environment for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to add the CellML environment for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML environment to add.
    INTEGER(INTG), INTENT(OUT) :: CellMLIndex !<On return, the index of the added CellML environment.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: CELLML_EQUATIONS
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLEquationsCellMLAddNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(CELLML_EQUATIONS)
    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_CELLML_EQUATIONS_GET(SOLVER,CELLML_EQUATIONS,err,error,*999)
      CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
      IF(ASSOCIATED(REGION)) THEN
        CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
        IF(ASSOCIATED(CELLML)) THEN
          CALL CELLML_EQUATIONS_CELLML_ADD(CELLML_EQUATIONS,CELLML,CellMLIndex,err,error,*999)
        ELSE
          LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
            & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
          & " does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSCellMLEquationsCellMLAddNumber1")
    RETURN
999 CALL ERRORS("CMISSCellMLEquationsCellMLAddNumber1",err,error)
    CALL EXITS("CMISSCellmlEquationsCellMLAddNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLEquationsCellMLAddNumber1

  !
  !================================================================================================================================
  !

  !>Adds a CellML environment to CellML equations identified by an object.
  SUBROUTINE CMISSCellMLEquationsCellMLAddObj(CellMLEquations,CellML,CellMLIndex,err)

    !Argument variables
    TYPE(CMISSCellMLEquationsType), INTENT(IN) :: CellMLEquations !<The CellML equations to add the CellML environment for.
    TYPE(CMISSCellMLType), INTENT(IN) :: CellML !<The CellML environment to add.
    INTEGER(INTG), INTENT(OUT) :: CellMLIndex !<On return, the index of the added CellML environment.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLEquationsCellMLAddObj",err,error,*999)

    CALL CELLML_EQUATIONS_CELLML_ADD(CellMLEquations%CELLML_EQUATIONS,CellML%CELLML,CellMLIndex,err,error,*999)

    CALL EXITS("CMISSCellMLEquationsCellMLAddObj")
    RETURN
999 CALL ERRORS("CMISSCellMLEquationsCellMLAddObj",err,error)
    CALL EXITS("CMISSCellMLEquationsCellMLAddObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLEquationsCellMLAddObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML equations for a solver identified by an user number.
  SUBROUTINE CMISSSolverCellMLEquationsGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,CellMLEquations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the CellML equations for.
    TYPE(CMISSCellMLEquationsType), INTENT(INOUT) :: CellMLEquations !<On return, the CellML equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverCellMLEquationsGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_CELLML_EQUATIONS_GET(SOLVER,CellMLEquations%CELLML_EQUATIONS,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverCellMLEquationsGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverCellMLEquationsGetNumber0",err,error)
    CALL EXITS("CMISSSolverCellMLEquationsGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverCellMLEquationsGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the CellML equations for a solver identified by an user number.
  SUBROUTINE CMISSSolverCellMLEquationsGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,CellMLEquations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the CellML equations for.
    TYPE(CMISSCellMLEquationsType), INTENT(INOUT) :: CellMLEquations !<On return, the CelllML equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverCellMLEquationsGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_CELLML_EQUATIONS_GET(SOLVER,CellMLEquations%CELLML_EQUATIONS,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverCellMLEquationsGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverCellMLEquationsGetNumber1",err,error)
    CALL EXITS("CMISSSolverCellMLEquationsGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverCellMLEquationsGetNumber1

  !================================================================================================================================
  !

  !>Returns the CellML equations for a solver identified by an object.
  SUBROUTINE CMISSSolverCellMLEquationsGetObj(solver,CellMLEquations,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to get the CellML equations for.
    TYPE(CMISSCellMLEquationsType), INTENT(INOUT) :: CellMLEquations !<On return, the CellML equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverCellMLEquationsGetObj",err,error,*999)

    CALL SOLVER_CELLML_EQUATIONS_GET(solver%SOLVER,CellMLEquations%CELLML_EQUATIONS,err,error,*999)

    CALL EXITS("CMISSSolverCellMLEquationsGetObj")
    RETURN
999 CALL ERRORS("CMISSSolverCellMLEquationsGetObj",err,error)
    CALL EXITS("CMISSSolverCellMLEquationsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverCellMLEquationsGetObj

  !
  !================================================================================================================================
  !

  !>Returns the solve type for an Euler differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolverDAEEulerSolverTypeGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,dAEEulerSolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the DAE Euler solver type for
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the DAE Euler solver type for
    INTEGER(INTG), INTENT(OUT) :: dAEEulerSolverType !<On return, the DAE Euler solver type. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverDAEEulerSolverTypeGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_EULER_SOLVER_TYPE_GET(SOLVER,dAEEulerSolverType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverDAEEulerSolverTypeGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverDAEEulerSolverTypeGetNumber0",err,error)
    CALL EXITS("CMISSSolverDAEEulerSolverTypeGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDAEEulerSolverTypeGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the solve type for an Euler differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolverDAEEulerSolverTypeGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,dAEEulerSolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the DAE Euler solver type for
    INTEGER(INTG), INTENT(OUT) :: dAEEulerSolverType !<On return, the DAE Euler solver type. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverDAEEulerSolverTypeGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_EULER_SOLVER_TYPE_GET(SOLVER,dAEEulerSolverType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverDAEEulerSolverTypeGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverDAEEulerSolverTypeGetNumber1",err,error)
    CALL EXITS("CMISSSolverDAEEulerSolverTypeGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDAEEulerSolverTypeGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the solve type for an Euler differential-algebraic equation solver identified by an object.
  SUBROUTINE CMISSSolverDAEEulerSolverTypeGetObj(solver,dAEEulerSolverType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to get the DAE Euler solver type for.
    INTEGER(INTG), INTENT(OUT) :: dAEEulerSolverType !<On return, the DAE Euler solver type. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverDAEEulerSolverTypeGetObj",err,error,*999)

    CALL SOLVER_DAE_EULER_SOLVER_TYPE_GET(solver%SOLVER,dAEEulerSolverType,err,error,*999)

    CALL EXITS("CMISSSolverDAEEulerSolverTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSSolverDAEEulerSolverTypeGetObj",err,error)
    CALL EXITS("CMISSSolverDAEEulerSolverTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDAEEulerSolverTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the solve type for an Euler differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolverDAEEulerSolverTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,dAEEulerSolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the DAE Euler solver type for
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE Euler solver type for
    INTEGER(INTG), INTENT(IN) :: dAEEulerSolverType !<The DAE Euler solver type to set. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverDAEEulerSolverTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_EULER_SOLVER_TYPE_SET(SOLVER,dAEEulerSolverType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverDAEEulerSolverTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverDAEEulerSolverTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolverDAEEulerSolverTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDAEEulerSolverTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the solve type for an Euler differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolverDAEEulerSolverTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,dAEEulerSolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE Euler solver type for
    INTEGER(INTG), INTENT(IN) :: dAEEulerSolverType !<The DAE Euler solver type to set. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverDAEEulerSolverTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_EULER_SOLVER_TYPE_SET(SOLVER,dAEEulerSolverType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverDAEEulerSolverTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverDAEEulerSolverTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolverDAEEulerSolverTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDAEEulerSolverTypeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the solve type for an Euler differential-algebraic equation solver identified by an object.
  SUBROUTINE CMISSSolverDAEEulerSolverTypeSetObj(solver,dAEEulerSolverType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to set the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: dAEEulerSolverType !<The DAE Euler solver type to set. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverDAEEulerSolverTypeSetObj",err,error,*999)

    CALL SOLVER_DAE_EULER_SOLVER_TYPE_SET(solver%SOLVER,dAEEulerSolverType,err,error,*999)

    CALL EXITS("CMISSSolverDAEEulerSolverTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverDAEEulerSolverTypeSetObj",err,error)
    CALL EXITS("CMISSSolverDAEEulerSolverTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDAEEulerSolverTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the solve type for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolverDAESolverTypeGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,dAESolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the DAE solver type for
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the DAE solver type for
    INTEGER(INTG), INTENT(OUT) :: dAESolverType !<On return, the DAE solver type. \see OPENCMISS_DAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverDAESolverTypeGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_SOLVER_TYPE_GET(SOLVER,dAESolverType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverDAESolverTypeGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverDAESolverTypeGetNumber0",err,error)
    CALL EXITS("CMISSSolverDAESolverTypeGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDAESolverTypeGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the solve type for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolverDAESolverTypeGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,dAESolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the DAE solver type for
    INTEGER(INTG), INTENT(OUT) :: dAESolverType !<On return, the DAE solver type. \see OPENCMISS_DAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverDAESolverTypeGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_SOLVER_TYPE_GET(SOLVER,dAESolverType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverDAESolverTypeGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverDAESolverTypeGetNumber1",err,error)
    CALL EXITS("CMISSSolverDAESolverTypeGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDAESolverTypeGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the solve type for an differential-algebraic equation solver identified by an object.
  SUBROUTINE CMISSSolverDAESolverTypeGetObj(solver,dAESolverType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to get the DAE solver type for.
    INTEGER(INTG), INTENT(OUT) :: dAESolverType !<On return, the DAE solver type. \see OPENCMISS_DAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverDAESolverTypeGetObj",err,error,*999)

    CALL SOLVER_DAE_SOLVER_TYPE_GET(solver%SOLVER,dAESolverType,err,error,*999)

    CALL EXITS("CMISSSolverDAESolverTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSSolverDAESolverTypeGetObj",err,error)
    CALL EXITS("CMISSSolverDAESolverTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDAESolverTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the solve type for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolverDAESolverTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,dAESolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the DAE solver type for
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE solver type for
    INTEGER(INTG), INTENT(IN) :: dAESolverType !<The DAE solver type to set. \see OPENCMISS_DAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverDAESolverTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_SOLVER_TYPE_SET(SOLVER,dAESolverType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverDAESolverTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverDAESolverTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolverDAESolverTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDAESolverTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the solve type for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolverDAESolverTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,dAESolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE solver type for
    INTEGER(INTG), INTENT(IN) :: dAESolverType !<The DAE solver type to set. \see OPENCMISS_DAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverDAESolverTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_SOLVER_TYPE_SET(SOLVER,dAESolverType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverDAESolverTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverDAESolverTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolverDAESolverTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDAESolverTypeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the solve type for an differential-algebraic equation solver identified by an object.
  SUBROUTINE CMISSSolverDAESolverTypeSetObj(solver,dAESolverType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to set the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: dAESolverType !<The DAE solver type to set. \see OPENCMISS_DAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverDAESolverTypeSetObj",err,error,*999)

    CALL SOLVER_DAE_SOLVER_TYPE_SET(solver%SOLVER,dAESolverType,err,error,*999)

    CALL EXITS("CMISSSolverDAESolverTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverDAESolverTypeSetObj",err,error)
    CALL EXITS("CMISSSolverDAESolverTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDAESolverTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the times for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolverDAETimesSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,startTime,endTime,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE times for.
    REAL(DP), INTENT(IN) :: startTime !<The start time for the differential-algebraic solver.
    REAL(DP), INTENT(IN) :: endTime !<The end time for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverDAETimesSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_TIMES_SET(SOLVER,startTime,endTime,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverDAETimesSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverDAETimesSetNumber0",err,error)
    CALL EXITS("CMISSSolverDAETimesSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDAETimesSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the times for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolverDAETimesSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,startTime,endTime,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE times for.
    REAL(DP), INTENT(IN) :: startTime !<The start time for the differential-algebraic solver.
    REAL(DP), INTENT(IN) :: endTime !<The end time for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverDAETimesSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_TIMES_SET(SOLVER,startTime,endTime,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverDAETimesSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverDAETimesSetNumber1",err,error)
    CALL EXITS("CMISSSolverDAETimesSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDAETimesSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the times for an differential-algebraic equation solver identified by an object.
  SUBROUTINE CMISSSolverDAETimesSetObj(solver,startTime,endTime,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to set the DAE times for.
    REAL(DP), INTENT(IN) :: startTime !<The start time for the differential-algebraic solver.
    REAL(DP), INTENT(IN) :: endTime !<The end time for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverDAETimesSetObj",err,error,*999)

    CALL SOLVER_DAE_TIMES_SET(solver%SOLVER,startTime,endTime,err,error,*999)

    CALL EXITS("CMISSSolverDAETimesSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverDAETimesSetObj",err,error)
    CALL EXITS("CMISSSolverDAETimesSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDAETimesSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the (initial) time step for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolverDAETimeStepSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,timeStep,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE times for.
    REAL(DP), INTENT(IN) :: timeStep !<The (initial) time step for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverDAETimeStepSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_TIME_STEP_SET(SOLVER,timeStep,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverDAETimeStepSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverDAETimeStepSetNumber0",err,error)
    CALL EXITS("CMISSSolverDAETimeStepSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDAETimeStepSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the (initial) time step for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolverDAETimeStepSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,timeStep,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE times for.
    REAL(DP), INTENT(IN) :: timeStep !<The (initial) time step for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverDAETimeStepSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_TIME_STEP_SET(SOLVER,timeStep,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverDAETimeStepSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverDAETimeStepSetNumber1",err,error)
    CALL EXITS("CMISSSolverDAETimeStepSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDAETimeStepSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the (initial) time step for an differential-algebraic equation solver identified by an object.
  SUBROUTINE CMISSSolverDAETimeStepSetObj(solver,timeStep,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to set the DAE times for.
    REAL(DP), INTENT(IN) :: timeStep !<The (initial) time step for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverDAETimeStepSetObj",err,error,*999)

    CALL SOLVER_DAE_TIME_STEP_SET(solver%SOLVER,timeStep,err,error,*999)

    CALL EXITS("CMISSSolverDAETimeStepSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverDAETimeStepSetObj",err,error)
    CALL EXITS("CMISSSolverDAETimeStepSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDAETimeStepSetObj

  !
  !================================================================================================================================
  !

  !>Returns the degree of the polynomial used to interpolate time for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicDegreeGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,degree,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic degree for.
    INTEGER(INTG), INTENT(OUT) :: degree !<On return, the dynamic degree. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverDynamicDegreeGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_DEGREE_GET(SOLVER,degree,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicDegreeGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicDegreeGetNumber0",err,error)
    CALL EXITS("CMISSSolverDynamicDegreeGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDynamicDegreeGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the degree of the polynomial used to interpolate time for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicDegreeGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,degree,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic degree for
    INTEGER(INTG), INTENT(OUT) :: degree !<On return, the dynamic degree. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverDynamicDegreeGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_DEGREE_GET(SOLVER,degree,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicDegreeGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicDegreeGetNumber1",err,error)
    CALL EXITS("CMISSSolverDynamicDegreeGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDynamicDegreeGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the degree of the polynomial used to interpolate time for a dynamic solver identified by an object.
  SUBROUTINE CMISSSolverDynamicDegreeGetObj(solver,degree,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to get the dynamic degree for.
    INTEGER(INTG), INTENT(OUT) :: degree !<On return, the dynamic degree. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverDynamicDegreeGetObj",err,error,*999)

    CALL SOLVER_DYNAMIC_DEGREE_GET(solver%SOLVER,degree,err,error,*999)

    CALL EXITS("CMISSSolverDynamicDegreeGetObj")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicDegreeGetObj",err,error)
    CALL EXITS("CMISSSolverDynamicDegreeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDynamicDegreeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the degree of the polynomial used to interpolate time for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicDegreeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,degree,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: degree !<The dynamic degree to set. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverDynamicDegreeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_DEGREE_SET(SOLVER,degree,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicDegreeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicDegreeSetNumber0",err,error)
    CALL EXITS("CMISSSolverDynamicDegreeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDynamicDegreeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the degree of the polynomial used to interpolate time for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicDegreeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,degree,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the dynamic degree for
    INTEGER(INTG), INTENT(IN) :: degree !<The dynamic degree to set. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverDynamicDegreeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_DEGREE_SET(SOLVER,degree,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicDegreeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicDegreeSetNumber1",err,error)
    CALL EXITS("CMISSSolverDynamicDegreeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDynamicDegreeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the degree of the polynomial used to interpolate time for a dynamic solver identified by an object.
  SUBROUTINE CMISSSolverDynamicDegreeSetObj(solver,degree,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: degree !<The dynamic degree to set. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverDynamicDegreeSetObj",err,error,*999)

    CALL SOLVER_DYNAMIC_DEGREE_SET(solver%SOLVER,degree,err,error,*999)

    CALL EXITS("CMISSSolverDynamicDegreeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicDegreeSetObj",err,error)
    CALL EXITS("CMISSSolverDynamicDegreeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDynamicDegreeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the linearity type for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicLinearityTypeGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,linearityType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On return, the dynamic linearity type. \see OPENCMISS_DynamicLinearityTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverDynamicLinearityTypeGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_LINEARITY_TYPE_GET(SOLVER,linearityType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicLinearityTypeGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicLinearityTypeGetNumber0",err,error)
    CALL EXITS("CMISSSolverDynamicLinearityTypeGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDynamicLinearityTypeGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the linearity type for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicLinearityTypeGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,linearityType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On return, the dynamic linearity type. \see OPENCMISS_DynamicLinearityTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverDynamicLinearityTypeGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_LINEARITY_TYPE_GET(SOLVER,linearityType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicLinearityTypeGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicLinearityTypeGetNumber1",err,error)
    CALL EXITS("CMISSSolverDynamicLinearityTypeGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDynamicLinearityTypeGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the linearity type for a dynamic solver identified by an object.
  SUBROUTINE CMISSSolverDynamicLinearityTypeGetObj(solver,linearityType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On return, the dynamic linearity type. \see OPENCMISS_DynamicLinearityTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverDynamicLinearityTypeGetObj",err,error,*999)

    CALL SOLVER_DYNAMIC_LINEARITY_TYPE_GET(solver%SOLVER,linearityType,err,error,*999)

    CALL EXITS("CMISSSolverDynamicLinearityTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicLinearityTypeGetObj",err,error)
    CALL EXITS("CMISSSolverDynamicLinearityTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDynamicLinearityTypeGetObj

  !
  !================================================================================================================================
  !

  !>Returns the nonlinear solver associated with a nonlinear dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicNonlinearSolverGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & nonlinearSolverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(OUT) :: nonlinearSolverIndex !<On return, the solver index of the nonlinear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverDynamicNonlinearSolverGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(NONLINEAR_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_NONLINEAR_SOLVER_GET(SOLVER,NONLINEAR_SOLVER,err,error,*999)
      !todo: get the solver index from nonlinear solver
      nonlinearSolverIndex=NONLINEAR_SOLVER%GLOBAL_NUMBER
      CALL FLAG_ERROR("Not implemented.",err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicNonlinearSolverGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicNonlinearSolverGetNumber0",err,error)
    CALL EXITS("CMISSSolverDynamicNonlinearSolverGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDynamicNonlinearSolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the nonlinear solver associated with a nonlinear dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicNonlinearSolverGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & nonlinearSolverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(OUT) :: nonlinearSolverIndex !<On return, the dynamic nonlinear solver index.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverDynamicNonlinearSolverGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(NONLINEAR_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_NONLINEAR_SOLVER_GET(SOLVER,NONLINEAR_SOLVER,err,error,*999)
      !todo: get the solver index from nonlinear solver
      nonlinearSolverIndex=NONLINEAR_SOLVER%GLOBAL_NUMBER
      CALL FLAG_ERROR("Not implemented.",err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicNonlinearSolverGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicNonlinearSolverGetNumber1",err,error)
    CALL EXITS("CMISSSolverDynamicNonlinearSolverGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDynamicNonlinearSolverGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the nonlinear solver associated with a nonlinear dynamic solver identified by an object.
  SUBROUTINE CMISSSolverDynamicNonlinearSolverGetObj(solver,nonlinearSolver,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to get the dynamic nonlinear solver for.
    TYPE(CMISSSolverType), INTENT(INOUT) :: nonlinearSolver  !<On return, the dynamic nonlinear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverDynamicNonlinearSolverGetObj",err,error,*999)

    CALL SOLVER_DYNAMIC_NONLINEAR_SOLVER_GET(solver%SOLVER,nonlinearSolver%SOLVER,err,error,*999)

    CALL EXITS("CMISSSolverDynamicNonlinearSolverGetObj")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicNonlinearSolverGetObj",err,error)
    CALL EXITS("CMISSSolverDynamicNonlinearSolverGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDynamicNonlinearSolverGetObj

  !
  !================================================================================================================================
  !

  !>Returns the linear solver associated with a linear dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicLinearSolverGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,linearSolverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(OUT) :: linearSolverIndex !<On return, the solver index of the linear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,LINEAR_SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverDynamicLinearSolverGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(LINEAR_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_LINEAR_SOLVER_GET(SOLVER,LINEAR_SOLVER,err,error,*999)
      !todo: get the solver index from linear solver
      linearSolverIndex=LINEAR_SOLVER%GLOBAL_NUMBER
      CALL FLAG_ERROR("Not implemented.",err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicLinearSolverGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicLinearSolverGetNumber0",err,error)
    CALL EXITS("CMISSSolverDynamicLinearSolverGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDynamicLinearSolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the linear solver associated with a linear dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicLinearSolverGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,linearSolverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(OUT) :: linearSolverIndex !<On return, the dynamic linear solver index.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,LINEAR_SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverDynamicLinearSolverGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(LINEAR_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_LINEAR_SOLVER_GET(SOLVER,LINEAR_SOLVER,err,error,*999)
      !todo: get the solver index from linear solver
      linearSolverIndex=LINEAR_SOLVER%GLOBAL_NUMBER
      CALL FLAG_ERROR("Not implemented.",err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicLinearSolverGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicLinearSolverGetNumber1",err,error)
    CALL EXITS("CMISSSolverDynamicLinearSolverGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDynamicLinearSolverGetNumber1

  !================================================================================================================================
  !

  !>Returns the linear solver associated with a linear dynamic solver identified by an object.
  SUBROUTINE CMISSSolverDynamicLinearSolverGetObj(solver,linearSolver,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to get the dynamic linear solver for.
    TYPE(CMISSSolverType), INTENT(INOUT) :: linearSolver !<On return, the dynamic linear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverDynamicLinearSolverGetObj",err,error,*999)

    CALL SOLVER_DYNAMIC_LINEAR_SOLVER_GET(solver%SOLVER,linearSolver%SOLVER,err,error,*999)

    CALL EXITS("CMISSSolverDynamicLinearSolverGetObj")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicLinearSolverGetObj",err,error)
    CALL EXITS("CMISSSolverDynamicLinearSolverGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDynamicLinearSolverGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the scheme for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicSchemeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,scheme,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: scheme !<The dynamic scheme to set. \see OPENCMISS_DynamicSchemeTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverDynamicSchemeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_SCHEME_SET(SOLVER,scheme,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicSchemeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicSchemeSetNumber0",err,error)
    CALL EXITS("CMISSSolverDynamicSchemeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDynamicSchemeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the scheme for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicSchemeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,scheme,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: scheme !<The dynamic scheme to set. \see OPENCMISS_DynamicSchemeTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverDynamicSchemeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_SCHEME_SET(SOLVER,scheme,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicSchemeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicSchemeSetNumber1",err,error)
    CALL EXITS("CMISSSolverDynamicSchemeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDynamicSchemeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the scheme for a dynamic solver identified by an object.
  SUBROUTINE CMISSSolverDynamicSchemeSetObj(solver,scheme,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: scheme !<The dynamic scheme to set. \see OPENCMISS_DynamicSchemeTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverDynamicSchemeSetObj",err,error,*999)

    CALL SOLVER_DYNAMIC_SCHEME_SET(solver%SOLVER,scheme,err,error,*999)

    CALL EXITS("CMISSSolverDynamicSchemeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicSchemeSetObj",err,error)
    CALL EXITS("CMISSSolverDynamicSchemeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDynamicSchemeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the theta value for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicThetaSetNumber00(problemUserNumber,controlLoopIdentifier,solverIndex,theta,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the theta for.
    REAL(DP), INTENT(IN) :: theta !<The dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverDynamicThetaSetNumber00",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,theta,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicThetaSetNumber00")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicThetaSetNumber00",err,error)
    CALL EXITS("CMISSSolverDynamicThetaSetNumber00")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDynamicThetaSetNumber00

  !
  !================================================================================================================================
  !

  !>Sets/changes the theta value for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicThetaSetNumber01(problemUserNumber,controlLoopIdentifier,solverIndex,thetas,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the theta for.
    REAL(DP), INTENT(IN) :: thetas(:) !<thetas(i). The i'th dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverDynamicThetaSetNumber01",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,thetas,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicThetaSetNumber01")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicThetaSetNumber01",err,error)
    CALL EXITS("CMISSSolverDynamicThetaSetNumber01")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDynamicThetaSetNumber01

  !
  !================================================================================================================================
  !

  !>Sets/changes the theta for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicThetaSetNumber10(problemUserNumber,controlLoopIdentifiers,solverIndex,theta,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the theta for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the theta for.
    REAL(DP), INTENT(IN) :: theta !<The dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverDynamicThetaSetNumber10",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,theta,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicThetaSetNumber10")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicThetaSetNumber10",err,error)
    CALL EXITS("CMISSSolverDynamicThetaSetNumber10")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDynamicThetaSetNumber10

  !
  !================================================================================================================================
  !

  !>Sets/changes the theta for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicThetaSetNumber11(problemUserNumber,controlLoopIdentifiers,solverIndex,thetas,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the theta for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the theta for.
    REAL(DP), INTENT(IN) :: thetas(:) !<thetas(i). The i'th dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverDynamicThetaSetNumber11",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,thetas,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicThetaSetNumber11")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicThetaSetNumber11",err,error)
    CALL EXITS("CMISSSolverDynamicThetaSetNumber11")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDynamicThetaSetNumber11

  !
  !================================================================================================================================
  !

  !>Sets/changes the theta for a dynamic solver identified by an object.
  SUBROUTINE CMISSSolverDynamicThetaSetObj0(solver,theta,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to set the theta for.
    REAL(DP), INTENT(IN) :: theta !<The dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverDynamicThetaSetObj0",err,error,*999)

    CALL SOLVER_DYNAMIC_THETA_SET(solver%SOLVER,theta,err,error,*999)

    CALL EXITS("CMISSSolverDynamicThetaSetObj0")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicThetaSetObj0",err,error)
    CALL EXITS("CMISSSolverDynamicThetaSetObj0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDynamicThetaSetObj0

   !
  !================================================================================================================================
  !

  !>Sets/changes the theta for a dynamic solver identified by an object.
  SUBROUTINE CMISSSolverDynamicThetaSetObj1(solver,thetas,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to set the theta for.
    REAL(DP), INTENT(IN) :: thetas(:) !<thetas(i). The i'th dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverDynamicThetaSetObj1",err,error,*999)

    CALL SOLVER_DYNAMIC_THETA_SET(solver%SOLVER,thetas,err,error,*999)

    CALL EXITS("CMISSSolverDynamicThetaSetObj1")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicThetaSetObj1",err,error)
    CALL EXITS("CMISSSolverDynamicThetaSetObj1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDynamicThetaSetObj1

  !
  !================================================================================================================================
  !

  !>Sets/changes the times for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicTimesSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,currentTime,timeIncrement,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the times for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the times for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the times for.
    REAL(DP), INTENT(IN) :: currentTime !<The current time to set.
    REAL(DP), INTENT(IN) :: timeIncrement !<The time increment to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverDynamicTimesSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_TIMES_SET(SOLVER,currentTime,timeIncrement,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicTimesSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicTimesSetNumber0",err,error)
    CALL EXITS("CMISSSolverDynamicTimesSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDynamicTimesSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the times for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolverDynamicTimesSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,currentTime,timeIncrement,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the times for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the times for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the times for.
    REAL(DP), INTENT(IN) :: currentTime !<The current time to set.
    REAL(DP), INTENT(IN) :: timeIncrement !<The time increment to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverDynamicTimeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_TIMES_SET(SOLVER,currentTime,timeIncrement,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverDynamicTimesSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicTimesSetNumber1",err,error)
    CALL EXITS("CMISSSolverDynamicTimesSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDynamicTimesSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the times for a dynamic solver identified by an object.
  SUBROUTINE CMISSSolverDynamicTimesSetObj(solver,currentTime,timeIncrement,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to set the times for.
    REAL(DP), INTENT(IN) :: currentTime !<The current time to set.
    REAL(DP), INTENT(IN) :: timeIncrement !<The time increment to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverDynamicTimesSetObj",err,error,*999)

    CALL SOLVER_DYNAMIC_TIMES_SET(solver%SOLVER,currentTime,timeIncrement,err,error,*999)

    CALL EXITS("CMISSSolverDynamicTimesSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverDynamicTimesSetObj",err,error)
    CALL EXITS("CMISSSolverDynamicTimesSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverDynamicTimesSetObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a solver identified by an user number.
  SUBROUTINE CMISSSolverLabelGetCNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the solver label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverLabelGetCNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LABEL_GET(SOLVER,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverLabelGetCNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverLabelGetCNumber0",err,error)
    CALL EXITS("CMISSSolverLabelGetCNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLabelGetCNumber0

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a solver identified by an user number.
  SUBROUTINE CMISSSolverLabelGetCNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the solver label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverLabelGetCNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LABEL_GET(SOLVER,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverLabelGetCNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverLabelGetCNumber1",err,error)
    CALL EXITS("CMISSSolverLabelGetCNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLabelGetCNumber1

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a solver identified by an object.
  SUBROUTINE CMISSSolverLabelGetCObj(solver,label,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the solver label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverLabelGetCObj",err,error,*999)

    CALL SOLVER_LABEL_GET(solver%SOLVER,label,err,error,*999)

    CALL EXITS("CMISSSolverLabelGetCObj")
    RETURN
999 CALL ERRORS("CMISSSolverLabelGetCObj",err,error)
    CALL EXITS("CMISSSolverLabelGetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a solver identified by an user number.
  SUBROUTINE CMISSSolverLabelGetVSNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the solver label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverLabelGetVSNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LABEL_GET(SOLVER,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverLabelGetVSNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverLabelGetVSNumber0",err,error)
    CALL EXITS("CMISSSolverLabelGetVSNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLabelGetVSNumber0

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a solver identified by an user number.
  SUBROUTINE CMISSSolverLabelGetVSNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The solver identifiers.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the solver label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverLabelGetVSNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LABEL_GET(SOLVER,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverLabelGetVSNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverLabelGetVSNumber1",err,error)
    CALL EXITS("CMISSSolverLabelGetVSNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLabelGetVSNumber1

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a solver identified by an object.
  SUBROUTINE CMISSSolverLabelGetVSObj(solver,label,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the solver label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverLabelGetVSObj",err,error,*999)

    CALL SOLVER_LABEL_GET(solver%SOLVER,label,err,error,*999)

    CALL EXITS("CMISSSolverLabelGetVSObj")
    RETURN
999 CALL ERRORS("CMISSSolverLabelGetVSObj",err,error)
    CALL EXITS("CMISSSolverLabelGetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a solver identified by an user number.
  SUBROUTINE CMISSSolverLabelSetCNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the times for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverLabelSetCNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LABEL_SET(SOLVER,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverLabelSetCNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverLabelSetCNumber0",err,error)
    CALL EXITS("CMISSSolverLabelSetCNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLabelSetCNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a solver identified by an user number.
  SUBROUTINE CMISSSolverLabelSetCNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The solver identifiers.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopLabelSetCNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LABEL_SET(SOLVER,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverLabelSetCNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverLabelSetCNumber1",err,error)
    CALL EXITS("CMISSSolverLabelSetCNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLabelSetCNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a solver identified by an object.
  SUBROUTINE CMISSSolverLabelSetCObj(solver,label,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The solver label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverLabelSetCObj",err,error,*999)

    CALL SOLVER_LABEL_SET(solver%SOLVER,label,err,error,*999)

    CALL EXITS("CMISSSolverLabelSetCObj")
    RETURN
999 CALL ERRORS("CMISSSolverLabelSetCObj",err,error)
    CALL EXITS("CMISSSolverLabelSetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a solver identified by an user number.
  SUBROUTINE CMISSSolverLabelSetVSNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The solver identifier.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The solver label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverLabelSetVSNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LABEL_SET(SOLVER,CHAR(label),err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverLabelStVSNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverLabelSetVSNumber0",err,error)
    CALL EXITS("CMISSControlLabelSetVSNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLabelSetVSNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a solver identified by an user number.
  SUBROUTINE CMISSSolverLabelSetVSNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the times for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The solver label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverLabelSetVSNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LABEL_SET(SOLVER,CHAR(label),err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverLabelStVSNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverLabelSetVSNumber1",err,error)
    CALL EXITS("CMISSControlLabelSetVSNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLabelSetVSNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes string label for a solver identified by an object.
  SUBROUTINE CMISSSolverLabelSetVSObj(solver,label,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The solver label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverLabelSetVSObj",err,error,*999)

    CALL SOLVER_LABEL_SET(solver%SOLVER,CHAR(label),err,error,*999)

    CALL EXITS("CMISSSolverLabelSetVSObj")
    RETURN
999 CALL ERRORS("CMISSSolverLabelSetVSObj",err,error)
    CALL EXITS("CMISSSolverLabelSetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the type of library for a solver identified by an user number.
  SUBROUTINE CMISSSolverLibraryTypeGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,libraryType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the library type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the library type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the library type for.
    INTEGER(INTG), INTENT(OUT) :: libraryType !<On return, the library type for the solver. \see OPENCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverLibraryTypeGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LIBRARY_TYPE_GET(SOLVER,libraryType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverLibraryTypeGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverLibraryTypeGetNumber0",err,error)
    CALL EXITS("CMISSSolverLibraryTypeGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLibraryTypeGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the library type for a solver identified by an user number.
  SUBROUTINE CMISSSolverLibraryTypeGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,libraryType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the library type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the library type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the library type for.
    INTEGER(INTG), INTENT(OUT) :: libraryType !<On return, the library type for the solver. \see OPENCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverLibraryTypeGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LIBRARY_TYPE_GET(SOLVER,libraryType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverLibraryTypeGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverLibraryTypeGetNumber1",err,error)
    CALL EXITS("CMISSSolverLibraryTypeGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLibraryTypeGetNumber1

  !================================================================================================================================
  !

  !>Returns the library type for a solver identified by an object.
  SUBROUTINE CMISSSolverLibraryTypeGetObj(solver,libraryType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to get the library type for.
    INTEGER(INTG), INTENT(OUT) :: libraryType !<On return, the library type for the solver. \see OPENCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverLibraryTypeGetObj",err,error,*999)

    CALL SOLVER_LIBRARY_TYPE_GET(solver%SOLVER,libraryType,err,error,*999)

    CALL EXITS("CMISSSolverLibraryTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSSolverLibraryTypeGetObj",err,error)
    CALL EXITS("CMISSSolverLibraryTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLibraryTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of library for a solver identified by an user number.
  SUBROUTINE CMISSSolverLibraryTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,libraryType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the library type for.
    INTEGER(INTG), INTENT(IN) :: libraryType !<The library type for the solver to set. \see OPENCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverLibraryTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LIBRARY_TYPE_SET(SOLVER,libraryType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverLibraryTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverLibraryTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolverLibraryTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLibraryTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the library type for a solver identified by an user number.
  SUBROUTINE CMISSSolverLibraryTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,libraryType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the library type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the library type for.
    INTEGER(INTG), INTENT(IN) :: libraryType !<The library type for the solver to set. \see OPENCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverLibraryTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LIBRARY_TYPE_SET(SOLVER,libraryType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverLibraryTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverLibraryTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolverLibraryTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLibraryTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the library type for a solver identified by an object.
  SUBROUTINE CMISSSolverLibraryTypeSetObj(solver,libraryType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: libraryType !<The library type for the solver to set. \see OPENCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverLibraryTypeSetObj",err,error,*999)

    CALL SOLVER_LIBRARY_TYPE_SET(solver%SOLVER,libraryType,err,error,*999)

    CALL EXITS("CMISSSolverLibraryTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverLibraryTypeSetObj",err,error)
    CALL EXITS("CMISSSolverLibraryTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLibraryTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of direct linear solver for a solver identified by an user number.
  SUBROUTINE CMISSSolverLinearDirectTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,directSolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the direct linear solver to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the direct linear solver to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: directSolverType !<The type of the direct linear solver to set. \see OPENCMISS_DirectLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverLinearDirectTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_DIRECT_TYPE_SET(SOLVER,directSolverType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearDirectTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverLinearDirectTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolverLinearDirectTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLinearDirectTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of direct linear solver for a solver identified by an user number.
  SUBROUTINE CMISSSolverLinearDirectTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,directSolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the direct linear solver to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: directSolverType !<The type of the direct linear solver to set. \see OPENCMISS_DirectLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverLinearDirectTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_DIRECT_TYPE_SET(SOLVER,directSolverType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearDirectTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverLinearDirectTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolverLinearDirectTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLinearDirectTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type of direct linear solver for a solver identified by an object.
  SUBROUTINE CMISSSolverLinearDirectTypeSetObj(solver,directSolverType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: directSolverType !<The type of the direct linear solver to set. \see OPENCMISS_DirectLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverLinearDirectTypeSetObj",err,error,*999)

    CALL SOLVER_LINEAR_DIRECT_TYPE_SET(solver%SOLVER,directSolverType,err,error,*999)

    CALL EXITS("CMISSSolverLinearDirectTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverLinearDirectTypeSetObj",err,error)
    CALL EXITS("CMISSSolverLinearDirectTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLinearDirectTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum absolute tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolverLinearIterativeAbsoluteToleranceSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & absoluteTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverLinearIterativeAbsoluteToleranceSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_ABSOLUTE_TOLERANCE_SET(SOLVER,absoluteTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearIterativeAbsoluteToleranceSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeAbsoluteToleranceSetNumber0",err,error)
    CALL EXITS("CMISSSolverLinearIterativeAbsoluteToleranceSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLinearIterativeAbsoluteToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum absolute tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolverLinearIterativeAbsoluteToleranceSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & absoluteTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverLinearIterativeAbsoluteToleranceSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_ABSOLUTE_TOLERANCE_SET(SOLVER,absoluteTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearIterativeAbsoluteToleranceSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeAbsoluteToleranceSetNumber1",err,error)
    CALL EXITS("CMISSSolverLinearIterativeAbsoluteToleranceSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLinearIterativeAbsoluteToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum absolute tolerance for an iterative linear solver identified by an object.
  SUBROUTINE CMISSSolverLinearIterativeAbsoluteToleranceSetObj(solver,absoluteTolerance,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The iterative linear solver to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverLinearIterativeAbsoluteToleranceSetObj",err,error,*999)

    CALL SOLVER_LINEAR_ITERATIVE_ABSOLUTE_TOLERANCE_SET(solver%SOLVER,absoluteTolerance,err,error,*999)

    CALL EXITS("CMISSSolverLinearIterativeAbsoluteToleranceSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeAbsoluteToleranceSetObj",err,error)
    CALL EXITS("CMISSSolverLinearIterativeAbsoluteToleranceSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLinearIterativeAbsoluteToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum divergence tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolverLinearIterativeDivergenceToleranceSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & divergenceTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the divergence tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the divergence tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the divergence tolerance for.
    REAL(DP), INTENT(IN) :: divergenceTolerance !<The divergence tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverLinearIterativeDivergenceToleranceSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_DIVERGENCE_TOLERANCE_SET(SOLVER,divergenceTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearIterativeDivergenceToleranceSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeDivergenceToleranceSetNumber0",err,error)
    CALL EXITS("CMISSSolverLinearIterativeDivergenceToleranceSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLinearIterativeDivergenceToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum divergence tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolverLinearIterativeDivergenceToleranceSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & divergenceTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the divergence tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the divergence tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the divergence tolerance for.
    REAL(DP), INTENT(IN) :: divergenceTolerance !<The divergence tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverLinearIterativeDivergenceToleranceSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_DIVERGENCE_TOLERANCE_SET(SOLVER,divergenceTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearIterativeDivergenceToleranceSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeDivergenceToleranceSetNumber1",err,error)
    CALL EXITS("CMISSSolverLinearIterativeDivergenceToleranceSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLinearIterativeDivergenceToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum divergence tolerance for an iterative linear solver identified by an object.
  SUBROUTINE CMISSSolverLinearIterativeDivergenceToleranceSetObj(solver,divergenceTolerance,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The iterative linear solver to set the divergence tolerance for.
    REAL(DP), INTENT(IN) :: divergenceTolerance !<The divergence tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverLinearIterativeDivergenceToleranceSetObj",err,error,*999)

    CALL SOLVER_LINEAR_ITERATIVE_DIVERGENCE_TOLERANCE_SET(solver%SOLVER,divergenceTolerance,err,error,*999)

    CALL EXITS("CMISSSolverLinearIterativeDivergenceToleranceSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeDivergenceToleranceSetObj",err,error)
    CALL EXITS("CMISSSolverLinearIterativeDivergenceToleranceSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLinearIterativeDivergenceToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the GMRES restart value for a GMRES iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolverLinearIterativeGMRESRestartSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & gMRESRestart,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the GMRES iterative linear solver to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the GMRES iterative linear solver to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the GMRES restart value for.
    INTEGER(INTG), INTENT(IN) :: gMRESRestart !<The GMRES restart value to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverLinearIterativeGMRESRestartSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_GMRES_RESTART_SET(SOLVER,gMRESRestart,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearIterativeGMRESRestartSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeGMRESRestartSetNumber0",err,error)
    CALL EXITS("CMISSSolverLinearIterativeGMRESRestartSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLinearIterativeGMRESRestartSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the GMRES restart value for a GMRES iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolverLinearIterativeGMRESRestartSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & gMRESRestart,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the GMRES iterative linear solver to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: gMRESRestart !<The GMRES restart value to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverLinearIterativeGMRESRestartSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_GMRES_RESTART_SET(SOLVER,gMRESRestart,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearIterativeGMRESRestartSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeGMRESRestartSetNumber1",err,error)
    CALL EXITS("CMISSSolverLinearIterativeGMRESRestartSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLinearIterativeGMRESRestartSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the GMRES restart value for a GMRES iterative linear solver identified by an object.
  SUBROUTINE CMISSSolverLinearIterativeGMRESRestartSetObj(solver,gMRESRestart,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The GMRES iterative linear solver to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: gMRESRestart !<The GMRES restart value to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverLinearIterativeGMRESRestartSetObj",err,error,*999)

    CALL SOLVER_LINEAR_ITERATIVE_GMRES_RESTART_SET(solver%SOLVER,gMRESRestart,err,error,*999)

    CALL EXITS("CMISSSolverLinearIterativeGMRESRestartSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeGMRESRestartSetObj",err,error)
    CALL EXITS("CMISSSolverLinearIterativeGMRESRestartSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLinearIterativeGMRESRestartSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolverLinearIterativeMaximumIterationsSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & maximumIterations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum iterations to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverLinearIterativeMaximumIterationsSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_MAXIMUM_ITERATIONS_SET(SOLVER,maximumIterations,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearIterativeMaximumIterationsSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeMaximumIterationsSetNumber0",err,error)
    CALL EXITS("CMISSSolverLinearIterativeMaximumIterationsSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLinearIterativeMaximumIterationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolverLinearIterativeMaximumIterationsSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & maximumIterations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum iterations to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverLinearIterativeMaximumIterationsSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_MAXIMUM_ITERATIONS_SET(SOLVER,maximumIterations,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearIterativeMaximumIterationsSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeMaximumIterationsSetNumber1",err,error)
    CALL EXITS("CMISSSolverLinearIterativeMaximumIterationsSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLinearIterativeMaximumIterationsSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for an iterative linear solver identified by an object.
  SUBROUTINE CMISSSolverLinearIterativeMaximumIterationsSetObj(solver,maximumIterations,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The iterative linear solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum iterations to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverLinearIterativeMaximumIterationsSetObj",err,error,*999)

    CALL SOLVER_LINEAR_ITERATIVE_MAXIMUM_ITERATIONS_SET(solver%SOLVER,maximumIterations,err,error,*999)

    CALL EXITS("CMISSSolverLinearIterativeMaximumIterationsSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeMaximumIterationsSetObj",err,error)
    CALL EXITS("CMISSSolverLinearIterativeMaximumIterationsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLinearIterativeMaximumIterationsSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the preconditioner type for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolverLinearIterativePreconditionerTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & preconditionerType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: preconditionerType !<The preconditioner type to set. \see OPENCMISS_IterativePreconditionerTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverLinearIterativePreconditionerTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_PRECONDITIONER_TYPE_SET(SOLVER,preconditionerType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearIterativePreconditionerTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativePreconditionerTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolverLinearIterativePreconditionerTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLinearIterativePreconditionerTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the preconditioner type for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolverLinearIterativePreconditionerTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & preconditionerType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: preconditionerType !<The preconditioner type to set. \see OPENCMISS_IterativePreconditionerTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverLinearIterativePreconditionerTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_PRECONDITIONER_TYPE_SET(SOLVER,preconditionerType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearIterativePreconditionerTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativePreconditionerTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolverLinearIterativePreconditionerTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLinearIterativePreconditionerTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the preconditioner type for an iterative linear solver identified by an object.
  SUBROUTINE CMISSSolverLinearIterativePreconditionerTypeSetObj(solver,preconditionerType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The iterative linear solver to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: preconditionerType !<The preconditioner type to set. \see OPENCMISS_IterativePreconditionerTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverLinearIterativePreconditionerTypeSetObj",err,error,*999)

    CALL SOLVER_LINEAR_ITERATIVE_PRECONDITIONER_TYPE_SET(solver%SOLVER,preconditionerType,err,error,*999)

    CALL EXITS("CMISSSolverLinearIterativePreconditionerTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativePreconditionerTypeSetObj",err,error)
    CALL EXITS("CMISSSolverLinearIterativePreconditionerTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLinearIterativePreconditionerTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum relative tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolverLinearIterativeRelativeToleranceSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & relativeTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverLinearIterativeRelativeToleranceSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_RELATIVE_TOLERANCE_SET(SOLVER,relativeTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearIterativeRelativeToleranceSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeRelativeToleranceSetNumber0",err,error)
    CALL EXITS("CMISSSolverLinearIterativeRelativeToleranceSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLinearIterativeRelativeToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum relative tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolverLinearIterativeRelativeToleranceSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & relativeTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverLinearIterativeRelativeToleranceSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_RELATIVE_TOLERANCE_SET(SOLVER,relativeTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearIterativeRelativeToleranceSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeRelativeToleranceSetNumber1",err,error)
    CALL EXITS("CMISSSolverLinearIterativeRelativeToleranceSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLinearIterativeRelativeToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum relative tolerance for an iterative linear solver identified by an object.
  SUBROUTINE CMISSSolverLinearIterativeRelativeToleranceSetObj(solver,relativeTolerance,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The iterative linear solver to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverLinearIterativeRelativeToleranceSetObj",err,error,*999)

    CALL SOLVER_LINEAR_ITERATIVE_RELATIVE_TOLERANCE_SET(solver%SOLVER,relativeTolerance,err,error,*999)

    CALL EXITS("CMISSSolverLinearIterativeRelativeToleranceSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeRelativeToleranceSetObj",err,error)
    CALL EXITS("CMISSSolverLinearIterativeRelativeToleranceSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLinearIterativeRelativeToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolverLinearIterativeTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,iterativeSolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: iterativeSolverType !<The iterative solver type to set. \see OPENCMISS_IterativeLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverLinearIterativeTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_TYPE_SET(SOLVER,iterativeSolverType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearIterativeTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolverLinearIterativeTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLinearIterativeTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolverLinearIterativeTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,iterativeSolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: iterativeSolverType !<The iterative solver type to set. \see OPENCMISS_IterativeLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverLinearIterativeTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_TYPE_SET(SOLVER,iterativeSolverType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearIterativeTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolverLinearIterativeTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLinearIterativeTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type for an iterative linear solver identified by an object.
  SUBROUTINE CMISSSolverLinearIterativeTypeSetObj(solver,iterativeSolverType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The iterative linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: iterativeSolverType !<The iterative solver type to set. \see OPENCMISS_IterativeLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverLinearIterativeTypeSetObj",err,error,*999)

    CALL SOLVER_LINEAR_ITERATIVE_TYPE_SET(solver%SOLVER,iterativeSolverType,err,error,*999)

    CALL EXITS("CMISSSolverLinearIterativeTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverLinearIterativeTypeSetObj",err,error)
    CALL EXITS("CMISSSolverLinearIterativeTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLinearIterativeTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type for a linear solver identified by an user number.
  SUBROUTINE CMISSSolverLinearTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,linearSolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: linearSolverType !<The linear solver type to set. \see OPENCMISS_LinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverLinearTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_TYPE_SET(SOLVER,linearSolverType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverLinearTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolverLinearTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLinearTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type for a linear solver identified by an user number.
  SUBROUTINE CMISSSolverLinearTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,linearSolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: linearSolverType !<The linear solver type to set. \see OPENCMISS_LinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverLinearTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_TYPE_SET(SOLVER,linearSolverType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverLinearTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverLinearTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolverLinearTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLinearTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type for a linear solver identified by an object.
  SUBROUTINE CMISSSolverLinearTypeSetObj(solver,linearSolverType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: linearSolverType !<The linear solver type to set. \see OPENCMISS_LinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverLinearTypeSetObj",err,error,*999)

    CALL SOLVER_LINEAR_TYPE_SET(solver%SOLVER,linearSolverType,err,error,*999)

    CALL EXITS("CMISSSolverLinearTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverLinearTypeSetObj",err,error)
    CALL EXITS("CMISSSolverLinearTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverLinearTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance for an Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonAbsoluteToleranceSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,absoluteTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverNewtonAbsoluteToleranceSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_ABSOLUTE_TOLERANCE_SET(SOLVER,absoluteTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonAbsoluteToleranceSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonAbsoluteToleranceSetNumber0",err,error)
    CALL EXITS("CMISSSolverNewtonAbsoluteToleranceSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonAbsoluteToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance for a Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonAbsoluteToleranceSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,absoluteTolerance, &
    & err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverNewtonAbsoluteToleranceSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_ABSOLUTE_TOLERANCE_SET(SOLVER,absoluteTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonAbsoluteToleranceSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonAbsoluteToleranceSetNumber1",err,error)
    CALL EXITS("CMISSSolverNewtonAbsoluteToleranceSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonAbsoluteToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance for a Newton solver identified by an object.
  SUBROUTINE CMISSSolverNewtonAbsoluteToleranceSetObj(solver,absoluteTolerance,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Newton solver to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverNewtonAbsoluteToleranceSetObj",err,error,*999)

    CALL SOLVER_NEWTON_ABSOLUTE_TOLERANCE_SET(solver%SOLVER,absoluteTolerance,err,error,*999)

    CALL EXITS("CMISSSolverNewtonAbsoluteToleranceSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonAbsoluteToleranceSetObj",err,error)
    CALL EXITS("CMISSSolverNewtonAbsoluteToleranceSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonAbsoluteToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the Jacobian calculation type for an Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonJacobianCalculationTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & jacobianCalculationType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: jacobianCalculationType !<The Jacobian calculation type for the Newton solver to set. \see OPENCMISS_JacobianCalculationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverNewtonJacobianCalculationTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_JACOBIAN_CALCULATION_TYPE_SET(SOLVER,jacobianCalculationType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonJacobianCalculationTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonJacobianCalculationTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolverNewtonJacobianCalculationTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonJacobianCalculationTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the Jacobian calculation type for a Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonJacobianCalculationTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & jacobianCalculationType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: jacobianCalculationType !<The Jacobian calculation type for the Newton solver to set. \see OPENCMISS_JacobianCalculationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverNewtonJacobianCalculationTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_JACOBIAN_CALCULATION_TYPE_SET(SOLVER,jacobianCalculationType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonJacobianCalculationTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonJacobianCalculationTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolverNewtonJacobianCalculationTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonJacobianCalculationTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the Jacobian calculation type for a Newton solver identified by an object.
  SUBROUTINE CMISSSolverNewtonJacobianCalculationTypeSetObj(solver,jacobianCalculationType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: jacobianCalculationType !<The Jacobian calculation type for the Newton solver to set. \see OPENCMISS_JacobianCalculationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverNewtonJacobianCalculationTypeSetObj",err,error,*999)

    CALL SOLVER_NEWTON_JACOBIAN_CALCULATION_TYPE_SET(solver%SOLVER,jacobianCalculationType,err,error,*999)

    CALL EXITS("CMISSSolverNewtonJacobianCalculationTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonJacobianCalculationTypeSetObj",err,error)
    CALL EXITS("CMISSSolverNewtonJacobianCalculationTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonJacobianCalculationTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the linear solver associated with a Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonLinearSolverGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,linearSolverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Newton linear solver for.
    INTEGER(INTG), INTENT(OUT) :: linearSolverIndex !<On return, the solver index of the linear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,LINEAR_SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverNewtonLinearSolverGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(LINEAR_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_LINEAR_SOLVER_GET(SOLVER,LINEAR_SOLVER,err,error,*999)
      !todo: get the solver index from linear solver
      linearSolverIndex=LINEAR_SOLVER%GLOBAL_NUMBER
      CALL FLAG_ERROR("Not implemented.",err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonLinearSolverGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonLinearSolverGetNumber0",err,error)
    CALL EXITS("CMISSSolverNewtonLinearSolverGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonLinearSolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the linear solver associated with a Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonLinearSolverGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,linearSolverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Newton linear solver for.
    INTEGER(INTG), INTENT(OUT) :: linearSolverIndex !<On return, the Newton linear solver index.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,LINEAR_SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverNewtonLinearSolverGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(LINEAR_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_LINEAR_SOLVER_GET(SOLVER,LINEAR_SOLVER,err,error,*999)
      !todo: get the solver index from linear solver
      linearSolverIndex=LINEAR_SOLVER%GLOBAL_NUMBER
      CALL FLAG_ERROR("Not implemented.",err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonLinearSolverGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonLinearSolverGetNumber1",err,error)
    CALL EXITS("CMISSSolverNewtonLinearSolverGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonLinearSolverGetNumber1

  !================================================================================================================================
  !

  !>Returns the linear solver associated with a Newton solver identified by an object.
  SUBROUTINE CMISSSolverNewtonLinearSolverGetObj(solver,linearSolver,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to get the Newton linear solver for.
    TYPE(CMISSSolverType), INTENT(INOUT) :: linearSolver !<On return, the Newton linear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverNewtonLinearSolverGetObj",err,error,*999)

    CALL SOLVER_NEWTON_LINEAR_SOLVER_GET(solver%SOLVER,linearSolver%SOLVER,err,error,*999)

    CALL EXITS("CMISSSolverNewtonLinearSolverGetObj")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonLinearSolverGetObj",err,error)
    CALL EXITS("CMISSSolverNewtonLinearSolverGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonLinearSolverGetObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML solver associated with a Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonCellMLSolverGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,CellMLSolverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Newton CellML solver for.
    INTEGER(INTG), INTENT(OUT) :: CellMLSolverIndex !<On return, the solver index of the CellML solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,CELLML_SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverNewtonCellMLSolverGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(CELLML_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_CELLML_SOLVER_GET(SOLVER,CELLML_SOLVER,err,error,*999)
      !todo: get the solver index from CellML solver
      CellMLSolverIndex=CELLML_SOLVER%GLOBAL_NUMBER
      CALL FLAG_ERROR("Not implemented.",err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonCellMLSolverGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonCellMLSolverGetNumber0",err,error)
    CALL EXITS("CMISSSolverNewtonCellMLSolverGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonCellMLSolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the CellML solver associated with a Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonCellMLSolverGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,CellMLSolverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Newton CellML solver for.
    INTEGER(INTG), INTENT(OUT) :: CellMLSolverIndex !<On return, the Newton CellML solver index.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,CELLML_SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverNewtonCellMLSolverGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(CELLML_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_CELLML_SOLVER_GET(SOLVER,CELLML_SOLVER,err,error,*999)
      !todo: get the solver index from CellML solver
      CellMLSolverIndex=CELLML_SOLVER%GLOBAL_NUMBER
      CALL FLAG_ERROR("Not implemented.",err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonCellMLSolverGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonCellMLSolverGetNumber1",err,error)
    CALL EXITS("CMISSSolverNewtonCellMLSolverGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonCellMLSolverGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the CellML solver associated with a Newton solver identified by an object.
  SUBROUTINE CMISSSolverNewtonCellMLSolverGetObj(solver,CellMLSolver,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to get the Newton CellML solver for.
    TYPE(CMISSSolverType), INTENT(INOUT) :: CellMLSolver !<On return, the Newton CellML solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverNewtonCellMLSolverGetObj",err,error,*999)

    CALL SOLVER_NEWTON_CELLML_SOLVER_GET(solver%SOLVER,CellMLSolver%SOLVER,err,error,*999)

    CALL EXITS("CMISSSolverNewtonCellMLSolverGetObj")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonCellMLSolverGetObj",err,error)
    CALL EXITS("CMISSSolverNewtonCellMLSolverGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonCellMLSolverGetObj

  !
  !================================================================================================================================
  !>Sets/changes the line search alpha for an Newton linesearch solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonLineSearchAlphaSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,alpha,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the alpha for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton line search solver to set the alpha for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search alpha for.
    REAL(DP), INTENT(IN) :: alpha !<The alpha for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverNewtonLineSearchAlphaSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_LINESEARCH_ALPHA_SET(SOLVER,alpha,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonLineSearchAlphaSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonLineSearchAlphaSetNumber0",err,error)
    CALL EXITS("CMISSSolverNewtonLineSearchAlphaSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonLineSearchAlphaSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search alpha for a Newton line search solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonLineSearchAlphaSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,alpha,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the alpha for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the alpha for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the alpha for.
    REAL(DP), INTENT(IN) :: alpha !<The alpha for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverNewtonLineSearchAlphaSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_LINESEARCH_ALPHA_SET(SOLVER,alpha,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonLineSearchAlphaSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonLineSearchAlphaSetNumber1",err,error)
    CALL EXITS("CMISSSolverNewtonLineSearchAlphaSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonLineSearchAlphaSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the line search alpha for a Newton line search solver identified by an object.
  SUBROUTINE CMISSSolverNewtonLineSearchAlphaSetObj(solver,alpha,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Newton line search solver to set the alpha for.
    REAL(DP), INTENT(IN) :: alpha !<The alpha for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverNewtonLineSearchAlphaSetObj",err,error,*999)

    CALL SOLVER_NEWTON_LINESEARCH_ALPHA_SET(solver%SOLVER,alpha,err,error,*999)

    CALL EXITS("CMISSSolverNewtonLineSearchAlphaSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonLineSearchAlphaSetObj",err,error)
    CALL EXITS("CMISSSolverNewtonLineSearchAlphaSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonLineSearchAlphaSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search maximum step for an Newton linesearch solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonLineSearchMaxStepSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,maxStep,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton line search solver to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search maximum step for.
    REAL(DP), INTENT(IN) :: maxStep !<The maximum step for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverNewtonLineSearchMaxStepSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_LINESEARCH_MAXSTEP_SET(SOLVER,maxStep,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonLineSearchMaxStepSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonLineSearchMaxStepSetNumber0",err,error)
    CALL EXITS("CMISSSolverNewtonLineSearchMaxStepSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonLineSearchMaxStepSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search maximum step for a Newton line search solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonLineSearchMaxStepSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,maxStep,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum step for.
    REAL(DP), INTENT(IN) :: maxStep !<The maximum step for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverNewtonLineSearchMaxStepSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_LINESEARCH_MAXSTEP_SET(SOLVER,maxStep,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonLineSearchMaxStepSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonLineSearchMaxStepSetNumber1",err,error)
    CALL EXITS("CMISSSolverNewtonLineSearchMaxStepSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonLineSearchMaxStepSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the line search maximum step for a Newton line search solver identified by an object.
  SUBROUTINE CMISSSolverNewtonLineSearchMaxStepSetObj(solver,maxStep,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Newton line search solver to set the maximum step for.
    REAL(DP), INTENT(IN) :: maxStep !<The maximum step for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverNewtonLineSearchMaxStepSetObj",err,error,*999)

    CALL SOLVER_NEWTON_LINESEARCH_MAXSTEP_SET(solver%SOLVER,maxStep,err,error,*999)

    CALL EXITS("CMISSSolverNewtonLineSearchMaxStepSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonLineSearchMaxStepSetObj",err,error)
    CALL EXITS("CMISSSolverNewtonLineSearchMaxStepSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonLineSearchMaxStepSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search step tolerance for an Newton linesearch solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonLineSearchStepTolSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,stepTol,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton line search solver to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search step tolerance for.
    REAL(DP), INTENT(IN) :: stepTol !<The step tolerance for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverNewtonLineSearchStepTolSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_LINESEARCH_STEPTOL_SET(SOLVER,stepTol,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonLineSearchStepTolSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonLineSearchStepTolSetNumber0",err,error)
    CALL EXITS("CMISSSolverNewtonLineSearchStepTolSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonLineSearchStepTolSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search step tolerance for a Newton line search solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonLineSearchStepTolSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,stepTol,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the step tolerance for.
    REAL(DP), INTENT(IN) :: stepTol !<The step tolerance for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverNewtonLineSearchStepTolSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_LINESEARCH_STEPTOL_SET(SOLVER,stepTol,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonLineSearchStepTolSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonLineSearchStepTolSetNumber1",err,error)
    CALL EXITS("CMISSSolverNewtonLineSearchStepTolSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonLineSearchStepTolSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the line search step tolerance for a Newton line search solver identified by an object.
  SUBROUTINE CMISSSolverNewtonLineSearchStepTolSetObj(solver,stepTol,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Newton line search solver to set the step tolerance for.
    REAL(DP), INTENT(IN) :: stepTol !<The step tolerance for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverNewtonLineSearchStepTolSetObj",err,error,*999)

    CALL SOLVER_NEWTON_LINESEARCH_STEPTOL_SET(solver%SOLVER,stepTol,err,error,*999)

    CALL EXITS("CMISSSolverNewtonLineSearchStepTolSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonLineSearchStepTolSetObj",err,error)
    CALL EXITS("CMISSSolverNewtonLineSearchStepTolSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonLineSearchStepTolSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search type for an Newton linesearch solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonLineSearchTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,lineSearchType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: lineSearchType !<The type of line search for the Newton line search solver to set. \see OPENCMISS_NewtonLineSearchTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverNewtonLineSearchTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_LINESEARCH_TYPE_SET(SOLVER,lineSearchType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonLineSearchTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonLineSearchTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolverNewtonLineSearchTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonLineSearchTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of line search for a Newton line search solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonLineSearchTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,lineSearchType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: lineSearchType !<The type of line search for the Newton line search solver to set. \see OPENCMISS_NewtonLineSearchTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverNewtonLineSearchTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_LINESEARCH_TYPE_SET(SOLVER,lineSearchType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonLineSearchTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonLineSearchTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolverNewtonLineSearchTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonLineSearchTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type of line search for a Newton line search solver identified by an object.
  SUBROUTINE CMISSSolverNewtonLineSearchTypeSetObj(solver,lineSearchType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: lineSearchType !<The type of line search for the Newton line search solver to set. \see OPENCMISS_NewtonLineSearchTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverNewtonLineSearchTypeSetObj",err,error,*999)

    CALL SOLVER_NEWTON_LINESEARCH_TYPE_SET(solver%SOLVER,lineSearchType,err,error,*999)

    CALL EXITS("CMISSSolverNewtonLineSearchTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonLineSearchTypeSetObj",err,error)
    CALL EXITS("CMISSSolverNewtonLineSearchTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonLineSearchTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of function evaluations for an Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonMaximumFunctionEvaluationsSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & maximumFunctionEvaluations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: maximumFunctionEvaluations !<The maximum number of function evaluations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverNewtonMaximumFunctionEvaluationsSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_MAXIMUM_FUNCTION_EVALUATIONS_SET(SOLVER,maximumFunctionEvaluations,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonMaximumFunctionEvaluationsSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonMaximumFunctionEvaluationsSetNumber0",err,error)
    CALL EXITS("CMISSSolverNewtonMaximumFunctionEvaluationsSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonMaximumFunctionEvaluationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of function evaluations for a Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonMaximumFunctionEvaluationsSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & maximumFunctionEvaluations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: maximumFunctionEvaluations !<The maximum number of function evaluations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverNewtonMaximumFunctionEvaluationsSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_MAXIMUM_FUNCTION_EVALUATIONS_SET(SOLVER,maximumFunctionEvaluations,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonMaximumFunctionEvaluationsSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonMaximumFunctionEvaluationsSetNumber1",err,error)
    CALL EXITS("CMISSSolverNewtonMaximumFunctionEvaluationsSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonMaximumFunctionEvaluationsSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum number of function evaluations for a Newton solver identified by an object.
  SUBROUTINE CMISSSolverNewtonMaximumFunctionEvaluationsSetObj(solver,maximumFunctionEvaluations,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Newton solver to set the maximum number of function evaluations for.
    INTEGER(INTG), INTENT(IN) :: maximumFunctionEvaluations !<The maximum number of function evaluations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverNewtonMaximumFunctionEvaluationsSetObj",err,error,*999)

    CALL SOLVER_NEWTON_MAXIMUM_FUNCTION_EVALUATIONS_SET(solver%SOLVER,maximumFunctionEvaluations,err,error,*999)

    CALL EXITS("CMISSSolverNewtonMaximumFunctionEvaluationsSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonMaximumFunctionEvaluationsSetObj",err,error)
    CALL EXITS("CMISSSolverNewtonMaximumFunctionEvaluationsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonMaximumFunctionEvaluationsSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for an Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonMaximumIterationsSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,maximumIterations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum number of iterations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverNewtonMaximumIterationsSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_MAXIMUM_ITERATIONS_SET(SOLVER,maximumIterations,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonMaximumIterationsSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonMaximumIterationsSetNumber0",err,error)
    CALL EXITS("CMISSSolverNewtonMaximumIterationsSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonMaximumIterationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for a Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonMaximumIterationsSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,maximumIterations, &
    & err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum number of iterations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverNewtonMaximumIterationsSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_MAXIMUM_ITERATIONS_SET(SOLVER,maximumIterations,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonMaximumIterationsSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonMaximumIterationsSetNumber1",err,error)
    CALL EXITS("CMISSSolverNewtonMaximumIterationsSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonMaximumIterationsSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for a Newton solver identified by an object.
  SUBROUTINE CMISSSolverNewtonMaximumIterationsSetObj(solver,maximumIterations,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Newton solver to set the maximum number of iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum number of iterations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverNewtonMaximumIterationsSetObj",err,error,*999)

    CALL SOLVER_NEWTON_MAXIMUM_ITERATIONS_SET(solver%SOLVER,maximumIterations,err,error,*999)

    CALL EXITS("CMISSSolverNewtonMaximumIterationsSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonMaximumIterationsSetObj",err,error)
    CALL EXITS("CMISSSolverNewtonMaximumIterationsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonMaximumIterationsSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for an Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonRelativeToleranceSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,relativeTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverNewtonRelativeToleranceSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_RELATIVE_TOLERANCE_SET(SOLVER,relativeTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonRelativeToleranceSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonRelativeToleranceSetNumber0",err,error)
    CALL EXITS("CMISSSolverNewtonRelativeToleranceSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonRelativeToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for a Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonRelativeToleranceSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,relativeTolerance, &
    & err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverNewtonRelativeToleranceSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_RELATIVE_TOLERANCE_SET(SOLVER,relativeTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonRelativeToleranceSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonRelativeToleranceSetNumber1",err,error)
    CALL EXITS("CMISSSolverNewtonRelativeToleranceSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonRelativeToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for a Newton solver identified by an object.
  SUBROUTINE CMISSSolverNewtonRelativeToleranceSetObj(solver,relativeTolerance,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Newton solver to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverNewtonRelativeToleranceSetObj",err,error,*999)

    CALL SOLVER_NEWTON_RELATIVE_TOLERANCE_SET(solver%SOLVER,relativeTolerance,err,error,*999)

    CALL EXITS("CMISSSolverNewtonRelativeToleranceSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonRelativeToleranceSetObj",err,error)
    CALL EXITS("CMISSSolverNewtonRelativeToleranceSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonRelativeToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the solution tolerance for an Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonSolutionToleranceSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,solutionTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the solution tolerance for.
    REAL(DP), INTENT(IN) :: solutionTolerance !<The solution tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverNewtonSolutionToleranceSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_SOLUTION_TOLERANCE_SET(SOLVER,solutionTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonSolutionToleranceSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonSolutionToleranceSetNumber0",err,error)
    CALL EXITS("CMISSSolverNewtonSolutionToleranceSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonSolutionToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the solution tolerance for a Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonSolutionToleranceSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,solutionTolerance, &
    & err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the solution tolerance for.
    REAL(DP), INTENT(IN) :: solutionTolerance !<The absolulte tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverNewtonSolutionToleranceSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_SOLUTION_TOLERANCE_SET(SOLVER,solutionTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonSolutionToleranceSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonSolutionToleranceSetNumber1",err,error)
    CALL EXITS("CMISSSolverNewtonSolutionToleranceSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonSolutionToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the solution tolerance for a Newton solver identified by an object.
  SUBROUTINE CMISSSolverNewtonSolutionToleranceSetObj(solver,solutionTolerance,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Newton solver to set the solution tolerance for.
    REAL(DP), INTENT(IN) :: solutionTolerance !<The solution tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverNewtonSolutionToleranceSetObj",err,error,*999)

    CALL SOLVER_NEWTON_SOLUTION_TOLERANCE_SET(solver%SOLVER,solutionTolerance,err,error,*999)

    CALL EXITS("CMISSSolverNewtonSolutionToleranceSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonSolutionToleranceSetObj",err,error)
    CALL EXITS("CMISSSolverNewtonSolutionToleranceSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonSolutionToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the delta0 for a Newton trust region solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonTrustRegionDelta0SetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,delta0,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton trust region solver to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton trust region solver to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the delta0 for.
    REAL(DP), INTENT(IN) :: delta0 !<The delta0 for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverNewtonTrustRegionDelta0SetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_TRUSTREGION_DELTA0_SET(SOLVER,delta0,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonTrustRegionDelta0SetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonTrustRegionDelta0SetNumber0",err,error)
    CALL EXITS("CMISSSolverNewtonTrustRegionDelta0SetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonTrustRegionDelta0SetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the delta0 for a Newton trust region solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonTrustRegionDelta0SetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,delta0,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton trust region solver to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the delta0 for.
    REAL(DP), INTENT(IN) :: delta0 !<The delta0 for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverNewtonTrustRegionDelta0SetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_TRUSTREGION_DELTA0_SET(SOLVER,delta0,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonTrustRegionDelta0SetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonTrustRegionDelta0SetNumber1",err,error)
    CALL EXITS("CMISSSolverNewtonTrustRegionDelta0SetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonTrustRegionDelta0SetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the delta0 for a Newton trust region solver identified by an object.
  SUBROUTINE CMISSSolverNewtonTrustRegionDelta0SetObj(solver,delta0,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Newton trust region solver to set the delta0 for.
    REAL(DP), INTENT(IN) :: delta0 !<The delta0 for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverNewtonTrustRegionDelta0SetObj",err,error,*999)

    CALL SOLVER_NEWTON_TRUSTREGION_DELTA0_SET(solver%SOLVER,delta0,err,error,*999)

    CALL EXITS("CMISSSolverNewtonTrustRegionDelta0SetObj")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonTrustRegionDelta0SetObj",err,error)
    CALL EXITS("CMISSSolverNewtonTrustRegionDelta0SetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonTrustRegionDelta0SetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the tolerance for a Newton trust region solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonTrustRegionToleranceSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,tolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton trust region solver to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton trust region solver to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the tolerance for.
    REAL(DP), INTENT(IN) :: tolerance !<The tolerance for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverNewtonTrustRegionToleranceSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_TRUSTREGION_TOLERANCE_SET(SOLVER,tolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonTrustRegionToleranceSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonTrustRegionToleranceSetNumber0",err,error)
    CALL EXITS("CMISSSolverNewtonTrustRegionToleranceSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonTrustRegionToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the tolerance for a Newton trust region solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonTrustRegionToleranceSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,tolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton trust region solver to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the tolerance for.
    REAL(DP), INTENT(IN) :: tolerance !<The tolerance for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverNewtonTrustRegionToleranceSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_TRUSTREGION_TOLERANCE_SET(SOLVER,tolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonTrustRegionToleranceSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonTrustRegionToleranceSetNumber1",err,error)
    CALL EXITS("CMISSSolverNewtonTrustRegionToleranceSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonTrustRegionToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the tolerance for a Newton trust region solver identified by an object.
  SUBROUTINE CMISSSolverNewtonTrustRegionToleranceSetObj(solver,tolerance,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Newton trust region solver to set the tolerance for.
    REAL(DP), INTENT(IN) :: tolerance !<The tolerance for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverNewtonTrustRegionToleranceSetObj",err,error,*999)

    CALL SOLVER_NEWTON_TRUSTREGION_TOLERANCE_SET(solver%SOLVER,tolerance,err,error,*999)

    CALL EXITS("CMISSSolverNewtonTrustRegionToleranceSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonTrustRegionToleranceSetObj",err,error)
    CALL EXITS("CMISSSolverNewtonTrustRegionToleranceSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonTrustRegionToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,newtonSolveType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: newtonSolveType !<The type of the Newton solver to set. \see OPENCMISS_NewtonSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverNewtonTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_TYPE_SET(SOLVER,newtonSolveType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolverNewtonTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a Newton solver identified by an user number.
  SUBROUTINE CMISSSolverNewtonTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,newtonSolveType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: newtonSolveType !<The type of the Newton solver to set. \see OPENCMISS_NewtonSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverNewtonTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_TYPE_SET(SOLVER,newtonSolveType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverNewtonTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolverNewtonTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type of a Newton solver identified by an object.
  SUBROUTINE CMISSSolverNewtonTypeSetObj(solver,newtonSolveType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: newtonSolveType !<The type of the Newton solver to set. \see OPENCMISS_NewtonSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverNewtonTypeSetObj",err,error,*999)

    CALL SOLVER_NEWTON_TYPE_SET(solver%SOLVER,newtonSolveType,err,error,*999)

    CALL EXITS("CMISSSolverNewtonTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverNewtonTypeSetObj",err,error)
    CALL EXITS("CMISSSolverNewtonTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNewtonTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a nonlinear solver identified by an user number.
  SUBROUTINE CMISSSolverNonlinearTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,nonlinearSolveType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the nonlinear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the nonlinear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: nonlinearSolveType !<The type of the nonlinear solver to set. \see OPENCMISS_NonlinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverNonlinearTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NONLINEAR_TYPE_SET(SOLVER,nonlinearSolveType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverNonlinearTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverNonlinearTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolverNonlinearTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNonlinearTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a nonlinear solver identified by an user number.
  SUBROUTINE CMISSSolverNonlinearTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,nonlinearSolveType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the nonlinear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: nonlinearSolveType !<The type of the nonlinear solver to set. \see OPENCMISS_NonlinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverNonlinearTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NONLINEAR_TYPE_SET(SOLVER,nonlinearSolveType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverNonlinearTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverNonlinearTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolverNonlinearTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNonlinearTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type of a nonlinear solver identified by an object.
  SUBROUTINE CMISSSolverNonlinearTypeSetObj(solver,nonlinearSolveType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The nonlinear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: nonlinearSolveType !<The type of the nonlinear solver to set. \see OPENCMISS_NonlinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverNonlinearTypeSetObj",err,error,*999)

    CALL SOLVER_NONLINEAR_TYPE_SET(solver%SOLVER,nonlinearSolveType,err,error,*999)

    CALL EXITS("CMISSSolverNonlinearTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverNonlinearTypeSetObj",err,error)
    CALL EXITS("CMISSSolverNonlinearTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverNonlinearTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for a solver identified by an user number.
  SUBROUTINE CMISSSolverOutputTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,outputType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the output type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the output type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The type of solver output to set. \see OPENCMISS_SolverOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverOutputTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_OUTPUT_TYPE_SET(SOLVER,outputType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverOutputTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverOutputTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolverOutputTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverOutputTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of output for a solver identified by an user number.
  SUBROUTINE CMISSSolverOutputTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,outputType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the output type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the output type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The type of solver output to set. \see OPENCMISS_SolverOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverOutputTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_OUTPUT_TYPE_SET(SOLVER,outputType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverOutputTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverOutputTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolverOutputTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverOutputTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the output type for a solver identified by an object.
  SUBROUTINE CMISSSolverOutputTypeSetObj(solver,outputType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The type of solver output to set. \see OPENCMISS_SolverOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverOutputTypeSetObj",err,error,*999)

    CALL SOLVER_OUTPUT_TYPE_SET(solver%SOLVER,outputType,err,error,*999)

    CALL EXITS("CMISSSolverOutputTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverOutputTypeSetObj",err,error)
    CALL EXITS("CMISSSolverOutputTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverOutputTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the solver equations for a solver identified by an user number.
  SUBROUTINE CMISSSolverSolverEquationsGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,solverEquations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(CMISSSolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the solver equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverSolverEquationsGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_SOLVER_EQUATIONS_GET(SOLVER,solverEquations%SOLVER_EQUATIONS,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverSolverEquationsGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverSolverEquationsGetNumber0",err,error)
    CALL EXITS("CMISSSolverSolverEquationsGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverSolverEquationsGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the solver equations for a solver identified by an user number.
  SUBROUTINE CMISSSolverSolverEquationsGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,solverEquations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(CMISSSolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the solver equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverSolverEquationsGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_SOLVER_EQUATIONS_GET(SOLVER,solverEquations%SOLVER_EQUATIONS,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverSolverEquationsGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverSolverEquationsGetNumber1",err,error)
    CALL EXITS("CMISSSolverSolverEquationsGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverSolverEquationsGetNumber1

  !================================================================================================================================
  !

  !>Returns the solver equations for a solver identified by an object.
  SUBROUTINE CMISSSolverSolverEquationsGetObj(solver,solverEquations,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to get the solver equations for.
    TYPE(CMISSSolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the solver equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverSolverEquationsGetObj",err,error,*999)

    CALL SOLVER_SOLVER_EQUATIONS_GET(solver%SOLVER,solverEquations%SOLVER_EQUATIONS,err,error,*999)

    CALL EXITS("CMISSSolverSolverEquationsGetObj")
    RETURN
999 CALL ERRORS("CMISSSolverSolverEquationsGetObj",err,error)
    CALL EXITS("CMISSSolverSolverEquationsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverSolverEquationsGetObj

  !
  !================================================================================================================================
  !

  !>Adds equations sets to solver equations identified by an user number.
  SUBROUTINE CMISSSolverEquationsEquationsSetAddNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & regionUserNumber,equationsSetUserNumber,equationsSetIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem with the solver to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region with the equations set to add.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to add.
    INTEGER(INTG), INTENT(OUT) :: equationsSetIndex !<On return, the index of the added equations set in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverEquationsEquationsSetAddNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_SOLVER_EQUATIONS_GET(SOLVER,SOLVER_EQUATIONS,err,error,*999)
      CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
      IF(ASSOCIATED(REGION)) THEN
        CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
        IF(ASSOCIATED(EQUATIONS_SET)) THEN
          CALL SOLVER_EQUATIONS_EQUATIONS_SET_ADD(SOLVER_EQUATIONS,EQUATIONS_SET,equationsSetIndex,err,error,*999)
        ELSE
          LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
            & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
          & " does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverEquationsEquationsSetAddNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverEquationsEquationsSetAddNumber0",err,error)
    CALL EXITS("CMISSSolverEquationsEquationsSetAddNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquationsEquationsSetAddNumber0

  !
  !================================================================================================================================
  !

  !>Adds equations sets to solver equations identified by an user number.
  SUBROUTINE CMISSSolverEquationsEquationsSetAddNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & regionUserNumber,equationsSetUserNumber,equationsSetIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region with the equations set to add.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to add.
    INTEGER(INTG), INTENT(OUT) :: equationsSetIndex !<On return, the index of the added equations set in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverEquationsEquationsSetAddNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_SOLVER_EQUATIONS_GET(SOLVER,SOLVER_EQUATIONS,err,error,*999)
      CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
      IF(ASSOCIATED(REGION)) THEN
        CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
        IF(ASSOCIATED(EQUATIONS_SET)) THEN
          CALL SOLVER_EQUATIONS_EQUATIONS_SET_ADD(SOLVER_EQUATIONS,EQUATIONS_SET,equationsSetIndex,err,error,*999)
        ELSE
          LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
            & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
          & " does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverEquationsEquationsSetAddNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverEquationsEquationsSetAddNumber1",err,error)
    CALL EXITS("CMISSSolverEquationsEquationsSetAddNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquationsEquationsSetAddNumber1

  !================================================================================================================================
  !

  !>Adds equations sets to solver equations identified by an object.
  SUBROUTINE CMISSSolverEquationsEquationsSetAddObj(solverEquations,equationsSet,equationsSetIndex,err)

    !Argument variables
    TYPE(CMISSSolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to add the equations set for.
    TYPE(CMISSEquationsSetType), INTENT(IN) :: equationsSet !<The equations set to add.
    INTEGER(INTG), INTENT(OUT) :: equationsSetIndex !<On return, the index of the added equations set in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverEquationsEquationsSetAddObj",err,error,*999)

    CALL SOLVER_EQUATIONS_EQUATIONS_SET_ADD(solverEquations%SOLVER_EQUATIONS,equationsSet%EQUATIONS_SET,equationsSetIndex, &
      & err,error,*999)

    CALL EXITS("CMISSSolverEquationsEquationsSetAddObj")
    RETURN
999 CALL ERRORS("CMISSSolverEquationsEquationsSetAddObj",err,error)
    CALL EXITS("CMISSSolverEquationsEquationsSetAddObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquationsEquationsSetAddObj

  !
  !================================================================================================================================
  !

  !>Adds an interface condition to solver equations identified by an user number.
  SUBROUTINE CMISSSolverEquationsInterfaceConditionAddNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & interfaceRegionUserNumber,interfaceUserNumber,interfaceConditionUserNumber,interfaceConditionIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem with the solver to add the interface condition for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to add the interface condition for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to add the interface condition for.
    INTEGER(INTG), INTENT(IN) :: interfaceRegionUserNumber !<The user number of the region containing the interface and interface condition to add.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to add.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to add.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionIndex !<On return, the index of the added interface condition in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(REGION_TYPE), POINTER :: INTERFACE_REGION
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverEquationsInterfaceConditionAddNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(INTERFACE_REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_SOLVER_EQUATIONS_GET(SOLVER,SOLVER_EQUATIONS,err,error,*999)
      CALL REGION_USER_NUMBER_FIND(interfaceRegionUserNumber,INTERFACE_REGION,err,error,*999)
      IF(ASSOCIATED(INTERFACE_REGION)) THEN
        CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,INTERFACE_REGION,INTERFACE,err,error,*999)
        IF(ASSOCIATED(INTERFACE)) THEN
          CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
          IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
            CALL SOLVER_EQUATIONS_INTERFACE_CONDITION_ADD(SOLVER_EQUATIONS,INTERFACE_CONDITION,interfaceConditionIndex, &
              & err,error,*999)
          ELSE
            LOCAL_ERROR="An interface condition with an user number of "// &
              & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
              & " does not exist on interface number "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
              & " of parent region number "//TRIM(NUMBER_TO_VSTRING(interfaceRegionUserNumber,"*",err,error))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="An interface with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " does not exist on parent region number "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceRegionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceRegionUserNumber,"*",err,error))// &
          & " does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverEquationsInterfaceConditionNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverEquationsInterfaceConditionAddNumber0",err,error)
    CALL EXITS("CMISSSolverEquationsInterfaceConditionAddNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquationsInterfaceConditionAddNumber0

  !
  !================================================================================================================================
  !

  !>Adds an interface condition to solver equations identified by an user number.
  SUBROUTINE CMISSSolverEquationsInterfaceConditionAddNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & interfaceRegionUserNumber,interfaceUserNumber,interfaceConditionUserNumber,interfaceConditionIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to add the interface condition for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to add the interface condition for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to add the interface condition for.
    INTEGER(INTG), INTENT(IN) :: interfaceRegionUserNumber !<The user number of the region containing the interface and interface condition to add.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containting the interface condition to add.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface conditions to add.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionIndex !<On return, the index of the added interface condition in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(REGION_TYPE), POINTER :: INTERFACE_REGION
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverEquationsInterfaceConditionAddNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(INTERFACE_REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_SOLVER_EQUATIONS_GET(SOLVER,SOLVER_EQUATIONS,err,error,*999)
      CALL REGION_USER_NUMBER_FIND(interfaceRegionUserNumber,INTERFACE_REGION,err,error,*999)
      IF(ASSOCIATED(INTERFACE_REGION)) THEN
        CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,INTERFACE_REGION,INTERFACE,err,error,*999)
        IF(ASSOCIATED(INTERFACE)) THEN
          CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
          IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
            CALL SOLVER_EQUATIONS_INTERFACE_CONDITION_ADD(SOLVER_EQUATIONS,INTERFACE_CONDITION,interfaceConditionIndex, &
              & err,error,*999)
          ELSE
            LOCAL_ERROR="An interface condition with an user number of "// &
              & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
              & " does not exist on interface number "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
              & " of parent region number "//TRIM(NUMBER_TO_VSTRING(interfaceRegionUserNumber,"*",err,error))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="An interface with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " does not exist on parent region number "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceRegionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceRegionUserNumber,"*",err,error))// &
          & " does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverEquationsInterfaceConditionAddNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverEquationsInterfaceConditionAddNumber1",err,error)
    CALL EXITS("CMISSSolverEquationsInterfaceConditionAddNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquationsInterfaceConditionAddNumber1

  !================================================================================================================================
  !

  !>Adds an interface condition to solver equations identified by an object.
  SUBROUTINE CMISSSolverEquationsInterfaceConditionAddObj(solverEquations,interfaceCondition,interfaceConditionIndex,err)

    !Argument variables
    TYPE(CMISSSolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to add the equations set for.
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to add.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionIndex !<On return, the index of the added interface condition in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverEquationsInterfaceConditionAddObj",err,error,*999)

    CALL SOLVER_EQUATIONS_INTERFACE_CONDITION_ADD(solverEquations%SOLVER_EQUATIONS,interfaceCondition%INTERFACE_CONDITION, &
      & interfaceConditionIndex,err,error,*999)

    CALL EXITS("CMISSSolverEquationsInterfaceConditionAddObj")
    RETURN
999 CALL ERRORS("CMISSSolverEquationsInterfaceConditionAddObj",err,error)
    CALL EXITS("CMISSSolverEquationsInterfaceConditionAddObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquationsInterfaceConditionAddObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for solver equations identified by an user number.
  SUBROUTINE CMISSSolverEquationsSparsityTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,sparsityType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type to set. \see OPENCMISS_SolverEquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverEquationsSparsityTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(SOLVER_EQUATIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_SOLVER_EQUATIONS_GET(SOLVER,SOLVER_EQUATIONS,err,error,*999)
      CALL SOLVER_EQUATIONS_SPARSITY_TYPE_SET(SOLVER_EQUATIONS,sparsityType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverEquationsSparsityTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverEquationsSparsityTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolverEquationsSparsityTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquationsSparsityTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for solver equations identified by an user number.
  SUBROUTINE CMISSSolverEquationsSparsityTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,sparsityType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type to set. \see OPENCMISS_SolverEquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverEquationsSparsityTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(SOLVER_EQUATIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_SOLVER_EQUATIONS_GET(SOLVER,SOLVER_EQUATIONS,err,error,*999)
      CALL SOLVER_EQUATIONS_SPARSITY_TYPE_SET(SOLVER_EQUATIONS,sparsityType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverEquationsSparsityTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverEquationsSparsityTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolverEquationsSparsityTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquationsSparsityTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for solver equations identified by an object.
  SUBROUTINE CMISSSolverEquationsSparsityTypeSetObj(solverEquations,sparsityType,err)

    !Argument variables
    TYPE(CMISSSolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type to set. \see OPENCMISS_SolverEquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverEquationsSparsityTypeSetObj",err,error,*999)

    CALL SOLVER_EQUATIONS_SPARSITY_TYPE_SET(solverEquations%SOLVER_EQUATIONS,sparsityType,err,error,*999)

    CALL EXITS("CMISSSolverEquationsSparsityTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverEquationsSparsityTypeSetObj",err,error)
    CALL EXITS("CMISSSolverEquationsSparsityTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquationsSparsityTypeSetObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of the boundary conditions for the solver equations identified by the user numbers
  SUBROUTINE CMISSSolverEquationsBoundaryConditionsCreateFinishNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to finish the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverEquationsBoundaryConditionsCreateFinishNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER_EQUATIONS,err,error,*999)
      IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
        CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_CREATE_FINISH(SOLVER_EQUATIONS,err,error,*999)
      ELSE
        LOCAL_ERROR="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverEquationsBoundaryConditionsCreateFinishNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverEquationsBoundaryConditionsCreateFinishNumber0",err,error)
    CALL EXITS("CMISSSolverEquationsBoundaryConditionsCreateFinishNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquationsBoundaryConditionsCreateFinishNumber0

  !
  !================================================================================================================================
  !

  !>Finish the creation of the boundary conditions for the solver equations identified by the user numbers
  SUBROUTINE CMISSSolverEquationsBoundaryConditionsCreateFinishNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to finish the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverEquationsBoundaryConditionsCreateFinishNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
      IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
        CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_CREATE_FINISH(SOLVER_EQUATIONS,err,error,*999)
      ELSE
        LOCAL_ERROR="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverEquationsBoundaryConditionsCreateFinishNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverEquationsBoundaryConditionsCreateFinishNumber1",err,error)
    CALL EXITS("CMISSSolverEquationsBoundaryConditionsCreateFinishNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquationsBoundaryConditionsCreateFinishNumber1

  !
  !================================================================================================================================
  !

  !>Finish the creation of the boundary conditions for the solver equations
  SUBROUTINE CMISSSolverEquationsBoundaryConditionsCreateFinishObj(solverEquations,err)

    !Argument variables
    TYPE(CMISSSolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations containing the boundary conditions to finish.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverEquationsBoundaryConditionsCreateFinishObj",err,error,*999)

    CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_CREATE_FINISH(solverEquations%SOLVER_EQUATIONS,err,error,*999)

    CALL EXITS("CMISSSolverEquationsBoundaryConditionsCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSSolverEquationsBoundaryConditionsCreateFinishObj",err,error)
    CALL EXITS("CMISSSolverEquationsBoundaryConditionsCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquationsBoundaryConditionsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of boundary conditions for solver equations identified by user numbers
  SUBROUTINE CMISSSolverEquationsBoundaryConditionsCreateStartNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to start the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverEquationsBoundaryConditionsCreateStartNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER_EQUATIONS,err,error,*999)
      IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
        CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_CREATE_START(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
      ELSE
        LOCAL_ERROR="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverEquationsBoundaryConditionsCreateStartNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverEquationsBoundaryConditionsCreateStartNumber0",err,error)
    CALL EXITS("CMISSSolverEquationsBoundaryConditionsCreateStartNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquationsBoundaryConditionsCreateStartNumber0

  !
  !================================================================================================================================
  !

  !>Start the creation of boundary conditions for solver equations identified by user numbers
  SUBROUTINE CMISSSolverEquationsBoundaryConditionsCreateStartNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to start the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverEquationsBoundaryConditionsCreateStartNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
      IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
        CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_CREATE_START(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
      ELSE
        LOCAL_ERROR="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverEquationsBoundaryConditionsCreateStartNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverEquationsBoundaryConditionsCreateStartNumber1",err,error)
    CALL EXITS("CMISSSolverEquationsBoundaryConditionsCreateStartNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquationsBoundaryConditionsCreateStartNumber1

  !
  !================================================================================================================================
  !

  !>Start the creation of boundary conditions for solver equations
  SUBROUTINE CMISSSolverEquationsBoundaryConditionsCreateStartObj(solverEquations,boundaryConditions,err)

    !Argument variables
    TYPE(CMISSSolverEquationsType), INTENT(INOUT) :: solverEquations !<The solver equations containing the boundary conditions to start.
    TYPE(CMISSBoundaryConditionsType), INTENT(INOUT) :: boundaryConditions !<On return, the created boundary conditions.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverEquationsBoundaryConditionsCreateStartObj",err,error,*999)

    CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_CREATE_START(solverEquations%SOLVER_EQUATIONS, &
        & boundaryConditions%BOUNDARY_CONDITIONS,err,error,*999)

    CALL EXITS("CMISSSolverEquationsBoundaryConditionsCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSSolverEquationsBoundaryConditionsCreateStartObj",err,error)
    CALL EXITS("CMISSSolverEquationsBoundaryConditionsCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquationsBoundaryConditionsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Get the boundary conditions for solver equations identified by user numbers
  SUBROUTINE CMISSSolverEquationsBoundaryConditionsGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & boundaryConditions,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to get the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    TYPE(CMISSBoundaryConditionsType), INTENT(INOUT) :: boundaryConditions !<On return, The boundary conditions for the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverEquationsBoundaryConditionsGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER_EQUATIONS,err,error,*999)
      IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
        CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,boundaryConditions%BOUNDARY_CONDITIONS,err,error,*999)
      ELSE
        LOCAL_ERROR="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverEquationsBoundaryConditionsGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverEquationsBoundaryConditionsGetNumber0",err,error)
    CALL EXITS("CMISSSolverEquationsBoundaryConditionsGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquationsBoundaryConditionsGetNumber0

  !
  !================================================================================================================================
  !

  !>Get the boundary conditions for solver equations identified by user numbers
  SUBROUTINE CMISSSolverEquationsBoundaryConditionsGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & boundaryConditions,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to start the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    TYPE(CMISSBoundaryConditionsType), INTENT(INOUT) :: boundaryConditions !<On return, The boundary conditions for the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverEquationsBoundaryConditionsGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
      IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
        CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,boundaryConditions%BOUNDARY_CONDITIONS,err,error,*999)
      ELSE
        LOCAL_ERROR="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolverEquationsBoundaryConditionsGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverEquationsBoundaryConditionsGetNumber1",err,error)
    CALL EXITS("CMISSSolverEquationsBoundaryConditionsGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquationsBoundaryConditionsGetNumber1

  !
  !================================================================================================================================
  !

  !>Get the boundary conditions for solver equations
  SUBROUTINE CMISSSolverEquationsBoundaryConditionsGetObj(solverEquations,boundaryConditions,err)

    !Argument variables
    TYPE(CMISSSolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the boundary conditions for.
    TYPE(CMISSBoundaryConditionsType), INTENT(INOUT) :: boundaryConditions !<On return, The boundary conditions for the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL ENTERS("CMISSSolverEquationsBoundaryConditionsGetObj",err,error,*999)

    CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(solverEquations%SOLVER_EQUATIONS,boundaryConditions%BOUNDARY_CONDITIONS, &
      & err,error,*999)

    CALL EXITS("CMISSSolverEquationsBoundaryConditionsGetObj")
    RETURN
999 CALL ERRORS("CMISSSolverEquationsBoundaryConditionsGetObj",err,error)
    CALL EXITS("CMISSSolverEquationsBoundaryConditionsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquationsBoundaryConditionsGetObj

  !
  !================================================================================================================================
  !

  !>Get the user number of the given region.
  SUBROUTINE CMISSUserNumberGetRegion( region, userNumber, err )
    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region to get the user number for
    INTEGER(INTG), INTENT(OUT) :: userNumber !<The region's user number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    err = 0

    userNumber = region%REGION%USER_NUMBER

  END SUBROUTINE CMISSUserNumberGetRegion

  !
  !================================================================================================================================
  !

  !>Get the user number of the given mesh.
  SUBROUTINE CMISSUserNumberGetMesh( mesh, userNumber, err )
    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !<The mesh to get the user number for
    INTEGER(INTG), INTENT(OUT) :: userNumber !<The mesh's user number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    err = 0

    userNumber = mesh%MESH%USER_NUMBER

  END SUBROUTINE CMISSUserNumberGetMesh

  !
  !================================================================================================================================
  !

  !>Get the user number of the given basis.
  SUBROUTINE CMISSUserNumberGetBasis( basis, userNumber, err )
    !Argument variables
    TYPE(CMISSBasisType), INTENT(IN) :: basis !<The basis to get the user number for
    INTEGER(INTG), INTENT(OUT) :: userNumber !<The basis's user number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    err = 0

    userNumber = basis%BASIS%USER_NUMBER

  END SUBROUTINE CMISSUserNumberGetBasis

  !
  !================================================================================================================================
  !

  !> Initialise the given FieldML context using the given FieldML XML file.
  SUBROUTINE CMISSFieldMLInputCreateFromFileVS( fieldml, filename, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context to initialise.
    TYPE(VARYING_STRING), INTENT(IN) :: filename !< The FieldML XML file to parse.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldMLInputCreateFromFileVS",err,error,*999)

#ifdef USEFIELDML

    ALLOCATE( fieldml%fieldmlInfo, stat=err )
    CALL FIELDML_INPUT_INITIALISE_FROM_FILE( fieldml%fieldmlInfo, filename, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLInputCreateFromFileVS")
    RETURN
999 CALL ERRORS("CMISSFieldMLInputCreateFromFileVS",err,error)
    CALL EXITS("CMISSFieldMLInputCreateFromFileVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLInputCreateFromFileVS

  !
  !================================================================================================================================
  !

  !> Initialise the given FieldML context using the given FieldML XML file.
  SUBROUTINE CMISSFieldMLInputCreateFromFileC( fieldml, filename, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context to initialise.
    CHARACTER(LEN=*), INTENT(IN) :: filename !< The FieldML XML file to parse.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldMLInputCreateFromFileC",err,error,*999)

#ifdef USEFIELDML

    ALLOCATE( fieldml%fieldmlInfo, stat=err )
    CALL FIELDML_INPUT_INITIALISE_FROM_FILE( fieldml%fieldmlInfo, var_str(filename), err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLInputCreateFromFileC")
    RETURN
999 CALL ERRORS("CMISSFieldMLInputCreateFromFileC",err,error)
    CALL EXITS("CMISSFieldMLInputCreateFromFileC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLInputCreateFromFileC

  !
  !================================================================================================================================
  !

  !> Creates a mesh using the given FieldML evaluator.
  SUBROUTINE CMISSFieldMLInputMeshCreateStartObjVS( fieldml, meshArgumentName, mesh, meshNumber, region, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: meshArgumentName !< The name of the argument evaluator to create a mesh from.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number to assign to the new mesh.
    TYPE(CMISSRegionType), INTENT(IN) :: region !< The region in which to create the mesh.
    TYPE(CMISSMeshType), INTENT(OUT) :: mesh !< On return, the newly created mesh.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldMLInputMeshCreateStartObjVS",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_MESH_CREATE_START( fieldml%fieldmlInfo, meshArgumentName, mesh%MESH, meshNumber, region%REGION, &
      & err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLInputMeshCreateStartObjVS")
    RETURN
999 CALL ERRORS("CMISSFieldMLInputMeshCreateStartObjVS",err,error)
    CALL EXITS("CMISSFieldMLInputMeshCreateStartObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLInputMeshCreateStartObjVS

  !
  !================================================================================================================================
  !

  !> Creates a mesh with the given user number using the given FieldML evaluator.
  SUBROUTINE CMISSFieldMLInputMeshCreateStartNumberVS( fieldml, meshArgumentName, meshNumber, regionNumber, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: meshArgumentName !< The name of the mesh argument evaluator to create a mesh from.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number to assign to the new mesh.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region in which to create the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(MESH_TYPE), POINTER :: mesh

    CALL ENTERS("CMISSFieldMLInputMeshCreateStartNumberVS",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    NULLIFY( mesh )
    CALL FIELDML_INPUT_MESH_CREATE_START( fieldml%fieldmlInfo, meshArgumentName, mesh, meshNumber, region, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLInputMeshCreateStartNumberVS")
    RETURN
999 CALL ERRORS("CMISSFieldMLInputMeshCreateStartNumberVS",err,error)
    CALL EXITS("CMISSFieldMLInputMeshCreateStartNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLInputMeshCreateStartNumberVS

  !
  !================================================================================================================================
  !

  !> Creates a mesh using the given FieldML evaluator.
  SUBROUTINE CMISSFieldMLInputMeshCreateStartObjC( fieldml, meshArgumentName, mesh, meshNumber, region, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: meshArgumentName !< The name of the argument evaluator to create a mesh from.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number to assign to the new mesh.
    TYPE(CMISSRegionType), INTENT(IN) :: region !< The region in which to create the mesh.
    TYPE(CMISSMeshType), INTENT(OUT) :: mesh !< On return, the newly created mesh.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldMLInputMeshCreateStartObjC",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_MESH_CREATE_START( fieldml%fieldmlInfo, var_str(meshArgumentName), mesh%MESH, meshNumber, region%REGION, &
      & err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLInputMeshCreateStartObjC")
    RETURN
999 CALL ERRORS("CMISSFieldMLInputMeshCreateStartObjC",err,error)
    CALL EXITS("CMISSFieldMLInputMeshCreateStartObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLInputMeshCreateStartObjC

  !
  !================================================================================================================================
  !

  !> Creates a mesh with the given user number using the given FieldML evaluator.
  SUBROUTINE CMISSFieldMLInputMeshCreateStartNumberC( fieldml, meshArgumentName, meshNumber, regionNumber, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: meshArgumentName !< The name of the mesh argument evaluator to create a mesh from.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number to assign to the new mesh.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region in which to create the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(MESH_TYPE), POINTER :: mesh

    CALL ENTERS("CMISSFieldMLInputMeshCreateStartNumberC",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    NULLIFY( mesh )
    CALL FIELDML_INPUT_MESH_CREATE_START( fieldml%fieldmlInfo, var_str(meshArgumentName), mesh, meshNumber, region, &
      & err, error, *999)

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLInputMeshCreateStartNumberC")
    RETURN
999 CALL ERRORS("CMISSFieldMLInputMeshCreateStartNumberC",err,error)
    CALL EXITS("CMISSFieldMLInputMeshCreateStartNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLInputMeshCreateStartNumberC

  !
  !================================================================================================================================
  !

  !> Create a coordinate system using the given FieldML evaluator.
  SUBROUTINE CMISSFieldMLInputCoordinateSystemCreateStartObjVS( fieldml, evaluatorName, coordinateSystem, userNumber, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the coordinate system from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new coordinate system.
    TYPE(CMISSCoordinateSystemType), INTENT(OUT) :: coordinateSystem !< On return, the newly created coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldMLInputCoordinateSystemCreateStartObjVS",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_COORDINATE_SYSTEM_CREATE_START( fieldml%fieldmlInfo, evaluatorName, coordinateSystem%COORDINATE_SYSTEM, &
      & userNumber, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLInputCoordinateSystemCreateStartObjVS")
   RETURN
999 CALL ERRORS("CMISSFieldMLInputCoordinateSystemCreateStartObjVS",err,error)
    CALL EXITS("CMISSFieldMLInputCoordinateSystemCreateStartObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

 END SUBROUTINE CMISSFieldMLInputCoordinateSystemCreateStartObjVS

  !
  !================================================================================================================================
  !

  !> Create a coordinate system using the given FieldML evaluator.
  SUBROUTINE CMISSFieldMLInputCoordinateSystemCreateStartNumberVS( fieldml, evaluatorName, userNumber, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the coordinate system from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM

    CALL ENTERS("CMISSFieldMLInputCoordinateSystemCreateStartNumberVS",err,error,*999)

#ifdef USEFIELDML

    NULLIFY( COORDINATE_SYSTEM )
    CALL FIELDML_INPUT_COORDINATE_SYSTEM_CREATE_START( fieldml%fieldmlInfo, evaluatorName, COORDINATE_SYSTEM, &
      & userNumber, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLInputCoordinateSystemCreateStartNumberVS")
   RETURN
999 CALL ERRORS("CMISSFieldMLInputCoordinateSystemCreateStartNumberVS",err,error)
    CALL EXITS("CMISSFieldMLInputCoordinateSystemCreateStartNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

 END SUBROUTINE CMISSFieldMLInputCoordinateSystemCreateStartNumberVS

  !
  !================================================================================================================================
  !

  !> Create a coordinate system using the given FieldML evaluator.
  SUBROUTINE CMISSFieldMLInputCoordinateSystemCreateStartObjC( fieldml, evaluatorName, coordinateSystem, userNumber, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the coordinate system from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new coordinate system.
    TYPE(CMISSCoordinateSystemType), INTENT(OUT) :: coordinateSystem !< On return, the newly created coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldMLInputCoordinateSystemCreateStartObjC",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_COORDINATE_SYSTEM_CREATE_START( fieldml%fieldmlInfo, var_str(evaluatorName), &
      & coordinateSystem%COORDINATE_SYSTEM, userNumber, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLInputCoordinateSystemCreateStartObjC")
   RETURN
999 CALL ERRORS("CMISSFieldMLInputCoordinateSystemCreateStartObjC",err,error)
    CALL EXITS("CMISSFieldMLInputCoordinateSystemCreateStartObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

 END SUBROUTINE CMISSFieldMLInputCoordinateSystemCreateStartObjC

  !
  !================================================================================================================================
  !

  !> Create a coordinate system using the given FieldML evaluator.
  SUBROUTINE CMISSFieldMLInputCoordinateSystemCreateStartNumberC( fieldml, evaluatorName, userNumber, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the coordinate system from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM

    CALL ENTERS("CMISSFieldMLInputCoordinateSystemCreateStartNumberC",err,error,*999)

#ifdef USEFIELDML

    NULLIFY( COORDINATE_SYSTEM )
    CALL FIELDML_INPUT_COORDINATE_SYSTEM_CREATE_START( fieldml%fieldmlInfo, var_str(evaluatorName), COORDINATE_SYSTEM, &
      & userNumber, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLInputCoordinateSystemCreateStartNumberC")
   RETURN
999 CALL ERRORS("CMISSFieldMLInputCoordinateSystemCreateStartNumberC",err,error)
    CALL EXITS("CMISSFieldMLInputCoordinateSystemCreateStartNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

 END SUBROUTINE CMISSFieldMLInputCoordinateSystemCreateStartNumberC

  !
  !================================================================================================================================
  !

  !> Create a basis using the given FieldML evaluator.
  SUBROUTINE CMISSFieldMLInputBasisCreateStartNumberVS( fieldml, evaluatorName, userNumber, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the basis from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new basis.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(BASIS_TYPE), POINTER :: basis

    CALL ENTERS("CMISSFieldMLInputBasisCreateStartNumberVS",err,error,*999)

#ifdef USEFIELDML

    NULLIFY( basis )
    CALL FIELDML_INPUT_BASIS_CREATE_START( fieldml%fieldmlInfo, evaluatorName, userNumber, basis, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLInputBasisCreateStartNumberVS")
    RETURN
999 CALL ERRORS("CMISSFieldMLInputBasisCreateStartNumberVS",err,error)
    CALL EXITS("CMISSFieldMLInputBasisCreateStartNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
   RETURN

  END SUBROUTINE CMISSFieldMLInputBasisCreateStartNumberVS

  !
  !================================================================================================================================
  !

  !> Create a basis using the given FieldML evaluator.
  SUBROUTINE CMISSFieldMLInputBasisCreateStartObjVS( fieldml, evaluatorName, userNumber, basis, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the basis from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new basis.
    TYPE(CMISSBasisType), INTENT(OUT) :: basis !<On return, the newly created basis.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldMLInputBasisCreateStartObjVS",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_BASIS_CREATE_START( fieldml%fieldmlInfo, evaluatorName, userNumber, basis%BASIS, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLInputBasisCreateStartObjVS")
    RETURN
999 CALL ERRORS("CMISSFieldMLInputBasisCreateStartObjVS",err,error)
    CALL EXITS("CMISSFieldMLInputBasisCreateStartObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
   RETURN

  END SUBROUTINE CMISSFieldMLInputBasisCreateStartObjVS

  !
  !================================================================================================================================
  !

  !> Create a basis using the given FieldML evaluator.
  SUBROUTINE CMISSFieldMLInputBasisCreateStartNumberC( fieldml, evaluatorName, userNumber, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the basis from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new basis.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(BASIS_TYPE), POINTER :: basis

    CALL ENTERS("CMISSFieldMLInputBasisCreateStartNumberC",err,error,*999)

#ifdef USEFIELDML

    NULLIFY( basis )
    CALL FIELDML_INPUT_BASIS_CREATE_START( fieldml%fieldmlInfo, var_str(evaluatorName), userNumber, basis, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLInputBasisCreateStartNumberC")
    RETURN
999 CALL ERRORS("CMISSFieldMLInputBasisCreateStartNumberC",err,error)
    CALL EXITS("CMISSFieldMLInputBasisCreateStartNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)
   RETURN

  END SUBROUTINE CMISSFieldMLInputBasisCreateStartNumberC

  !
  !================================================================================================================================
  !

  !> Create a basis using the given FieldML evaluator.
  SUBROUTINE CMISSFieldMLInputBasisCreateStartObjC( fieldml, evaluatorName, userNumber, basis, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the basis from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new basis.
    TYPE(CMISSBasisType), INTENT(OUT) :: basis !<On return, the newly created basis.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldMLInputBasisCreateStartObjC",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_BASIS_CREATE_START( fieldml%fieldmlInfo, var_str(evaluatorName), userNumber, basis%BASIS, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLInputBasisCreateStartObjC")
    RETURN
999 CALL ERRORS("CMISSFieldMLInputBasisCreateStartObjC",err,error)
    CALL EXITS("CMISSFieldMLInputBasisCreateStartObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
   RETURN

  END SUBROUTINE CMISSFieldMLInputBasisCreateStartObjC

  !
  !================================================================================================================================
  !

  !> Creates a region's nodes using the given FieldML evaluator.
  SUBROUTINE CMISSFieldMLInputNodesCreateStartNumberVS( fieldml, nodesArgumentName, regionNumber, nodes, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: nodesArgumentName !< The name of the argument evaluator to create the nodes from.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region to create to the nodes in.
    TYPE(CMISSNodesType), INTENT(OUT) :: nodes !< On return, the newly created nodes.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region

    CALL ENTERS("CMISSFieldMLInputNodesCreateStartNumberVS",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL FIELDML_INPUT_NODES_CREATE_START( fieldml%fieldmlInfo, nodesArgumentName, region, nodes%NODES, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLInputNodesCreateStartNumberVS")
    RETURN
999 CALL ERRORS("CMISSFieldMLInputNodesCreateStartNumberVS",err,error)
    CALL EXITS("CMISSFieldMLInputNodesCreateStartNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
   RETURN

  END SUBROUTINE CMISSFieldMLInputNodesCreateStartNumberVS

  !
  !================================================================================================================================
  !

  !> Creates a region's nodes using the given FieldML evaluator.
  SUBROUTINE CMISSFieldMLInputNodesCreateStartObjVS( fieldml, nodesArgumentName, region, nodes, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: nodesArgumentName !< The name of the argument evaluator to create the basis from.
    TYPE(CMISSRegionType), INTENT(IN) :: region !< The user number of the region to create to the nodes in.
    TYPE(CMISSNodesType), INTENT(OUT) :: nodes  !< On return, the newly created nodes.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldMLInputNodesCreateStartObjVS",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_NODES_CREATE_START( fieldml%fieldmlInfo, nodesArgumentName, region%REGION, nodes%NODES, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLInputNodesCreateStartObjVS")
    RETURN
999 CALL ERRORS("CMISSFieldMLInputNodesCreateStartObjVS",err,error)
    CALL EXITS("CMISSFieldMLInputNodesCreateStartObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
   RETURN

  END SUBROUTINE CMISSFieldMLInputNodesCreateStartObjVS

  !
  !================================================================================================================================
  !

  !> Creates a region's nodes using the given FieldML evaluator.
  SUBROUTINE CMISSFieldMLInputNodesCreateStartNumberC( fieldml, nodesArgumentName, regionNumber, nodes, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: nodesArgumentName !< The name of the argument evaluator to create the nodes from.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region to create to the nodes in.
    TYPE(CMISSNodesType), INTENT(OUT) :: nodes !< On return, the newly created nodes.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region

    CALL ENTERS("CMISSFieldMLInputNodesCreateStartNumberC",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL FIELDML_INPUT_NODES_CREATE_START( fieldml%fieldmlInfo, var_str(nodesArgumentName), region, nodes%NODES, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLInputNodesCreateStartNumberC")
    RETURN
999 CALL ERRORS("CMISSFieldMLInputNodesCreateStartNumberC",err,error)
    CALL EXITS("CMISSFieldMLInputNodesCreateStartNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)
   RETURN

  END SUBROUTINE CMISSFieldMLInputNodesCreateStartNumberC

  !
  !================================================================================================================================
  !

  !> Creates a region's nodes using the given FieldML evaluator.
  SUBROUTINE CMISSFieldMLInputNodesCreateStartObjC( fieldml, nodesArgumentName, region, nodes, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: nodesArgumentName !< The name of the argument evaluator to create the basis from.
    TYPE(CMISSRegionType), INTENT(IN) :: region !< The user number of the region to create to the nodes in.
    TYPE(CMISSNodesType), INTENT(OUT) :: nodes  !< On return, the newly created nodes.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldMLInputNodesCreateStartObjC",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_NODES_CREATE_START( fieldml%fieldmlInfo, var_str(nodesArgumentName), region%REGION, nodes%NODES, &
      & err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLInputNodesCreateStartObjC")
    RETURN
999 CALL ERRORS("CMISSFieldMLInputNodesCreateStartObjC",err,error)
    CALL EXITS("CMISSFieldMLInputNodesCreateStartObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
   RETURN

  END SUBROUTINE CMISSFieldMLInputNodesCreateStartObjC

  !
  !================================================================================================================================
  !

  !> Use the given FieldML evaluator as a template to create a component on the given mesh.
  SUBROUTINE CMISSFieldMLInputCreateMeshComponentObjVS( fieldml, mesh, componentNumber, evaluatorName, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !< The mesh for which to create the mesh component.
    INTEGER(INTG), INTENT(IN) :: componentNumber !< The number of the mesh component to create.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the mesh from.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldMLInputCreateMeshComponentObjVS",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_CREATE_MESH_COMPONENT( fieldml%fieldmlInfo, mesh%MESH, componentNumber, evaluatorName, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLInputCreateMeshComponentObjVS")
    RETURN
999 CALL ERRORS("CMISSFieldMLInputCreateMeshComponentObjVS",err,error)
    CALL EXITS("CMISSFieldMLInputCreateMeshComponentObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLInputCreateMeshComponentObjVS

  !
  !================================================================================================================================
  !

  !> Use the given FieldML evaluator as a template to create a component on the mesh identified by the given user number.
  SUBROUTINE CMISSFieldMLInputCreateMeshComponentNumberVS( fieldml, regionNumber, meshNumber, componentNumber, evaluatorName, &
    & err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region in which the mesh component is to be created.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number of the mesh for which the mesh component is to be created.
    INTEGER(INTG), INTENT(IN) :: componentNumber !< The number of the mesh component to create.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the basis from.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Local variables
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(MESH_TYPE), POINTER :: mesh

    CALL ENTERS( "CMISSFieldMLInputCreateMeshComponentNumberVS", err, error, *999 )

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL MESH_USER_NUMBER_TO_MESH( meshNumber, region, mesh, err, error, *999 )

    CALL FIELDML_INPUT_CREATE_MESH_COMPONENT( fieldml%fieldmlInfo, mesh, componentNumber, evaluatorName, err, error, *999 )

    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLInputNodesCreateStartObjVS")
    CALL EXITS("CMISSFieldMLInputCreateMeshComponentNumberVS")
    RETURN
999 CALL ERRORS("CMISSFieldMLInputCreateMeshComponentNumberVS",err,error)
    CALL EXITS("CMISSFieldMLInputCreateMeshComponentNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLInputCreateMeshComponentNumberVS

  !
  !================================================================================================================================
  !

  !> Use the given FieldML evaluator as a template to create a component on the given mesh.
  SUBROUTINE CMISSFieldMLInputCreateMeshComponentObjC( fieldml, mesh, componentNumber, evaluatorName, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !< The mesh for which to create the mesh component.
    INTEGER(INTG), INTENT(IN) :: componentNumber !< The number of the mesh component to create.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the mesh from.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldMLInputCreateMeshComponentObjC",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_CREATE_MESH_COMPONENT( fieldml%fieldmlInfo, mesh%MESH, componentNumber, var_str(evaluatorName), &
      & err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLInputCreateMeshComponentObjC")
    RETURN
999 CALL ERRORS("CMISSFieldMLInputCreateMeshComponentObjC",err,error)
    CALL EXITS("CMISSFieldMLInputCreateMeshComponentObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLInputCreateMeshComponentObjC

  !
  !================================================================================================================================
  !

  !> Use the given FieldML evaluator as a template to create a component on the mesh identified by the given user number.
  SUBROUTINE CMISSFieldMLInputCreateMeshComponentNumberC( fieldml, regionNumber, meshNumber, componentNumber, evaluatorName, &
    & err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region in which the mesh component is to be created.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number of the mesh for which the mesh component is to be created.
    INTEGER(INTG), INTENT(IN) :: componentNumber !< The number of the mesh component to create.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the basis from.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Local variables
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(MESH_TYPE), POINTER :: mesh

    CALL ENTERS( "CMISSFieldMLInputCreateMeshComponentNumberC", err, error, *999 )

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL MESH_USER_NUMBER_TO_MESH( meshNumber, region, mesh, err, error, *999 )

    CALL FIELDML_INPUT_CREATE_MESH_COMPONENT( fieldml%fieldmlInfo, mesh, componentNumber, var_str(evaluatorName), err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLInputNodesCreateStartObjVS")
    CALL EXITS("CMISSFieldMLInputCreateMeshComponentNumberC")
    RETURN
999 CALL ERRORS("CMISSFieldMLInputCreateMeshComponentNumberC",err,error)
    CALL EXITS("CMISSFieldMLInputCreateMeshComponentNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLInputCreateMeshComponentNumberC

  !
  !================================================================================================================================
  !

  !> Create a field using the given FieldML evaluator.
  SUBROUTINE CMISSFieldMLInputFieldCreateStartObjVS( fieldml, region, decomposition, fieldNumber, field, variableType, &
    & evaluatorName, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(CMISSRegionType), INTENT(IN) :: region !< The region in which the field is to be created.
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !< The decomposition to use when creating the field.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number to assign to the new field.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the field from.
    TYPE(CMISSFieldType), INTENT(OUT) :: field !< On return, the newly created field.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldMLInputFieldCreateStartObjVS",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_FIELD_CREATE_START( fieldml%fieldmlInfo, region%REGION, decomposition%DECOMPOSITION, fieldNumber, &
      & field%FIELD, variableType, evaluatorName, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLInputFieldCreateStartObjVS")
    RETURN
999 CALL ERRORS("CMISSFieldMLInputFieldCreateStartObjVS",err,error)
    CALL EXITS("CMISSFieldMLInputFieldCreateStartObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLInputFieldCreateStartObjVS

  !
  !================================================================================================================================
  !

  !> Create a field with the given user number using the given FieldML evaluator.
  SUBROUTINE CMISSFieldMLInputFieldCreateStartNumberVS( fieldml, regionNumber, meshNumber, decompositionNumber, fieldNumber, &
    & variableType, evaluatorName, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region in which to create the field.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number of the mesh to use when creating the field.
    INTEGER(INTG), INTENT(IN) :: decompositionNumber !< The user number of the decomposition to use when creating the field.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number to assign to the new field.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the field from.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Local variables
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(MESH_TYPE), POINTER :: mesh
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(FIELD_TYPE), POINTER :: field

    CALL ENTERS("CMISSFieldMLInputFieldCreateStartNumberVS",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL MESH_USER_NUMBER_TO_MESH( meshNumber, region, mesh, err, error, *999 )
    CALL DECOMPOSITION_USER_NUMBER_TO_DECOMPOSITION( decompositionNumber, mesh, decomposition, err, error, *999 )

    NULLIFY( field )
    CALL FIELDML_INPUT_FIELD_CREATE_START( fieldml%fieldmlInfo, region, decomposition, fieldNumber, field, variableType, &
      & evaluatorName, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLInputFieldCreateStartNumberVS")
    RETURN
999 CALL ERRORS("CMISSFieldMLInputFieldCreateStartNumberVS",err,error)
    CALL EXITS("CMISSFieldMLInputFieldCreateStartNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLInputFieldCreateStartNumberVS

  !
  !================================================================================================================================
  !

  !> Create a field using the given FieldML evaluator.
  SUBROUTINE CMISSFieldMLInputFieldCreateStartObjC( fieldml, region, decomposition, fieldNumber, field, variableType, &
    & evaluatorName, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(CMISSRegionType), INTENT(IN) :: region !< The region in which the field is to be created.
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !< The decomposition to use when creating the field.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number to assign to the new field.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the field from.
    TYPE(CMISSFieldType), INTENT(OUT) :: field !< On return, the newly created field.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldMLInputFieldCreateStartObjC",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_FIELD_CREATE_START( fieldml%fieldmlInfo, region%REGION, decomposition%DECOMPOSITION, fieldNumber, &
      & field%FIELD, variableType, var_str(evaluatorName), err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLInputFieldCreateStartObjC")
    RETURN
999 CALL ERRORS("CMISSFieldMLInputFieldCreateStartObjC",err,error)
    CALL EXITS("CMISSFieldMLInputFieldCreateStartObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLInputFieldCreateStartObjC

  !
  !================================================================================================================================
  !

  !> Create a field with the given user number using the given FieldML evaluator.
  SUBROUTINE CMISSFieldMLInputFieldCreateStartNumberC( fieldml, regionNumber, meshNumber, decompositionNumber, fieldNumber, &
    & variableType, evaluatorName, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region in which to create the field.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number of the mesh to use when creating the field.
    INTEGER(INTG), INTENT(IN) :: decompositionNumber !< The user number of the decomposition to use when creating the field.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number to assign to the new field.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the field from.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Local variables
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(MESH_TYPE), POINTER :: mesh
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(FIELD_TYPE), POINTER :: field

    CALL ENTERS("CMISSFieldMLInputFieldCreateStartNumberC",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL MESH_USER_NUMBER_TO_MESH( meshNumber, region, mesh, err, error, *999 )
    CALL DECOMPOSITION_USER_NUMBER_TO_DECOMPOSITION( decompositionNumber, mesh, decomposition, err, error, *999 )

    NULLIFY( field )
    CALL FIELDML_INPUT_FIELD_CREATE_START( fieldml%fieldmlInfo, region, decomposition, fieldNumber, field, variableType, &
      & var_str(evaluatorName), err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLInputFieldCreateStartNumberC")
    RETURN
999 CALL ERRORS("CMISSFieldMLInputFieldCreateStartNumberC",err,error)
    CALL EXITS("CMISSFieldMLInputFieldCreateStartNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLInputFieldCreateStartNumberC

  !
  !================================================================================================================================
  !

  !> Update the DOF parameters of the given field, using the given FieldML evaluator.
  SUBROUTINE CMISSFieldMLInputFieldParametersUpdateObjVS( fieldml, field, evaluatorName, variableType, &
    & setType, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(CMISSFieldType), INTENT(INOUT) :: field !< On return, the field object.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to get the parameters from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldMLInputFieldParametersUpdateObjVS",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_FIELD_PARAMETERS_UPDATE( fieldml%fieldmlInfo, evaluatorName, field%FIELD, variableType, &
      &  setType, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLInputFieldParametersUpdateObjVS")
    RETURN
999 CALL ERRORS("CMISSFieldMLInputFieldParametersUpdateObjVS",err,error)
    CALL EXITS("CMISSFieldMLInputFieldParametersUpdateObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLInputFieldParametersUpdateObjVS

  !
  !================================================================================================================================
  !

  !> Update the DOF parameters of field with the given user number, using the given FieldML evaluator.
  SUBROUTINE CMISSFieldMLInputFieldParametersUpdateNumberVS( fieldml, regionNumber, fieldNumber, &
    & evaluatorName, variableType, setType, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region of the field for which parameters are to be updated.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field for which parameters are to be updated.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to get the parameters from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Local variables
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field

    CALL ENTERS("CMISSFieldMLInputFieldParametersUpdateNumberVS",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL FIELD_USER_NUMBER_TO_FIELD( fieldNumber, region, field, err, error, *999 )

    CALL FIELDML_INPUT_FIELD_PARAMETERS_UPDATE( fieldml%fieldmlInfo, evaluatorName, field, variableType, setType, &
      & err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLInputFieldParametersUpdateNumberVS")
    RETURN
999 CALL ERRORS("CMISSFieldMLInputFieldParametersUpdateNumberVS",err,error)
    CALL EXITS("CMISSFieldMLInputFieldParametersUpdateNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLInputFieldParametersUpdateNumberVS

  !
  !================================================================================================================================
  !

  !> Update the DOF parameters of the given field, using the given FieldML evaluator.
  SUBROUTINE CMISSFieldMLInputFieldParametersUpdateObjC( fieldml, field, evaluatorName, &
    & variableType, setType, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(CMISSFieldType), INTENT(INOUT) :: field !< On return, the field object.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to get the parameters from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldMLInputFieldParametersUpdateObjC",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_FIELD_PARAMETERS_UPDATE( fieldml%fieldmlInfo, var_str(evaluatorName), field%FIELD, variableType, &
      & setType, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLInputFieldParametersUpdateObjC")
    RETURN
999 CALL ERRORS("CMISSFieldMLInputFieldParametersUpdateObjC",err,error)
    CALL EXITS("CMISSFieldMLInputFieldParametersUpdateObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLInputFieldParametersUpdateObjC

  !
  !================================================================================================================================
  !

  !> Update the DOF parameters of field with the given user number, using the given FieldML evaluator.
  SUBROUTINE CMISSFieldMLInputFieldParametersUpdateNumberC( fieldml, regionNumber, fieldNumber, &
    & evaluatorName, variableType, setType, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region of the field for which parameters are to be updated.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field for which parameters are to be updated.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to get the parameters from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Local variables
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field

    CALL ENTERS("CMISSFieldMLInputFieldParametersUpdateNumberC",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL FIELD_USER_NUMBER_TO_FIELD( fieldNumber, region, field, err, error, *999 )

    CALL FIELDML_INPUT_FIELD_PARAMETERS_UPDATE( fieldml%fieldmlInfo, var_str(evaluatorName), field, variableType, &
      & setType, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLInputFieldParametersUpdateNumberC")
    RETURN
999 CALL ERRORS("CMISSFieldMLInputFieldParametersUpdateNumberC",err,error)
    CALL EXITS("CMISSFieldMLInputFieldParametersUpdateNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLInputFieldParametersUpdateNumberC

  !
  !================================================================================================================================
  !

  !> Write the FieldML document managed by the given context to a file with the given name.
  SUBROUTINE CMISSFieldMLOutputWriteVS( fieldml, filename, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: filename !< The name of the file to write the FieldML document to.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFieldMLOutputWriteVS",err,error,*999)

#ifdef USEFIELDML

    IF( .NOT. fieldml%fieldmlInfo%IS_OUT ) THEN
      CALL FLAG_ERROR( "Inbound FieldML handle used four an output-only operation.", ERR, error, *999 )
    ENDIF

    CALL FIELDML_OUTPUT_WRITE( fieldml%fieldmlInfo, filename, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLOutputWriteVS")
    RETURN
999 CALL ERRORS("CMISSFieldMLOutputWriteVS",err,error)
    CALL EXITS("CMISSFieldMLOutputWriteVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLOutputWriteVS

  !
  !================================================================================================================================
  !

  !> Write the FieldML document managed by the given context to a file with the given name.
  SUBROUTINE CMISSFieldMLOutputWriteC( fieldml, filename, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: filename !< The name of the file to write the FieldML document to.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldMLOutputWriteC",err,error,*999)

#ifdef USEFIELDML

    IF( .NOT. fieldml%fieldmlInfo%IS_OUT ) THEN
      CALL FLAG_ERROR( "Inbound FieldML handle used four an output-only operation.", ERR, error, *999 )
    ENDIF

    CALL FIELDML_OUTPUT_WRITE( fieldml%fieldmlInfo, var_str(filename), err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLOutputWriteC")
    RETURN
999 CALL ERRORS("CMISSFieldMLOutputWriteC",err,error)
    CALL EXITS("CMISSFieldMLOutputWriteC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLOutputWriteC

  !
  !================================================================================================================================
  !

  !> Add the given field to the given FieldML context. The FieldML type will be inferred.
  SUBROUTINE CMISSFieldMLOutputAddFieldNoTypeObjVS( fieldml, baseName, dofFormat, field, variableType, setType, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    TYPE(CMISSFieldType), INTENT(IN) :: field !< The field to add.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldMLOutputAddFieldNoTypeObjVS",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, baseName, dofFormat, field%FIELD, variableType, setType, &
      & err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLOutputAddFieldNoTypeObjVS")
    RETURN
999 CALL ERRORS("CMISSFieldMLOutputAddFieldNoTypeObjVS",err,error)
    CALL EXITS("CMISSFieldMLOutputAddFieldNoTypeObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLOutputAddFieldNoTypeObjVS

  !
  !================================================================================================================================
  !

  !> Add the field with the given user number to the given FieldML context. The FieldML type will be inferred.
  SUBROUTINE CMISSFieldMLOutputAddFieldNoTypeNumberVS( fieldml, baseName, dofFormat, regionNumber, fieldNumber, &
    & variableType, setType, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region containing the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field

    CALL ENTERS("CMISSFieldMLOutputAddFieldNoTypeNumberVS",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL FIELD_USER_NUMBER_TO_FIELD( fieldNumber, region, field, err, error, *999 )

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, baseName, dofFormat, field, variableType, setType, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLOutputAddFieldNoTypeNumberVS")
    RETURN
999 CALL ERRORS("CMISSFieldMLOutputAddFieldNoTypeNumberVS",err,error)
    CALL EXITS("CMISSFieldMLOutputAddFieldNoTypeNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLOutputAddFieldNoTypeNumberVS

  !
  !================================================================================================================================
  !

  !> Add the given field to the given FieldML context, using the given FieldML type.
  SUBROUTINE CMISSFieldMLOutputAddFieldWithTypeObjVS( fieldml, baseName, dofFormat, field, variableType, setType, typeHandle, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    TYPE(CMISSFieldType), INTENT(IN) :: field !< The field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldMLOutputAddFieldWithTypeObjVS",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, baseName, dofFormat, field%FIELD, variableType, setType, typeHandle, &
      & err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLOutputAddFieldWithTypeObjVS")
    RETURN
999 CALL ERRORS("CMISSFieldMLOutputAddFieldWithTypeObjVS",err,error)
    CALL EXITS("CMISSFieldMLOutputAddFieldWithTypeObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLOutputAddFieldWithTypeObjVS

  !
  !================================================================================================================================
  !

  !> Add the given field to the given FieldML context, using the given FieldML type.
  SUBROUTINE CMISSFieldMLOutputAddFieldWithTypeNumberVS( fieldml, baseName, dofFormat, regionNumber, fieldNumber, &
    & variableType, setType, typeHandle, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region owning the field to add.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field to add.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field

    CALL ENTERS("CMISSFieldMLOutputAddFieldWithTypeNumberVS",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL FIELD_USER_NUMBER_TO_FIELD( fieldNumber, region, field, err, error, *999 )

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, baseName, dofFormat, field, variableType, setType, typeHandle, &
      & err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLOutputAddFieldWithTypeNumberVS")
    RETURN
999 CALL ERRORS("CMISSFieldMLOutputAddFieldWithTypeNumberVS",err,error)
    CALL EXITS("CMISSFieldMLOutputAddFieldWithTypeNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLOutputAddFieldWithTypeNumberVS

  !
  !================================================================================================================================
  !

  !> Add the given field to the given FieldML context. The FieldML type will be inferred.
  SUBROUTINE CMISSFieldMLOutputAddFieldNoTypeObjC( fieldml, baseName, dofFormat, field, variableType, setType, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    TYPE(CMISSFieldType), INTENT(IN) :: field !< The field to add.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldMLOutputAddFieldNoTypeObjC",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, var_str(baseName), var_str(dofFormat), field%FIELD, variableType, &
      & setType, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLOutputAddFieldNoTypeObjC")
    RETURN
999 CALL ERRORS("CMISSFieldMLOutputAddFieldNoTypeObjC",err,error)
    CALL EXITS("CMISSFieldMLOutputAddFieldNoTypeObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLOutputAddFieldNoTypeObjC

  !
  !================================================================================================================================
  !

  !> Add the field with the given user number to the given FieldML context. The FieldML type will be inferred.
  SUBROUTINE CMISSFieldMLOutputAddFieldNoTypeNumberC( fieldml, baseName, dofFormat, regionNumber, fieldNumber, &
    & variableType, setType, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region containing the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field

    CALL ENTERS("CMISSFieldMLOutputAddFieldNoTypeNumberC",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL FIELD_USER_NUMBER_TO_FIELD( fieldNumber, region, field, err, error, *999 )

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, var_str(baseName), var_str(dofFormat), field, variableType, &
      & setType, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLOutputAddFieldNoTypeNumberC")
    RETURN
999 CALL ERRORS("CMISSFieldMLOutputAddFieldNoTypeNumberC",err,error)
    CALL EXITS("CMISSFieldMLOutputAddFieldNoTypeNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLOutputAddFieldNoTypeNumberC

  !
  !================================================================================================================================
  !

  !> Add the given field to the given FieldML context, using the given FieldML type.
  SUBROUTINE CMISSFieldMLOutputAddFieldWithTypeObjC( fieldml, baseName, dofFormat, field, variableType, setType, typeHandle, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    TYPE(CMISSFieldType), INTENT(IN) :: field !< The field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldMLOutputAddFieldWithTypeObjC",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, var_str(baseName), var_str(dofFormat), field%FIELD, variableType, &
      & typeHandle, setType, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLOutputAddFieldWithTypeObjC")
    RETURN
999 CALL ERRORS("CMISSFieldMLOutputAddFieldWithTypeObjC",err,error)
    CALL EXITS("CMISSFieldMLOutputAddFieldWithTypeObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLOutputAddFieldWithTypeObjC

  !
  !================================================================================================================================
  !

  !> Add the given field to the given FieldML context, using the given FieldML type.
  SUBROUTINE CMISSFieldMLOutputAddFieldWithTypeNumberC( fieldml, baseName, dofFormat, regionNumber, fieldNumber, &
    & variableType, setType, typeHandle, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region owning the field to add.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field to add.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field

    CALL ENTERS("CMISSFieldMLOutputAddFieldWithTypeNumberC",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL FIELD_USER_NUMBER_TO_FIELD( fieldNumber, region, field, err, error, *999 )

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, var_str(baseName), var_str(dofFormat), field, variableType, &
      & setType, typeHandle, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLOutputAddFieldWithTypeNumberC")
    RETURN
999 CALL ERRORS("CMISSFieldMLOutputAddFieldWithTypeNumberC",err,error)
    CALL EXITS("CMISSFieldMLOutputAddFieldWithTypeNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLOutputAddFieldWithTypeNumberC

  !
  !================================================================================================================================
  !

  !> Initialise the given FieldML context using the given mesh.
  SUBROUTINE CMISSFieldMLOutputCreateObjVS( mesh, location, baseName, connectivityFormat, fieldml, err )
    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !< The mesh to use when initialising the FieldML context.
    TYPE(VARYING_STRING), INTENT(IN) :: location !< The root directory in which associated data files should be created.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: connectivityFormat !<The name of the format to use when writing connectivity data.
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldMLOutputCreateObjVS",err,error,*999)

#ifdef USEFIELDML

    ALLOCATE( fieldml%fieldmlInfo, stat=err )
    CALL FIELDML_OUTPUT_INITIALISE_INFO( mesh%MESH, location, baseName, connectivityFormat, fieldml%fieldmlInfo, &
      & err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLOutputCreateObjVS")
    RETURN
999 CALL ERRORS("CMISSFieldMLOutputCreateObjVS",err,error)
    CALL EXITS("CMISSFieldMLOutputCreateObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLOutputCreateObjVS

  !
  !================================================================================================================================
  !

  !> Initialise the given FieldML context using the mesh with the given user number.
  SUBROUTINE CMISSFieldMLOutputCreateNumberVS( regionNumber, meshNumber, location, baseName, connectivityFormat, fieldml, err )
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region owning the mesh to use when initialising the FieldML context.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number of the mesh to use when initialising the FieldML context.
    TYPE(VARYING_STRING), INTENT(IN) :: location !< The root directory in which associated data files should be created.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: connectivityFormat !<The name of the format to use when writing connectivity data.
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(MESH_TYPE), POINTER :: mesh

    CALL ENTERS("CMISSFieldMLOutputCreateNumberVS",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL MESH_USER_NUMBER_TO_MESH( meshNumber, region, mesh, err, error, *999 )

    CALL FIELDML_OUTPUT_INITIALISE_INFO( mesh, location, baseName, connectivityFormat, fieldml%fieldmlInfo, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLOutputCreateNumberVS")
    RETURN
999 CALL ERRORS("CMISSFieldMLOutputCreateNumberVS",err,error)
    CALL EXITS("CMISSFieldMLOutputCreateNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLOutputCreateNumberVS

  !
  !================================================================================================================================
  !

  !> Initialise the given FieldML context using the given mesh.
  SUBROUTINE CMISSFieldMLOutputCreateObjC( mesh, location, baseName, connectivityFormat, fieldml, err )
    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !< The mesh to use when initialising the FieldML context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: location !< The root directory in which associated data files should be created.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: connectivityFormat !<The name of the format to use when writing connectivity data.
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldMLOutputCreateObjC",err,error,*999)

#ifdef USEFIELDML

    ALLOCATE( fieldml%fieldmlInfo, stat=err )
    CALL FIELDML_OUTPUT_INITIALISE_INFO( mesh%MESH, var_str(location), var_str(baseName), var_str(connectivityFormat), &
      & fieldml%fieldmlInfo, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLOutputCreateObjC")
    RETURN
999 CALL ERRORS("CMISSFieldMLOutputCreateObjC",err,error)
    CALL EXITS("CMISSFieldMLOutputCreateObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLOutputCreateObjC

  !
  !================================================================================================================================
  !

  !> Initialise the given FieldML context using the mesh with the given user number.
  SUBROUTINE CMISSFieldMLOutputCreateNumberC( regionNumber, meshNumber, location, baseName, connectivityFormat, fieldml, err )
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region owning the mesh to use when initialising the FieldML context.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number of the mesh to use when initialising the FieldML context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: location !< The root directory in which associated data files should be created.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: connectivityFormat !<The name of the format to use when writing connectivity data.
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(MESH_TYPE), POINTER :: mesh

    CALL ENTERS("CMISSFieldMLOutputCreateNumberC",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL MESH_USER_NUMBER_TO_MESH( meshNumber, region, mesh, err, error, *999 )

    CALL FIELDML_OUTPUT_INITIALISE_INFO( mesh, var_str(location), var_str(baseName), var_str(connectivityFormat), &
      & fieldml%fieldmlInfo, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLOutputCreateNumberC")
    RETURN
999 CALL ERRORS("CMISSFieldMLOutputCreateNumberC",err,error)
    CALL EXITS("CMISSFieldMLOutputCreateNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLOutputCreateNumberC

  !
  !================================================================================================================================
  !

  !> Add the given field to the current FieldML context, only including the given components.
  SUBROUTINE CMISSFieldMLOutputAddFieldComponentsObjVS( fieldml, typeHandle, baseName, dofFormat, field, fieldComponentNumbers, &
    & variableType, setType, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    TYPE(CMISSFieldType), INTENT(IN) :: field !< The field whose components are to be added.
    INTEGER(INTG), INTENT(IN) :: fieldComponentNumbers(:)
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldMLOutputAddFieldComponentsObjVS",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_OUTPUT_ADD_FIELD_COMPONENTS( fieldml%fieldmlInfo, typeHandle, baseName, dofFormat, field%FIELD, &
      & fieldComponentNumbers, variableType, setType, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLOutputAddFieldComponentsObjVS")
    RETURN
999 CALL ERRORS("CMISSFieldMLOutputAddFieldComponentsObjVS",err,error)
    CALL EXITS("CMISSFieldMLOutputAddFieldComponentsObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLOutputAddFieldComponentsObjVS

  !
  !================================================================================================================================
  !

  !> Add the field with the given user number to the current FieldML context, only including the given components.
  SUBROUTINE CMISSFieldMLOutputAddFieldComponentsNumberVS( fieldml, typeHandle, baseName, dofFormat, regionNumber, &
    & fieldNumber, fieldComponentNumbers, variableType, setType, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region owning the field to add.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field whose components are to be added.
    INTEGER(INTG), INTENT(IN) :: fieldComponentNumbers(:) !< The component numbers to add.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field

    CALL ENTERS("CMISSFieldMLOutputAddFieldComponentsNumberVS",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL FIELD_USER_NUMBER_TO_FIELD( fieldNumber, region, field, err, error, *999 )

    CALL FIELDML_OUTPUT_ADD_FIELD_COMPONENTS( fieldml%fieldmlInfo, typeHandle, baseName, dofFormat, field, fieldComponentNumbers,&
      & variableType, setType, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLOutputAddFieldComponentsNumberVS")
    RETURN
999 CALL ERRORS("CMISSFieldMLOutputAddFieldComponentsNumberVS",err,error)
    CALL EXITS("CMISSFieldMLOutputAddFieldComponentsNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLOutputAddFieldComponentsNumberVS

  !
  !================================================================================================================================
  !

  !> Add the given field to the current FieldML context, only including the given components.
  SUBROUTINE CMISSFieldMLOutputAddFieldComponentsObjC( fieldml, typeHandle, baseName, dofFormat, field, fieldComponentNumbers, &
    & variableType, setType, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    TYPE(CMISSFieldType), INTENT(IN) :: field !< The field whose components are to be added.
    INTEGER(INTG), INTENT(IN) :: fieldComponentNumbers(:)
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldMLOutputAddFieldComponentsObjC",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_OUTPUT_ADD_FIELD_COMPONENTS( fieldml%fieldmlInfo, typeHandle, var_str(baseName), var_str(dofFormat), &
      & field%FIELD, fieldComponentNumbers, variableType, setType, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLOutputAddFieldComponentsObjC")
    RETURN
999 CALL ERRORS("CMISSFieldMLOutputAddFieldComponentsObjC",err,error)
    CALL EXITS("CMISSFieldMLOutputAddFieldComponentsObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLOutputAddFieldComponentsObjC

  !
  !================================================================================================================================
  !

  !> Add the field with the given user number to the current FieldML context, only including the given components.
  SUBROUTINE CMISSFieldMLOutputAddFieldComponentsNumberC( fieldml, typeHandle, baseName, dofFormat, regionNumber, &
    & fieldNumber, fieldComponentNumbers, variableType, setType, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region owning the field to add.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field whose components are to be added.
    INTEGER(INTG), INTENT(IN) :: fieldComponentNumbers(:) !< The component numbers to add.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field

    CALL ENTERS("CMISSFieldMLOutputAddFieldComponentsNumberC",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL FIELD_USER_NUMBER_TO_FIELD( fieldNumber, region, field, err, error, *999 )

    CALL FIELDML_OUTPUT_ADD_FIELD_COMPONENTS( fieldml%fieldmlInfo, typeHandle, var_str(baseName), var_str(dofFormat), &
      & field, fieldComponentNumbers, variableType, setType, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLOutputAddFieldComponentsNumberC")
    RETURN
999 CALL ERRORS("CMISSFieldMLOutputAddFieldComponentsNumberC",err,error)
    CALL EXITS("CMISSFieldMLOutputAddFieldComponentsNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldMLOutputAddFieldComponentsNumberC

  !
  !================================================================================================================================
  !

  !>Import a FieldML object from the library into the current session.
  SUBROUTINE CMISSFieldMLOutputAddImport( fieldml, name, handle, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: name !< The name of the object to import.
    INTEGER(INTG), INTENT(OUT) :: handle !< A handle to the newly imported FieldML object.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    !Locals
    TYPE(VARYING_STRING) :: stringName

    CALL ENTERS("CMISSFieldMLOutputAddImport",err,error,*999)

#ifdef USEFIELDML

    stringName = name

    handle = FIELDML_OUTPUT_IMPORT( fieldml%fieldmlInfo, stringName, err, error )
    IF(err/=0) GOTO 999

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLOutputAddImport")
    RETURN
999 CALL ERRORS("CMISSFieldMLOutputAddImport",err,error)
    CALL EXITS("CMISSFieldMLOutputAddImport")
    CALL CMISS_HANDLE_ERROR( err, error )
    RETURN

  END SUBROUTINE CMISSFieldMLOutputAddImport

  !
  !================================================================================================================================
  !

  !>Finalises a Fieldml context.
  SUBROUTINE CMISSFieldMLIOTypeFinalise( fieldml, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(OUT) :: fieldml !< The FieldML context to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL ENTERS("CMISSFieldMLIOTypeFinalise", err, error, *999 )

#ifdef USEFIELDML

    CALL FIELDML_IO_FINALISE( fieldml%fieldmlInfo, err, error, *999  )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLIOTypeFinalise")
    RETURN
999 CALL ERRORS("CMISSFieldMLIOTypeFinalise",err,error)
    CALL EXITS("CMISSFieldMLIOTypeFinalise")
    CALL CMISS_HANDLE_ERROR( err, error )
    RETURN

  END SUBROUTINE CMISSFieldMLIOTypeFinalise

  !
  !================================================================================================================================
  !

  !>Initialises a Fieldml context.
  SUBROUTINE CMISSFieldMLIOTypeInitialise( fieldml, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(OUT) :: fieldml !< The FieldML context to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL ENTERS("CMISSFieldMLIOTypeInitialise", err, error, *999 )

#ifdef USEFIELDML

    NULLIFY( fieldml%fieldmlInfo )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLIOTypeInitialise")
    RETURN
999 CALL ERRORS("CMISSFieldMLIOTypeInitialise",err,error)
    CALL EXITS("CMISSFieldMLIOTypeInitialise")
    CALL CMISS_HANDLE_ERROR( err, error )
    RETURN

  END SUBROUTINE CMISSFieldMLIOTypeInitialise

  !
  !================================================================================================================================
  !

  !>Get the session handle from a Fieldml context.
  SUBROUTINE CMISSFieldMLIOGetSession( fieldml, sessionHandle, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context whose session handle is to be returned.
    INTEGER(INTG), INTENT(OUT) :: sessionHandle !<The session handle.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL ENTERS("CMISSFieldMLIOGetSession", err, error, *999 )

#ifdef USEFIELDML

    sessionHandle = fieldml%fieldmlInfo%FML_HANDLE

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLIOGetSession")
    RETURN
999 CALL ERRORS("CMISSFieldMLIOGetSession",err,error)
    CALL EXITS("CMISSFieldMLIOGetSession")
    CALL CMISS_HANDLE_ERROR( err, error )
    RETURN

  END SUBROUTINE CMISSFieldMLIOGetSession

  !
  !================================================================================================================================
  !


END MODULE OPENCMISS
